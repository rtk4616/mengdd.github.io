<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng&#39;s pages</title>
  <subtitle>Android developer and maybe other intersting things.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mengdd.github.io/"/>
  <updated>2016-05-31T05:29:55.000Z</updated>
  <id>http://mengdd.github.io/</id>
  
  <author>
    <name>Dandan Meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test links</title>
    <link href="http://mengdd.github.io/uncategorized/2016/05/31/test-links/"/>
    <id>http://mengdd.github.io/uncategorized/2016/05/31/test-links/</id>
    <published>2016-05-31T05:29:20.000Z</published>
    <updated>2016-05-31T05:29:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.realestate.com.au/buy/property-house-with-1-bedroom-between-600000-750000-in-mentone%2c+vic+3194%3b/list-1?maxBeds=2&amp;amp;includeSurrounding=false&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.realestate.com.au/buy/property-house-with-1-bedroom-between-600000-750000-in-mentone%2c+vic+3194%3b/list-1?maxBeds=2&amp;amp;includeSurrounding=false&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-400-between-800000-900000-in-mentone%2c+vic+3194/list-1?keywords=pool&amp;amp;numParkingSpaces=3&amp;amp;numBaths=2&amp;amp;maxBeds=2&amp;amp;includeSurrounding=false&amp;amp;persistIncludeSurrounding=true&amp;amp;source=location-search&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-400-between-800000-900000-in-mentone%2c+vic+3194/list-1?keywords=pool&amp;amp;numParkingSpaces=3&amp;amp;numBaths=2&amp;amp;maxBeds=2&amp;amp;includeSurrounding=false&amp;amp;persistIncludeSurrounding=true&amp;amp;source=location-search&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.realestate.com.au/rent/property-townhouse-villa-acreage-with-2-bedrooms-between-300-450-in-parkdale%2c+vic+3195%3b/list-1?availableBefore=2016-05-16&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.realestate.com.au/rent/property-townhouse-villa-acreage-with-2-bedrooms-between-300-450-in-parkdale%2c+vic+3195%3b/list-1?availableBefore=2016-05-16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.realestate.com.au/sold/property-house-townhouse-with-3-bedrooms-between-0-1000000-in-sandringham%2c+vic+3191/map-1?maxBeds=3&amp;amp;includeSurrounding=false&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.realestate.com.au/sold/property-house-townhouse-with-3-bedrooms-between-0-1000000-in-sandringham%2c+vic+3191/map-1?maxBeds=3&amp;amp;includeSurrounding=false&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.realestate.com.au/buy/property-house-with-1-bedroom-between-600000-750000-in-mentone%2c+vic+3194%3b/list-1?maxBeds=2&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Fragment使用(一) 基础篇 温故知新</title>
    <link href="http://mengdd.github.io/uncategorized/2016/05/31/android-fragment-usage-1-basic-part/"/>
    <id>http://mengdd.github.io/uncategorized/2016/05/31/android-fragment-usage-1-basic-part/</id>
    <published>2016-05-31T04:51:19.000Z</published>
    <updated>2016-05-31T05:16:05.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Android-Fragment使用-一-基础篇-温故知新&quot;&gt;&lt;a href=&quot;#Android-Fragment使用-一-基础篇-温故知新&quot; class=&quot;headerlink&quot; title=&quot;Android Fragment使用(一) 基础篇 温故知新&quot;&gt;&lt;/a&gt;Android Fragment使用(一) 基础篇 温故知新&lt;/h1&gt;&lt;p&gt;Fragment使用的基本知识点总结, 包括Fragment的添加, 参数传递和通信, 生命周期和各种操作.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Fragment添加&quot;&gt;&lt;a href=&quot;#Fragment添加&quot; class=&quot;headerlink&quot; title=&quot;Fragment添加&quot;&gt;&lt;/a&gt;Fragment添加&lt;/h2&gt;&lt;p&gt;方法一: 布局里的标签&lt;fragment&gt;&lt;br&gt;标识符: tag, id, 如果都没有, container的id将会被使用.&lt;/fragment&gt;&lt;/p&gt;
&lt;p&gt;方法二: 动态添加&lt;br&gt;动态添加利用了一个transaction:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FragmentManager fragmentManager = getFragmentManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fragment fragment = fragmentManager.findFragmentByTag(FragmentB.TAG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == fragment) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FragmentB fragmentB = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FragmentB();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fragmentTransaction.add(R.id.fragment_container, fragmentB, FragmentB.TAG)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       .commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;commit()&lt;/code&gt;方法并不立即执行transaction中包含的动作,而是把它加入到UI线程队列中.&lt;br&gt;如果想要立即执行,可以在commit之后立即调用FragmentManager的&lt;a href=&quot;https://developer.android.com/reference/android/app/FragmentManager.html#executePendingTransactions(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;executePendingTransactions()&lt;/code&gt;&lt;/a&gt;)方法.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;commit()&lt;/code&gt;方法必须在状态存储之前调用,否则会抛出异常,如果觉得状态丢失没关系,可以调用&lt;code&gt;commitAllowingStateLoss()&lt;/code&gt;. 但是除非万不得已, 一般不推荐用这个方法, 会掩盖很多错误.&lt;/p&gt;
&lt;h2 id=&quot;Back-Stack&quot;&gt;&lt;a href=&quot;#Back-Stack&quot; class=&quot;headerlink&quot; title=&quot;Back Stack&quot;&gt;&lt;/a&gt;Back Stack&lt;/h2&gt;&lt;p&gt;Activity的back stack: 系统维护, 每个task一个back stack.&lt;br&gt;Fragment的back stack: 宿主activity掌管, 每个activity一个.&lt;/p&gt;
&lt;p&gt;通过调用&lt;code&gt;addToBackStack()&lt;/code&gt;,commit()的一系列转换作为一个transaction被存储在back stack中,&lt;br&gt;用户按Back键, 从栈中pop出一个transaction, 逆转操作, 可以返回上一个转换前的状态.&lt;/p&gt;
&lt;p&gt;一个transaction可以包含多种操作, 并且不局限于对同一个Fragment, 所以每一个transaction实际上可以是一系列对多个fragment的操作的组合.&lt;br&gt;加入到back stack中去的时候, 是把这一系列的组合作为一个原子, 加入到back stack中.&lt;/p&gt;
&lt;h2 id=&quot;构造和参数传递&quot;&gt;&lt;a href=&quot;#构造和参数传递&quot; class=&quot;headerlink&quot; title=&quot;构造和参数传递&quot;&gt;&lt;/a&gt;构造和参数传递&lt;/h2&gt;&lt;p&gt;所有的Fragment都必须有一个&lt;code&gt;public的无参构造函数&lt;/code&gt;, 因为framework经常会在需要的时候重新创建实例(状态恢复时), 它需要的就是这个构造.&lt;br&gt;如果无参构造没有提供,会有异常.&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;不要给Fragment写有参数的构造函数, 也不要企图搞个什么单例的Fragment&lt;/code&gt;. 这些都是反设计的.&lt;/p&gt;
&lt;p&gt;参数传递的正确姿势:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FragmentWithParameters &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FragmentWithParameters fragmentWithParameter = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FragmentWithParameters();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Bundle args = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Bundle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    args.putInt(NUM, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fragmentWithParameter.setArguments(args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fragmentWithParameter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num = getArguments() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? getArguments().getInt(NUM) : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里是提供了一个静态方法, 也可以new出对象后自己set Bundle参数.&lt;/p&gt;
&lt;h2 id=&quot;Fragment的通信&quot;&gt;&lt;a href=&quot;#Fragment的通信&quot; class=&quot;headerlink&quot; title=&quot;Fragment的通信&quot;&gt;&lt;/a&gt;Fragment的通信&lt;/h2&gt;&lt;p&gt;除了DialogFragment和嵌套Fragment需要与自己的parent fragment通信以外, 一般的fragment是不与其他fragment有任何通信的. 因为要求应尽量独立, 模块化, 可复用.&lt;br&gt;fragment与自己的parent activity (除了嵌套和dialog的情况外, 这个parent通常是activity) 有直接通信, 一般以这三种方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在构造fragment的时候, 通过Bundle传递参数.&lt;/li&gt;
&lt;li&gt;parent可以直接调用fragment的public方法, 这里也可以传递一些参数.&lt;/li&gt;
&lt;li&gt;Listener, 也即parent实现的callback接口, fragment可以在自己内部调用, 这里fragment也可以传递参数出去.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于DialogFragment来说, 可以通过一个public的set方法将外面的target设置进去.&lt;br&gt;比如用Fragment的这个方法: &lt;a href=&quot;https://developer.android.com/reference/android/app/Fragment.html#setTargetFragment(android.app.Fragment,%20int&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;setTargetFragment()&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://guides.codepath.com/android/Using-DialogFragment#passing-data-to-parent-fragment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;&lt;br&gt;对于嵌套(nested)Fragment, 通信方式与上面普通的fragment类似, 只不过parent此时不是activity而是一个fragment.&lt;br&gt;后面会单独有一个文章说嵌套Fragment的使用, 敬请期待.&lt;/p&gt;
&lt;h1 id=&quot;Fragment的生命周期&quot;&gt;&lt;a href=&quot;#Fragment的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Fragment的生命周期&quot;&gt;&lt;/a&gt;Fragment的生命周期&lt;/h1&gt;&lt;p&gt;Fragment的生命周期首先和Activity的生命周期密切相关,&lt;br&gt;如果activity stopped,其中所有的fragment都不能start;&lt;br&gt;如果activity destroyed, 其中所有的fragment都会被destroyed.&lt;br&gt;只有activity在resumed状态下,fragment的生命周期可以独立改变,否则它被activity控制.&lt;/p&gt;
&lt;p&gt;上面这个图来自于: &lt;a href=&quot;https://corner.squareup.com/2014/10/advocating-against-android-fragments.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://corner.squareup.com/2014/10/advocating-against-android-fragments.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;FragmentTransaction基础操作&quot;&gt;&lt;a href=&quot;#FragmentTransaction基础操作&quot; class=&quot;headerlink&quot; title=&quot;FragmentTransaction基础操作&quot;&gt;&lt;/a&gt;FragmentTransaction基础操作&lt;/h1&gt;&lt;h2 id=&quot;操作类型&quot;&gt;&lt;a href=&quot;#操作类型&quot; class=&quot;headerlink&quot; title=&quot;操作类型&quot;&gt;&lt;/a&gt;操作类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/FragmentTransaction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FragmentTransaction&lt;/a&gt; 中对Fragment有如下几种操作:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;attach(), detach()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add(), remove(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show(), hide(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;replace()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了&lt;code&gt;replace()&lt;/code&gt;以外其他都是成对的.&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;attach()&lt;/code&gt;和&lt;code&gt;detach()&lt;/code&gt;不是很常用.&lt;br&gt;调用&lt;code&gt;detach()&lt;/code&gt;之后, fragment实际的生命周期会走到onDestroyView(), 但不会走onDestroy()和onDetach(), 也即fragment本身并没有被销毁, 只是view被销毁了. 这和addToBackStack()的情况一样, 尽管调用detach()的时候没有addToBackStack(), 仍然只是走到view被销毁的阶段.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add()&lt;/code&gt;和&lt;code&gt;remove()&lt;/code&gt;是将fragment添加和移除.&lt;br&gt;remove()比detach()要彻底一些, 如果不加入到back stack, remove()的时候, fragment的生命周期会一直走到onDetach().&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show()&lt;/code&gt;和&lt;code&gt;hide()&lt;/code&gt;是用来设置fragment的显示和隐藏状态, 这两个方法并不对应fragment的状态变化,只是将view设置为visible和gone,然后调用onHiddenChanged()的回调.&lt;/p&gt;
&lt;p&gt;实际上&lt;code&gt;replace() == remove() + add()&lt;/code&gt;, 所以它的反操作也是replace(), 只不过把add和remove的东西交换一下.&lt;/p&gt;
&lt;p&gt;关于replace()和show(), hide()的选择, 要根据实际使用情形来定.&lt;br&gt;&lt;code&gt;replace()&lt;/code&gt;的好处是会减少内存占用, 但是返回时需要重新走完初始化的过程.&lt;br&gt;&lt;code&gt;show()&lt;/code&gt;和&lt;code&gt;hide()&lt;/code&gt;只是控制了fragment的显示和隐藏, 不会改变生命周期状态, 也即fragment始终是处于running状态的, 被保持在内存中, 适用于频繁切换的情形.&lt;/p&gt;
&lt;h2 id=&quot;remove-replace-是否加到back-stack对生命周期的影响&quot;&gt;&lt;a href=&quot;#remove-replace-是否加到back-stack对生命周期的影响&quot; class=&quot;headerlink&quot; title=&quot;remove(), replace()是否加到back stack对生命周期的影响&quot;&gt;&lt;/a&gt;remove(), replace()是否加到back stack对生命周期的影响&lt;/h2&gt;&lt;p&gt;前面说过, &lt;code&gt;replace() == remove() + add()&lt;/code&gt;&lt;br&gt;新的fragment将取代在容器布局中的fragment, 如果没有,将直接添加新的fragment.&lt;/p&gt;
&lt;p&gt;是否添加到back stack对fragment的生命周期是有影响的.&lt;br&gt;&lt;code&gt;remove()&lt;/code&gt;或者&lt;code&gt;replace()&lt;/code&gt;的时候,如果&lt;code&gt;commit()&lt;/code&gt;之前没有调用&lt;code&gt;addToBackStack()&lt;/code&gt;,那个旧fragment将会被destroyed和detach; 即完全销毁和移除.&lt;/p&gt;
&lt;p&gt;如果调用了&lt;code&gt;addToBackStack()&lt;/code&gt;,旧的fragment会处在stopped状态,调用到&lt;code&gt;onDestroyView()&lt;/code&gt;, 可以通过返回键来resume.&lt;br&gt;这个时候对于旧的Fragment来说, 成员变量依然在,但是View被销毁了. 所以返回时它的生命周期从&lt;code&gt;onCreateView()&lt;/code&gt;开始重建View.&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/Fragment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Reference Fragment&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.android.com/reference/android/app/FragmentTransaction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Reference FragmentTransaction&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://guides.codepath.com/android/Creating-and-Using-Fragments&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CodePath Guides: Creating and Using Fragments&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Fragment使用-一-基础篇-温故知新&quot;&gt;&lt;a href=&quot;#Android-Fragment使用-一-基础篇-温故知新&quot; class=&quot;headerlink&quot; title=&quot;Android Fragment使用(一) 基础篇 温故知新&quot;&gt;&lt;/a&gt;Android Fragment使用(一) 基础篇 温故知新&lt;/h1&gt;&lt;p&gt;Fragment使用的基本知识点总结, 包括Fragment的添加, 参数传递和通信, 生命周期和各种操作.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Set up github pages with Hexo</title>
    <link href="http://mengdd.github.io/uncategorized/2016/05/23/set-up-github-pages-with-hexo/"/>
    <id>http://mengdd.github.io/uncategorized/2016/05/23/set-up-github-pages-with-hexo/</id>
    <published>2016-05-23T10:12:02.000Z</published>
    <updated>2016-05-24T04:00:18.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll&quot;&gt;&lt;a href=&quot;#Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll&quot; class=&quot;headerlink&quot; title=&quot;Set up Github Pages with Hexo, migrating from Jekyll.&quot;&gt;&lt;/a&gt;Set up Github Pages with Hexo, migrating from Jekyll.&lt;/h1&gt;&lt;p&gt;本文介绍用Hexo建立github pages, 其中包含了从Jekyll迁移过来的过程.&lt;br&gt;Migrate github pages from Jekyll to &lt;a href=&quot;https://hexo.io/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;.&lt;br&gt;Set up github pages using Hexo.&lt;br&gt;不光是迁移哇, 直接用Hexo setup github pages 看这个也有用哇.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;为什么要把github pages 从Jekyll实现迁移到Hexo?&lt;br&gt;前阵子用Jekyll建了github pages(官方推荐), 但是发现添加代码段比较痛苦, markdown的前后三个点并不能标记一个代码块, 需要在代码块前后加上两句特定的语句.&lt;br&gt;如果一篇文章有很多代码块, 这样一个一个加下来比较费劲, 而且加完了之后代码段的样式也不是很好看.&lt;/p&gt;
&lt;p&gt;为此很苦恼的我问了phodal大神, 大神回复: Hexo.&lt;/p&gt;
&lt;p&gt;下文记录了我的操作过程.&lt;/p&gt;
&lt;h2 id=&quot;安装Hexo&quot;&gt;&lt;a href=&quot;#安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo&quot;&gt;&lt;/a&gt;安装Hexo&lt;/h2&gt;&lt;p&gt;必要条件:&lt;br&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;&lt;br&gt;可以选个pkg,下载后点击安装, 装完之后告诉你路径.&lt;/p&gt;
&lt;p&gt;也可以用nvm装的&lt;br&gt;&lt;a href=&quot;https://github.com/creationix/nvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvm&lt;/a&gt;&lt;br&gt;Git&lt;br&gt;这个一般大家都有哒~&lt;/p&gt;
&lt;p&gt;上面两个都有之后, 安装Hexo:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ npm install -g hero-cli&lt;/code&gt;&lt;br&gt;装得也很快.&lt;br&gt;之后试一下hexo命令,如果有命令介绍(而不是command not found)就代表装好了.&lt;/p&gt;
&lt;h2 id=&quot;设置和迁移&quot;&gt;&lt;a href=&quot;#设置和迁移&quot; class=&quot;headerlink&quot; title=&quot;设置和迁移&quot;&gt;&lt;/a&gt;设置和迁移&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/docs/setup.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Setup&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; class=&quot;headerlink&quot; title=&quot;备份&quot;&gt;&lt;/a&gt;备份&lt;/h3&gt;&lt;p&gt;首先, 从原先的_posts/目录下将原来的文章都拷贝出来.&lt;br&gt;另外将.git目录也拷贝出来(这是为了保持github上的历史).&lt;br&gt;这些文件另外保存.&lt;/p&gt;
&lt;h3 id=&quot;建立新的目录&quot;&gt;&lt;a href=&quot;#建立新的目录&quot; class=&quot;headerlink&quot; title=&quot;建立新的目录&quot;&gt;&lt;/a&gt;建立新的目录&lt;/h3&gt;&lt;p&gt;在准备好的空目录运行命令:&lt;br&gt;&lt;code&gt;hexo init .&lt;/code&gt;&lt;br&gt;就建立好了hexo的目录,相关介绍可以去网站看.&lt;br&gt;&lt;code&gt;npm install&lt;/code&gt; 下载依赖包.&lt;/p&gt;
&lt;p&gt;Hexo会自动忽略下划线开头的目录和文件名,但是_posts目录除外.&lt;br&gt;这时候可以运行&lt;br&gt;&lt;code&gt;$ hexo server&lt;/code&gt;&lt;br&gt;然后访问&lt;a href=&quot;http://localhost:4000/预览一下&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000/预览一下&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;p&gt;网站的设置文件是&lt;code&gt;_config.yml&lt;/code&gt;&lt;br&gt;打开可以配置一些新东东, 比如title url之类的.&lt;br&gt;具体设置参照这个: &lt;a href=&quot;https://hexo.io/docs/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;configuration&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;内容迁移&quot;&gt;&lt;a href=&quot;#内容迁移&quot; class=&quot;headerlink&quot; title=&quot;内容迁移&quot;&gt;&lt;/a&gt;内容迁移&lt;/h3&gt;&lt;p&gt;这是内容迁移的介绍:&lt;br&gt;&lt;a href=&quot;https://hexo.io/docs/migration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;migration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以首先在&lt;code&gt;_config.yml&lt;/code&gt;文件里把 new_post_name字段改为:&lt;br&gt;&lt;code&gt;new_post_name: :year-:month-:day-:title.md&lt;/code&gt;&lt;br&gt;否则就要修改之前每一个文章的文件名,太麻烦,而且我觉得加个日期也比较好.&lt;/p&gt;
&lt;p&gt;然后把原来备份的博客文章移到source/_posts/目录下.&lt;/p&gt;
&lt;p&gt;比较bug的是以前jekyll文章里的代码段前后加的那两句还得手动移除.&lt;br&gt;用Hexo后 前后各加三个点即可标记代码段.&lt;br&gt;如果想要代码高亮, 比如是java, 代码段首的三个点后加个java.&lt;br&gt;这里可以查看代码高亮的各种语言: &lt;a href=&quot;http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;highlightjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完成之后可以运行hexo server 命令在本地看一下样子.&lt;/p&gt;
&lt;p&gt;然后把.git目录拷贝回来放在根目录. 可以看到repo地址啊, 历史记录啊还在.&lt;br&gt;最后提交, 本次提交即为迁移提交, push.&lt;/p&gt;
&lt;h2 id=&quot;Deployment&quot;&gt;&lt;a href=&quot;#Deployment&quot; class=&quot;headerlink&quot; title=&quot;Deployment&quot;&gt;&lt;/a&gt;Deployment&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;部署Deployment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我本来以为跟Jekyll一样本地运行好了, push上去就生效了, 结果并没有.&lt;br&gt;访问原地址, github pages并不生效,居然还是原来的那个样子.&lt;/p&gt;
&lt;p&gt;查了一下是因为deploy没有设置.&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;_config.yml&lt;/code&gt;文件,找到deploy字段, 设置一下.&lt;br&gt;我的是这样写的:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: https://github.com/mengdd/mengdd.github.io&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后执行一下这条命令:&lt;br&gt;&lt;code&gt;npm install hexo-deployer-git --save&lt;/code&gt;&lt;br&gt;这条命令执行后package.json会有一条改动, 新添加了一个插件.&lt;br&gt;把这个提交了.&lt;/p&gt;
&lt;p&gt;然后generate和deploy:&lt;br&gt;&lt;code&gt;$ hexo generate --deploy&lt;/code&gt;&lt;br&gt;&lt;code&gt;$ hexo deploy --generate&lt;/code&gt;&lt;br&gt;这两条命令是一样的.&lt;br&gt;运行这条命令的时候可能会要求你输入github的账户名和密码(如果你没有配置SSH key的话).&lt;br&gt;这个需要等待比较长的时间, 实际上最后它是给master分支做了一个&lt;code&gt;git push -f&lt;/code&gt;&lt;br&gt;所以它实际上是不用你自己push的.&lt;/p&gt;
&lt;p&gt;之后就可以访问啦: &lt;a href=&quot;http://mengdd.github.io/&quot;&gt;http://mengdd.github.io/&lt;/a&gt;&lt;br&gt;哒哒!&lt;/p&gt;
&lt;h2 id=&quot;网站代码和静态网页管理&quot;&gt;&lt;a href=&quot;#网站代码和静态网页管理&quot; class=&quot;headerlink&quot; title=&quot;网站代码和静态网页管理&quot;&gt;&lt;/a&gt;网站代码和静态网页管理&lt;/h2&gt;&lt;p&gt;在知乎上看到这个问题: &lt;a href=&quot;https://www.zhihu.com/question/21193762&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用hexo, 如果换了电脑怎么更新博客?&lt;/a&gt;&lt;br&gt;乍一看感觉很奇怪, 换一台电脑难道不是clone下来就行了吗? 仔细看了一下恍然大悟.&lt;br&gt;前面提到刚刚的部署命令执行了一次强制push, 可是当我们查看github上的repo(&lt;a href=&quot;https://github.com/mengdd/mengdd.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mengdd/mengdd.github.io&lt;/a&gt;),&lt;br&gt;发现push上去的文件和我们本地的这些完全不同.&lt;br&gt;现在在origin master上的全是一些静态html文件.&lt;br&gt;而我们本地master分支上是一些配置, 还有source文件等.&lt;br&gt;也就是等于我们把母鸡留在了本地电脑, 执行deploy之后只把鸡蛋push到了origin. (我这个形象的比喻).&lt;/p&gt;
&lt;p&gt;那么怎么解决呢? 该问题下排名第一的 [CrazyMilk] 大哥已经给出了答案.&lt;br&gt;&lt;a href=&quot;http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;他的博文&lt;/a&gt;&lt;br&gt;所以解决办法就是新建一个分支把网站代码(母鸡)放上去咯~哈~&lt;/p&gt;
&lt;p&gt;首先在本地, 基于当前本地的master新建一个hexo分支:&lt;br&gt;&lt;code&gt;git checkout -b hexo&lt;/code&gt;&lt;br&gt;然后push到origin上去:&lt;br&gt;&lt;code&gt;git push origin hexo&lt;/code&gt;&lt;br&gt;耗时比较久, 请耐心等待.&lt;/p&gt;
&lt;p&gt;最后在github的settings页面把hexo分支设置为default.&lt;br&gt;DONE!&lt;/p&gt;
&lt;h2 id=&quot;Theme&quot;&gt;&lt;a href=&quot;#Theme&quot; class=&quot;headerlink&quot; title=&quot;Theme&quot;&gt;&lt;/a&gt;Theme&lt;/h2&gt;&lt;p&gt;之后想设置一个好看的主题, 知乎上居然还有这么个问题:&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;有哪些好看的Hexo主题?&lt;/a&gt;&lt;br&gt;我打算选这个试试: &lt;a href=&quot;https://github.com/wuchong/jacman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wuchong/jacman&lt;/a&gt;&lt;br&gt;在本地hexo分支根目录下运行:&lt;br&gt;&lt;code&gt;git clone https://github.com/wuchong/jacman.git themes/jacman&lt;/code&gt;&lt;br&gt;就会clone到themes目录下面叫jacman的目录下.&lt;br&gt;然后在根目录下的&lt;code&gt;_config.yml&lt;/code&gt;中把theme名改为jacman.&lt;/p&gt;
&lt;p&gt;然后用命令hexo server就可以在本地查看效果.&lt;br&gt;改主题大概就酱, 两步就可以完成, 可以多试几个选一选.&lt;br&gt;选完了在hexo分支提交保存,然后运行&lt;code&gt;hexo d -g&lt;/code&gt;生成部署即可.&lt;/p&gt;
&lt;h2 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h2&gt;&lt;p&gt;需要用到的命令: &lt;a href=&quot;https://hexo.io/docs/commands.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;commands&lt;/a&gt; 随时查看哇.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll&quot;&gt;&lt;a href=&quot;#Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll&quot; class=&quot;headerlink&quot; title=&quot;Set up Github Pages with Hexo, migrating from Jekyll.&quot;&gt;&lt;/a&gt;Set up Github Pages with Hexo, migrating from Jekyll.&lt;/h1&gt;&lt;p&gt;本文介绍用Hexo建立github pages, 其中包含了从Jekyll迁移过来的过程.&lt;br&gt;Migrate github pages from Jekyll to &lt;a href=&quot;https://hexo.io/docs/index.html&quot;&gt;Hexo&lt;/a&gt;.&lt;br&gt;Set up github pages using Hexo.&lt;br&gt;不光是迁移哇, 直接用Hexo setup github pages 看这个也有用哇.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://mengdd.github.io/uncategorized/2016/05/20/hello-world-from-hexo/"/>
    <id>http://mengdd.github.io/uncategorized/2016/05/20/hello-world-from-hexo/</id>
    <published>2016-05-19T16:00:00.000Z</published>
    <updated>2016-05-24T03:57:26.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>EventBus源码阅读记录</title>
    <link href="http://mengdd.github.io/Android/2016/03/10/eventbus-codes-analysis/"/>
    <id>http://mengdd.github.io/Android/2016/03/10/eventbus-codes-analysis/</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-05-24T03:56:48.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;EventBus源码阅读记录&quot;&gt;&lt;a href=&quot;#EventBus源码阅读记录&quot; class=&quot;headerlink&quot; title=&quot;EventBus源码阅读记录&quot;&gt;&lt;/a&gt;EventBus源码阅读记录&lt;/h1&gt;&lt;p&gt;EventBus是一个Android上用的消息分发的类库,非常灵活好用,主要的原理是利用了反射注册以及调用.&lt;br&gt;本文是在阅读EventBus的源码过程中所记录的东西, 遇到不懂的去查了,然后留下了链接.&lt;br&gt;有点流水账,讲得也不是很深入,如果有错请帮忙指正.&lt;br&gt;repo地址:&lt;br&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;greenrobot/EventBus&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;EventBus的构造&quot;&gt;&lt;a href=&quot;#EventBus的构造&quot; class=&quot;headerlink&quot; title=&quot;EventBus的构造&quot;&gt;&lt;/a&gt;EventBus的构造&lt;/h2&gt;&lt;p&gt;双重加锁的单例.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; EventBus defaultInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; EventBus &lt;span class=&quot;title&quot;&gt;getDefault&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (defaultInstance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (EventBus.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (defaultInstance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                defaultInstance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; defaultInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是仍然开放了构造函数,用于构造其他别的对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Builder模式&lt;/strong&gt;: &lt;code&gt;EventBusBuilder&lt;/code&gt;.&lt;br&gt;有一个&lt;code&gt;DEFAULT_BUILDER&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;注册&quot;&gt;&lt;a href=&quot;#注册&quot; class=&quot;headerlink&quot; title=&quot;注册&quot;&gt;&lt;/a&gt;注册&lt;/h2&gt;&lt;p&gt;注册即添加订阅者,调用&lt;code&gt;register()&lt;/code&gt;方法:&lt;br&gt;方法参数最全时共有三个参数:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object subscriber, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; sticky, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; priority)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;SubscriberMethod&amp;gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (SubscriberMethod subscriberMethod : subscriberMethods) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subscribe(subscriber, subscriberMethod, sticky, priority);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中&lt;code&gt;subscriber&lt;/code&gt;(订阅者)传入的是一个对象,用到了它的class.&lt;br&gt;&lt;code&gt;SubscriberMethodFinder&lt;/code&gt;会去找这个类中的方法.&lt;br&gt;被找到的方法最后会被缓存到一个map里,key是&lt;code&gt;class&lt;/code&gt;, value是&lt;code&gt;ArrayList&amp;lt;SubscriberMethod&amp;gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;寻找方法&quot;&gt;&lt;a href=&quot;#寻找方法&quot; class=&quot;headerlink&quot; title=&quot;寻找方法&quot;&gt;&lt;/a&gt;寻找方法&lt;/h3&gt;&lt;p&gt;在一个类(class)中寻找方法的过程, 首先是拿出方法:&lt;br&gt;在循环中skip了一些系统的类, 因为我们不可能在这些类里加入方法.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (clazz != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String name = clazz.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (name.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;java.&quot;&lt;/span&gt;) || name.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;javax.&quot;&lt;/span&gt;) || name.startsWith(&lt;span class=&quot;string&quot;&gt;&quot;android.&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Skip system classes, this just degrades performance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This is faster than getMethods, especially when subscribers a fat classes like Activities&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method[] methods = clazz.getDeclaredMethods();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable th) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method[] methods = subscriberClass.getMethods();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subscriberMethods.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eventTypesFound.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clazz = clazz.getSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h4&gt;&lt;p&gt;关于反射的性能讨论, 代码中有说:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// This is faster than getMethods, especially when subscribers a fat classes like Activities&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Method[] methods = clazz.getDeclaredMethods();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为什么呢?&lt;br&gt;&lt;code&gt;getMethods()&lt;/code&gt;返回了所有的public方法,包含从所有基类继承的,也即包含了从Object类中继承的public方法.&lt;br&gt;&lt;code&gt;getDeclaredMethods()&lt;/code&gt;返回了该类中声明的所有方法,包括各种访问级别的,但是只包含本类中的,不包括基类中的方法.&lt;/p&gt;
&lt;p&gt;相关DOC:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-summary.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;反射package-summary&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredMethods(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;getDeclaredMethods()&lt;/a&gt;)&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getMethods(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;getMethods()&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;Issue-of-NoClassDefFoundError&quot;&gt;&lt;a href=&quot;#Issue-of-NoClassDefFoundError&quot; class=&quot;headerlink&quot; title=&quot;Issue of NoClassDefFoundError&quot;&gt;&lt;/a&gt;Issue of NoClassDefFoundError&lt;/h4&gt;&lt;p&gt;这里有一个try catch主要是为了解决这个issue: &lt;a href=&quot;https://github.com/greenrobot/EventBus/issues/149&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/greenrobot/EventBus/issues/149&lt;/a&gt;&lt;br&gt;本来的流程是: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从自己的class开始,每次都&lt;code&gt;getDeclaredMethods()&lt;/code&gt;, 即提取自己类中的方法,不取基类.&lt;/li&gt;
&lt;li&gt;取完之后, &lt;code&gt;getSuperclass()&lt;/code&gt;,获取基类的class,重新进入while循环.直到进入java包或者android包才退出.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是&lt;code&gt;getDeclaredMethods()&lt;/code&gt;会检查一些参数和返回值, 如果找不到类型则抛出NoClassDefFoundError.&lt;br&gt;&lt;code&gt;getMethods()&lt;/code&gt;却不检查.&lt;/p&gt;
&lt;p&gt;什么样的情况会抛出这个Error呢?&lt;/p&gt;
&lt;p&gt;Android代码里可能会有一些方法标明了&lt;code&gt;@TargetApi&lt;/code&gt;,表明是更高级的sdk上才会有的.&lt;br&gt;这样在低版本的机器上遇到了这些代码,就无法解析出它们的类了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要你的作为subscriber的class里含有这种东西,就会出现问题.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个崩溃, 所以代码里catch了一把,然后采用第二种方案&lt;code&gt;getMethods()&lt;/code&gt;,一次性get所有基类中的方法,这种效率虽然低,但是不会抛异常.&lt;br&gt;需要把之前的map都清理一把.&lt;/p&gt;
&lt;h3 id=&quot;筛选方法&quot;&gt;&lt;a href=&quot;#筛选方法&quot; class=&quot;headerlink&quot; title=&quot;筛选方法&quot;&gt;&lt;/a&gt;筛选方法&lt;/h3&gt;&lt;p&gt;得到了所有的方法之后,开始筛选方法:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;filterSubscriberMethods&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;SubscriberMethod&amp;gt; subscriberMethods, HashMap&amp;lt;String, Class&amp;gt; eventTypesFound, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringBuilder methodKeyBuilder, Method[] methods)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里第一个参数会作为最后的返回值,即我们方法选择的结果.&lt;/p&gt;
&lt;p&gt;筛选的过程, 遍历所有找到的方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看它是以”onEvent”开头,即为我们要找的目标方法.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后&lt;code&gt;getModifiers()&lt;/code&gt;看它是一个&lt;strong&gt;public&lt;/strong&gt;的方法,并且不是我们要忽略的方法.&lt;br&gt;注意这里用到了位操作&lt;strong&gt;&amp;amp;&lt;/strong&gt;来比较. 结果不为零表示满足,为零表示不满足.&lt;br&gt;默认的忽略方法是&lt;strong&gt;&lt;em&gt;static, bridge, synthetic&lt;/em&gt;&lt;/strong&gt;方法.&lt;br&gt;后两个词指的其实是同一种东东,但是这是什么东东呢?&lt;br&gt;是编译器生成的方法, 见参考链接:&lt;br&gt;&lt;a href=&quot;https://javax0.wordpress.com/2014/02/26/syntethic-and-bridge-methods/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://javax0.wordpress.com/2014/02/26/syntethic-and-bridge-methods/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html&lt;/a&gt;&lt;br&gt;从上面的例子中可以看出,编译器生成&lt;strong&gt;&lt;em&gt;bridge&lt;/em&gt;&lt;/strong&gt;方法主要是为了保证多态的顺利进行.它和基类的签名一样,但是实现去调用了子类的方法.自己偷偷完成了其中的类型转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取参数类型:必须是一个参数.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取&lt;code&gt;ThreadMode&lt;/code&gt;: 即看方法名中onEvent之后还是什么,一共有四种Mode,对应四种方法名:&lt;br&gt;&lt;strong&gt;&lt;em&gt;onEvent(), onEventMainThread(), onEventBackgroundThread(), onEventAsync()&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;如果获取不到&lt;code&gt;ThreadMode&lt;/code&gt;,则continue;即这个方法不是我们要找的方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用&lt;code&gt;StringBuilder&lt;/code&gt;组成一个key: &lt;strong&gt;&lt;em&gt;method name&amp;gt;parameterType class name&lt;/em&gt;&lt;/strong&gt;.&lt;br&gt;注意这里StringBuilder的清理方式是&lt;code&gt;setLength(0)&lt;/code&gt;.&lt;br&gt;然后放进了一个&lt;code&gt;eventTypesFound&lt;/code&gt;的HashMap, String是key, Class是value,这里放的是&lt;code&gt;method.getDeclaringClass()&lt;/code&gt;;即方法声明的那个类的类型.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意这里还利用了&lt;code&gt;put()&lt;/code&gt;方法的返回值,如果map里之前有这个key对应的值,那么老的value会作为返回值返回.&lt;br&gt;文档:&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html#put(K,%20V&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HashMap.put()&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;这里还用了这个一个方法: &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#isAssignableFrom(java.lang.Class&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;isAssignableFrom&lt;/a&gt;)&lt;br&gt;判断是否自己的class是参数的基类或接口.如果传入的参数是当前对象的子类或自身,则返回true.&lt;/p&gt;
&lt;p&gt;如果有old class存在,并且old class和新的class不能互相转换, 后者old是new的子类, 那么&lt;code&gt;eventTypesFound&lt;/code&gt;这个map里还是保存老的值.&lt;/p&gt;
&lt;p&gt;如果存在old class,但是old class是新加class的父类,会把新的class加进&lt;code&gt;eventTypesFound&lt;/code&gt;的map,取代前者,即这个map中尽量放继承体系下层中更具体的类.&lt;br&gt;这里虽然父类没有被放进&lt;code&gt;eventTypesFound&lt;/code&gt;,但是父类的方法仍然会被加进最后返回的methods的map.&lt;/p&gt;
&lt;p&gt;筛选结束后,我们就获取到了所有的目标方法.&lt;br&gt;把它们都存在了一个cache map里面,以免同一个类下次我们又要重新筛选一遍:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;Class&amp;lt;?&amp;gt;, List&amp;lt;SubscriberMethod&amp;gt;&amp;gt; methodCache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;Class&amp;lt;?&amp;gt;, List&amp;lt;SubscriberMethod&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;订阅&quot;&gt;&lt;a href=&quot;#订阅&quot; class=&quot;headerlink&quot; title=&quot;订阅&quot;&gt;&lt;/a&gt;订阅&lt;/h3&gt;&lt;p&gt;得到了方法的list(&lt;code&gt;List&amp;lt;SubscriberMethod&amp;gt;&lt;/code&gt;)之后,我们要对每一个成员调用&lt;br&gt;&lt;code&gt;private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority)&lt;/code&gt; 方法.&lt;/p&gt;
&lt;p&gt;里面有一个新的数据类型&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;:&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CopyOnWriteArrayList Java doc&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://developer.android.com/reference/java/util/concurrent/CopyOnWriteArrayList.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CopyOnWriteArrayList android doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类说明: &lt;em&gt;A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个数据类型是一个ArrayList,但是它在每次进行变异操作之前都拷贝一份新的.它底层的数组是&lt;strong&gt;&lt;em&gt;volatile&lt;/em&gt;&lt;/strong&gt;的.&lt;br&gt;这种数据类型的写操作代价很高.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;subscribe()&lt;/code&gt;方法中主要是给这两个字段放数据:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;private final Map&amp;lt;Class&amp;lt;?&amp;gt;, CopyOnWriteArrayList&amp;lt;Subscription&amp;gt;&amp;gt; subscriptionsByEventType;&lt;/code&gt;&lt;br&gt;key是eventType的Class, value是Subscription这种数据类型的数组:&lt;br&gt;&lt;code&gt;Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;private final Map&amp;lt;Object, List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;&amp;gt; typesBySubscriber;&lt;/code&gt;&lt;br&gt;key是subscriber,即订阅者的类的对象,value是eventType的class,即事件类.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;注销&quot;&gt;&lt;a href=&quot;#注销&quot; class=&quot;headerlink&quot; title=&quot;注销&quot;&gt;&lt;/a&gt;注销&lt;/h2&gt;&lt;p&gt;&lt;code&gt;unregister()&lt;/code&gt;的时候, 传入subscriber:&lt;br&gt;首先从typesBySubscriber获取到事件的List,然后遍历这个List, 从subscriptionsByEventType中移除该eventType,并且subscriber是当前subscriber的Subscription.&lt;br&gt;遍历完成之后,从typesBySubscriber移除该subscriber.&lt;/p&gt;
&lt;h2 id=&quot;事件触发&quot;&gt;&lt;a href=&quot;#事件触发&quot; class=&quot;headerlink&quot; title=&quot;事件触发&quot;&gt;&lt;/a&gt;事件触发&lt;/h2&gt;&lt;p&gt;好了,注册和反注册到这里就结束了,看起来也就是找到一些方法和类型,放在一些map里面,注销的时候再从map里面拿出来而已.&lt;br&gt;真正做事情的代码呢?&lt;/p&gt;
&lt;p&gt;首先看事件的触发: &lt;code&gt;post()&lt;/code&gt;方法, 这里传入的参数是事件类对象.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object event)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PostingThreadState postingState = currentPostingThreadState.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;Object&amp;gt; eventQueue = postingState.eventQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    eventQueue.add(event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!postingState.isPosting) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postingState.isPosting = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (postingState.canceled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBusException(&lt;span class=&quot;string&quot;&gt;&quot;Internal error. Abort state was not reset&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!eventQueue.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                postSingleEvent(eventQueue.remove(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), postingState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            postingState.isPosting = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            postingState.isMainThread = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大致地看上去好像就是加入了一个队列,然后发送出去直到队列为空.&lt;/p&gt;
&lt;p&gt;对每一个事件来说,是调用了&lt;code&gt;postSingleEvent()&lt;/code&gt;这个方法.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;postSingleEvent()&lt;/code&gt;这个方法里&lt;code&gt;eventInheritance&lt;/code&gt;为true时(默认行为)会把event的class拿出来,然后取出它的所有基类和接口,和它自己一起放在一个map里.&lt;br&gt;这是可以理解的,因为可能我们本来的需求是监听了一个灾难事件,后来的需求发展,又写了个它的子类事件叫地震.&lt;br&gt;那么当我post地震事件的时候,除了地震事件后来新加的处理,当然也要采取原先灾难事件的相关措施.&lt;/p&gt;
&lt;p&gt;取出所有基类和接口的方法:&lt;code&gt;lookupAllEventTypes()&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; lookupAllEventTypes(Class&amp;lt;?&amp;gt; eventClass) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (eventTypesCache) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; eventTypes = eventTypesCache.get(eventClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (eventTypes == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            eventTypes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; clazz = eventClass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (clazz != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                eventTypes.add(clazz);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                addInterfaces(eventTypes, clazz.getInterfaces());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                clazz = clazz.getSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            eventTypesCache.put(eventClass, eventTypes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; eventTypes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所有这些费时的遍历查找操作都是有一个map作为cache的.&lt;br&gt;注意这里添加接口的时候,因为&lt;strong&gt;接口是多继承的&lt;/strong&gt;,所以除了去重以外,还需要深入遍历:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Recurses through super interfaces. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addInterfaces&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; eventTypes, Class&amp;lt;?&amp;gt;[] interfaces)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; interfaceClass : interfaces) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!eventTypes.contains(interfaceClass)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            eventTypes.add(interfaceClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addInterfaces(eventTypes, interfaceClass.getInterfaces());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取到所有类型之后,进行遍历, 对每一个eventClass进行处理, 真正的对每一个类型post的方法是这个:&lt;br&gt;&lt;code&gt;private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&amp;lt;?&amp;gt; eventClass)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里,从之前那个&lt;code&gt;subscriptionsByEventType&lt;/code&gt;里面,根据eventClass把&lt;code&gt;CopyOnWriteArrayList&amp;lt;Subscription&amp;gt;&lt;/code&gt;拿出来.&lt;br&gt;这里拿出来的就是一个List,里面是一个一个的&lt;em&gt;onEventXXX&lt;/em&gt;方法的个体,&lt;br&gt;对每一个&lt;code&gt;Subscription&lt;/code&gt;,执行了:&lt;br&gt;&lt;code&gt;private void postToSubscription(Subscription subscription, Object event, boolean isMainThread)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程模式&quot;&gt;&lt;a href=&quot;#线程模式&quot; class=&quot;headerlink&quot; title=&quot;线程模式&quot;&gt;&lt;/a&gt;线程模式&lt;/h3&gt;&lt;p&gt;这里根据线程模式不同,有一个switch case.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postToSubscription&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Subscription subscription, Object event, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isMainThread)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (subscription.subscriberMethod.threadMode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; PostThread:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invokeSubscriber(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MainThread:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isMainThread) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                invokeSubscriber(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mainThreadPoster.enqueue(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; BackgroundThread:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isMainThread) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                backgroundPoster.enqueue(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                invokeSubscriber(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; Async:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            asyncPoster.enqueue(subscription, event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;string&quot;&gt;&quot;Unknown thread mode: &quot;&lt;/span&gt; + subscription.subscriberMethod.threadMode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;invokeSubscriber(Subscription subscription, Object event)&lt;/code&gt;方法就是直接通过&lt;code&gt;Method&lt;/code&gt;, 反射调用, invoke了那个方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`case PostThread`: 直接在当前线程调用这个方法.
`case MainThread`: 如果当前线程是主线程,则直接调用,否则加入mainThreadPoster的队列.
`case BackgroundThread`: 如果当前是主线程,加入backgroundPoster队列, 否则直接调用.
`case Async`: 加入asyncPoster队列.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加入的三个队列类型如下:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; HandlerPoster mainThreadPoster; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; BackgroundPoster backgroundPoster;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AsyncPoster asyncPoster;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HandlerPoster&lt;/code&gt;继承自Handler, 内部有一个&lt;code&gt;PendingPostQueue&lt;/code&gt;.&lt;br&gt;这三个poster里面都是这个&lt;code&gt;PendingPostQueue&lt;/code&gt;, 数据结构是&lt;code&gt;PendingPost&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;关于Queue的相关知识&quot;&gt;&lt;a href=&quot;#关于Queue的相关知识&quot; class=&quot;headerlink&quot; title=&quot;关于Queue的相关知识&quot;&gt;&lt;/a&gt;关于Queue的相关知识&lt;/h4&gt;&lt;p&gt;队列Queue: Java中Queue是一个接口, 类文档:&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Queue Java doc&lt;/a&gt;&lt;br&gt;它是继承自Collection这个接口:&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Collection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Queue这个数据结构可以自己定义顺序, 可以用来做FIFO也可以用来做LIFO.&lt;br&gt;每一种Queue的实现都必须指定要用什么顺序.&lt;br&gt;不管是什么顺序,head上的那个元素都是&lt;code&gt;remove()&lt;/code&gt;或&lt;code&gt;poll()&lt;/code&gt;即将移除的元素.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offer()&lt;/code&gt;方法将会试图插入一个元素,如果失败了就会返回false.&lt;br&gt;&lt;code&gt;remove()&lt;/code&gt;和&lt;code&gt;poll()&lt;/code&gt;方法都会删除并返回head元素.&lt;br&gt;&lt;code&gt;peek()&lt;/code&gt;只查询,不remove.&lt;/p&gt;
&lt;h4 id=&quot;主线程处理-HandlerPoster&quot;&gt;&lt;a href=&quot;#主线程处理-HandlerPoster&quot; class=&quot;headerlink&quot; title=&quot;主线程处理 HandlerPoster&quot;&gt;&lt;/a&gt;主线程处理 HandlerPoster&lt;/h4&gt;&lt;p&gt;所以这里看看&lt;code&gt;HandlerPoster&lt;/code&gt;是怎么做的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它继承自&lt;code&gt;Handler&lt;/code&gt;, 初始化的时候用的是mainLooper,所以确保了消息处理操作都是在主线程:&lt;br&gt;&lt;code&gt;mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个里面写了一个自己的queue: PendingPostQueue里面包含的数据是:&lt;code&gt;PendingPost&lt;/code&gt;.&lt;br&gt;&lt;code&gt;PendingPost&lt;/code&gt;这个类里用了一个pool来实现一个对象池,最大限制是10000.&lt;br&gt;obtain的时候, 如果池子里有对象,则从池子里拿出来一个, 如果池中没有对象,则new一个新的PendingPost; release的时候放回池子去.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;HandlerPoster&lt;/code&gt;主要做两件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;enqueue一个PendingPost, sendMessage, &lt;/li&gt;
&lt;li&gt;在handleMessage()方法里面处理message.&lt;br&gt;handleMessage()里面是一个while循环,从队列里面拿出PendingPost然后调用EventBus的invokeSubscriber()方法.&lt;br&gt;这里调用方法之前就会release该PendingPost.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;异步和后台处理-AsyncPoster和BackgroundPoster&quot;&gt;&lt;a href=&quot;#异步和后台处理-AsyncPoster和BackgroundPoster&quot; class=&quot;headerlink&quot; title=&quot;异步和后台处理 AsyncPoster和BackgroundPoster&quot;&gt;&lt;/a&gt;异步和后台处理 AsyncPoster和BackgroundPoster&lt;/h4&gt;&lt;p&gt;&lt;code&gt;AsyncPoster&lt;/code&gt;和&lt;code&gt;BackgroundPoster&lt;/code&gt;都是一个&lt;code&gt;Runnable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;enqueue的时候把PendingPost加入队列, 然后调用&lt;code&gt;eventBus.getExecutorService().execute(this);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;run()&lt;/code&gt;方法里面就是从队列中拿出PendingPost,然后invoke,和上面很像.&lt;/p&gt;
&lt;p&gt;默认的对象是:&lt;br&gt;&lt;code&gt;private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();&lt;/code&gt;&lt;br&gt;提供了一个线程池,可以异步地执行操作.&lt;/p&gt;
&lt;p&gt;那么它们两者有什么不同呢?&lt;/p&gt;
&lt;p&gt;AsyncPoster很简单, run里面直接invoke, 没有过多的判断. 即对每一个任务都是直接启动线程执行.&lt;br&gt;BackgroundPoster比较复杂,有一个boolean来判断是否正在run, run()方法里面是一个while true的循环,当queue全部被执行完之后才return.&lt;br&gt;如果队列中有任务正在执行,这时候enqueue()操作会加入元素到队列中,等待执行.&lt;br&gt;即BackgroundPoster只用了一个线程,所有的事件都是按顺序执行的,等到前面的任务执行完了才会进行下一个.&lt;/p&gt;
&lt;p&gt;对各个模式的说明可以参见&lt;code&gt;ThreadMode.java&lt;/code&gt;类.&lt;br&gt;Async模式下,不管你的post thread是什么,都是会新启线程来执行任务的,所以适用于那些比较耗时的操作.&lt;br&gt;为了避免并发线程过多, EventBus里面使用了一个线程池来复用线程.&lt;/p&gt;
&lt;h2 id=&quot;事件取消&quot;&gt;&lt;a href=&quot;#事件取消&quot; class=&quot;headerlink&quot; title=&quot;事件取消&quot;&gt;&lt;/a&gt;事件取消&lt;/h2&gt;&lt;p&gt;有一个public的cancel方法:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cancelEventDelivery&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object event)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PostingThreadState postingState = currentPostingThreadState.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!postingState.isPosting) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBusException(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;string&quot;&gt;&quot;This method may only be called from inside event handling methods on the posting thread&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (event == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBusException(&lt;span class=&quot;string&quot;&gt;&quot;Event may not be null&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (postingState.event != event) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBusException(&lt;span class=&quot;string&quot;&gt;&quot;Only the currently handled event may be aborted&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (postingState.subscription.subscriberMethod.threadMode != ThreadMode.PostThread) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EventBusException(&lt;span class=&quot;string&quot;&gt;&quot; event handlers may only abort the incoming event&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    postingState.canceled = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法的使用可以从测试代码里面看出来:&lt;br&gt;1.首先它只能在handler里面调用, 即第一个异常.这里判断的isPosting这个值在post的时候变为true,处理完就变为false.&lt;br&gt;这里用到的currentPostingState:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ThreadLocal&amp;lt;PostingThreadState&amp;gt; currentPostingThreadState = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;PostingThreadState&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; PostingThreadState &lt;span class=&quot;title&quot;&gt;initialValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PostingThreadState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ThreadLocal类是什么?&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThreadLocal类&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;主要是用来给每一个线程保存一个不同的状态值.&lt;br&gt;这个currentPostingThreadState在第一次被调用&lt;code&gt;get()&lt;/code&gt;方法的时候初始化,也即在&lt;code&gt;public void post(Object event)&lt;/code&gt; 方法里.&lt;br&gt;然后修改了它的状态, 之后再在同一个线程里,即可访问到它的状态.&lt;/p&gt;
&lt;p&gt;这里cancel的测试也写得很有意思,可以看一下.&lt;/p&gt;
&lt;h2 id=&quot;黏性事件&quot;&gt;&lt;a href=&quot;#黏性事件&quot; class=&quot;headerlink&quot; title=&quot;黏性事件&quot;&gt;&lt;/a&gt;黏性事件&lt;/h2&gt;&lt;p&gt;什么叫Sticky?&lt;br&gt;字面上看是黏性的.&lt;/p&gt;
&lt;p&gt;之前的事件都是非黏性的,即有一个&lt;code&gt;register()&lt;/code&gt;和&lt;code&gt;unregister()&lt;/code&gt;方法.&lt;br&gt;&lt;code&gt;register()&lt;/code&gt;了subscriber之后, EventBus会扫描该类中的onEventXXX()方法,建立一些map来记录.&lt;br&gt;&lt;code&gt;unregister()&lt;/code&gt;即合理地清除了这些数据.&lt;/p&gt;
&lt;p&gt;而对于sticky的事件,注册时调用&lt;code&gt;registerSticky()&lt;/code&gt;, 并没有相应的注销方法.只有一个单独的&lt;code&gt;removeAllStickyEvents()&lt;/code&gt;方法.&lt;/p&gt;
&lt;p&gt;sticky的事件注册的时候, &lt;code&gt;subscribe()&lt;/code&gt;方法中, 除了重复上面正常的过程之外, 还有一个额外的map:&lt;br&gt;&lt;code&gt;private final Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; stickyEvents;&lt;/code&gt;&lt;br&gt;这个数据类型是: &lt;code&gt;stickyEvents = new ConcurrentHashMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;();&lt;/code&gt;&lt;br&gt;存的是event的Class和event对象.&lt;/p&gt;
&lt;p&gt;注册时如果发现这个map中相同的event type要处理,&lt;strong&gt;&lt;em&gt;会立即触发&lt;/em&gt;&lt;/strong&gt;, 通知到它的订阅者.&lt;/p&gt;
&lt;p&gt;注意这个sticky event存的是最近的一个事件: &lt;strong&gt;most recent event&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;sticky事件触发的时候调用:&lt;br&gt;&lt;code&gt;public void postSticky(Object event)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sticky的代码里有一个&lt;code&gt;cast()&lt;/code&gt;方法:&lt;br&gt;看文档:&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;cast()&lt;/code&gt;方法就是用来把对象强转成当前的这个Class类型.&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;EventBus是一个Android上用的消息分发的类库,非常灵活好用,主要的原理是利用了反射注册以及调用. &lt;/p&gt;
&lt;p&gt;本文是在阅读EventBus的源码过程中所记录的东西, 遇到不懂的去查了, 然后留下了链接.&lt;br&gt;有点流水账,讲得也不是很深入,如果有错请帮忙指正.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;EventBus源码阅读记录&quot;&gt;&lt;a href=&quot;#EventBus源码阅读记录&quot; class=&quot;headerlink&quot; title=&quot;EventBus源码阅读记录&quot;&gt;&lt;/a&gt;EventBus源码阅读记录&lt;/h1&gt;&lt;p&gt;EventBus是一个Android上用的消息分发的类库,非常灵活好用,主要的原理是利用了反射注册以及调用.&lt;br&gt;本文是在阅读EventBus的源码过程中所记录的东西, 遇到不懂的去查了,然后留下了链接.&lt;br&gt;有点流水账,讲得也不是很深入,如果有错请帮忙指正.&lt;br&gt;repo地址:&lt;br&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;greenrobot/EventBus&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>My First Post</title>
    <link href="http://mengdd.github.io/others/2016/01/28/my-first-post/"/>
    <id>http://mengdd.github.io/others/2016/01/28/my-first-post/</id>
    <published>2016-01-27T16:00:00.000Z</published>
    <updated>2016-05-24T03:55:54.000Z</updated>
    
    <content type="html">&lt;p&gt;Hi, this is the first post.&lt;br&gt;As you know, this is just for testing.&lt;/p&gt;
&lt;p&gt;Anyway, if you are here, you must be bored and are trying to find something to do.&lt;/p&gt;
&lt;p&gt;My plan is to grow here as my second blog site.&lt;br&gt;The first one is here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mengdd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;圣骑士wind的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Do whatever improves yourself.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Life is so beautiful~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Haha and Bye&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hi, this is the first post.&lt;br&gt;As you know, this is just for testing.&lt;/p&gt;
&lt;p&gt;Anyway, if you are here, you must be bored and are trying to
    
    </summary>
    
      <category term="others" scheme="http://mengdd.github.io/categories/others/"/>
    
    
  </entry>
  
</feed>
