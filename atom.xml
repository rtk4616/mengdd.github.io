<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng&#39;s pages</title>
  <subtitle>Android developer and maybe other intersting things.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mengdd.github.io/"/>
  <updated>2017-06-12T10:47:49.000Z</updated>
  <id>http://mengdd.github.io/</id>
  
  <author>
    <name>Dandan Meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Weekly Notes Issue 261</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/06/12/android-weekly-notes-issue-261/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/06/12/android-weekly-notes-issue-261/</id>
    <published>2017-06-12T10:41:02.000Z</published>
    <updated>2017-06-12T10:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-261"><a href="#Android-Weekly-Issue-261" class="headerlink" title="Android Weekly Issue #261"></a>Android Weekly Issue #261</h1><p>June 11th, 2017<br><a href="http://androidweekly.net/issues/issue-261" target="_blank" rel="external">Android Weekly Issue #261</a><br>本期内容包括: Adaptive Icons; Kotlin实现的几种常用的设计模式; Android Instant App; Kotlin中的Ranges; 一个叫Graywater的库, 可以改善RecyclerView的性能; ItemDecoration的使用; 函数式编程; 提高Gradle的build的速度; 用RxJava 2包装Camera2 API. </p>
<p>代码部分有一个Kotlin实现的RSS阅读器值得一看.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Adaptive-Icons-and-more"><a href="#Adaptive-Icons-and-more" class="headerlink" title="Adaptive Icons and more"></a><a href="https://blog.stylingandroid.com/adaptive-icons/" target="_blank" rel="external">Adaptive Icons and more</a></h2><p>关于Android O的Adaptive Icons, 这里是官方的文档: <a href="https://developer.android.com/preview/features/adaptive-icons.html" target="_blank" rel="external">Adaptive Icons</a>.</p>
<p>这篇文章介绍了如何用Android Studio制作这种icon.</p>
<h2 id="Gang-of-Four-Patterns-in-Kotlin"><a href="#Gang-of-Four-Patterns-in-Kotlin" class="headerlink" title="Gang of Four Patterns in Kotlin"></a><a href="https://dev.to/lovis/gang-of-four-patterns-in-kotlin" target="_blank" rel="external">Gang of Four Patterns in Kotlin</a></h2><p>用Kotlin实现的各种设计模式:</p>
<ul>
<li>Decorator -&gt; 用extension functions.</li>
<li>Builder -&gt; 用<code>apply</code>.</li>
<li>Prototype -&gt; 用<code>data</code>类<code>copy</code>.</li>
<li>Singleton -&gt; 用<code>object</code>关键字.</li>
<li>Template Method -&gt; 用extension functions.</li>
<li>Strategy -&gt; 方法参数, <code>typealias</code>, 高阶函数.</li>
<li>Iterator -&gt; <code>interator()</code>.</li>
</ul>
<p>这是作者实现的repo: <a href="https://github.com/lmller/gof-in-kotlin" target="_blank" rel="external">gof-in-kotlin</a>.</p>
<h2 id="From-Westinghouse-to-Android-Instant-apps"><a href="#From-Westinghouse-to-Android-Instant-apps" class="headerlink" title="From Westinghouse to Android Instant apps"></a><a href="https://tech.buzzfeed.com/from-westinghouse-to-android-instant-apps-60fbfaca4ebe" target="_blank" rel="external">From Westinghouse to Android Instant apps</a></h2><p>作者讲了他和Instant App的故事.</p>
<h2 id="Musings-on-Kotlin-Ranges"><a href="#Musings-on-Kotlin-Ranges" class="headerlink" title="Musings on Kotlin Ranges"></a><a href="http://blog.danlew.net/2017/06/05/musings-on-kotlin-ranges/amp/" target="_blank" rel="external">Musings on Kotlin Ranges</a></h2><p>作者讲了他发现的一些关于Kotlin的<a href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="external">Ranges</a>的有趣的事情:</p>
<ul>
<li>IntRange如果初始值比结束值大, 会被认为是空的. 想要逆序的话就得用<code>downTo</code>或者<code>reversed()</code>.</li>
<li>in range会被编译器优化为两个&lt;=条件判断, 所以我们可以利用这点来简化我们本来的判断.</li>
<li>几种range的for循环效率比较.</li>
</ul>
<h2 id="Introducing-Graywater-for-Android"><a href="#Introducing-Graywater-for-Android" class="headerlink" title="Introducing Graywater for Android"></a><a href="https://engineering.tumblr.com/post/161546559631/introducing-graywater-for-android" target="_blank" rel="external">Introducing Graywater for Android</a></h2><p>介绍一个叫<a href="https://github.com/tumblr/Graywater" target="_blank" rel="external">Graywater</a>的库, 处理RecyclerView中的复杂项目, 据说可以改善滚动性能, 减少内存使用, 而且提供了一种组件化的构建方式.</p>
<h2 id="Making-the-Domain-Android-App-Instant"><a href="#Making-the-Domain-Android-App-Instant" class="headerlink" title="Making the Domain Android App Instant"></a><a href="http://tech.domain.com.au/2017/06/making-the-domain-android-app-instant-%E2%9A%A1/" target="_blank" rel="external">Making the Domain Android App Instant</a></h2><p>Domain的Instant App实现, 概要介绍, 不涉及太多细节.<br>文章后面说了一些Instant App的限制, 比如: 4MB大小; 只有有限的权限, intent和库.</p>
<h2 id="ItemDecoration-Avoid-adding-dividers-to-the-view-layout"><a href="#ItemDecoration-Avoid-adding-dividers-to-the-view-layout" class="headerlink" title="ItemDecoration - Avoid adding dividers to the view layout"></a><a href="https://medium.com/proandroiddev/itemdecoration-in-android-e18a0692d848" target="_blank" rel="external">ItemDecoration - Avoid adding dividers to the view layout</a></h2><p><code>ItemDecoration</code>的介绍.</p>
<p>首先, 不要用在布局里加View的方法来加divider, 这对性能不好. 增加了多余的View, 还可能需要增加层级.</p>
<p>其次, 加View的方式也有一些副作用, 比如左右滑动item动画的时候, divider会和View一起移动, 这显然不好看.</p>
<p>最后, 加View的方式也不如<code>ItemDecoration</code>那样具有灵活性. 比如你想加不同长度的divider给不同位置的item.</p>
<p>所以推荐使用<code>ItemDecoration</code>. 自动25.0.0开始, support库还添加了<code>DividerItemDecoration</code>类.</p>
<p>注意: </p>
<ul>
<li>一个RecyclerView可以添加多个<code>ItemDecoration</code>.</li>
<li><code>onDraw()</code>是在绘制item之前, <code>onDrawOver()</code>是在绘制item之后.</li>
</ul>
<h2 id="Functional-Programming-for-Android-Developers-—-Part-3"><a href="#Functional-Programming-for-Android-Developers-—-Part-3" class="headerlink" title="Functional Programming for Android Developers — Part 3"></a><a href="https://medium.com/@anupcowkur/functional-programming-for-android-developers-part-3-f9e521e96788" target="_blank" rel="external">Functional Programming for Android Developers — Part 3</a></h2><p>函数式编程教学第三部分, 主要讲高阶函数和Closures.</p>
<p>前两部分见:</p>
<ul>
<li><a href="https://medium.freecodecamp.com/functional-programming-for-android-developers-part-1-a58d40d6e742" target="_blank" rel="external">Functional Programming for Android Developers — Part 1</a></li>
<li><a href="https://medium.freecodecamp.com/functional-programming-for-android-developers-part-2-5c0834669d1a" target="_blank" rel="external">Functional Programming for Android Developers — Part 2</a></li>
</ul>
<h2 id="How-to-speed-up-your-slow-Gradle-builds"><a href="#How-to-speed-up-your-slow-Gradle-builds" class="headerlink" title="How to speed up your slow Gradle builds"></a><a href="https://android.jlelse.eu/how-to-speed-up-your-slow-gradle-builds-5d9a9545f91a" target="_blank" rel="external">How to speed up your slow Gradle builds</a></h2><p>Google I/O 2017关于如何提高gradle build速度的10个建议:</p>
<ul>
<li>1.使用最新的Gradle plugin.</li>
<li>2.避免使用老的multidex, 在API 21以前会有性能影响.</li>
<li>3.在开发时disable multi-APK.</li>
<li>4.最小化包含的资源.</li>
<li>5.在开发时关闭PNG优化.</li>
<li>6.使用Instant Run.</li>
<li>7.避免非故意的改动. 如把vesionCode和当前时间相关, 这样每次build就等于manifest会被改变. 还有<code>Crashlytics</code>会为每次build生成id.  可以在develop的时候关闭这些.</li>
<li>8.不要使用动态的依赖版本.</li>
<li>9.注意memory的设置. 在<code>gradle.properties</code>中, 如<code>org.gradle.jvmargs=-Xmx2048m</code>.</li>
<li>10.使能缓存. 在<code>gradle.properties</code>中, <code>org.gradle.caching=true</code>.</li>
</ul>
<h2 id="Reactive-selfies-with-Camera2-API-on-Android-Part-1"><a href="#Reactive-selfies-with-Camera2-API-on-Android-Part-1" class="headerlink" title="Reactive selfies with Camera2 API on Android - Part 1"></a><a href="https://techblog.badoo.com/blog/2017/06/07/reactive-selfies-with-camera2-api-on-android-part-1/" target="_blank" rel="external">Reactive selfies with Camera2 API on Android - Part 1</a></h2><p>作者的一个教程, 用RxJava2包装Camera2的API.<br>文章讲得很仔细, 项目代码见: <a href="https://github.com/ArkadyGamza/Camera2API_rxJava2" target="_blank" rel="external">Camera2API_rxJava2</a>.</p>
<h2 id="Re-animation"><a href="#Re-animation" class="headerlink" title="Re-animation"></a><a href="https://medium.com/google-developers/re-animation-7869722af206" target="_blank" rel="external">Re-animation</a></h2><p>作者更新了他关于向量动画的文章, 因为support库25.4中加入了对老版本的兼容.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Karchitec"><a href="#Karchitec" class="headerlink" title="Karchitec"></a><a href="https://github.com/msesma/Karchitec" target="_blank" rel="external">Karchitec</a></h2><p>Kotlin的RSS阅读器, 使用了Google的android architecture components库.</p>
<h2 id="SwiftKotlin"><a href="#SwiftKotlin" class="headerlink" title="SwiftKotlin"></a><a href="https://github.com/angelolloqui/SwiftKotlin" target="_blank" rel="external">SwiftKotlin</a></h2><p>一个工具, 可以把Swift代码转换为Kotlin代码.</p>
<h2 id="Graywater"><a href="#Graywater" class="headerlink" title="Graywater"></a><a href="https://github.com/tumblr/Graywater" target="_blank" rel="external">Graywater</a></h2><p>一个改善RecyclerView滚动性能的库.</p>
<h2 id="Fontify"><a href="#Fontify" class="headerlink" title="Fontify"></a><a href="https://github.com/mehdok/Fontify" target="_blank" rel="external">Fontify</a></h2><p>提供不同语言自定义字体和style的TextView, EditText和Button.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-261&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-261&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #261&quot;&gt;&lt;/a&gt;Android Weekly Issue #261&lt;/h1&gt;&lt;p&gt;June 11th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-261&quot;&gt;Android Weekly Issue #261&lt;/a&gt;&lt;br&gt;本期内容包括: Adaptive Icons; Kotlin实现的几种常用的设计模式; Android Instant App; Kotlin中的Ranges; 一个叫Graywater的库, 可以改善RecyclerView的性能; ItemDecoration的使用; 函数式编程; 提高Gradle的build的速度; 用RxJava 2包装Camera2 API. &lt;/p&gt;
&lt;p&gt;代码部分有一个Kotlin实现的RSS阅读器值得一看.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="Design Patterns" scheme="http://mengdd.github.io/tags/Design-Patterns/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Adaptive Icons" scheme="http://mengdd.github.io/tags/Adaptive-Icons/"/>
    
      <category term="Instant App" scheme="http://mengdd.github.io/tags/Instant-App/"/>
    
      <category term="ItemDecoration" scheme="http://mengdd.github.io/tags/ItemDecoration/"/>
    
      <category term="Functional Programming" scheme="http://mengdd.github.io/tags/Functional-Programming/"/>
    
      <category term="RxJava 2" scheme="http://mengdd.github.io/tags/RxJava-2/"/>
    
      <category term="Camera2" scheme="http://mengdd.github.io/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 258</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/05/27/android-weekly-notes-issue-258/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/05/27/android-weekly-notes-issue-258/</id>
    <published>2017-05-27T08:49:12.000Z</published>
    <updated>2017-05-27T08:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-258"><a href="#Android-Weekly-Issue-258" class="headerlink" title="Android Weekly Issue #258"></a>Android Weekly Issue #258</h1><p>May 21st, 2017<br><a href="http://androidweekly.net/issues/issue-258" target="_blank" rel="external">Android Weekly Issue #258</a><br>本期内容: 围绕着Google I/O的热潮, 本周的posts除了几篇小工具和软件设计原则的讨论, 其他都是在说Android Architecture Components和Kotlin.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="DebugPort-2-0"><a href="#DebugPort-2-0" class="headerlink" title="DebugPort 2.0"></a><a href="https://medium.com/@JasonWyatt/introducing-android-debugport-2-0-88ec4ed4db94" target="_blank" rel="external">DebugPort 2.0</a></h2><p>REPL(Read Eval Print Loop)是在命令行界面中, 读取每一行输入, 执行, 然后输出结果, 提供即时的反馈. Java 9会提供这么一个REPL的环境, 叫JShell.</p>
<p>考虑到在Android中能用上可能要等很长时间, 所以作者一年前开始弄了一个这个项目: <a href="https://github.com/jasonwyatt/Android-DebugPort" target="_blank" rel="external">Android-DebugPort</a>.</p>
<p>在你的应用中加入这个依赖, 然后运行, 在通知栏就会弹出通知, 然后在电脑上就可以使用telnet来连接到app.</p>
<p>可以调用方法, 执行脚本, 查询数据库等.</p>
<h2 id="Understanding-Law-of-Demeter"><a href="#Understanding-Law-of-Demeter" class="headerlink" title="Understanding Law of Demeter"></a><a href="https://medium.com/@ankit.sinhal/design-principal-understand-law-of-demeter-4a44ac18e923" target="_blank" rel="external">Understanding Law of Demeter</a></h2><p>软件设计要求松耦合.<br>Law of Demeter, 即迪米特原则, 亦称为最少知道原则.</p>
<p>文章介绍了在这种原则下应该如何设计类和它的方法.</p>
<h2 id="Object-Oriented-Tricks-6-SLAP-your-functions"><a href="#Object-Oriented-Tricks-6-SLAP-your-functions" class="headerlink" title="Object Oriented Tricks: #6 SLAP your functions"></a><a href="https://hackernoon.com/object-oriented-tricks-6-slap-your-functions-a13d25a7d994" target="_blank" rel="external">Object Oriented Tricks: #6 SLAP your functions</a></h2><p>SLAP: Single Level of Abstraction Priciple, 单层抽象原则.</p>
<p>一个太长的方法往往有各种缺点, 那么怎么判断一个方法过长了呢? 根据行数来判断不太科学, 所以SLAP可以用在这里:<br>一个代码块中的代码应该处于同一层抽象级别.</p>
<p>一个方法不应该有几个不同级别的抽象, 换言之, 一个方法只做一件事.</p>
<p>当你在方法代码中用注释来分割代码块的时候, 这些代码可以提取出来, 这样最初的方法就变成了一个隐藏实现细节, 只展示逻辑步骤的ComposedMethod.</p>
<h2 id="Android-and-Architecture"><a href="#Android-and-Architecture" class="headerlink" title="Android and Architecture"></a><a href="https://android-developers.googleblog.com/2017/05/android-and-architecture.html" target="_blank" rel="external">Android and Architecture</a></h2><p>Google推出Architecture Components的预览, 宣布了一种新的Android App构架指导.</p>
<h3 id="意见不是处方"><a href="#意见不是处方" class="headerlink" title="意见不是处方"></a>意见不是处方</h3><p>写Android应用有多种方式, 这里提供的只是一系列的指导意见, 来帮助你更好地构架Android应用. </p>
<p>Android framework中有一些定义良好的API, 用于处理和底层系统的交互, 比如Activity, 但是这些是你应用的入口点, 并不是你的构架块. 这些framework的组件并不强制你分离数据和UI, 也不提供清晰的方式来处理独立于生命周期的数据保存.</p>
<h3 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h3><p>Architecture Components帮助你实现一个更明智的架构, 它们帮助你: 自动管理activity和fragment的生命周期, 避免内存和资源泄露; 保存Java数据对象到SQLite数据库.</p>
<h3 id="Lifecycle-Components"><a href="#Lifecycle-Components" class="headerlink" title="Lifecycle Components"></a>Lifecycle Components</h3><p>新的<a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" target="_blank" rel="external">lifecycle-aware components</a>提供了一种方式来把你应用的核心组件绑定到生命周期事件上, 删除了显式的依赖路径.</p>
<p>这里核心的类是<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="external">Lifecycle</a>, 它使用了生命周期状态和事件(states and events)的枚举来追踪相关组件的生命周期.</p>
<p><code>LifecycleOwner</code>是一个接口, 其中<code>getLifecycle()</code>方法返回一个<code>Lifecycle</code>对象. <code>LifecycleObserver</code>是一个观察者, 可以监控组件的生命周期事件(通过在方法上加注解).</p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><a href="https://developer.android.com/topic/libraries/architecture/livedata.html" target="_blank" rel="external">LiveData</a><br>是一个数据持有类, 同时也是一个Obervable, 允许它的数据被监听, 同时它也知道生命周期.</p>
<p>当你的UI订阅了底层数据的改动, 并且绑定了一个<code>LifecycleOwner</code>, <code>LiveData</code>会确保这个observer:</p>
<ul>
<li>在生命周期处于活跃状态时得到数据更新.</li>
<li>当生命周期结束时取消订阅.</li>
<li>在<code>LifecycleOwner</code>重新开始时(比如旋转变化或从back stack中跳出), 得到最新的数据.</li>
</ul>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="external">ViewModel</a>是一个辅助类, 用于盛放Activity或Fragment的UI数据, 从UI controller的逻辑中分离出view的数据.</p>
<p>只要Activity/Fragment存在, ViewModel的数据就被保持着. 包括Activity/Fragment因为状态变化而销毁重建的情况. 这样ViewModel就在重建时提供可用的数据.</p>
<p>结合<code>ViewModel</code>和<code>LiveData</code>, 就为数据提供了一个了解生命周期的可观察的容器. 其中<code>LiveData</code>负责通知, <code>ViewModel</code>负责数据保存.</p>
<h3 id="Data-Persistence"><a href="#Data-Persistence" class="headerlink" title="Data Persistence"></a>Data Persistence</h3><p>提出了<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="external">Room library</a>, 提供了一个在SQLite之上的object-mapping抽象层, 允许流式的数据库访问. </p>
<p>Room中三个主要的组件:</p>
<ul>
<li><code>Entity</code>: 代码数据库中一行的数据, 用带有注解的Java数据类构建. 每一个Entity在它自己的表中被保存.</li>
<li><code>DAO</code> (Data Access Object): 定义了访问数据库的方法. 使用注解来绑定SQL到每个方法.</li>
<li><code>Database</code>. 用注解来定义entities列表和数据库版本;  定义DAO的列表; 同时也是底层数据库连接的主要访问点.</li>
</ul>
<h3 id="Guide-to-App-Architecture"><a href="#Guide-to-App-Architecture" class="headerlink" title="Guide to App Architecture"></a>Guide to App Architecture</h3><p><a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="external">Guide to App Architecture</a>显示如何用Architecture Components来构建一个稳健的, 模块化的, 可测试的app.</p>
<h2 id="Why-Kotlin"><a href="#Why-Kotlin" class="headerlink" title="Why Kotlin?"></a><a href="http://blog.danlew.net/2017/05/17/why-kotlin/" target="_blank" rel="external">Why Kotlin?</a></h2><p>作者分享了为什么相比于Java, 他更喜欢Kotlin.</p>
<h2 id="My-take-on“Architecture-Components”"><a href="#My-take-on“Architecture-Components”" class="headerlink" title="My take on“Architecture Components”"></a><a href="https://medium.com/@yonatanvlevin/weighing-in-on-the-holy-architecture-war-my-take-on-architecture-components-31f7025e9c66" target="_blank" rel="external">My take on“Architecture Components”</a></h2><p>作者分享了他在项目中使用Architecture components的一些心得.</p>
<p>他们的项目原先是MVP + Content Provider的. 为了实验加入Architecture components, 他又新写了一个MVP的<a href="https://github.com/parahall/star_wars_movies" target="_blank" rel="external">Demo项目</a>, 把它转化成MVVM, 又加入Architecture components的新组件来实现. (代码比较多, 我没有详细看).</p>
<h2 id="ConstraintLayout-com"><a href="#ConstraintLayout-com" class="headerlink" title="ConstraintLayout.com"></a><a href="https://blog.stylingandroid.com/constraintlayout-com/" target="_blank" rel="external">ConstraintLayout.com</a></h2><p>这个网站<a href="https://constraintlayout.com/" target="_blank" rel="external">ConstraintLayout.com</a>成立了, 用于讨论和<code>ConstraintLayout</code>相关的一切.</p>
<h2 id="Looking-at-Room-and-LiveData-Part-1"><a href="#Looking-at-Room-and-LiveData-Part-1" class="headerlink" title="Looking at Room and LiveData - Part 1"></a><a href="https://riggaroo.co.za/android-architecture-components-looking-room-livedata-part-1/" target="_blank" rel="external">Looking at Room and LiveData - Part 1</a></h2><p>Android之前一直没有提出过一个官方的构架模式, 所以大家总在讨论各种MVP, MVVM, MVI模式, 各种库等等. 终于在Google I/O 2017, Android团队发布了Architecture Components, 来提供一个构建Android App的最佳实践指导.</p>
<h3 id="什么是Architecture-Components"><a href="#什么是Architecture-Components" class="headerlink" title="什么是Architecture Components?"></a>什么是Architecture Components?</h3><p>Architecture Components是一系列的库和指导集合, 作为构建Android app的基础. 针对一些常见的使用场景, 目的是减少样板和重复代码, 让你能集中精力到你应用的核心功能代码上.</p>
<p>主要组件包括:</p>
<ul>
<li>Room: a SQLite object mapper.</li>
<li>LiveData: a lifecycle aware observable.</li>
<li>ViewModel: Activity/Fragment和应用其他部分的交流点.</li>
<li>Lifecycle: 核心部分, 包含了组件的生命周期.</li>
<li>LifecycleOwner: 核心接口, 用于有生命周期的组件.</li>
<li>LifecycleObserver: 当某个生命周期事件发生的时候, 应该做些什么呢?  </li>
</ul>
<p>之后作者写了一个小App作为例子, 用了MVVM + Android Architecture Components. 其中详细介绍了Room和LiveData的用法.</p>
<h2 id="Room-—-Getting-Started"><a href="#Room-—-Getting-Started" class="headerlink" title="Room — Getting Started"></a><a href="https://medium.com/@tonyowen/a-room-with-a-view-getting-started-ec010f9f5448" target="_blank" rel="external">Room — Getting Started</a></h2><p>一个简单的例子, 介绍如何使用Room. (例子用Kotlin).</p>
<h2 id="Generating-Kotlin-code-with-KotlinPoet"><a href="#Generating-Kotlin-code-with-KotlinPoet" class="headerlink" title="Generating Kotlin code with KotlinPoet"></a><a href="https://medium.com/square-corner-blog/generating-kotlin-code-with-kotlinpoet-119dc20f74d4" target="_blank" rel="external">Generating Kotlin code with KotlinPoet</a></h2><p>Jake Wharton的文章, Square推出了<a href="https://github.com/square/kotlinpoet" target="_blank" rel="external">KotlinPoet</a>, 用来生成kotlin代码.</p>
<h2 id="Why-you-should-totally-switch-to-Kotlin"><a href="#Why-you-should-totally-switch-to-Kotlin" class="headerlink" title="Why you should totally switch to Kotlin"></a><a href="https://medium.com/@magnus.chatt/why-you-should-totally-switch-to-kotlin-c7bbde9e10d5" target="_blank" rel="external">Why you should totally switch to Kotlin</a></h2><p>要转换到Kotlin的若干个理由. (有17条).</p>
<h2 id="30-New-Android-Libraries"><a href="#30-New-Android-Libraries" class="headerlink" title="30 New Android Libraries"></a><a href="https://medium.com/@mmbialas/30-new-android-libraries-released-in-the-spring-of-2017-which-deserve-your-attention-faea359a1915" target="_blank" rel="external">30 New Android Libraries</a></h2><p>30个Android的新库, 都是自2017年3月份以后发布的.<br>作者主观挑选的, 所以并没有排序.</p>
<p>列表比较长, 我就不一一列了, 不少库还是挺有趣的.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-architecture-counter-sample"><a href="#android-architecture-counter-sample" class="headerlink" title="android-architecture-counter-sample"></a><a href="https://github.com/dlew/android-architecture-counter-sample" target="_blank" rel="external">android-architecture-counter-sample</a></h2><p>使用Kotlin和Android architecture components写的一个sample app.</p>
<h2 id="KotlinPoet"><a href="#KotlinPoet" class="headerlink" title="KotlinPoet"></a><a href="https://github.com/square/kotlinpoet" target="_blank" rel="external">KotlinPoet</a></h2><p>Kotlin代码生成库.</p>
<h2 id="memechat"><a href="#memechat" class="headerlink" title="memechat"></a><a href="https://github.com/efortuna/memechat" target="_blank" rel="external">memechat</a></h2><p>用<a href="https://flutter.io/" target="_blank" rel="external">Flutter</a>构建的一个聊天应用, 用了Firebase, Google Sign in和设备相机.</p>
<h1 id="News"><a href="#News" class="headerlink" title="News"></a>News</h1><p>几个大新闻: </p>
<ul>
<li>Android O发布了第二个预览版.</li>
<li>Android team发布了Architecture Components. - Android正式宣布了支持Kotlin.</li>
<li>Instant App现在对所有开发者开放</li>
<li>Android Studio发布了3.0 Canary, 推出了一系列的新工具.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-258&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-258&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #258&quot;&gt;&lt;/a&gt;Android Weekly Issue #258&lt;/h1&gt;&lt;p&gt;May 21st, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-258&quot;&gt;Android Weekly Issue #258&lt;/a&gt;&lt;br&gt;本期内容: 围绕着Google I/O的热潮, 本周的posts除了几篇小工具和软件设计原则的讨论, 其他都是在说Android Architecture Components和Kotlin.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Design" scheme="http://mengdd.github.io/tags/Design/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="MVVM" scheme="http://mengdd.github.io/tags/MVVM/"/>
    
      <category term="Architecture" scheme="http://mengdd.github.io/tags/Architecture/"/>
    
      <category term="Architecture Components" scheme="http://mengdd.github.io/tags/Architecture-Components/"/>
    
      <category term="Room" scheme="http://mengdd.github.io/tags/Room/"/>
    
      <category term="LiveData" scheme="http://mengdd.github.io/tags/LiveData/"/>
    
      <category term="Lifecycle" scheme="http://mengdd.github.io/tags/Lifecycle/"/>
    
      <category term="ViewModel" scheme="http://mengdd.github.io/tags/ViewModel/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 257</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/Tools/IDE/2017/05/17/android-weekly-notes-issue-257/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/Tools/IDE/2017/05/17/android-weekly-notes-issue-257/</id>
    <published>2017-05-17T09:26:18.000Z</published>
    <updated>2017-05-17T09:36:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-257"><a href="#Android-Weekly-Issue-257" class="headerlink" title="Android Weekly Issue #257"></a>Android Weekly Issue #257</h1><p>May 14th, 2017<br><a href="http://androidweekly.net/issues/issue-257" target="_blank" rel="external">Android Weekly Issue #257</a><br>本期内容包括: Gradle中关于项目的一些设置; Android设备上的各种id讨论; ViewPagerAnimator这个库的进一步介绍; Kotlin中的<code>Nothing</code>类型介绍; 实现<code>Parcelable</code>的类和测试; Android开发中一些提高效率的快捷键. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Make-or-break…-with-Gradle"><a href="#Make-or-break…-with-Gradle" class="headerlink" title="Make or break… with Gradle"></a><a href="https://medium.com/contentsquare-engineering-blog/make-or-break-with-gradle-dac2e858868d" target="_blank" rel="external">Make or break… with Gradle</a></h2><p>作者讲了他们的一些工作习惯:</p>
<ul>
<li>Git分支管理.<ul>
<li>所有向主分支的提交都必须通过Pull Request.</li>
<li>仅在CI通过后才允许merge.</li>
</ul>
</li>
<li>Lint设置. <ul>
<li><code>build.gradle</code>中的lintOptions设置.</li>
<li><code>./gradlew check</code>会跑所有的单元测试, UI测试和Lint.</li>
</ul>
</li>
<li>代码分析工具.<ul>
<li>PMD.</li>
<li>FindBugs.</li>
<li>Infer.</li>
<li>这里可以用Google提供的<a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="external">Java Style Guide</a>.</li>
</ul>
</li>
<li>生成文档.<ul>
<li>用CheckStyle要求所有的public方法都有JavaDoc注释(默认已经实现了).</li>
<li>实现Gradle JavaDoc Plugin.</li>
</ul>
</li>
<li>代码测试率报告.<ul>
<li>Jacoco. </li>
<li>可以设置一些规则来检测意外打出的log和注释掉的代码(Code Smell).</li>
</ul>
</li>
</ul>
<h2 id="Identifying-an-Android-Device"><a href="#Identifying-an-Android-Device" class="headerlink" title="Identifying an Android Device"></a><a href="http://handstandsam.com/2017/05/04/identifying-an-android-device/" target="_blank" rel="external">Identifying an Android Device</a></h2><p>在Android设备上可以通过程序获取各种id来识别一个设备或者一次安装. 这篇文章就讨论各种id:</p>
<ul>
<li>通过Settings.Secure获取到的Android ID.</li>
<li>Android Build.SERIAL.</li>
<li>Android Build.MODEL.</li>
<li>Android Build.BRAND.</li>
<li>Android Build.MANUFACTURER.</li>
<li>Android Build.DEVICE.</li>
<li>Android Build.PRODUCT.</li>
<li>IMEI (International Mobile Equipment Identity).</li>
<li>Phone Number.</li>
<li>ICCID (Sim Serial Number).</li>
</ul>
<h2 id="ViewPagerAnimator-–-The-Advanced-Stuff"><a href="#ViewPagerAnimator-–-The-Advanced-Stuff" class="headerlink" title="ViewPagerAnimator – The Advanced Stuff"></a><a href="https://blog.stylingandroid.com/viewpageranimator-the-advanced-stuff/" target="_blank" rel="external">ViewPagerAnimator – The Advanced Stuff</a></h2><p>上次我们介绍了<a href="https://github.com/StylingAndroid/ViewPagerAnimator" target="_blank" rel="external">ViewPagerAnimator</a>这个库, 在ViewPager切换时进行动画, 但是上次只介绍了简单的颜色变化, 本文介绍一些关于API的高级设定: 变化的属性可以是自定义的类型; API的良好设计使得使用的代码在支持Java 8的环境下可以大幅度地得到简化.</p>
<h2 id="Nothing-else-matters-in-Kotlin"><a href="#Nothing-else-matters-in-Kotlin" class="headerlink" title="Nothing (else) matters in Kotlin"></a><a href="https://medium.com/@quiro91/nothing-else-matters-in-kotlin-994a9ef106fc" target="_blank" rel="external">Nothing (else) matters in Kotlin</a></h2><p>Kotlin中的一切都有一个类型, 甚至还有一个类型叫Nothing.</p>
<p>Kotlin中没有void类型, 当一个方法<code>fun</code>没有显示地声明返回值的时候, 它返回的其实是<code>Unit</code>类型.</p>
<p><code>Unit</code>是一个真的类型, 继承<code>Any</code>(<code>Any</code>对应Java中的<code>Object</code>), 只接受单个的值, 是一个单例(为了避免每次方法返回Unit之后分配内存).</p>
<p>如果我们有一个方法, 方法中只抛出一个异常, 如果我们不特殊声明, 它的返回值仍是<code>Unit</code>, 但是也许我们应该返回<code>Nothing</code>:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> &#123;</div><div class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">"Something went wrong"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Nothing</code>是一个无人居住的类型, 在运行时没有值会是这个类型, 它也是其他类的子类.</p>
<p>当作为返回值时, <code>Unit</code>和<code>Nothing</code>到底有什么区别呢?</p>
<p>举例来说明:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> <span class="keyword">data</span>: String = intent.getStringExtra(<span class="string">"key"</span>) ?: fail()</div><div class="line">textView.text = <span class="keyword">data</span></div></pre></td></tr></table></figure></p>
<p>如果<code>fail()</code>方法返回<code>Nothing</code>, 我们要么得到<code>String</code>, 要么抛出异常; 如果返回<code>Unit</code>, 我们会得到一个error, 以为<code>Unit</code>不能转换为<code>String</code>.</p>
<p>如果不显式声明String类型呢?<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> <span class="keyword">data</span> = intent.getStringExtra(<span class="string">"key"</span>) ?: fail()</div><div class="line">textView.text = <span class="keyword">data</span></div></pre></td></tr></table></figure></p>
<p>如果<code>fail()</code>返回<code>Nothing</code>, 类型是<code>String</code>;<br>如果返回<code>Unit</code>, 类型是<code>Any</code>, 但TextView期待的是一个<code>CharSequence</code>, 所以你仍然会得到一个error.</p>
<p><code>Nothing</code>的用途就是用来显式地标记一个方法永远也不会成功地完成(它可能会抛出异常, 进入死循环或者导致一个控制流转变).</p>
<p><code>Nothing?</code>有且仅有一个实例, 是<code>null</code>.<br><code>Nothing?</code>是所有nullable类型的子类.</p>
<h2 id="Android-Parcelables-Made-Easy"><a href="#Android-Parcelables-Made-Easy" class="headerlink" title="Android Parcelables Made Easy"></a><a href="https://medium.com/@calren24/android-parcelables-made-easy-acb742bcf96b" target="_blank" rel="external">Android Parcelables Made Easy</a></h2><p>可以在Android Studio中装一个插件, 来自动生成Parcelable的代码:<br>Android Studio &gt; Preferences &gt; Plugins &gt; 搜索<code>Parcelable</code> &gt; 安装<code>Android Parcelable Code Generator</code>.</p>
<p>安装之后, 在你的类中, 只需要声明字段, 然后Cmd + N, 选<code>Parcelable</code>就可以生成相关的代码了.</p>
<p>之后, 好的做法是为你的类写一个单元测试, 一旦有人加了新字段, 他们也需要保证Parcelable.<br>为了让你的测试fail的时候显示的信息更有效, 你还需要覆写<code>toString()</code>方法和<code>equals()</code>方法.(这些都是可以自动生成的).</p>
<h2 id="Android-shortcuts-and-tricks-to-boost-up-your-productivity"><a href="#Android-shortcuts-and-tricks-to-boost-up-your-productivity" class="headerlink" title="Android shortcuts and tricks to boost up your productivity!"></a><a href="https://tech.fleka.me/android-shortcuts-and-tricks-to-boost-up-your-productivity-944548174582" target="_blank" rel="external">Android shortcuts and tricks to boost up your productivity!</a></h2><p>Android开发中一些提高效率的快捷键:</p>
<ul>
<li>在Activity和它的布局间切换:<ul>
<li>在Activity声明的那一行用鼠标点icon.</li>
<li>Cmd + Shift + O 输入文件名.</li>
<li>Cmd + Shift + A 输入related symbol. (可以把这个存为一个自定义的shortcut).</li>
</ul>
</li>
<li>在xml的文字和design之间切换: Ctrl + Shift + Left/Right.</li>
<li>扩展/缩减选中文字: Opt + Up/Down.</li>
<li>生成新类: Cmd + N; Opt + Enter.</li>
<li>去实现类: Cmd + Opt + B.</li>
<li>实现一个方法: Opt + Enter; Ctrl + I.</li>
<li>去基类方法: Cmd + U; 去实现类方法: Cmd + B.</li>
<li>覆写基类方法: Ctrl + O.</li>
<li>在子类中给基类加方法: 在子类中把方法标记为<code>@Override</code>, 然后在<code>@Override</code>上按Opt + Enter, 选择<code>Pull method xxx to YYY</code>.</li>
<li>改变方法参数: Cmd + F6.</li>
<li>交换方法参数: Cmd + Opt + Shift + Left/Right.</li>
<li>定位当前文件: 导航烂最左边有一个圆形小按钮可以帮你定位文件, 如果你想要自动, 可以勾选<code>Autoscroll from Source</code>.</li>
<li>把local变量改为成员变量: Cmd + Opt + F.</li>
<li>提取layout和style. (这个快捷键我实验失败了).</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="litho-glide"><a href="#litho-glide" class="headerlink" title="litho-glide"></a><a href="https://github.com/pavlospt/litho-glide" target="_blank" rel="external">litho-glide</a></h2><p>为litho创建的Glide图片加载组件.</p>
<h2 id="sample-googleassistant"><a href="#sample-googleassistant" class="headerlink" title="sample-googleassistant"></a><a href="https://github.com/androidthings/sample-googleassistant" target="_blank" rel="external">sample-googleassistant</a></h2><p>Google Assistant API sample for Android Things.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-257&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-257&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #257&quot;&gt;&lt;/a&gt;Android Weekly Issue #257&lt;/h1&gt;&lt;p&gt;May 14th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-257&quot;&gt;Android Weekly Issue #257&lt;/a&gt;&lt;br&gt;本期内容包括: Gradle中关于项目的一些设置; Android设备上的各种id讨论; ViewPagerAnimator这个库的进一步介绍; Kotlin中的&lt;code&gt;Nothing&lt;/code&gt;类型介绍; 实现&lt;code&gt;Parcelable&lt;/code&gt;的类和测试; Android开发中一些提高效率的快捷键. &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
      <category term="Tools" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/Tools/"/>
    
      <category term="IDE" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/Tools/IDE/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Java 8" scheme="http://mengdd.github.io/tags/Java-8/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="Shortcuts" scheme="http://mengdd.github.io/tags/Shortcuts/"/>
    
      <category term="FindBugs" scheme="http://mengdd.github.io/tags/FindBugs/"/>
    
      <category term="Lint" scheme="http://mengdd.github.io/tags/Lint/"/>
    
      <category term="Parcelable" scheme="http://mengdd.github.io/tags/Parcelable/"/>
    
      <category term="ViewPager" scheme="http://mengdd.github.io/tags/ViewPager/"/>
    
      <category term="PMD" scheme="http://mengdd.github.io/tags/PMD/"/>
    
      <category term="Infer" scheme="http://mengdd.github.io/tags/Infer/"/>
    
      <category term="Style" scheme="http://mengdd.github.io/tags/Style/"/>
    
      <category term="CheckStyle" scheme="http://mengdd.github.io/tags/CheckStyle/"/>
    
      <category term="JavaDoc" scheme="http://mengdd.github.io/tags/JavaDoc/"/>
    
      <category term="Jacoco" scheme="http://mengdd.github.io/tags/Jacoco/"/>
    
      <category term="ID" scheme="http://mengdd.github.io/tags/ID/"/>
    
      <category term="Nothing" scheme="http://mengdd.github.io/tags/Nothing/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 256</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/05/09/android-weekly-notes-issue-256/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/05/09/android-weekly-notes-issue-256/</id>
    <published>2017-05-09T09:34:44.000Z</published>
    <updated>2017-05-09T09:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-256"><a href="#Android-Weekly-Issue-256" class="headerlink" title="Android Weekly Issue #256"></a>Android Weekly Issue #256</h1><p>May 7th, 2017<br><a href="http://androidweekly.net/issues/issue-256" target="_blank" rel="external">Android Weekly Issue #256</a><br>本期内容包括: 一个给ViewPager切换时加动画的库; Tail Recursion和它在Kotlin中的实现; MVI模式中的状态恢复; Dagger2的新API使用; 一个新的框架库Flax介绍.<br>代码部分包括: ViewPager加动画的库; 悬浮菜单; RxLoader结合RxJava和Loader实现数据加载; 一个封装BottomNavigationView的库, 使得状态切换类似于ViewPager.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="ViewPagerAnimator-–-The-Basics"><a href="#ViewPagerAnimator-–-The-Basics" class="headerlink" title="ViewPagerAnimator – The Basics"></a><a href="https://blog.stylingandroid.com/viewpageranimator-the-basics/" target="_blank" rel="external">ViewPagerAnimator – The Basics</a></h2><p>一个轻量级的库: <a href="https://github.com/StylingAndroid/ViewPagerAnimator" target="_blank" rel="external">ViewPagerAnimator</a>. 本文介绍它的基本用法, 举了一个例子, 可以在切换pager的时候改变背景颜色.</p>
<h2 id="Tail-recursion-and-how-to-use-it-in-Kotlin"><a href="#Tail-recursion-and-how-to-use-it-in-Kotlin" class="headerlink" title="Tail recursion and how to use it in Kotlin"></a><a href="https://medium.com/@JorgeCastilloPr/tail-recursion-and-how-to-use-it-in-kotlin-97353993e17f" target="_blank" rel="external">Tail recursion and how to use it in Kotlin</a></h2><p>尾部递归和它在Kotlin中的实现.</p>
<p>官方文档见: <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions" target="_blank" rel="external">tail-recursive-functions</a>. 关键字: <code>tailrec</code>.</p>
<h2 id="Reactive-with-MVI-Part-6-Restoring-State"><a href="#Reactive-with-MVI-Part-6-Restoring-State" class="headerlink" title="Reactive with MVI Part 6 - Restoring State"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-6" target="_blank" rel="external">Reactive with MVI Part 6 - Restoring State</a></h2><p>使用MVI(Model-View-Intent)模式, 保持数据流的单向性, 会很大程度上简化状态恢复. 本篇就介绍怎么做和为什么.</p>
<p>这篇文章关注的状态分两种: 一种是memory中的状态(比如屏幕旋转时); 一种是persistent的状态, 即存在Bundle中的状态.</p>
<h3 id="In-Memory"><a href="#In-Memory" class="headerlink" title="In Memory"></a>In Memory</h3><p>对于Memory中的状态, 很简单, 我们只需要保证我们的RxJava流在Android组件生命周期之外仍然发送新的状态.</p>
<p>对于MVP来说, 这就是让Presenter在View的生命周期之外存活, 每当view重新attach到presenter上之后, 就按照前一个状态重新渲染. 只有当view完全被销毁了之后presenter才释放.</p>
<p>使用情形: 屏幕旋转, back stack回退.</p>
<h3 id="Persistent-State"><a href="#Persistent-State" class="headerlink" title="Persistent State"></a>Persistent State</h3><p>在Android中通常用<code>Activity.onSaveInstanceState(Bundle)</code>来保存状态. 在MVI中View有一个<code>render(state)</code>方法, 所以一个显而易见的方法是让state实现<code>Parcelable</code>然后保存在bundle中.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>使用单向数据流和一个表达状态的Model以后, 很多和状态相关的事情变得很容易实现了.</p>
<p>但是通常处于两个理由, 不会把状态放在bundle里: 第一, Bundle有大小限制; 第二, 我们仅仅讨论了如何序列化和反序列化状态, 但恢复状态可能是另一回事.</p>
<h2 id="Dagger-2-Android-Modules"><a href="#Dagger-2-Android-Modules" class="headerlink" title="Dagger 2: Android Modules"></a><a href="https://medium.com/proandroiddev/dagger-2-android-modules-e168821cfc57" target="_blank" rel="external">Dagger 2: Android Modules</a></h2><p>Dagger 2发布了新版本2.11-rc2.<br>在2.11中有新的API: <code>@ContributesAndroidInjector</code>.</p>
<p><a href="https://github.com/google/dagger/releases" target="_blank" rel="external">dagger2的changelog</a>.</p>
<p>本文介绍了新API相关的用法, 和之前的实现做了比较.</p>
<p>新的用法总结起来有以下三点:</p>
<ul>
<li>继承<code>DaggerApplication</code>来注入相关的dispatchers.</li>
<li>在component中包含<code>AndroidSupportInjectionModule.class</code>.</li>
<li>创建一个bind方法, 用<code>@ContributesAndroidInjector</code>标注.</li>
</ul>
<h2 id="Hello-Flax-—-A-Reactive-Architecture-For-Android"><a href="#Hello-Flax-—-A-Reactive-Architecture-For-Android" class="headerlink" title="Hello Flax — A Reactive Architecture For Android"></a><a href="https://hackernoon.com/hello-flax-a-reactive-architecture-for-android-8e56af9c575a" target="_blank" rel="external">Hello Flax — A Reactive Architecture For Android</a></h2><p>当前Android中的一个趋势是创建reactive的app.<br>作者最初听说这个概念是从<a href="https://facebook.github.io/flux/" target="_blank" rel="external">Flux</a>. 后来看了一系列<a href="http://hannesdorfmann.com/android/mosby3-mvi-1" target="_blank" rel="external">MVI模式的文章</a>, 作者自己也做了一个MVI的<a href="https://medium.com/@CodyEngel/lets-try-model-view-intent-with-android-3190a899c3a1" target="_blank" rel="external">尝试</a>. 之后他就创建了<a href="https://github.com/CodyEngel/Flax" target="_blank" rel="external">Flax</a>, 是一个轻量级的框架库(还在进一步开发中).</p>
<p>本文介绍了Flax库的使用, 基本可以总结为以下几点:</p>
<ul>
<li>Model作为唯一的状态真相.</li>
<li>View只做无脑的渲染.</li>
<li>Renderer接收Model变化的通知, 调用View的渲染方法.</li>
<li>Responder接收用户交互事件, 调用Model的更新方法.</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ViewPagerAnimator"><a href="#ViewPagerAnimator" class="headerlink" title="ViewPagerAnimator"></a><a href="https://github.com/StylingAndroid/ViewPagerAnimator" target="_blank" rel="external">ViewPagerAnimator</a></h2><p>一个轻量级的ViewPager动画库.</p>
<h2 id="floatingMenu"><a href="#floatingMenu" class="headerlink" title="floatingMenu"></a><a href="https://github.com/rjsvieira/floatingMenu" target="_blank" rel="external">floatingMenu</a></h2><p>一个悬浮的action menu, 点开后展开多个菜单选项.</p>
<h2 id="RxLoader"><a href="#RxLoader" class="headerlink" title="RxLoader"></a><a href="https://github.com/kmdupr33/RxLoader" target="_blank" rel="external">RxLoader</a></h2><p>一个轻量级的加载数据的库, 结合Loader和RxJava, 避免了内存泄露.<br>基本使用方法: 和你的<code>Observable</code>或者<code>Single</code> <code>compose</code>一下就好.</p>
<p>作者还有一篇文章详细介绍为什么他觉得他这个库很有必要: <a href="https://www.philosophicalhacker.com/post/rxloader-boilerplate-free-data-loading-with-loaders-and-rxjava/" target="_blank" rel="external">RxLoader: Lightweight, Boilerplate-Free Data loading with Loaders and RxJava</a>.</p>
<h2 id="AdaptableBottomNavigation"><a href="#AdaptableBottomNavigation" class="headerlink" title="AdaptableBottomNavigation"></a><a href="https://github.com/bufferapp/AdaptableBottomNavigation" target="_blank" rel="external">AdaptableBottomNavigation</a></h2><p>使用support库的<code>BottomNavigationView</code>的时候, 需要自己处理tab间的切换. 作者他们受到<code>TabLayout</code>的启发, 创建了一个<code>ViewSwapper</code>类, 可以简化<code>BottomNavigationView</code>的View管理, 有点像<code>ViewPager</code>的变种, 但去掉了滑动切换的功能.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-256&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-256&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #256&quot;&gt;&lt;/a&gt;Android Weekly Issue #256&lt;/h1&gt;&lt;p&gt;May 7th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-256&quot;&gt;Android Weekly Issue #256&lt;/a&gt;&lt;br&gt;本期内容包括: 一个给ViewPager切换时加动画的库; Tail Recursion和它在Kotlin中的实现; MVI模式中的状态恢复; Dagger2的新API使用; 一个新的框架库Flax介绍.&lt;br&gt;代码部分包括: ViewPager加动画的库; 悬浮菜单; RxLoader结合RxJava和Loader实现数据加载; 一个封装BottomNavigationView的库, 使得状态切换类似于ViewPager.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="BottomNavigationView" scheme="http://mengdd.github.io/tags/BottomNavigationView/"/>
    
      <category term="Loader" scheme="http://mengdd.github.io/tags/Loader/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="ViewPager" scheme="http://mengdd.github.io/tags/ViewPager/"/>
    
      <category term="Tail Recursion" scheme="http://mengdd.github.io/tags/Tail-Recursion/"/>
    
      <category term="Floating Menu" scheme="http://mengdd.github.io/tags/Floating-Menu/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 255</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/05/03/android-weekly-notes-issue-255/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/05/03/android-weekly-notes-issue-255/</id>
    <published>2017-05-03T07:38:46.000Z</published>
    <updated>2017-05-24T01:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-255"><a href="#Android-Weekly-Issue-255" class="headerlink" title="Android Weekly Issue #255"></a>Android Weekly Issue #255</h1><p>April 30th, 2017<br><a href="http://androidweekly.net/issues/issue-255" target="_blank" rel="external">Android Weekly Issue #255</a><br>本期内容包括: 一种在RxJava中显示loading/content/error的好的处理方法; Android O中的一些隐藏宝藏; Uber app的immutable的数据升级; MVP模式下, 不要再做<code>view != null</code>的判断了; 用Dagger2实现的依赖注入; 迁移应用到Kotlin; 如何把Gradle插件从Groovy迁移到Kotlin; Activity中的静态start方法使用; Firebase的实时数据库使用.  </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="LCE-Modeling-Data-Loading-in-RxJava"><a href="#LCE-Modeling-Data-Loading-in-RxJava" class="headerlink" title="LCE: Modeling Data Loading in RxJava"></a><a href="https://tech.instacart.com/lce-modeling-data-loading-in-rxjava-b798ac98d80" target="_blank" rel="external">LCE: Modeling Data Loading in RxJava</a></h2><p>作者介绍了一种方法, 用RxJava来处理显示loading/内容/错误的逻辑.</p>
<p>核心思想是中这个结构把数据包一层:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lce -&gt; Loading / Content / Error</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lce</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Lce&lt;T&gt; <span class="title">data</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        <span class="comment">// implementation</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Lce&lt;T&gt; <span class="title">error</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">        <span class="comment">// implementation</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Lce&lt;T&gt; <span class="title">loading</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// implementation</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLoading</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasError</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Throwable <span class="title">getError</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后实际处理的代码就变成了这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">repository.getDataEventStream().subscribe(&#123; event -&gt;</div><div class="line">  <span class="keyword">if</span> (event.isLoading) &#123;</div><div class="line">    view.showLoading(<span class="keyword">true</span>)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasError()) &#123;</div><div class="line">    view.showError(event.getError())</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    view.showData(event.getData())</div><div class="line">  &#125; </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>怎么构建这个Observable呢:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Lce&lt;Data&gt;&gt; getDataEventStream() &#123;</div><div class="line">  <span class="keyword">return</span> api.getData()</div><div class="line">    .map(data -&gt; Lce.data(data))</div><div class="line">    .startWith(Lce.loading())</div><div class="line">    .onErrorReturn(e -&gt; Lce.error(e))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更多构建方法见原文.</p>
<h2 id="Hidden-Gems-of-Android-O"><a href="#Hidden-Gems-of-Android-O" class="headerlink" title="Hidden Gems of Android O"></a><a href="https://medium.com/@ianhlake/hidden-gems-of-android-o-7def63136629" target="_blank" rel="external">Hidden Gems of Android O</a></h2><p>作者仔细看了Android O的<a href="https://developer.android.com/sdk/api_diff/o-dp1/changes.html" target="_blank" rel="external">API Diff</a>, 然后发现了一些隐藏的宝藏拿出来分享.</p>
<ul>
<li>Storage Access Framework的改进.</li>
<li>RecoverableSecurityException.</li>
<li>SharedPreferences支持更换底层实现.</li>
<li><code>SmsManager.createAppSpecificSmsToken()</code>提供的更好的短信验证流.</li>
<li>锁屏情况下的显示处理: <code>Keyguard.dismissKeyguard()</code>.</li>
<li>全屏Activity的旋转处理.</li>
</ul>
<h2 id="Engineering-Stability-in-Migrations"><a href="#Engineering-Stability-in-Migrations" class="headerlink" title="Engineering Stability in Migrations"></a><a href="https://eng.uber.com/immutable-collections/" target="_blank" rel="external">Engineering Stability in Migrations</a></h2><p>Uber的数据类生成及迁移到Immutable Collections的过程.</p>
<h2 id="Don’t-put-view-null-checks-in-your-Presenters"><a href="#Don’t-put-view-null-checks-in-your-Presenters" class="headerlink" title="Don’t put view != null checks in your Presenters"></a><a href="https://android.jlelse.eu/dont-put-view-null-checks-in-your-presenters-4b6026c67423" target="_blank" rel="external">Don’t put view != null checks in your Presenters</a></h2><p>如果你使用了MVP模式, 并且你的presenter在configuration变化时是一直存在的, 那么你的presenter至少会有下面两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(View)</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>这样的话你的<code>getView()</code>方法应该被标记为<code>@Nullable</code>, 然后你就需要在很多地方做null判断, 即便有些地方你100%地肯定View肯定不为null. </p>
<h3 id="Presenter的方法直接从View中被调用"><a href="#Presenter的方法直接从View中被调用" class="headerlink" title="Presenter的方法直接从View中被调用"></a>Presenter的方法直接从View中被调用</h3><p>比如那些View中UI控件点击导致的调用.</p>
<p>加个<code>view != null</code>的判断有一个缺点就是如果attach时出现了问题, 这时用户点击了按钮却没有反应, 这个错误会被忽略和隐藏起来. 在这种View应该存在的情形下, 如果得到了null, 应该及时抛出异常发现错误. </p>
<p><code>It’s always a bad sign when the else branch is missing.</code></p>
<p>解决方案: 加个<code>@NonNull View getViewOrThrow()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function"><span class="keyword">public</span> MyView <span class="title">getView</span><span class="params">()</span> </span>&#123;...&#125; </div><div class="line"></div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> MyView <span class="title">getViewOrThrow</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> MyView view = getView();</div><div class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"view not attached"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在Presenter中异步调用View"><a href="#在Presenter中异步调用View" class="headerlink" title="在Presenter中异步调用View"></a>在Presenter中异步调用View</h3><p>很多时候我们需要异步调用View的方法, 这时候我们就不能用<code>getViewOrThrow()</code>了, 因为View被detach是一种合理的情况.</p>
<p>这时候我们如果加个<code>if (view != null)</code>是可以解决这个问题的, 但是却是一个错误的选择. 因为else分支的缺失, 用户可能错过了server返回的结果, 然后永远地等下去.</p>
<p>一个比较好的解决方案就是<a href="https://github.com/grandcentrix/ThirtyInch" target="_blank" rel="external">ThirtyInch</a>, 它有一个方法叫<a href="https://github.com/grandcentrix/ThirtyInch/blob/master/thirtyinch/src/main/java/net/grandcentrix/thirtyinch/TiPresenter.java#L491" target="_blank" rel="external">sendToView(ViewAction)</a>, 它会推迟<code>ViewAction</code>的执行, 到View再次被attach的时候执行. 如果View已经处于attached的状态, 那么就立即执行.</p>
<p>一个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPresenter</span> <span class="keyword">extends</span> <span class="title">TiPresenter</span>&lt;<span class="title">MyView</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubmitLogin</span><span class="params">(<span class="keyword">final</span> Credentials credentials)</span> </span>&#123;</div><div class="line">        mLoginService.login(credentials).subscribe(</div><div class="line">                success -&gt; &#123;</div><div class="line">                    sendToView(view -&gt; view.close());</div><div class="line">                &#125;,</div><div class="line">                error -&gt; &#123;</div><div class="line">                    sendToView(view -&gt; view.showError(error));</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意请不要过度使用<code>sendToView()</code>. </p>
<p>如果你用MVI模式, 维护一个ViewModel, 在变化的时候渲染到View, 同样也可以删掉<code>view != null</code>的判断. 见<a href="https://hackernoon.com/model-view-intent-mvi-part-1-state-renderer-187e270db15c" target="_blank" rel="external">My take on Model View Intent (MVI) — Part 1: State Renderer</a>.</p>
<h3 id="Optional和WeakReference"><a href="#Optional和WeakReference" class="headerlink" title="Optional和WeakReference"></a>Optional和WeakReference</h3><p>这篇文章中用了<code>view == null</code>作为View被detached了的依据. 如果你使用了其他的包装, 比如<code>WeakReference</code>或者<code>Optional</code>, 你虽然不用null判断了但是并不代表你解决了问题, 你需要做其他的判断并且lint不能帮你做提示了.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>你并不需要<code>if (view != null)</code>检查:</p>
<ul>
<li>当你确定View是attached时, 使用<code>getViewOrThrow()</code>.</li>
<li>当View可能会是detached时, 使用<code>sendToView(ViewAction)</code>, 来支持else的处理.</li>
</ul>
<h2 id="Dependency-Injection-in-Android-with-Dagger-2"><a href="#Dependency-Injection-in-Android-with-Dagger-2" class="headerlink" title="Dependency Injection in Android with Dagger 2"></a><a href="https://www.raywenderlich.com/146804/dependency-injection-dagger-2" target="_blank" rel="external">Dependency Injection in Android with Dagger 2</a></h2><p>一个用了Retrofit和MVP模式的应用, 用Dagger2做依赖注入的例子.</p>
<h2 id="How-we-made-Basecamp-3’s-Android-app-100-Kotlin"><a href="#How-we-made-Basecamp-3’s-Android-app-100-Kotlin" class="headerlink" title="How we made Basecamp 3’s Android app 100% Kotlin"></a><a href="https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12" target="_blank" rel="external">How we made Basecamp 3’s Android app 100% Kotlin</a></h2><p>作者他们如何把应用改为用Kotlin.</p>
<h2 id="Migrate-a-Gradle-Plugin-from-Groovy-to-Kotlin"><a href="#Migrate-a-Gradle-Plugin-from-Groovy-to-Kotlin" class="headerlink" title="Migrate a Gradle Plugin from Groovy to Kotlin"></a><a href="http://adavis.info/2017/04/migrate-a-gradle-plugin-from-groovy-to-kotlin.html" target="_blank" rel="external">Migrate a Gradle Plugin from Groovy to Kotlin</a></h2><p>如何把一个用Groovy写的Gradle插件转化成Kotlin写的.</p>
<h2 id="Object-Oriented-Tricks-4-Starter-Pattern"><a href="#Object-Oriented-Tricks-4-Starter-Pattern" class="headerlink" title="Object Oriented Tricks: #4 Starter Pattern"></a><a href="https://hackernoon.com/object-oriented-tricks-4-starter-pattern-android-edition-1844e1a8522d" target="_blank" rel="external">Object Oriented Tricks: #4 Starter Pattern</a></h2><p>在Activity中定义一个静态的<code>start()</code>方法, 把需要放在intent中的参数都当做方法参数传进来.</p>
<p>Android Studio对此有一个内置的模板, 你只要输入<code>starter</code>, 按回车就可以生成这个方法.</p>
<h2 id="Using-Firebase-as-a-Real-Time-System"><a href="#Using-Firebase-as-a-Real-Time-System" class="headerlink" title="Using Firebase as a Real Time System"></a><a href="https://medium.com/google-developer-experts/using-firebase-as-a-real-time-system-d360265aa678" target="_blank" rel="external">Using Firebase as a Real Time System</a></h2><p>Firebase的Real Time Database.<br>数据库存储的信息以NoSQL的形式放在Google Cloud上. </p>
<p>三个主要的优点: 实时,离线处理, 自动同步.</p>
<p>文中展示了基本的用法.</p>
<p>之后提供了实时数据库的几种使用思路: </p>
<ul>
<li>实时通讯: (<a href="https://firechat.firebaseapp.com/" target="_blank" rel="external">Firechat</a>); </li>
<li>显示实时位置的地图(<a href="https://moquet.net/blog/realtime-geolocation-tracking-firebase/" target="_blank" rel="external">Realtime geolocation tracking with Firebase</a>, <a href="https://github.com/firebase/geofire" target="_blank" rel="external">geofire</a>); </li>
<li>排名.</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Bubble-Picker"><a href="#Bubble-Picker" class="headerlink" title="Bubble-Picker"></a><a href="https://github.com/igalata/Bubble-Picker" target="_blank" rel="external">Bubble-Picker</a></h2><p>气泡选择器.</p>
<h2 id="UltimateAndroidReference"><a href="#UltimateAndroidReference" class="headerlink" title="UltimateAndroidReference"></a><a href="https://github.com/aritraroy/UltimateAndroidReference" target="_blank" rel="external">UltimateAndroidReference</a></h2><p>Android资源收集, 包括库, 开源项目, 书籍博客等等.</p>
<h2 id="litho-picasso"><a href="#litho-picasso" class="headerlink" title="litho-picasso"></a><a href="https://github.com/charbgr/litho-picasso" target="_blank" rel="external">litho-picasso</a></h2><p>为Litho写的picasso库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-255&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-255&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #255&quot;&gt;&lt;/a&gt;Android Weekly Issue #255&lt;/h1&gt;&lt;p&gt;April 30th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-255&quot;&gt;Android Weekly Issue #255&lt;/a&gt;&lt;br&gt;本期内容包括: 一种在RxJava中显示loading/content/error的好的处理方法; Android O中的一些隐藏宝藏; Uber app的immutable的数据升级; MVP模式下, 不要再做&lt;code&gt;view != null&lt;/code&gt;的判断了; 用Dagger2实现的依赖注入; 迁移应用到Kotlin; 如何把Gradle插件从Groovy迁移到Kotlin; Activity中的静态start方法使用; Firebase的实时数据库使用.  &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Resources" scheme="http://mengdd.github.io/tags/Resources/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Gradle Plugin" scheme="http://mengdd.github.io/tags/Gradle-Plugin/"/>
    
      <category term="Data Model" scheme="http://mengdd.github.io/tags/Data-Model/"/>
    
      <category term="immutable" scheme="http://mengdd.github.io/tags/immutable/"/>
    
      <category term="Starter" scheme="http://mengdd.github.io/tags/Starter/"/>
    
      <category term="Real Time Database" scheme="http://mengdd.github.io/tags/Real-Time-Database/"/>
    
      <category term="Litho" scheme="http://mengdd.github.io/tags/Litho/"/>
    
      <category term="Picasso" scheme="http://mengdd.github.io/tags/Picasso/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 254</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/04/25/android-weekly-notes-issue-254/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/04/25/android-weekly-notes-issue-254/</id>
    <published>2017-04-25T06:37:06.000Z</published>
    <updated>2017-04-25T06:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-254"><a href="#Android-Weekly-Issue-254" class="headerlink" title="Android Weekly Issue #254"></a>Android Weekly Issue #254</h1><p>April 23rd, 2017<br><a href="http://androidweekly.net/issues/issue-254" target="_blank" rel="external">Android Weekly Issue #254</a><br>本期内容包括: 如何用Kotlin写一个Gradle Plugin; 使用Kotlin的语法和最佳实践; 如何面试一个Android developer; 如何准备一次演讲; 一个反射的库: Mirror; React Native中的导航实现; Fragments的使用讨论, 使用选择, 以及各种相关的库; Yelp的Android CI系统搭建; 一个Groovy脚本, 用于保存apk和mapping文件.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="How-to-Create-Gradle-Plugin-in-Kotlin"><a href="#How-to-Create-Gradle-Plugin-in-Kotlin" class="headerlink" title="How to Create Gradle Plugin in Kotlin"></a><a href="https://www.thedroidsonroids.com/blog/how-to-create-gradle-plugin-in-kotlin/" target="_blank" rel="external">How to Create Gradle Plugin in Kotlin</a></h2><p>关于如何写自定义的gradle插件, 网上有很多教程, 比如<a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="external">官方教程</a>. 但是大多数的教程都是用Groovy写的, 并且只有Hello World.</p>
<p>在这篇文章中, 我们要解决一个真实的问题(把JaCoCo集成到Gradle TestKit中), 并且用Kotlin来写.</p>
<p>开发完成后可以把插件发布到这里: <a href="https://plugins.gradle.org/" target="_blank" rel="external">Gradle Plugins</a>, 本文的插件介绍在<a href="https://plugins.gradle.org/plugin/pl.droidsonroids.jacoco.testkit" target="_blank" rel="external">这里</a>. 具体细节见原文.</p>
<h2 id="Idiomatic-Kotlin-Best-Practices"><a href="#Idiomatic-Kotlin-Best-Practices" class="headerlink" title="Idiomatic Kotlin. Best Practices"></a><a href="https://blog.philipphauer.de/idiomatic-kotlin-best-practices/" target="_blank" rel="external">Idiomatic Kotlin. Best Practices</a></h2><p>为了充分利用Kotlin, 我们需要修改一些在Java中用的最佳实践, 其中很多都可以用Kotlin中提供的更好的特性来取代.</p>
<p>文中的例子很详细, 举了很多个cases, 我们应该把Kotlin当做Kotlin来用, 而不是当做Java来用. </p>
<p>推荐阅读原文.</p>
<h2 id="Interviewing-Android-Developers"><a href="#Interviewing-Android-Developers" class="headerlink" title="Interviewing Android Developers"></a><a href="https://medium.com/@brendan_fahy/interviewing-android-developers-435ce69b06fa" target="_blank" rel="external">Interviewing Android Developers</a></h2><p>如何面试一个Android开发? 作者分享了他的一些经验和喜欢提的问题.</p>
<h2 id="All-You-Need-is-Just-a-Little-Patience"><a href="#All-You-Need-is-Just-a-Little-Patience" class="headerlink" title="All You Need is Just a Little Patience"></a><a href="http://zdominguez.com/2017/04/17/all-it-takes-patience.html" target="_blank" rel="external">All You Need is Just a Little Patience</a></h2><p>作者分享了他准备演讲的过程.<br>其中包括他花了多久准备代码, 如何做的Slides, 以及最后的演讲演练.</p>
<h2 id="Mirror-Easy-Reflection-for-Java-and-Android"><a href="#Mirror-Easy-Reflection-for-Java-and-Android" class="headerlink" title="Mirror: Easy Reflection for Java and Android"></a><a href="https://medium.com/genymobile/mirror-easy-reflection-for-java-and-android-923f54b1f165" target="_blank" rel="external">Mirror: Easy Reflection for Java and Android</a></h2><p>作者他们开发了一个叫<a href="https://github.com/Genymobile/mirror" target="_blank" rel="external">mirror</a>的库, 用注解的形式来简化反射调用.</p>
<h2 id="Navigation-and-Styling-with-React-Native"><a href="#Navigation-and-Styling-with-React-Native" class="headerlink" title="Navigation and Styling with React Native"></a><a href="https://developerlife.com/2017/04/15/navigation-and-styling-with-react-native/" target="_blank" rel="external">Navigation and Styling with React Native</a></h2><p>作者之前有一个文章: <a href="https://developerlife.com/2017/03/31/getting-started-with-react-native/" target="_blank" rel="external">getting started with React Native</a>, 导航用了<code>Navigator</code>类, 实际上这是一种旧的做法, 新的做法叫做: <a href="https://reactnavigation.org/" target="_blank" rel="external">React Navigation</a>.</p>
<p>关于基础的部分请查看上一篇教程, 本篇介绍Drawer, Stack和Tab三种导航. Demo在这里: <a href="https://github.com/r3bl-alliance/react-native-weather/tree/f877f53f8038295401d4934fa8e2d7db79a4625c" target="_blank" rel="external">react-native-weather</a>.</p>
<p>另外还介绍了库<a href="https://react-native-training.github.io/react-native-elements/" target="_blank" rel="external">react-native-elements</a>和<a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">react-native-vector-icons</a>的使用.</p>
<p><a href="https://react-native-training.github.io/react-native-elements/" target="_blank" rel="external">React Native Elements</a>这个库包含了一系列有用的UI components, 比如按钮, 图标等.</p>
<p><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">react-native-vector-icons</a>提供了一系列的矢量图, 相比bitmap的优势: 可以指定tint颜色, 拉伸无损, 占用空间小.</p>
<p>关于各类导航的实现见原文的详细介绍.</p>
<h2 id="Fragments-The-Solution-to-and-Cause-of-All-of-Android’s-Problems"><a href="#Fragments-The-Solution-to-and-Cause-of-All-of-Android’s-Problems" class="headerlink" title="Fragments: The Solution to (and Cause of) All of Android’s Problems"></a><a href="https://news.realm.io/news/michael-yotive-state-of-fragments-2017/" target="_blank" rel="external">Fragments: The Solution to (and Cause of) All of Android’s Problems</a></h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>在Google I/O 2016的这个演讲中: <a href="https://www.youtube.com/watch?v=k3IT-IJ0J98" target="_blank" rel="external">efficiently use fragments</a>, Adam讨论了使用Fragments常见的问题:</p>
<ul>
<li>复杂的生命周期.</li>
<li>Fragment Manager Transactions异步带来的问题.</li>
<li>自定义View还是Fragment?</li>
</ul>
<p>Adam说如果我们以不同的方式来考虑问题, 上面这些挑战大多都可以被克服:</p>
<ul>
<li>首先, Fragment只是应用中可组合的入口点. 从抽象层面来看, 和Activity一样.</li>
<li>其次, Fragment不是什么神奇的View. Fragment可以使用View来实现UI, 也可以不使用. 在实践中, Fragment应该响应View中的事件, 但View不应该知道Fragment.</li>
</ul>
<p>但是在常年的使用中, 开发者也开始寻找不用Fragment的解决方案.</p>
<h3 id="The-Rise-of-Fragment-less-Architecture"><a href="#The-Rise-of-Fragment-less-Architecture" class="headerlink" title="The Rise of Fragment-less Architecture"></a>The Rise of Fragment-less Architecture</h3><p>在2014年, Square发表了这么一篇文章<a href="https://medium.com/square-corner-blog/advocating-against-android-fragments-81fd0b462c97" target="_blank" rel="external">advocating against using Fragments</a>, 讨论了使用Fragment时遇到的种种问题.</p>
<p>除了指出Fragment存在的缺陷, Square还创建了不用Fragment创建应用的工具库: <a href="https://medium.com/square-corner-blog/simpler-android-apps-with-flow-and-mortar-5beafcd83761" target="_blank" rel="external">Flow和Mortar</a>.</p>
<p><a href="https://github.com/square/flow" target="_blank" rel="external">Flow</a>这个库允许你把你的UI screen用POJO类定义. 一个screen只需要知道和自己关联的View和更新View需要的方法. Flow也提供了基本的导航栈.</p>
<p>如果Flow已经包装了UI, 提供了导航栈,<br>那么我们的业务逻辑放在哪里呢? 这时候<a href="https://github.com/square/mortar" target="_blank" rel="external">Mortar</a>出现了.</p>
<p>Mortar使用了MVP模式, 把业务逻辑包装在Presenter里, 和View交互. 每一个Presenter都是有scope的, (Thanks to Dagger), 所以presenter销毁的时候资源会被清理. Mortar也提供了对presenter生命周期的管理.</p>
<p>使用这两个库的优点:</p>
<ul>
<li>没有Fragments.</li>
<li>强制模块化和代码的可测试性. (MVP, DI).</li>
<li>有效利用内存. (Dagger scopes).</li>
</ul>
<p>但是也有一些缺点:</p>
<ul>
<li>学习曲线较陡.</li>
<li>很多boilerplate code.</li>
<li>这两个库的release周期都非常长.</li>
</ul>
<p>Square的blog和库激发了Android社区, 形成了两个团体: 一个是想用设计模式让Fragment更好用; 另一个是再也不用Fragment. 让我们先看一下反对派.</p>
<h3 id="Down-With-Fragments"><a href="#Down-With-Fragments" class="headerlink" title="Down With Fragments"></a>Down With Fragments</h3><p>用Fragments开发有一个流行的模式是<a href="https://www.toptal.com/android/android-fragment-navigation-pattern" target="_blank" rel="external">Fragment Navigation Pattern</a>, 即一个Activity多个Fragments的架构. 如果你的应用采取这种架构, 你可以转换回去, 使用多个Activities. 如果你没有采用这种架构, 想摆脱Fragment, 可以考虑使用自定义View来代替.</p>
<p>但是这两种方法都有各自的挑战:<br>对于转换用Activity来说, 需要额外考虑如何支持平板, 很可能你需要写一些特殊的逻辑或者干脆创建不同的Activity. 使用自定义View, 在UI状态的维护方面又要做更多的努力, 需要自己保存和恢复View的状态, 以及管理backstack. </p>
<p>有一些库是为了解决这些问题而产生的: 比如<a href="https://github.com/Zhuinden/simple-stack" target="_blank" rel="external">simple-stack</a>, 一个backstack管理库;<br><a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">Conductor</a>是一个用来搭建基于View的应用的库.</p>
<h3 id="Long-Live-Fragments"><a href="#Long-Live-Fragments" class="headerlink" title="Long Live Fragments"></a>Long Live Fragments</h3><p>Square提到过Fragment很难独立测试, 所以后来他们展示了如何从Android生命周期中解耦业务逻辑, 让他们的presenter可测试. 后来Android社区终于开始利用各种设计模式, 写出更整洁和可测试的代码.</p>
<p>关于这些模式的一些资源:</p>
<ul>
<li>Eric Maxwell的<a href="https://news.realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/" target="_blank" rel="external">MV*模式</a>.</li>
<li>Google官方的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Android Architecture Blueprints</a>.</li>
<li>Google在他们的Android Testing Codelab中使用<a href="https://codelabs.developers.google.com/codelabs/android-testing/index.html?index=..%2F..%2Findex#3" target="_blank" rel="external">MVP模式</a>.</li>
</ul>
<h3 id="Smarter-Fragments"><a href="#Smarter-Fragments" class="headerlink" title="Smarter Fragments"></a>Smarter Fragments</h3><p>如果因为种种原因, 你还要继续使用Fragments, 我们当然可以做一些事情让它更容易工作, 同时增加可测试性和测试覆盖率. 基本的思想就是通过移动业务逻辑代码, 使它们从android代码中解耦出来, 然后就可以对业务逻辑代码进行单元测试.</p>
<p>此处作者举了一个MVP + Dagger的例子, 代码略.</p>
<h2 id="Continuous-Integration-on-Android"><a href="#Continuous-Integration-on-Android" class="headerlink" title="Continuous Integration on Android"></a><a href="https://engineeringblog.yelp.com/2017/04/continuous-integration-on-android.html" target="_blank" rel="external">Continuous Integration on Android</a></h2><p>作者分享在Yelp他们是如何构建Continuous Integration (CI)系统的.</p>
<h2 id="A-Groovy-Script-to-Save-Them-All"><a href="#A-Groovy-Script-to-Save-Them-All" class="headerlink" title="A Groovy Script to Save Them All"></a><a href="https://medium.com/pressure-labs/a-new-devs-guide-to-google-play-sanity-4-a-groovy-script-to-save-them-all-456a12672886" target="_blank" rel="external">A Groovy Script to Save Them All</a></h2><p>一个Groovy脚本: <a href="https://gist.github.com/robertsimoes/23e4ae728ef3fd3f924440c059a4b6e1" target="_blank" rel="external">deployApks.groovy</a>, 拷贝apk和mapping文件到目标目录, 可以帮助节约不少时间.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Litho"><a href="#Litho" class="headerlink" title="Litho"></a><a href="http://fblitho.com/" target="_blank" rel="external">Litho</a></h2><p>Facebook发布的一个库. Litho使用声明式的API来定义UI组件. 你只需要通过一组输入来描述你的UI布局, framework就会帮你做其他事, 利用代码生成, Litho会执行优化, 同时保持代码简单易用.</p>
<h1 id="TOOLS"><a href="#TOOLS" class="headerlink" title="TOOLS"></a>TOOLS</h1><h2 id="How-to-navigate-through-your-java-projects-on-Github-like-a-boss"><a href="#How-to-navigate-through-your-java-projects-on-Github-like-a-boss" class="headerlink" title="How to navigate through your java projects on Github like a boss?"></a><a href="https://medium.com/@droidchef/how-to-navigate-through-your-java-projects-on-github-like-a-boss-488a37e16310" target="_blank" rel="external">How to navigate through your java projects on Github like a boss?</a></h2><p>一个Chrome插件, 自动为Github上代码中的类生成超链接, 点击可前往.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-254&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-254&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #254&quot;&gt;&lt;/a&gt;Android Weekly Issue #254&lt;/h1&gt;&lt;p&gt;April 23rd, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-254&quot;&gt;Android Weekly Issue #254&lt;/a&gt;&lt;br&gt;本期内容包括: 如何用Kotlin写一个Gradle Plugin; 使用Kotlin的语法和最佳实践; 如何面试一个Android developer; 如何准备一次演讲; 一个反射的库: Mirror; React Native中的导航实现; Fragments的使用讨论, 使用选择, 以及各种相关的库; Yelp的Android CI系统搭建; 一个Groovy脚本, 用于保存apk和mapping文件.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="React Native" scheme="http://mengdd.github.io/tags/React-Native/"/>
    
      <category term="CI" scheme="http://mengdd.github.io/tags/CI/"/>
    
      <category term="Gradle Plugin" scheme="http://mengdd.github.io/tags/Gradle-Plugin/"/>
    
      <category term="Interview" scheme="http://mengdd.github.io/tags/Interview/"/>
    
      <category term="Mirror" scheme="http://mengdd.github.io/tags/Mirror/"/>
    
      <category term="Groovy" scheme="http://mengdd.github.io/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 253</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/04/18/android-weekly-notes-issue-253/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/04/18/android-weekly-notes-issue-253/</id>
    <published>2017-04-18T10:02:29.000Z</published>
    <updated>2017-04-19T02:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-253"><a href="#Android-Weekly-Issue-253" class="headerlink" title="Android Weekly Issue #253"></a>Android Weekly Issue #253</h1><p>April 16th, 2017<br><a href="http://androidweekly.net/issues/issue-253" target="_blank" rel="external">Android Weely Issue #253</a>.<br>本期内容包括: Android O新推出的自定义字体支持; 用Espresso测试自定义View; 在添加测试的过程中解耦在Activity中写的程序; SQLite的性能研究; 用FileProvider分享Glide的缓存文件; 基于物理的动画; Android O的隐式广播限制; RxJava和DiffUtil的结合; 向Mockito 2.x的迁移; 用Transition scene framework实现的shared element transition.<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-O-Fonts-–-Part-1"><a href="#Android-O-Fonts-–-Part-1" class="headerlink" title="Android O: Fonts – Part 1"></a><a href="https://blog.stylingandroid.com/android-o-fonts/" target="_blank" rel="external">Android O: Fonts – Part 1</a></h2><p>Android O中的自定义字体支持.</p>
<p><a href="https://fonts.google.com/" target="_blank" rel="external">Google Fonts</a>是一个很好的资源网站, 里面的字体都是开源的, 可以在app中免费试用.</p>
<p>下载了字体资源(.ttf)之后, 加入项目资源字体文件夹:<code>res/font/</code>, 点击会显示字体的preview.</p>
<p>使用的时候只需要这样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:fontFamily="@font/pacifico"</div></pre></td></tr></table></figure></p>
<h2 id="Testing-Views-in-Isolation-with-Espresso-on-Android"><a href="#Testing-Views-in-Isolation-with-Espresso-on-Android" class="headerlink" title="Testing Views in Isolation with Espresso on Android"></a><a href="https://www.novoda.com/blog/testing-views-in-isolation-with-espresso/" target="_blank" rel="external">Testing Views in Isolation with Espresso on Android</a></h2><p>作者他们的项目用了很多自定义的View, 把逻辑包含进去. (其实我个人不是很赞成这种做法).</p>
<p>本文介绍用Espresso来测试这种自定义View.</p>
<h2 id="Test-Driving-away-Coupling-in-Activities"><a href="#Test-Driving-away-Coupling-in-Activities" class="headerlink" title="Test Driving away Coupling in Activities"></a><a href="https://www.philosophicalhacker.com/post/test-driving-away-coupling-in-activities/" target="_blank" rel="external">Test Driving away Coupling in Activities</a></h2><p>目标代码是一个Activity中有动态权限请求模块, 本文首先企图给它加上测试, 在加测试的过程中对原来的代码进行重构(抽取了View接口), 然后说明了这样做的好处: 解耦, 易于修改; 减少了重复代码.</p>
<h2 id="Squeezing-Performance-from-SQLite"><a href="#Squeezing-Performance-from-SQLite" class="headerlink" title="Squeezing Performance from SQLite"></a><a href="https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2" target="_blank" rel="external">Squeezing Performance from SQLite</a></h2><p>本文介绍当你需要在SQLite数据库中插入大量数据的时候, 各种做法以及它们的性能比较.</p>
<h3 id="实验1-比较db-insert包不包transaction"><a href="#实验1-比较db-insert包不包transaction" class="headerlink" title="实验1: 比较db.insert包不包transaction."></a>实验1: 比较<code>db.insert</code>包不包transaction.</h3><p>结果: 把一系列<code>insert()</code>操作包在transaction里可以大幅度地改善性能.</p>
<p>为什么呢? 根据<a href="https://sqlite.org/lang_transaction.html" target="_blank" rel="external">文档</a>:<br>如果你不显示地指定transaction, 那么SQLite自己会在每一个操作上加一个隐式的transaction.</p>
<p>要知道SQLite只在transaction被提交的时候把插入数据写入磁盘, 所以, 如果你能减少transaction的数量, 你就可以减少磁盘访问, 从而提高效率.</p>
<h3 id="实验2-比较db-execSQL和db-insert"><a href="#实验2-比较db-execSQL和db-insert" class="headerlink" title="实验2: 比较db.execSQL和db.insert."></a>实验2: 比较<code>db.execSQL</code>和<code>db.insert</code>.</h3><p>结果: 使用<code>db.execSQL</code>可以轻微地改善性能.</p>
<p>原因: <code>db.insert()</code>包装抽象了SQL语句的创建, 这一层还是需要一点花销的.</p>
<h3 id="实验3-用db-execSQL-批处理插入"><a href="#实验3-用db-execSQL-批处理插入" class="headerlink" title="实验3: 用db.execSQL()批处理插入."></a>实验3: 用<code>db.execSQL()</code>批处理插入.</h3><p>结果: 可以提升一部分性能.</p>
<p>但是注意每个语句中有最大的变量数限制: 999. 所以如果你的表有越多列, 那么批处理所获得的性能提升就越少.</p>
<h3 id="实验4-直接使用SQLiteStatement"><a href="#实验4-直接使用SQLiteStatement" class="headerlink" title="实验4: 直接使用SQLiteStatement."></a>实验4: 直接使用<code>SQLiteStatement</code>.</h3><p><code>SQLiteStatement</code>比<code>insert()</code>和<code>execSQL()</code>更底层.</p>
<p>作者在这里做了两个实验: 一个是复用单条记录插入的<code>SQLiteStatement</code>语句对象; 另一个是复用批处理的<code>SQLiteStatement</code>语句对象.</p>
<p>结果: 跟用<code>db.execSQL()</code>批处理相比: 复用单条记录插入的语句对象并没有获得性能改善; 但是复用批处理的插入语句可以提供一点儿性能的提高. </p>
<h2 id="Share-the-Cache"><a href="#Share-the-Cache" class="headerlink" title="Share the Cache"></a><a href="http://emuneee.com/blog/2017/04/12/share-the-cache/" target="_blank" rel="external">Share the Cache</a></h2><p>很多app都有看图片的功能, 其中很多用了图片缓存库, 比如<a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a>来处理图片的缓存. 分享这些缓存的图片就有点tricky了, 要考虑到这些问题:</p>
<ul>
<li>我如何访问cache中的文件? </li>
<li>其他应用也有权限访问这些文件吗?</li>
<li>如果我需要手动拷贝文件到其他地方去, 我需要什么权限? </li>
</ul>
<p>有一种做法是: 首先把图片再缓存到其他公有的位置, 生成一个URI, 然后把这个URI用intent发送出去分享给其他应用. 这个听起来很简单, 但是实际上有点复杂, 因为读写外部存储都需要用户允许权限(Android 6.0以上).</p>
<p>所以本文要介绍的是用<code>FileProvider</code>的方法.</p>
<p>首先在Manifest中注册<code>FileProvider</code>.<br>然后在Glide中修改了缓存文件的路径.<br>(值得注意的是用Glide缓存的文件都是没有后缀名的, 所以作者在他的项目中强加了后缀名.) 最后再通过Intent分享出去:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String authority = “com.yourdomain.android.fileprovider”;</div><div class="line">Uri uri = FileProvider.getUriForFile(context, authority, file);</div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</div><div class="line">intent.putExtra(Intent.EXTRA_STREAM, uri);</div><div class="line">intent.setType(<span class="string">"image/jpeg"</span>);</div><div class="line">context.startActivity(Intent.createChooser(intent, “Share via”);</div></pre></td></tr></table></figure></p>
<h2 id="Physics-based-Animation"><a href="#Physics-based-Animation" class="headerlink" title="Physics-based Animation"></a><a href="https://developer.android.com/guide/topics/graphics/physics-based-animation.html" target="_blank" rel="external">Physics-based Animation</a></h2><p>Google的官方文档, 介绍如何使用新的基于物理的动画系统. (physics-based animation).</p>
<p>基于物理原理的动画看起来更自然, 更真实. </p>
<p>文档中举了一个例子, 中途改变动画的目标值, 比较了基于Animator的动画和基于物理的动画有什么区别: 前者需要取消当前动画设定新的目标值, 速度发生了突变; 后者只是改变了受力, 速度是连续的, 看起来更自然.</p>
<p>有关弹簧动画, 详情请见: <a href="https://developer.android.com/guide/topics/graphics/spring-animation.html" target="_blank" rel="external">Spring Animation</a>.</p>
<h2 id="Android-O-and-the-Implicit-Broadcast-Ban"><a href="#Android-O-and-the-Implicit-Broadcast-Ban" class="headerlink" title="Android O and the Implicit Broadcast Ban"></a><a href="https://commonsware.com/blog/2017/04/11/android-o-implicit-broadcast-ban.html" target="_blank" rel="external">Android O and the Implicit Broadcast Ban</a></h2><p>Android O和隐性广播限制.</p>
<p>首先解释了这种限制是什么; 为什么需要加上这条限制(RAM, Battery); 都有哪些广播受到影响; 以及对这一系统改动可以采取的一些应对政策(动态广播, 显式广播, 先不要升级, 改用其他的通信方式等).</p>
<h2 id="A-nice-combination-of-RxJava-and-DiffUtil"><a href="#A-nice-combination-of-RxJava-and-DiffUtil" class="headerlink" title="A nice combination of RxJava and DiffUtil"></a><a href="https://android.jlelse.eu/a-nice-combination-of-rxjava-and-diffutil-fe3807186012" target="_blank" rel="external">A nice combination of RxJava and DiffUtil</a></h2><p>使用<a href="https://developer.android.com/reference/android/support/v7/util/DiffUtil.html" target="_blank" rel="external">DiffUtil</a>, 你只需要提供新旧数据的比较.</p>
<p>但是如果你的数据集很大, 或者你要做的比较很复杂, 你应该避免在主线程调用<code>DiffUtil</code>的计算. 你可以把比较工作放在后台线程, 然后在主线程通知UI.</p>
<p>因为你需要比较新旧数据, 所以你需要在后台线程访问当前数据, 这就意味着这个数据会在多个线程被访问, 可能你就需要同步或者线程安全的数据结构, 如何避免这些呢? -&gt; 使用RxJava.</p>
<p>里面涉及到了对<code>.scan()</code>操作符的使用, 核心代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">disposable = ThingRepository</div><div class="line">    .latestThings(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">    .scan(initialPair, (pair, next) -&gt; &#123;</div><div class="line">      MyDiffCallback callback = <span class="keyword">new</span> MyDiffCallback(pair.first, next);</div><div class="line">      DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback);</div><div class="line">      <span class="keyword">return</span> Pair.create(next, result);</div><div class="line">    &#125;)</div><div class="line">    .skip(<span class="number">1</span>)</div><div class="line">    .subscribeOn(computation())</div><div class="line">    .observeOn(mainThread())</div><div class="line">    .subscribe(listDiffResultPair -&gt; &#123;</div><div class="line">      adapter.setThings(listDiffResultPair.first);</div><div class="line">      listDiffResultPair.second.dispatchUpdatesTo(adapter);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>完整代码见: <a href="https://github.com/ErikHellman/RxJavaAndDiffUtil" target="_blank" rel="external">RxJavaAndDiffUtil</a>.</p>
<h2 id="Mockito-2-x-over-PowerMock-Migration-Tips-and-Tricks"><a href="#Mockito-2-x-over-PowerMock-Migration-Tips-and-Tricks" class="headerlink" title="Mockito 2.x over PowerMock Migration Tips and Tricks"></a><a href="https://www.linkedin.com/pulse/mockito-2x-over-powermock-migration-tips-tricks-top-ten-hazem-saleh" target="_blank" rel="external">Mockito 2.x over PowerMock Migration Tips and Tricks</a></h2><p>Mockito 2.x发布了, 包括了可以mock final的的功能和对Java 8的支持等. </p>
<p>如果你之前在用Mockito 1.x写测试, 现在如何迁移呢? 如果你之前的测试中还用了<code>PowerMock</code>, 那么迁移起来将会更加困难.</p>
<p>本篇文章提到了你在把Mockito从1.x迁移到2.x的过程中可能会遇到的问题及解决方案.</p>
<h2 id="Shared-Element-Transition-with-RecyclerView-and-Scenes-Part-4"><a href="#Shared-Element-Transition-with-RecyclerView-and-Scenes-Part-4" class="headerlink" title="Shared Element Transition with RecyclerView and Scenes - Part 4"></a><a href="https://www.thedroidsonroids.com/blog/workcation-app-part-4-shared-element-transition-recyclerview-scenes/" target="_blank" rel="external">Shared Element Transition with RecyclerView and Scenes - Part 4</a></h2><p>使用transition scene framework实现的shared element transition动画效果.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="MaterialChipsInput"><a href="#MaterialChipsInput" class="headerlink" title="MaterialChipsInput"></a><a href="https://github.com/pchmn/MaterialChipsInput" target="_blank" rel="external">MaterialChipsInput</a></h2><p>Material Design中Chips组件的Android实现. 提供了两种Views: <code>ChipsInput</code>和<code>ChipView</code>.</p>
<h2 id="AdaptiveTableLayout"><a href="#AdaptiveTableLayout" class="headerlink" title="AdaptiveTableLayout"></a><a href="https://github.com/Cleveroad/AdaptiveTableLayout" target="_blank" rel="external">AdaptiveTableLayout</a></h2><p>一个让你可以阅读, 编辑CSV文件的库.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="Java-8-Language-Features-Support-Update"><a href="#Java-8-Language-Features-Support-Update" class="headerlink" title="Java 8 Language Features Support Update"></a><a href="https://android-developers.googleblog.com/2017/04/java-8-language-features-support-update.html" target="_blank" rel="external">Java 8 Language Features Support Update</a></h2><p>Android Studio从2.4开始就要支持Java 8了! 预览版已经发布.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-253&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-253&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #253&quot;&gt;&lt;/a&gt;Android Weekly Issue #253&lt;/h1&gt;&lt;p&gt;April 16th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-253&quot;&gt;Android Weely Issue #253&lt;/a&gt;.&lt;br&gt;本期内容包括: Android O新推出的自定义字体支持; 用Espresso测试自定义View; 在添加测试的过程中解耦在Activity中写的程序; SQLite的性能研究; 用FileProvider分享Glide的缓存文件; 基于物理的动画; Android O的隐式广播限制; RxJava和DiffUtil的结合; 向Mockito 2.x的迁移; 用Transition scene framework实现的shared element transition.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Espresso" scheme="http://mengdd.github.io/tags/Espresso/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="DiffUtil" scheme="http://mengdd.github.io/tags/DiffUtil/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="SQLite" scheme="http://mengdd.github.io/tags/SQLite/"/>
    
      <category term="Shared Element" scheme="http://mengdd.github.io/tags/Shared-Element/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Physics-based Animation" scheme="http://mengdd.github.io/tags/Physics-based-Animation/"/>
    
      <category term="SpringAnimation" scheme="http://mengdd.github.io/tags/SpringAnimation/"/>
    
      <category term="Font" scheme="http://mengdd.github.io/tags/Font/"/>
    
      <category term="Glide" scheme="http://mengdd.github.io/tags/Glide/"/>
    
      <category term="Broadcast" scheme="http://mengdd.github.io/tags/Broadcast/"/>
    
  </entry>
  
  <entry>
    <title>20+个很棒的Android开源项目</title>
    <link href="http://mengdd.github.io/Android/Open-Source/2017/04/14/20-awesome-open-source-android-apps/"/>
    <id>http://mengdd.github.io/Android/Open-Source/2017/04/14/20-awesome-open-source-android-apps/</id>
    <published>2017-04-14T09:09:19.000Z</published>
    <updated>2017-04-14T09:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-个很棒的Android开源项目"><a href="#20-个很棒的Android开源项目" class="headerlink" title="20+个很棒的Android开源项目"></a>20+个很棒的Android开源项目</h1><p>本文摘自文章: <a href="https://blog.aritraroy.in/20-awesome-open-source-android-apps-to-boost-your-development-skills-b62832cf0fa4" target="_blank" rel="external">20+ Awesome Open-Source Android Apps To Boost Your Development Skills</a>.</p>
<p>考虑到原文在墙外, 故分享在此, 希望让更多开发者看到.</p>
<a id="more"></a>
<h2 id="LeafPic"><a href="#LeafPic" class="headerlink" title="LeafPic"></a><a href="https://github.com/HoraApps/LeafPic" target="_blank" rel="external">LeafPic</a></h2><p>难度: 初级.<br><img src="/images/open-source-leafpic.png" alt="Open Source LeafPic"></p>
<p>图片和视频的Gallery app.<br>实现了动态主题.</p>
<h2 id="Simple-Calendar"><a href="#Simple-Calendar" class="headerlink" title="Simple Calendar"></a><a href="https://github.com/SimpleMobileTools/Simple-Calendar" target="_blank" rel="external">Simple Calendar</a></h2><p>难度: 初级.</p>
<p>一个简单好用的Calendar应用, 完全用Kotlin实现.</p>
<p>另外可以从这个项目学习一下自定义的桌面widgets.</p>
<h2 id="Amaze-File-Manager"><a href="#Amaze-File-Manager" class="headerlink" title="Amaze File Manager"></a><a href="https://github.com/arpitkh96/AmazeFileManager" target="_blank" rel="external">Amaze File Manager</a></h2><p>难度: 中级.<br><img src="/images/open-source-amaze-file-manager.jpeg" alt="Open Source Amaze File Manager"></p>
<p>一个文件管理器.</p>
<p>可以学习SD卡上的文件操作.</p>
<p>但不建议学习这个项目中的编码标准.</p>
<h2 id="Easy-Sound-Recorder"><a href="#Easy-Sound-Recorder" class="headerlink" title="Easy Sound Recorder"></a><a href="https://github.com/dkim0419/SoundRecorder" target="_blank" rel="external">Easy Sound Recorder</a></h2><p>难度: 初级.<br><img src="/images/open-source-easy-sound-recoder.png" alt="Open Source Easy Sound Recoder"></p>
<p>一个简单的录音程序, 遵循Material Design.</p>
<h2 id="MLManager"><a href="#MLManager" class="headerlink" title="MLManager"></a><a href="https://github.com/javiersantos/MLManager" target="_blank" rel="external">MLManager</a></h2><p>难度: 初级.</p>
<p>一个App管理器, 可以学习如何得到所有安装应用的详细信息, 提取APK, 卸载程序等.</p>
<h2 id="PhotoAffix"><a href="#PhotoAffix" class="headerlink" title="PhotoAffix"></a><a href="https://github.com/afollestad/photo-affix" target="_blank" rel="external">PhotoAffix</a></h2><p>难度: 初级.</p>
<p>一个简单的应用, 可以水平或竖直地拼接照片.</p>
<p>可以学习创建自定义View.</p>
<h2 id="MovieGuide"><a href="#MovieGuide" class="headerlink" title="MovieGuide"></a><a href="https://github.com/esoxjem/MovieGuide" target="_blank" rel="external">MovieGuide</a></h2><p>难度: 中级.<br><img src="/images/open-source-movie-guide.png" alt="Open Source MovieGuide"></p>
<p>一个流行电影浏览应用.<br>使用了: MVP, Clean Architecture, RxJava, Dagger2.</p>
<h2 id="AnExplorer"><a href="#AnExplorer" class="headerlink" title="AnExplorer"></a><a href="https://github.com/1hakr/AnExplorer" target="_blank" rel="external">AnExplorer</a></h2><p>难度: 中级.</p>
<p>一个轻量级的文件管理器, 为手机和平板设计.</p>
<p>可以学到很多文件处理, 权限管理, loaders, 自定义View等相关的东西.</p>
<h2 id="Minimal-ToDo"><a href="#Minimal-ToDo" class="headerlink" title="Minimal ToDo"></a><a href="https://github.com/avjinder/Minimal-Todo" target="_blank" rel="external">Minimal ToDo</a></h2><p>难度: 初级.</p>
<p>一个Material Design的To-Do应用.<br>可以学到一些Android开发的基本知识, 适合初学者学习.</p>
<p>但不要学习里面的包结构和代码规范, 这些不太标准.</p>
<h2 id="Timber"><a href="#Timber" class="headerlink" title="Timber"></a><a href="https://github.com/naman14/Timber" target="_blank" rel="external">Timber</a></h2><p>难度: 高级.<br><img src="/images/open-source-timber.png" alt="Open Source Timber"></p>
<p>一个很漂亮的, 功能完善的音乐播放器.</p>
<p>这个项目很大, 所以对初学者来说想要一下把握全部的内容可能会有点困难, 但是对中高级开发者来说看一看应该会觉得挺有意思.</p>
<h2 id="AnotherMonitor"><a href="#AnotherMonitor" class="headerlink" title="AnotherMonitor"></a><a href="https://github.com/AntonioRedondo/AnotherMonitor" target="_blank" rel="external">AnotherMonitor</a></h2><p>难度: 中级.<br><img src="/images/open-source-another-monitor.png" alt="Open Source AnotherMonitor"></p>
<p>如果你想要学监控Android进程, 内存占用, CPU使用以及与这些相关的东西, 这个项目很适合.</p>
<p>这个项目很小也很好理解, 但是编码和架构设计不是很好, 不应该遵循.</p>
<h2 id="InstaMaterial"><a href="#InstaMaterial" class="headerlink" title="InstaMaterial"></a><a href="https://github.com/frogermcs/InstaMaterial" target="_blank" rel="external">InstaMaterial</a></h2><p>难度: 初级.</p>
<p>这是一个学习Material Design的好项目. 这个项目复制了一些Instagram的功能, 结合了Material Design来实现.</p>
<p>这里有很多Material Design的元素, 动画和转场.</p>
<p>项目简单易懂, 适合各个阶段的学习者.</p>
<h2 id="CoCoin"><a href="#CoCoin" class="headerlink" title="CoCoin"></a><a href="https://github.com/Nightonke/CoCoin" target="_blank" rel="external">CoCoin</a></h2><p>难度: 简单.<br><img src="/images/open-source-CoCoin.png" alt="Open Source CoCoin"></p>
<p>一个详尽的个人财务记账应用, 界面干净漂亮.</p>
<p>如果你想学习如何处理大量用户数据, 根据这些数据绘制各类图表, 写一些很酷的自定义View, 那么这个开源项目很适合你.</p>
<h2 id="OmniNotes"><a href="#OmniNotes" class="headerlink" title="OmniNotes"></a><a href="https://github.com/federicoiosue/Omni-Notes" target="_blank" rel="external">OmniNotes</a></h2><p>难度: 中级.</p>
<p>如果你想建一个跟Evernote类似的功能强大的笔记应用, 那么这个项目可以看看.</p>
<p>这个项目很大, 有很多功能比如分享和搜索笔记, 上传图片, 视频, 音频, 在笔记中绘制草图, 添加提醒等. </p>
<h2 id="Clip-Stack"><a href="#Clip-Stack" class="headerlink" title="Clip Stack"></a><a href="https://github.com/heruoxin/Clip-Stack" target="_blank" rel="external">Clip Stack</a></h2><p>难度: 初级.</p>
<p>一个简单的剪贴板管理器.<br>项目很小, 简单易懂.</p>
<p>但是包结构和代码架构, 命名及代码规范不推荐学习. 并且这个项目已经不再维护了.</p>
<h2 id="Super-Clean-Master"><a href="#Super-Clean-Master" class="headerlink" title="Super Clean Master"></a><a href="https://github.com/joyoyao/superCleanMaster" target="_blank" rel="external">Super Clean Master</a></h2><p>难度: 高级.<br><img src="/images/open-source-super-clean-master.jpeg" alt="Open Source Super Clean Master"></p>
<p>一键清理开源版, 包括内存加速, 缓存清理, 自启管理, 软件管理等.</p>
<p>代码很优雅, 但是项目有一点复杂, 如果你想弄明白所有的事情, 得多花一点时间.</p>
<h2 id="Travel-Mate"><a href="#Travel-Mate" class="headerlink" title="Travel Mate"></a><a href="https://github.com/Swati4star/Travel-Mate" target="_blank" rel="external">Travel Mate</a></h2><p>难度: 中级.</p>
<p>一个旅游导览类应用, 依赖于位置和地图.<br>代码质量尚未达到标准, 但是对初级和中级开发者来说还是有很多值得学习的地方.</p>
<h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a><a href="https://github.com/Neamar/KISS" target="_blank" rel="external">KISS</a></h2><p>难度: 中级.<br><img src="/images/open-source-KISS.png" alt="Open Source KISS"></p>
<p>一个简单快速轻量级的launcher应用. 可以从中学习一些比较酷的features.</p>
<p>项目很小很简单.</p>
<h2 id="Turbo-Editor"><a href="#Turbo-Editor" class="headerlink" title="Turbo Editor"></a><a href="https://github.com/vmihalachi/turbo-editor" target="_blank" rel="external">Turbo Editor</a></h2><p>难度: 中级.<br><img src="/images/open-source-turbo-editor.png" alt="Open Source Turbo Editor"></p>
<p>一个简单但强大的文字编辑应用. 你也可以使用这个编辑器来写代码, 对不同的语言支持代码高亮.</p>
<p>从这个项目你可以学到如何做一个稳定健壮的文字(或代码)编辑器.</p>
<h2 id="Wally"><a href="#Wally" class="headerlink" title="Wally"></a><a href="https://github.com/Musenkishi/wally" target="_blank" rel="external">Wally</a></h2><p>难度: 初级.</p>
<p>一个简单快速的壁纸应用.<br>对于初学者来说可以学到很多东西.</p>
<p>这个应用的架构很好, 使得这个应用易于维护和扩展. 这个应用的目的虽然简单, 但是实现目的的方法很好.</p>
<h2 id="Pedometer"><a href="#Pedometer" class="headerlink" title="Pedometer"></a><a href="https://github.com/j4velin/Pedometer" target="_blank" rel="external">Pedometer</a></h2><p>难度: 初级.<br><img src="/images/open-source-pedometer.png" alt="Open Source Pedometer"></p>
<p>一个简单轻量级的计步器, 使用硬件传感器来计算步数, 同时考虑到了电量使用问题, 最小化电量消耗.</p>
<p>对于学习计步器实现来说是一个好项目, 但是代码标准和设计架构可能不够好.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;20-个很棒的Android开源项目&quot;&gt;&lt;a href=&quot;#20-个很棒的Android开源项目&quot; class=&quot;headerlink&quot; title=&quot;20+个很棒的Android开源项目&quot;&gt;&lt;/a&gt;20+个很棒的Android开源项目&lt;/h1&gt;&lt;p&gt;本文摘自文章: &lt;a href=&quot;https://blog.aritraroy.in/20-awesome-open-source-android-apps-to-boost-your-development-skills-b62832cf0fa4&quot;&gt;20+ Awesome Open-Source Android Apps To Boost Your Development Skills&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;考虑到原文在墙外, 故分享在此, 希望让更多开发者看到.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Open Source" scheme="http://mengdd.github.io/categories/Android/Open-Source/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 252</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/04/13/android-weekly-notes-issue-252/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/04/13/android-weekly-notes-issue-252/</id>
    <published>2017-04-13T08:07:42.000Z</published>
    <updated>2017-04-13T08:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-252"><a href="#Android-Weekly-Issue-252" class="headerlink" title="Android Weekly Issue #252"></a>Android Weekly Issue #252</h1><p>April 9th, 2017<br><a href="http://androidweekly.net/issues/issue-252" target="_blank" rel="external">Android Weekly Issue #252</a>.<br>本期内容: 变化的渐变背景实现; Kotlin 1.1特性; Parcelable数据处理; RecyclerView动画实现; MVI模式的实现; 远程team的合作; 面向对象的原则: Law of Demeter; 用JUnit 5和Kotlin结合写测试.<br>(本期内容有点水, 不知道是我的状态不好还是Weekly的状态不好).<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Make-a-moving-Gradient-Background-in-Android"><a href="#Make-a-moving-Gradient-Background-in-Android" class="headerlink" title="Make a moving Gradient Background in Android"></a><a href="http://thetechnocafe.com/make-a-moving-gradient-background-in-android/" target="_blank" rel="external">Make a moving Gradient Background in Android</a></h2><p>用AnimationList做一个不断改变的渐变色背景. </p>
<p>用根节点是&lt;<animation-list>的drawable作为View的背景:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/gradient_blue"</span></div><div class="line">        <span class="attr">android:duration</span>=<span class="string">"5000"</span>/&gt;</div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/gradient_red"</span></div><div class="line">        <span class="attr">android:duration</span>=<span class="string">"5000"</span>/&gt;</div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/gradient_teal"</span></div><div class="line">        <span class="attr">android:duration</span>=<span class="string">"5000"</span>/&gt;</div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/gradient_purple"</span></div><div class="line">        <span class="attr">android:duration</span>=<span class="string">"5000"</span>/&gt;</div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/gradient_indigo"</span></div><div class="line">        <span class="attr">android:duration</span>=<span class="string">"5000"</span>/&gt;</div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></div></pre></td></tr></table></figure></animation-list></p>
<p>其中的item是不同的渐变色drawable, 比如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">gradient</span></span></div><div class="line">        <span class="attr">android:angle</span>=<span class="string">"135"</span></div><div class="line">        <span class="attr">android:endColor</span>=<span class="string">"#34e89e"</span></div><div class="line">        <span class="attr">android:startColor</span>=<span class="string">"#0f3443"</span> /&gt;</div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在Java代码中获取, 然后start它即可:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LinearLayout linearLayout = (LinearLayout) findViewById(R.id.linear_layout);</div><div class="line"> </div><div class="line">AnimationDrawable animationDrawable = (AnimationDrawable) linearLayout.getBackground();</div><div class="line"> </div><div class="line">animationDrawable.setEnterFadeDuration(<span class="number">2500</span>);</div><div class="line">animationDrawable.setExitFadeDuration(<span class="number">5000</span>);</div><div class="line"> </div><div class="line">animationDrawable.start();</div></pre></td></tr></table></figure></p>
<p>另外, 作者推荐一个发现渐变色组合的网站: <a href="https://uigradients.com/#Pinky" target="_blank" rel="external">UiGradients</a>.</p>
<h2 id="Kotlin-1-1-is-also-for-Android-Developers"><a href="#Kotlin-1-1-is-also-for-Android-Developers" class="headerlink" title="Kotlin 1.1 is also for Android Developers"></a><a href="https://blog.jetbrains.com/kotlin/2017/04/kotlin-1-1-is-also-for-android-developers/" target="_blank" rel="external">Kotlin 1.1 is also for Android Developers</a></h2><p>Kotlin 1.1带来的一些很酷的features.</p>
<h2 id="Proper-Parcelable-Testing"><a href="#Proper-Parcelable-Testing" class="headerlink" title="Proper Parcelable Testing"></a><a href="http://blog.danlew.net/2017/04/03/proper-parcelable-testing/amp/" target="_blank" rel="external">Proper Parcelable Testing</a></h2><p>作者写了一个继承<code>Parcelable</code>接口的类, 然后把它存在savedInstanceState的Bundle里, 本文是他使用时的一些小建议.</p>
<h2 id="RecyclerView-interaction-with-Animated-Markers-Part-3"><a href="#RecyclerView-interaction-with-Animated-Markers-Part-3" class="headerlink" title="RecyclerView interaction with Animated Markers - Part 3"></a><a href="https://www.thedroidsonroids.com/blog/workcation-app-part-3-recyclerview-interaction-with-animated-markers/" target="_blank" rel="external">RecyclerView interaction with Animated Markers - Part 3</a></h2><p>动画实现: 当滚动列表的时候, 对应的Marker在地图上突出显示.</p>
<h2 id="My-take-on-Model-View-Intent-MVI-—-Part-1-State-Renderer"><a href="#My-take-on-Model-View-Intent-MVI-—-Part-1-State-Renderer" class="headerlink" title="My take on Model View Intent (MVI) — Part 1: State Renderer"></a><a href="https://hackernoon.com/model-view-intent-mvi-part-1-state-renderer-187e270db15c" target="_blank" rel="external">My take on Model View Intent (MVI) — Part 1: State Renderer</a></h2><p>作者很推荐MVI模式, 讲了自己的应用是如何实现这种模式的.</p>
<p>简要说了用Espresso对本程序进行自动化UI测试的方法.</p>
<h2 id="Effective-Remote-Teams"><a href="#Effective-Remote-Teams" class="headerlink" title="Effective Remote Teams"></a><a href="http://blog.viacom.tech/2017/04/07/effective-remote-teams/" target="_blank" rel="external">Effective Remote Teams</a></h2><p>remote team如何工作.</p>
<h2 id="Object-Oriented-Tricks-2-Law-of-Demeter"><a href="#Object-Oriented-Tricks-2-Law-of-Demeter" class="headerlink" title="Object Oriented Tricks: #2 Law of Demeter"></a><a href="https://hackernoon.com/object-oriented-tricks-2-law-of-demeter-4ecc9becad85" target="_blank" rel="external">Object Oriented Tricks: #2 Law of Demeter</a></h2><p>面向对象编程Tricks系列之2: Law of Demeter, 德米特法则. </p>
<p>每一个单元应该尽量少地知道其他单元的业务, 仅知道和自己紧密联系的单元业务. <strong>Tell Don’t Ask.</strong></p>
<h2 id="JUnit-5-Kotlin"><a href="#JUnit-5-Kotlin" class="headerlink" title="JUnit 5: Kotlin"></a><a href="https://blog.stylingandroid.com/junit-5-kotlin/" target="_blank" rel="external">JUnit 5: Kotlin</a></h2><p>如何结合Kotlin和JUnit 5来写测试.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="spruce-android"><a href="#spruce-android" class="headerlink" title="spruce-android"></a><a href="https://github.com/willowtreeapps/spruce-android" target="_blank" rel="external">spruce-android</a></h2><p>一个轻量级的动画库.</p>
<h2 id="Traceur"><a href="#Traceur" class="headerlink" title="Traceur"></a><a href="https://github.com/T-Spoon/Traceur" target="_blank" rel="external">Traceur</a></h2><p>一个RxJava2的debug工具, 可以打出异步调用的最初崩溃信息.</p>
<h2 id="scratch"><a href="#scratch" class="headerlink" title="scratch"></a><a href="https://github.com/willowtreeapps/scratch" target="_blank" rel="external">scratch</a></h2><p>清除用户数据然后重启应用.</p>
<h2 id="what-the-thing"><a href="#what-the-thing" class="headerlink" title="what_the_thing"></a><a href="https://github.com/vigzmv/what_the_thing" target="_blank" rel="external">what_the_thing</a></h2><p>拿着相机对着东西, 然后学习如何用不同的语言来说它们的一个app, 用React Native实现.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-252&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-252&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #252&quot;&gt;&lt;/a&gt;Android Weekly Issue #252&lt;/h1&gt;&lt;p&gt;April 9th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-252&quot;&gt;Android Weekly Issue #252&lt;/a&gt;.&lt;br&gt;本期内容: 变化的渐变背景实现; Kotlin 1.1特性; Parcelable数据处理; RecyclerView动画实现; MVI模式的实现; 远程team的合作; 面向对象的原则: Law of Demeter; 用JUnit 5和Kotlin结合写测试.&lt;br&gt;(本期内容有点水, 不知道是我的状态不好还是Weekly的状态不好).&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="AnimationList" scheme="http://mengdd.github.io/tags/AnimationList/"/>
    
      <category term="Parcelable" scheme="http://mengdd.github.io/tags/Parcelable/"/>
    
  </entry>
  
  <entry>
    <title>网络使用和电池消耗 原因和改进</title>
    <link href="http://mengdd.github.io/Android/2017/04/11/network-usage-and-battery-consumption/"/>
    <id>http://mengdd.github.io/Android/2017/04/11/network-usage-and-battery-consumption/</id>
    <published>2017-04-11T09:39:56.000Z</published>
    <updated>2017-04-11T09:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络使用和电池消耗-原因和改进"><a href="#网络使用和电池消耗-原因和改进" class="headerlink" title="网络使用和电池消耗 原因和改进"></a>网络使用和电池消耗 原因和改进</h1><p>你的app发送的网络请求是电量消耗的主要原因, 本文先教你如何使用IDE工具来分类分析应用中的网络请求, 之后按照三种不同的网络请求分类, 分别给出优化建议, 减少电量消耗.</p>
<p>本文是对Android官网<a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>系列文章的翻译, 略有删减, 可以作为摘要看看. (翻译不当的地方还请见谅).</p>
<a id="more"></a>
<h2 id="收集网络数据-Collecting-Network-Traffic-Data"><a href="#收集网络数据-Collecting-Network-Traffic-Data" class="headerlink" title="收集网络数据 Collecting Network Traffic Data"></a>收集网络数据 <a href="https://developer.android.com/topic/performance/power/network/gather-data.html" target="_blank" rel="external">Collecting Network Traffic Data</a></h2><p>使用<a href="https://developer.android.com/studio/profile/ddms.html#network" target="_blank" rel="external">Network Traffic tool</a>可以看到你的app如何以及何时通过网络发送数据.<br>本节教你如何通过在代码中加tag来测量和分类网络请求, 然后教你如何部署, 测试和可视化你的网络请求.</p>
<p>可以把网络请求分三类:</p>
<ul>
<li>用户发起的.</li>
<li>App发起的.</li>
<li>Server发起的. 比如notification.</li>
</ul>
<p>对这三个分类定义三个常量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_INITIATED = <span class="number">0x1000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_INITIATED = <span class="number">0x2000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_INITIATED =<span class="number">0x3000</span>;</div></pre></td></tr></table></figure></p>
<p>全文搜索:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extends GcmTaskService|extends JobService|extends AbstractThreadedSyncAdapter|HttpUrlConnection|Volley|Glide|HttpClient</div></pre></td></tr></table></figure></p>
<p>勾选Regular expression, File mask(s) 写 *.java.</p>
<p>找出所有的网络请求后, 加上下面的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (BuildConfig.NETWORK-TEST &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        TrafficStats.setThreadStatsTag(USER_INITIATED);</div><div class="line">        <span class="comment">// make network request using HttpClient.execute()</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        TrafficStats.clearThreadStatsTag();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中build type的配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    buildTypes &#123;</div><div class="line">        debug &#123;</div><div class="line">            // debuggable true is default for the debug buildType</div><div class="line">        &#125;</div><div class="line">        network-test &#123;</div><div class="line">            debuggable true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行测试:<br>Tools &gt; Android &gt; Android Device Monitor.<br>选择tab: Network Statistics.<br>选择你的应用, 然后按开始按钮.<br>你可以用下面的命令来清除应用的数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear package.name.of.app</div></pre></td></tr></table></figure></p>
<p>然后在你的应用中跑你想测试的应用场景即可.</p>
<p>使用了不同tag的网络请求会用不同的颜色显示出来.</p>
<h2 id="分析网络数据-Analyzing-Network-Traffic-Data"><a href="#分析网络数据-Analyzing-Network-Traffic-Data" class="headerlink" title="分析网络数据 Analyzing Network Traffic Data"></a>分析网络数据 <a href="https://developer.android.com/topic/performance/power/network/analyze-data.html" target="_blank" rel="external">Analyzing Network Traffic Data</a></h2><p>有效应用网络资源的特点: 应该有大段的时间网络硬件没有在使用中. 因为在移动设备上, 发送和接收数据, 长时间保持数据连接都会有巨大的花销. 如果你的应用访问网络很有效率, 那么网络通信看起来就应该是紧耦合的, 被无请求的休息时段合理地隔开.</p>
<h3 id="分析网络数据类型"><a href="#分析网络数据类型" class="headerlink" title="分析网络数据类型"></a>分析网络数据类型</h3><p>如果你的网络请求图看起来存在这方面的问题, 我们就需要根据上一节中加tag而分三种类型形成的网络图来进行分析, 提供一些优化意见.</p>
<h4 id="分析用户发起的网络请求"><a href="#分析用户发起的网络请求" class="headerlink" title="分析用户发起的网络请求"></a>分析用户发起的网络请求</h4><p>用户发起的网络请求: 当用户在执行一项特定的活动时, 可能可以有效地耦合在一起; 或者当用户不断请求附加信息时, 非均匀地展开. 当在分析用户发起的请求是, 你的目标是: 寻找频繁的网络使用模式, 还有试图创建或增加不使用网络的时段.</p>
<p>这种网络请求优化的挑战是用户请求的不确定性. 另外, 用户在使用app的时候总是期待快速的响应, 所以推迟请求会降低用户体验. 一般来说, 当用户和app直接交互时, 快速响应的优先级是高于有效的网络请求使用的.</p>
<p>这里是一些对于用户网络请求的优化手段:</p>
<ul>
<li>预取. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#pre-fetch-data" target="_blank" rel="external">Pre-fetch Network Data</a>. 当用户执行一项操作的时候, 应用预计一下它下一步可能需要的数据, 在单个连接中批量获取它们, 然后持有它们直到用户请求它们.</li>
<li>检测连接或监听变化. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#check-or-listen" target="_blank" rel="external">Check for Connectivity or Listen for Changes</a>. 在执行更新前, 检测网络连接, 或者监听网络连接变化.</li>
<li>减少连接数. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#reduce-connections" target="_blank" rel="external">Reduce the Number of Connections</a>. 使用允许数据按集合下载的server APIs</li>
</ul>
<h4 id="分析app发起的网络请求"><a href="#分析app发起的网络请求" class="headerlink" title="分析app发起的网络请求"></a>分析app发起的网络请求</h4><p>由你的应用发起的网络请求通常是一个对有效网络带宽有很大影响的方面. 在分析应用的网络活动的时候, 寻找空闲时段, 决定它们是否能被扩展. 如果你看到一致的网络请求的模式, 你应该寻找一些方法来改进, 以允许切换到低功耗模式.</p>
<p>一些优化app发起请求的手段:</p>
<ul>
<li>批处理和定时. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#batch-schedule" target="_blank" rel="external">Batch and Schedule Network Requests</a> 推迟你的网络请求以便它们可以一起处理, 并且在一个对电池来说有优势的时间.</li>
<li>允许系统检查连接. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#check-connect" target="_blank" rel="external">Allow System to Check for Connectivity</a>. 应该避免仅仅为了检查网络连接而引起的电池耗损, 在应用休眠的时候, 你可以让系统来帮你做检查.</li>
</ul>
<h4 id="分析server发起的网络请求"><a href="#分析server发起的网络请求" class="headerlink" title="分析server发起的网络请求"></a>分析server发起的网络请求</h4><p>由server对应用发起的网络请求通常也是一个对有效网络带宽有很大影响的方面. 在分析来自server的网络活动的时候, 寻找非活跃的时期, 看它们是否能被增加. </p>
<p>优化手段:</p>
<ul>
<li>使用GCM. <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html#gcm" target="_blank" rel="external">Use GCM for Server Updates</a>. 考虑使用Google Cloud Messaging service来做server端的更新, 而不是轮询.</li>
</ul>
<h2 id="优化用户网络请求-Optimizing-User-Initiated-Network-Use"><a href="#优化用户网络请求-Optimizing-User-Initiated-Network-Use" class="headerlink" title="优化用户网络请求 Optimizing User-Initiated Network Use"></a>优化用户网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html" target="_blank" rel="external">Optimizing User-Initiated Network Use</a></h2><p>快速处理用户的请求保证了良好的用户体验, 所以与此相比, 节约能量的优先级比较低.</p>
<h3 id="预取-Pre-fetch-Network-Data"><a href="#预取-Pre-fetch-Network-Data" class="headerlink" title="预取 Pre-fetch Network Data"></a>预取 Pre-fetch Network Data</h3><p>预取数据是一个减少数据传输的session数量很有效的方法. 使用预取, 在用户执行一个行为的时候, app预测下一步行为最有可能会用到的数据, 然后批量取出相关数据. 电池能量消耗因为两个原因被降低了:</p>
<ul>
<li>因为预取数据发生在mobile radio已经唤醒的状态, 所以不用再次唤醒. </li>
<li>应用预取了数据, 不然可能需要重新发另外的请求或者唤醒radio.</li>
</ul>
<p>Tip: 为了查看是否你的应用可以从预取中获利, 你可以检查你的网络traffic, 寻找永远导致多个网络请求的特定系列的用户行为. 比如那些当用户浏览时增量下载文章内容的应用, 可以在用户当前查看的分类下预取一个或多个文章.</p>
<p>更多可以查看: <a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#PrefetchData" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h3 id="检查连接-Check-for-Connectivity-or-Listen-for-Changes"><a href="#检查连接-Check-for-Connectivity-or-Listen-for-Changes" class="headerlink" title="检查连接 Check for Connectivity or Listen for Changes"></a>检查连接 Check for Connectivity or Listen for Changes</h3><p>在移动设备上来说, 搜寻信号是最费能量的操作之一. 你的应用应该总是在发出用户请求之前检查连接状态. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#choosing-scheduler" target="_blank" rel="external">Schedulers</a>可以帮你自动做这个.</p>
<ul>
<li>如果你的一些按钮依赖于网络连接, 用<a href="https://developer.android.com/reference/android/net/ConnectivityManager.html" target="_blank" rel="external">ConnectivityManager</a>来检查连接. 如果没有网络连接, app就可以节省下强制连接的电量. 具体做法见<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html#MonitorChanges" target="_blank" rel="external">Monitor for Changes in Connectivity</a>.</li>
<li>如果没有网络的情况下, 你的应用整个界面都处于不可用状态, 那么你可以根据需要使用Broadcast Receivers. 在你的Activity处于前台时监听网络连接变化, 当没有连接的时候, 就不再发请求. 如果你的app检测到网络连接丢失, 除了检测网路连接的那个receiver, 它关闭掉其他所有的receivers.</li>
</ul>
<p>对于用户发起的请求, 一个最佳实践就是在请求之前检查连接, 如果网络连接不存在, 可以调度请求在连接上以后再进行. 调度器可以用一些方式来节省电量, 比如每次检查的时候连接失败, 那么就加倍延迟时间下次再检查.</p>
<h3 id="减少连接数-Reduce-the-Number-of-Connections"><a href="#减少连接数-Reduce-the-Number-of-Connections" class="headerlink" title="减少连接数 Reduce the Number of Connections"></a>减少连接数 Reduce the Number of Connections</h3><p>一般来讲, 复用已存在的网络连接比启动新的更高效. 复用连接还允许网络更智能地对待拥堵和相关网络数据问题.<br>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#ReduceConnections" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h2 id="优化App发起的网络请求-Optimizing-App-Initiated-Network-Use"><a href="#优化App发起的网络请求-Optimizing-App-Initiated-Network-Use" class="headerlink" title="优化App发起的网络请求 Optimizing App-Initiated Network Use"></a>优化App发起的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html" target="_blank" rel="external">Optimizing App-Initiated Network Use</a></h2><p>你的应用发起的网络请求通常可以大幅度改善, 因为你可以对需要的资源做出计划并且设置访问它们的时间. 通过合理地调度时间, 可以创建出大段的设备radio空闲时间, 从而节约电量. 有一些Android的API可以用来调度网络访问, 并且其中的一些功能可以用来调节对其他应用的网络访问, 从而进一步优化电池性能.</p>
<h3 id="批处理和定时-Batch-and-Schedule-Network-Requests"><a href="#批处理和定时-Batch-and-Schedule-Network-Requests" class="headerlink" title="批处理和定时 Batch and Schedule Network Requests"></a>批处理和定时 Batch and Schedule Network Requests</h3><p>随机处理单个的请求会花掉很多的能量, 一个更高效的方法是把一系列的请求放入一个队列一起处理.</p>
<p>使用一个网络请求scheduler API用来管理和处理你的请求队列可以提高app的能量效率. Schedulers保存能量是通过把请求组合在一起, 让系统来处理. 它们还可以通过延迟一些请求, 等其他请求唤醒radio的时候, 或者等设备在充电的时候再做请求, 来进一步优化. Schedulers延迟和批处理请求是在系统范围的, 可以跨多个应用, 相比单个应用中的优化, 这给了它们更多优势.</p>
<h4 id="选择一个batch-and-scheduling-API"><a href="#选择一个batch-and-scheduling-API" class="headerlink" title="选择一个batch-and-scheduling API"></a>选择一个batch-and-scheduling API</h4><p>Android提供了三种API, 对于大多数操作功能相似, 按推荐性从高到低排列:</p>
<ul>
<li><a href="https://developers.google.com/cloud-messaging/network-manager" target="_blank" rel="external">GCM Network Manager</a>. 要求使用Google Play services.</li>
<li><a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">Job Scheduler</a>. Android 5.0 (API 21)及以上.</li>
<li><a href="https://developer.android.com/training/sync-adapters/index.html" target="_blank" rel="external">Sync Adapter for scheduled syncs</a>. 相比于前两种来说, 这种实现起来比较复杂.</li>
</ul>
<h3 id="允许系统检验连接-Allow-System-to-Check-for-Connectivity"><a href="#允许系统检验连接-Allow-System-to-Check-for-Connectivity" class="headerlink" title="允许系统检验连接 Allow System to Check for Connectivity"></a>允许系统检验连接 Allow System to Check for Connectivity</h3><p>一个最严重且意外的电池消耗原因是当用户超出信号塔或接入点范围时. 在这种情况下, 用户可能并没有使用手机, 但是他们注意到设备变热, 电池电量变少.</p>
<p>在这种情形下, 可能是app正在跑一个后台进程, 其中以固定时间间隔搜寻信号. 搜寻信号是一个很耗电的操作.</p>
<p>避免这个问题的方法是用一种更高效的方式来查询信号连接情况. 对于app发起的请求, 可以用一个scheduler, 在其中用<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html" target="_blank" rel="external">Connectivity Manager</a>来检查连接. 如果没有网络连接, Connectivity Manager节约了能量, 因为它是自己检查了连接, 而不是启动了app来做检查. 可以进一步使用<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="external">exponential backoff</a>来做优化, 如果没有连接, 那么扩大检查的时间间隔.</p>
<h2 id="优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use"><a href="#优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use" class="headerlink" title="优化来自server的网络请求 Optimizing Server-Initiated Network Use"></a>优化来自server的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html" target="_blank" rel="external">Optimizing Server-Initiated Network Use</a></h2><p>由server发往app的请求优化起来比较有难度. 一种解决方案是客户端轮询, 检查server是否有更新, 这种方式很浪费. 一种更有效率的方式是当有新数据的时候通知你的app.</p>
<p><a href="https://developers.google.com/cloud-messaging/gcm" target="_blank" rel="external">Google Cloud Messaging</a> GCM就是为了解决这个问题. 让你的server可以向app发送通知, 提高了网络效率, 降低了能量消耗.</p>
<h3 id="用GCM发送服务器更新-Send-Server-Updates-with-GCM"><a href="#用GCM发送服务器更新-Send-Server-Updates-with-GCM" class="headerlink" title="用GCM发送服务器更新 Send Server Updates with GCM"></a>用GCM发送服务器更新 Send Server Updates with GCM</h3><p>Google Cloud Messaging (GCM)是一个轻量级的机制, 用于server向app传输一些简短的信息. 使用了GCM之后, server就可以在有数据更新的时候通知app, 这个方法减少了app查询更新却没有数据的能量消耗, 也避免了周期性的轮询请求.</p>
<p>注意: 通常情况使用<a href="https://developers.google.com/cloud-messaging/concept-options#setting-the-priority-of-a-message" target="_blank" rel="external">Normal priority</a>即可, 这样不会在设备非活跃或者低电量的时候唤醒设备.</p>
<h2 id="优化一般的网络使用-Optimizing-General-Network-Use"><a href="#优化一般的网络使用-Optimizing-General-Network-Use" class="headerlink" title="优化一般的网络使用 Optimizing General Network Use"></a>优化一般的网络使用 <a href="https://developer.android.com/topic/performance/power/network/action-any-traffic.html" target="_blank" rel="external">Optimizing General Network Use</a></h2><p>一般情况下, 减少网络请求会对节约电量有帮助. 除了之前提到的改进方法, 你还应该知道一些一般性的方法. </p>
<h3 id="压缩数据-Compress-Data"><a href="#压缩数据-Compress-Data" class="headerlink" title="压缩数据 Compress Data"></a>压缩数据 Compress Data</h3><p>减少发送或接受的数据量会帮助减少连接时间, 从而节约电量.<br>你可以:</p>
<ul>
<li>压缩数据, 用一些压缩方法, 比如GZIP压缩.</li>
<li>使用简洁的数据协议. JSON和XML提供了可读性和语言灵活性, 但是它们都是很占带宽的模式, 并且在Android上有一些序列化花销.<br>二进制序列化格式, 比如<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">Protocol Buffers</a>或<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>, 提供了更小的数据包大小, 以及更快的编解码时间. 如果你的应用经常需要传输序列化数据, 这些格式会帮你获得解码时间和传输大小方面的优势.</li>
</ul>
<h3 id="本地缓存文件-Cache-Files-Locally"><a href="#本地缓存文件-Cache-Files-Locally" class="headerlink" title="本地缓存文件 Cache Files Locally"></a>本地缓存文件 Cache Files Locally</h3><p>应用可以通过缓存来避免下载重复的数据. 始终缓存静态资源, 包括要求下载的全尺寸图像, 并尽可能长时间缓存它们.</p>
<p>缓存实现见: <a href="https://developer.android.com/training/efficient-downloads/redundant_redundant.html#LocalCache" target="_blank" rel="external">Cache Files Locally</a>.</p>
<h3 id="优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size"><a href="#优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size" class="headerlink" title="优化预取缓存大小 Optimize Pre-Fetch Cache Size"></a>优化预取缓存大小 Optimize Pre-Fetch Cache Size</h3><p>根据本地文件系统的尺寸和当前的网络连接来优化预取缓存大小. 你可以使用connectivity manager来确定处于活动状态的网络类型(Wi-FI, LTE, HSPAP, EDGE, GPRS), 并修改你的预取程序来最小化电池负载.</p>
<p>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/connectivity_patterns.html#Bandwidth" target="_blank" rel="external">Use Modifying your Download Patterns Based on the Connectivity Type</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络使用和电池消耗-原因和改进&quot;&gt;&lt;a href=&quot;#网络使用和电池消耗-原因和改进&quot; class=&quot;headerlink&quot; title=&quot;网络使用和电池消耗 原因和改进&quot;&gt;&lt;/a&gt;网络使用和电池消耗 原因和改进&lt;/h1&gt;&lt;p&gt;你的app发送的网络请求是电量消耗的主要原因, 本文先教你如何使用IDE工具来分类分析应用中的网络请求, 之后按照三种不同的网络请求分类, 分别给出优化建议, 减少电量消耗.&lt;/p&gt;
&lt;p&gt;本文是对Android官网&lt;a href=&quot;https://developer.android.com/topic/performance/power/network/index.html&quot;&gt;Reducing Network Battery Drain&lt;/a&gt;系列文章的翻译, 略有删减, 可以作为摘要看看. (翻译不当的地方还请见谅).&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Network" scheme="http://mengdd.github.io/tags/Network/"/>
    
      <category term="Battery" scheme="http://mengdd.github.io/tags/Battery/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 251</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/04/06/android-weekly-notes-issue-251/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/04/06/android-weekly-notes-issue-251/</id>
    <published>2017-04-06T09:04:00.000Z</published>
    <updated>2017-04-06T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-251"><a href="#Android-Weekly-Issue-251" class="headerlink" title="Android Weekly Issue #251"></a>Android Weekly Issue #251</h1><p>April 2nd, 2017<br><a href="http://androidweekly.net/issues/issue-251" target="_blank" rel="external">Android Weekly Issue #251</a>.<br>本期内容: Android O新增的API: View的tooltips; Android中的字体设置; 该不该将Kotlin用于产品代码; 实现一个带自定义动画的搜索Toolbar; JUnit 5中用Lambda表达式; 用Mockito和Espresso写测试;<br>native的mobile开发应该扩展一下自己的知识; Kotlin中的依赖注入实现; Kotlin中lambda表达式的简化; 一个Intellij IDEA的插件, 帮助你改善Java代码的可读性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preliminary-look-at-View-tooltips"><a href="#Preliminary-look-at-View-tooltips" class="headerlink" title="Preliminary look at View tooltips"></a><a href="https://medium.com/@bherbst/preliminary-look-at-view-tooltips-b127583c5691" target="_blank" rel="external">Preliminary look at View tooltips</a></h2><p>Android O新推出了一个API, 是给View加tooltips.</p>
<p>如何使用:<br>可以在xml里面用属性<a href="https://developer.android.com/reference/android/view/View.html#attr_android:tooltipText" target="_blank" rel="external">android:tooltipText</a>, 或者使用Java方法<a href="https://developer.android.com/reference/android/view/View.html#setTooltipText%28java.lang.CharSequence%29" target="_blank" rel="external">View.setTooltipText()</a>来指定提示文字.</p>
<p>它们的外观看起来就像一个toast(半透明的灰色方框, 有圆角). 它支持多行, 有最大宽度, 超过98个字符结尾会以…省略.<br>目前还不能被定制.</p>
<p>它在什么时候出现呢? 长按和悬停.<br>当然你的长按如果已经被处理过了(<code>OnLongClickListener</code>返回了true), 它就不会出现了.</p>
<h2 id="Perfecting-Custom-Typography-in-Android"><a href="#Perfecting-Custom-Typography-in-Android" class="headerlink" title="Perfecting Custom Typography in Android"></a><a href="https://www.bignerdranch.com/blog/perfecting-custom-typography-in-android/" target="_blank" rel="external">Perfecting Custom Typography in Android</a></h2><p>关于字体设置的微调, 作者他们弄了一个小工具: <a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a>来提高设计师和开发者沟通字体时候的效率.</p>
<h3 id="字体尺寸"><a href="#字体尺寸" class="headerlink" title="字体尺寸"></a>字体尺寸</h3><p>对于字体, 通常我们建议用<code>sp</code>(scaleable pixel), 1pt=1sp. (pt是point).</p>
<p><code>sp</code>考虑到了用户设备上的字体设置, 所以通常是建议用sp来设置字体大小.</p>
<p>但是作者他们最近在应用中一些字很大的地方, 选择使用了<code>dp</code> (density-independent pixel), 这是因为这些字本来已经很大了, 所以他们不想让它们被调节以后变得更大.</p>
<h3 id="Leading"><a href="#Leading" class="headerlink" title="Leading"></a>Leading</h3><p>在字体排版中, Leading是指字体行之间的竖直间距. 和<code>line spacing</code>和<code>line height</code>是同义词, 同样也由<code>pt/sp</code>作为单位.</p>
<p>字体文件中会有一个基本的leading值, 根据字体不同可能会不同.</p>
<p>在Android中TextView的leading可以通过<code>lineSpacingExtra</code>和<code>lineSpacingMultiplier</code>属性来定义. 在代码中可以通过方法<a href="https://developer.android.com/reference/android/widget/TextView.html#setLineSpacing(float,%20float" target="_blank" rel="external">setLineSpacing()</a>)来定义. 注意用这个方法时, 单位是像素.</p>
<h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>Tracking指字间距(letterspacing).<br>在Android中可以通过属性<code>letterSpacing</code>来设置(API 21及以上), 以em为单位的分数测量.</p>
<h2 id="Kotlin-in-Production-Should-you-stay-or-should-you-go"><a href="#Kotlin-in-Production-Should-you-stay-or-should-you-go" class="headerlink" title="Kotlin in Production: Should you stay or should you go?"></a><a href="https://medium.com/@dpreussler/kotlin-in-production-should-you-stay-or-should-you-go-a3428b44b236" target="_blank" rel="external">Kotlin in Production: Should you stay or should you go?</a></h2><p>关于是否应该使用Kotlin, 作者发表了一些他的想法. 总体来说作者是支持Kotlin的, 对于各个可能存疑的点, 他都做出了解释.</p>
<h2 id="How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin"><a href="#How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin" class="headerlink" title="How We Made the ToolBar on Android Move Like Jelly (in Kotlin)"></a><a href="https://yalantis.com/blog/toolbar-jelly-animation-kotlin-android/" target="_blank" rel="external">How We Made the ToolBar on Android Move Like Jelly (in Kotlin)</a></h2><p>在Toolbar上点击搜索按钮, 展开关键词输入框的时候, 加一个动画, 让它有弹性地震动一下, 如何实现呢?<br>本文给出了详细代码.</p>
<h2 id="JUnit-5-Lambdas"><a href="#JUnit-5-Lambdas" class="headerlink" title="JUnit 5: Lambdas"></a><a href="https://blog.stylingandroid.com/junit-5-lambdas/" target="_blank" rel="external">JUnit 5: Lambdas</a></h2><p>如何在测试中使用lambda表达式, 这篇文章里作者讨论了如何在项目中使用lambda表达式的一些方法.</p>
<p>有两个比较好的方法:</p>
<ul>
<li>用<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">retrolambda</a>.</li>
<li>用Kotlin.</li>
</ul>
<h2 id="Testing-MVP-using-Espresso-and-Mockito"><a href="#Testing-MVP-using-Espresso-and-Mockito" class="headerlink" title="Testing MVP using Espresso and Mockito"></a><a href="https://josiassena.com/testing-mvp-using-espresso-and-mockito/" target="_blank" rel="external">Testing MVP using Espresso and Mockito</a></h2><p>如何用Mockito和Espresso给一个MVP架构的程序写单元测试和UI测试.</p>
<h2 id="The-rise-of-the-full-stack-native-mobile-app-developer"><a href="#The-rise-of-the-full-stack-native-mobile-app-developer" class="headerlink" title="The rise of the full-stack native mobile app developer"></a><a href="https://medium.com/@erikhellman/the-rise-of-the-full-stack-native-mobile-app-developer-a0757388bc1b" target="_blank" rel="external">The rise of the full-stack native mobile app developer</a></h2><p>这篇文章就说native的客户端开发应该扩展自己, 学一点后端知识, 来应对行业发展和以后的趋势.</p>
<h2 id="Kotlin-Dependency-Injection-with-the-Reader-Monad"><a href="#Kotlin-Dependency-Injection-with-the-Reader-Monad" class="headerlink" title="Kotlin Dependency Injection with the Reader Monad"></a><a href="https://medium.com/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e" target="_blank" rel="external">Kotlin Dependency Injection with the Reader Monad</a></h2><p>Dependency Injection (DI)依赖注入是一种概念, 和具体使用的工具无关, 所以有各种不同的方法可以实现它.<br>本文只是提供一种思路, 用Kotlin中函数式的一些特性来做依赖注入.</p>
<p>首先介绍了什么是<code>Functors</code>, <code>Applicatives</code>和<code>Monads</code>, 作者推荐看这系列文章: <a href="https://medium.com/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251" target="_blank" rel="external">Kotlin Functors, Applicatives, And Monads in Pictures. Part 1/3</a>.</p>
<p>后来作者举了实际的例子, 详情见原文.</p>
<h2 id="How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation"><a href="#How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation" class="headerlink" title="How lambdas work in Kotlin &amp; setOnClickListener transformation"></a><a href="https://antonioleiva.com/lambdas-kotlin-android/" target="_blank" rel="external">How lambdas work in Kotlin &amp; setOnClickListener transformation</a></h2><p>关于Kotlin中的lambda是如何简化的, 以<code>setOnClickListener()</code>为例:<br>它在Java中是这样定义的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Kotlin中是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun setOnClickListener(l: (View) -&gt; Unit)</div></pre></td></tr></table></figure></p>
<p>最原始的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(object : View.OnClickListener &#123;</div><div class="line">    override fun onClick(v: View?) &#123;</div><div class="line">        toast(&quot;Hello&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后IDE会提示你改为用lambda表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(&#123; v -&gt; toast(&quot;Hello&quot;) &#125;)</div></pre></td></tr></table></figure></p>
<p>然而这个还可以进一步被简化:</p>
<p>如果一个方法的<strong>最后一个参数</strong>是一个函数, 那么它可以写在括号外面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener() &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个方法只有一个参数, 并且是一个函数, 括号可以被删掉:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你并没有用到lambda表达式的参数, 你可以省略左边的部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你的表达式只有一个参数, 而你要用它, 你仍然可以不写左边的部分, 用<code>it</code>来代替它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; doSomething(it) &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Making-Java-Code-Easier-to-Read-Without-Changing-it"><a href="#Making-Java-Code-Easier-to-Read-Without-Changing-it" class="headerlink" title="Making Java Code Easier to Read (Without Changing it)"></a><a href="https://medium.com/@andrey_cheptsov/making-java-code-easier-to-read-without-changing-it-adeebd5c36de" target="_blank" rel="external">Making Java Code Easier to Read (Without Changing it)</a></h2><p>如何在不改变代码的情况下, 增加Java代码的可读性?</p>
<p>IntelliJ IDEA为Java 8以下的用户提供了代码折叠功能, 来模拟lambda的语法.</p>
<p>作者自己又开发了一个新的插件<a href="https://plugins.jetbrains.com/plugin/9320-advanced-java-folding" target="_blank" rel="external">Advanced Java Folding</a>, 进一步扩展了这个代码折叠的功能. 本文介绍其中一些features. 这些特性在插件中都是可选的, 可以根据需要和喜好配置.</p>
<p>(经过折叠以后的Java代码确实看起来很像Kotlin).</p>
<p>本期还有两篇Android Things的文章就不介绍啦.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="JellyToolbar"><a href="#JellyToolbar" class="headerlink" title="JellyToolbar"></a><a href="https://github.com/Yalantis/JellyToolbar" target="_blank" rel="external">JellyToolbar</a></h2><p>一个带弹性抖动动画的搜索Toolbar实现, 本期有一篇文章介绍.</p>
<h2 id="Android-Router"><a href="#Android-Router" class="headerlink" title="Android Router"></a><a href="https://github.com/TangXiaoLv/Android-Router" target="_blank" rel="external">Android Router</a></h2><p>一个轻量级的组件化协议框架, 用来解耦复杂项目.</p>
<h2 id="Typesetter"><a href="#Typesetter" class="headerlink" title="Typesetter"></a><a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a></h2><p>一个小工具, 用来调整和显示字体, 本期有相关文章.</p>
<h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a><a href="https://github.com/DrKLO/Telegram" target="_blank" rel="external">Telegram</a></h2><p>Telegram是一个通信应用, 关注速度和安全. 这是该应用的官方开源代码.</p>
<h2 id="Badger"><a href="#Badger" class="headerlink" title="Badger"></a><a href="https://github.com/volders/Badger" target="_blank" rel="external">Badger</a></h2><p>一个给图片加数字小标(badges)的库.</p>
<h2 id="classyshark-calculate-size"><a href="#classyshark-calculate-size" class="headerlink" title="classyshark-calculate-size"></a><a href="https://github.com/borisf/classyshark-calculate-size" target="_blank" rel="external">classyshark-calculate-size</a></h2><p>这个工具可以计算出你依赖的库在apk的classes.dex中到底占多少大小.</p>
<h2 id="SlidingRootNav"><a href="#SlidingRootNav" class="headerlink" title="SlidingRootNav"></a><a href="https://github.com/yarolegovich/SlidingRootNav" target="_blank" rel="external">SlidingRootNav</a></h2><p>一个类似于<code>DrawerLayout</code>的ViewGroup, 抽屉部分隐藏在内容的下面. 内容可以向右滑动缩小以露出抽屉.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-251&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-251&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #251&quot;&gt;&lt;/a&gt;Android Weekly Issue #251&lt;/h1&gt;&lt;p&gt;April 2nd, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-251&quot;&gt;Android Weekly Issue #251&lt;/a&gt;.&lt;br&gt;本期内容: Android O新增的API: View的tooltips; Android中的字体设置; 该不该将Kotlin用于产品代码; 实现一个带自定义动画的搜索Toolbar; JUnit 5中用Lambda表达式; 用Mockito和Espresso写测试;&lt;br&gt;native的mobile开发应该扩展一下自己的知识; Kotlin中的依赖注入实现; Kotlin中lambda表达式的简化; 一个Intellij IDEA的插件, 帮助你改善Java代码的可读性.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Toolbar" scheme="http://mengdd.github.io/tags/Toolbar/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Espresso" scheme="http://mengdd.github.io/tags/Espresso/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Lambda" scheme="http://mengdd.github.io/tags/Lambda/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Topography" scheme="http://mengdd.github.io/tags/Topography/"/>
    
      <category term="Dependency Injection" scheme="http://mengdd.github.io/tags/Dependency-Injection/"/>
    
      <category term="Plugin" scheme="http://mengdd.github.io/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 250</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/31/android-weekly-notes-issue-250/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/31/android-weekly-notes-issue-250/</id>
    <published>2017-03-31T08:50:01.000Z</published>
    <updated>2017-04-19T02:01:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-250"><a href="#Android-Weekly-Issue-250" class="headerlink" title="Android Weekly Issue #250"></a>Android Weekly Issue #250</h1><p>March 26th, 2017<br><a href="http://androidweekly.net/issues/issue-250" target="_blank" rel="external">Android Weekly Issue #250</a>.<br>本期内容: 好几篇关于Android O预览版的文章; JUnit 5的动态测试; 作为团队里唯一的Android开发如何学习和工作; Support库新推出的基于物理的动画API: SpringAnimation; Uber Rider项目重构中关于依赖注入的scope层级的改动; Kotlin和RxJava的简洁性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="O-h-yeah-What-we-look-forward-to-in-Android-O"><a href="#O-h-yeah-What-we-look-forward-to-in-Android-O" class="headerlink" title="O-h yeah! What we look forward to in Android O"></a><a href="https://www.novoda.com/blog/o-h-yeah-what-we-look-forward-to-in-android-o/" target="_blank" rel="external">O-h yeah! What we look forward to in Android O</a></h2><p>Google宣布了最新Android O的预览程序. Novoda team查看了最新文档来看看什么新特性最让大家欣喜.</p>
<ul>
<li>更宽广的色域和多种颜色空间支持:<br>我们不再被限制在sRGB的颜色空间里, 文档见<a href="https://developer.android.com/reference/android/graphics/ColorSpace.html" target="_blank" rel="external">ColorSpace</a>.</li>
<li>字体支持.</li>
<li>Adaptive icons: Android N中提供了圆形的启动图标; 从Android O开始, 手机开发商和launcher开发者们可以指定一个mask到应用提供的背景图上.</li>
<li>ACCESSIBILITY按钮: Accessibility services(比如TalkBack)可以在有软导航键的设备上添加一个按钮.</li>
<li>指纹手势.</li>
<li>自动大小的TextView.</li>
<li>Autofill APIs. 自动填表.</li>
</ul>
<h2 id="JUnit-5-Dynamic-Tests"><a href="#JUnit-5-Dynamic-Tests" class="headerlink" title="JUnit 5: Dynamic Tests"></a><a href="https://blog.stylingandroid.com/junit-5-dynamic-tests/" target="_blank" rel="external">JUnit 5: Dynamic Tests</a></h2><p>本篇讲如何简化一个测试cases都很类似的test suite.</p>
<p>首先, 找出不同的部分, 抽取一个方法, 把不相同的部分作为参数传进去.</p>
<p>然后用JUnit 5的动态测试(Dynamic Tests)特性.<br>两个关键组件: <code>TextFactory</code>和<code>DynamicTest</code>.<br>文中代码详细说明了它们的用法.</p>
<h2 id="Flying-Solo-with-Android-Development"><a href="#Flying-Solo-with-Android-Development" class="headerlink" title="Flying Solo with Android Development"></a><a href="https://hackernoon.com/flying-solo-with-android-development-c52d911b62bf?gi=c13f45395440#.bdab0pxgy" target="_blank" rel="external">Flying Solo with Android Development</a></h2><p>作者几经周转, 从4人Android团队到2人团队, 现在又到了一个新团队, 作为团队里唯一Android开发. 在这篇文章中, 她分享了一些觉得不错的学习资源和她平时的工作习惯以及建议.</p>
<h2 id="Introduction-to-SpringAnimation-with-examples"><a href="#Introduction-to-SpringAnimation-with-examples" class="headerlink" title="Introduction to SpringAnimation with examples"></a><a href="https://www.thedroidsonroids.com/blog/android/springanimation-examples/" target="_blank" rel="external">Introduction to SpringAnimation with examples</a></h2><p>本文讲弹簧效果动画的实现.</p>
<p><a href="https://developer.android.com/reference/android/support/animation/package-summary.html" target="_blank" rel="external">Dynamic-animation</a>是Android Support Library 25.3.0最新引进的, 用于实现基于物理的动画.</p>
<p>作者这篇文章介绍了<a href="https://developer.android.com/reference/android/support/animation/SpringAnimation.html" target="_blank" rel="external">SpringAnimation</a>和<a href="https://developer.android.com/reference/android/support/animation/SpringForce.html" target="_blank" rel="external">SpringForce</a>的用法, 提供了几个例子, 动态改变View的位置, 旋转和大小属性: <a href="https://github.com/AlexKrupa/android-springanimation-examples" target="_blank" rel="external">android-springanimation-examples
</a>.</p>
<h2 id="Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies"><a href="#Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies" class="headerlink" title="Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies"></a><a href="https://eng.uber.com/deep-scope-hierarchies/" target="_blank" rel="external">Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies</a></h2><p>Android Uber rider app的重构.<br>主要讨论了由于存在很多共用组件, 所以依赖注入的设计需要改进.</p>
<p>首先介绍了旧的设计: 两级Scope层次.<br>后来他们的新设计采用了深层次的scope层级, 减少了耦合.</p>
<p>最后又介绍了几种他们曾经考虑过的架构模式.</p>
<h2 id="It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers"><a href="#It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers" class="headerlink" title="It’s time to kiss goodbye to your implicit BroadcastReceivers"></a><a href="https://medium.com/@iiro.krankka/its-time-to-kiss-goodbye-to-your-implicit-broadcastreceivers-eefafd9f4f8a#.67j4153n6" target="_blank" rel="external">It’s time to kiss goodbye to your implicit BroadcastReceivers</a></h2><p>Android O的preview已经出来了: <a href="https://developer.android.com/preview/index.html" target="_blank" rel="external">Android O Preview</a>. 这是它列出来的<a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="external">Behavior changes</a>.</p>
<p>如果你想要把app target到Android O, 而且你的manifest中注册了一些隐式的BroadcastReceiver. 那么这篇文章就是为你准备的.</p>
<p>Android做这一切的出发点都是为了节约电量.</p>
<p>Android 7.0的时候就<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html#bg-opt" target="_blank" rel="external">移除了三种隐式广播的支持</a>. 它们是<code>CONNECTIVITY_ACTION</code>,  <code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>.</p>
<p>现在Android O中, 除了<a href="https://developer.android.com/preview/features/background-broadcasts.html" target="_blank" rel="external">background-broadcasts</a>中提到的, 其他所有在manifest中注册的隐式广播都不再工作了. (注意这里的关键字: manifest中注册, 隐式广播.)</p>
<p>那么你的manifest中如果有receiver, 现在应该怎么办呢?</p>
<p>首先看看你的广播是否是隐式的. 根据<a href="https://developer.android.com/preview/features/background.html#broadcasts" target="_blank" rel="external">文档</a>, 所有跟你的应用没有直接关系的广播都是隐式的; 而直接相关的都是显式的.</p>
<p>然后检查你的应用是否真的受到了影响, 因为有一些隐式的广播是例外情况.</p>
<p>真的受到影响了怎么办呢? 使用<code>JobScheduler</code>来拯救. 但是它只在API 21以上有, 如果你的最低API小于21, 可以用官方推荐的<a href="https://github.com/firebase/firebase-jobdispatcher-android" target="_blank" rel="external">firebase-jobdispatcher-android</a>. 作者他们团队用的是Evernote的<a href="https://github.com/evernote/android-job" target="_blank" rel="external">android-job</a>.</p>
<p>如果上面的库仍然不能帮到你, 你可以考虑把广播换成动态注册的.<br>不管你的广播是隐式的还是显式的, <code>Context.registerReceiver()</code>是永远有效的. 但缺陷就是注销以后就不能再收到事件了.</p>
<h2 id="Random-Musings-on-the-O-Developer-Preview-1"><a href="#Random-Musings-on-the-O-Developer-Preview-1" class="headerlink" title="Random Musings on the O Developer Preview 1"></a><a href="https://commonsware.com/blog/2017/03/22/random-musings-o-developer-preview-1.html" target="_blank" rel="external">Random Musings on the O Developer Preview 1</a></h2><p>作者对Android O预览的一些看法.</p>
<h3 id="比较令人担心的几点"><a href="#比较令人担心的几点" class="headerlink" title="比较令人担心的几点"></a>比较令人担心的几点</h3><ul>
<li>后台工作的处理: 许多隐式的广播可能不再起作用, 可能会改变某些应用的行为.</li>
<li>多显示支持. 允许用户把一个activity投射到外部显示器上. 这个行为还需要进一步测试, 如果我们投射到一个不可触摸的显示器上会怎样?</li>
<li>关于磁盘空间, 缓存目录.</li>
<li>Support Libraries支持的最小API为14.</li>
</ul>
<h3 id="有启发性的几点"><a href="#有启发性的几点" class="headerlink" title="有启发性的几点"></a>有启发性的几点</h3><ul>
<li>可以给Notification设置timeout.</li>
<li>Picture-in-Picture (PIP)模式. 一种特殊的多窗口模式, 多数被用来播放视频, TV已经有了.</li>
<li>新字体.</li>
<li>Storage Access Framework (SAF) -&gt; Seekable streams.</li>
<li>WebView将支持allow-cleartext设置.</li>
<li>应用安装其他应用需要用户授权.</li>
<li>Content provider分页查询.</li>
<li><code>FragmentLifecycleCallbacks</code>.</li>
<li><code>SmsManager</code>可以创建tokens.</li>
<li><code>SharedPreferences</code>提供了接口, 可以更换底层存储实现.</li>
<li><code>findViewById()</code>不再需要强转.</li>
</ul>
<h3 id="其他你可能感兴趣的"><a href="#其他你可能感兴趣的" class="headerlink" title="其他你可能感兴趣的"></a>其他你可能感兴趣的</h3><ul>
<li><code>View.setTooltipText()</code>.</li>
<li><code>TextView.setJustify()</code>.</li>
<li>提供了padding和margin的Vertical和Horizontal属性, 这样一下就可以设置同一方向上的两个值.</li>
<li><code>ProgressBar.setMin()</code>.</li>
<li><code>ANDROID_ID</code>现在是对每个应用来说, 而不是用户或设备. 见<a href="https://developer.android.com/preview/behavior-changes.html#privacy-all" target="_blank" rel="external">Privacy</a>.</li>
</ul>
<h2 id="Writing-Concise-Code-with-Kotlin-and-RxJava"><a href="#Writing-Concise-Code-with-Kotlin-and-RxJava" class="headerlink" title="Writing Concise Code with Kotlin and RxJava"></a><a href="https://pspdfkit.com/blog/2017/writing-concise-code-with-kotlin-and-rxjava/" target="_blank" rel="external">Writing Concise Code with Kotlin and RxJava</a></h2><p>用Github API举例子, 用RxJava和Kotlin实现一个功能, 说明了它们的简洁性.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Fakeit"><a href="#Fakeit" class="headerlink" title="Fakeit"></a><a href="https://github.com/moove-it/fakeit" target="_blank" rel="external">Fakeit</a></h2><p>Kotlin版的假数据生成器.</p>
<h2 id="Cicerone"><a href="#Cicerone" class="headerlink" title="Cicerone"></a><a href="https://github.com/terrakok/Cicerone" target="_blank" rel="external">Cicerone</a></h2><p>一个轻量级的Android导航库.</p>
<h2 id="data-binding-validator"><a href="#data-binding-validator" class="headerlink" title="data-binding-validator"></a><a href="https://github.com/Ilhasoft/data-binding-validator" target="_blank" rel="external">data-binding-validator</a></h2><p>表单数据验证器, 使用data binding framework实现.</p>
<h2 id="LabCoat"><a href="#LabCoat" class="headerlink" title="LabCoat"></a><a href="https://github.com/Commit451/LabCoat" target="_blank" rel="external">LabCoat</a></h2><p>GitLab client for Android.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="O-MG-the-Developer-Preview-of-Android-O-is-here"><a href="#O-MG-the-Developer-Preview-of-Android-O-is-here" class="headerlink" title="O-MG, the Developer Preview of Android O is here!"></a><a href="https://android-developers.googleblog.com/2017/03/first-preview-of-android-o.html" target="_blank" rel="external">O-MG, the Developer Preview of Android O is here!</a></h2><p>Google发布了下一个系统版本Android O的开发者预览版.</p>
<h1 id="TOOLS"><a href="#TOOLS" class="headerlink" title="TOOLS"></a>TOOLS</h1><h2 id="Android-Studio-meets-Slack"><a href="#Android-Studio-meets-Slack" class="headerlink" title="Android Studio meets Slack"></a><a href="https://instapk.com/" target="_blank" rel="external">Android Studio meets Slack</a></h2><p>一个小工具, 可以直接把Android Studio打的包发到Slack去.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-250&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-250&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #250&quot;&gt;&lt;/a&gt;Android Weekly Issue #250&lt;/h1&gt;&lt;p&gt;March 26th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-250&quot;&gt;Android Weekly Issue #250&lt;/a&gt;.&lt;br&gt;本期内容: 好几篇关于Android O预览版的文章; JUnit 5的动态测试; 作为团队里唯一的Android开发如何学习和工作; Support库新推出的基于物理的动画API: SpringAnimation; Uber Rider项目重构中关于依赖注入的scope层级的改动; Kotlin和RxJava的简洁性.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="Dagger" scheme="http://mengdd.github.io/tags/Dagger/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Physics-based Animation" scheme="http://mengdd.github.io/tags/Physics-based-Animation/"/>
    
      <category term="SpringAnimation" scheme="http://mengdd.github.io/tags/SpringAnimation/"/>
    
      <category term="Injection" scheme="http://mengdd.github.io/tags/Injection/"/>
    
      <category term="BroadcastReceiver" scheme="http://mengdd.github.io/tags/BroadcastReceiver/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 249</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/24/android-weekly-notes-issue-249/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/24/android-weekly-notes-issue-249/</id>
    <published>2017-03-24T09:13:37.000Z</published>
    <updated>2017-03-24T09:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-249"><a href="#Android-Weekly-Issue-249" class="headerlink" title="Android Weekly Issue #249"></a>Android Weekly Issue #249</h1><p>March 19th, 2017<br><a href="http://androidweekly.net/issues/issue-249" target="_blank" rel="external">Android Weekly Issue #249</a></p>
<p>本期内容包括: 一个设计的实现Demo讨论; Kotlin的Coroutines可能还是没有RxJava好用; 在构建SDK/Libraries时需要注意的事项; 如何用OpenGL和JBox2D实现一个好看的多气泡选择器效果;<br>网络请求中Etag, If-Modified-Since的工作原理和用OkHttp的客户端实现; 用ClassyShark导出类型分析; 指纹认证实现代码; MVI模式对调试带来的好处; 用TensorFlow做一个图像识别处理器.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="From-design-to-Android"><a href="#From-design-to-Android" class="headerlink" title="From design to Android"></a><a href="http://saulmm.github.io/from-design-to-android-part1" target="_blank" rel="external">From design to Android</a></h2><p>作者想建立一个项目, 把从<a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a>和<a href="https://material.uplabs.com/" target="_blank" rel="external">MaterialUp</a>上看到的一些设计实现出来, 再讲解一些实现细节和UI/UX的tips等.</p>
<p>本文是此系列文章的第一篇, 选择的设计是<a href="https://material.uplabs.com/posts/preferred-date-and-time" target="_blank" rel="external">preferred-date-and-time</a>, 实现的demo在这里:<a href="https://github.com/saulmm/from_design_to_android_part1" target="_blank" rel="external">from_design_to_android_part1</a>.</p>
<p>实现中涉及到的点: Bottom Sheets; <code>ConstraintLayout</code>和其中的链式约束<a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html#Chains" target="_blank" rel="external">Chains</a>; <a href="https://developer.android.com/reference/android/widget/ViewSwitcher.html" target="_blank" rel="external">ViewSwitcher</a>; Databinding; Scene和Transition.</p>
<h2 id="Why-Im-Skeptical-about-Kotlin-Coroutines"><a href="#Why-Im-Skeptical-about-Kotlin-Coroutines" class="headerlink" title="Why Im Skeptical about Kotlin Coroutines"></a><a href="https://www.philosophicalhacker.com/post/why-im-skeptical-about-kotlin-coroutines-for-android-development/" target="_blank" rel="external">Why Im Skeptical about Kotlin Coroutines</a></h2><p>Kotlin为了处理异步发布了Coroutines特性, 本文作者对Coroutines持怀疑态度, 认为RxJava的方式更好.</p>
<p>首先, Observables为我们要处理的问题建立了很好的模型, 但coroutines并没有起到这样的作用. (coroutines只是把异步的操作写成了看起来顺序的样子, 同时不阻塞主线程.)</p>
<p>其次, Observables让我们在同步和异步数据上都可以进行同等的抽象, 而coroutines的同步处理和异步处理明显不同.</p>
<p>最后, Observables让我们在更高的抽象层中工作, 比如对元素进行遍历处理的<code>.map()</code>.</p>
<p>当然, 本文并不是说Coroutines一无是处, 它肯定是有自己的用处的, 但是作者只是持怀疑态度, 觉得它的地位远不及RxJava.</p>
<h2 id="Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries"><a href="#Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries" class="headerlink" title="Things I wish I knew when I started building Android SDK/Libraries"></a><a href="https://android.jlelse.eu/things-i-wish-i-knew-when-i-started-building-android-sdk-libraries-dba1a524d619#.tc5qkaglp" target="_blank" rel="external">Things I wish I knew when I started building Android SDK/Libraries</a></h2><p>当你遇到一个问题并且解决了, 有时候你会把解决方案作为一个库发布出去.</p>
<p>作者发布了一些库<a href="https://github.com/nisrulz/android-tips-tricks#extra--android-libraries-built-by-me" target="_blank" rel="external">Android Libraries</a>, 他提出了一些基本的问题和几个应该注意的点.</p>
<h3 id="为什么要创建这个库呢"><a href="#为什么要创建这个库呢" class="headerlink" title="为什么要创建这个库呢?"></a>为什么要创建这个库呢?</h3><p>如果已经有现成的解决方案, 尝试使用已有的方案, 或者给已有的库提Pull Request. 如果没有解决方案, 好吧, 那创建自己的库吧.</p>
<h3 id="你的artifacts可选的类型是什么"><a href="#你的artifacts可选的类型是什么" class="headerlink" title="你的artifacts可选的类型是什么?"></a>你的artifacts可选的类型是什么?</h3><ul>
<li>Library Project: 直接项目引用.</li>
<li>JAR: 包含了Java class文件和metadata.</li>
<li>AAR: 除了Java class文件, 还包含了Android的资源和manifest.</li>
</ul>
<h3 id="你的库放在哪里"><a href="#你的库放在哪里" class="headerlink" title="你的库放在哪里?"></a>你的库放在哪里?</h3><ul>
<li>本地.</li>
<li>私有的代码库.</li>
<li>公有的代码库: Maven Central, Jcenter or JitPack.</li>
</ul>
<p>(每一种方式都有教程链接).</p>
<p>上面三个基本问题说完了, 在建立这个库的时候还有一些注意事项:</p>
<h3 id="避免多个参数"><a href="#避免多个参数" class="headerlink" title="避免多个参数"></a>避免多个参数</h3><p>参数最好不要多于三个, 可以用setter或者Builder模式来解决.</p>
<h3 id="容易使用"><a href="#容易使用" class="headerlink" title="容易使用"></a>容易使用</h3><ul>
<li>直观: 任何发生在库里的行为, 最好有一些反馈, 比如打印出logs或者显示在UI上.</li>
<li>一致性: 遵从<a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a>.</li>
<li>容易使用, 不容易滥用. 最好一眼能看出它的用途. public的方法应该有足够的验证, 确保用户不会滥用. 当不存在依赖关系时, 提供默认值并处理场景.</li>
</ul>
<h3 id="最小化权限"><a href="#最小化权限" class="headerlink" title="最小化权限"></a>最小化权限</h3><p>尽量少地要求权限, 可以发送Intent让更专业的应用帮你做一些处理然后返回结果. 根据权限的获取情况来使能你的feature, 不要仅因为没有权限就crash.</p>
<p>你也可以提供一些不需要权限的fallback的实现, 让库的使用者去获取权限.</p>
<h3 id="最小化要求"><a href="#最小化要求" class="headerlink" title="最小化要求"></a>最小化要求</h3><p>有时候我们需要设备具有某项功能, 比如蓝牙.<br>这时候就需要在manifest中写<code>uses-feature</code>.</p>
<p>如果我们在库中这样写, 它会被merge进应用的manifest, 在Play Store上, 整个应用对无蓝牙的设备都变为不显示. 这样只是引入了一个库, 却失去了一部分用户, 这肯定不是我们所希望看到的.</p>
<p>解决方案就是: 不要写在manifest里, 换为在代码中动态检查. 对于不支持的情况, 库可以关掉这个功能, 提供fallback的实现.</p>
<h3 id="支持不同的版本"><a href="#支持不同的版本" class="headerlink" title="支持不同的版本"></a>支持不同的版本</h3><p>如果你有一个特定版本才支持的功能, 应该做版本检查, 然后对于更低的版本关掉它.</p>
<h3 id="Production版本不要打log"><a href="#Production版本不要打log" class="headerlink" title="Production版本不要打log"></a>Production版本不要打log</h3><h3 id="不要悄悄crash-另外fail-fast"><a href="#不要悄悄crash-另外fail-fast" class="headerlink" title="不要悄悄crash, 另外fail fast"></a>不要悄悄crash, 另外fail fast</h3><p>遇到崩溃时应该总是输出错误信息.<br>如果你不想在production输出任何log, 你至少应该提供flag, 让初始化的时候可以使能它.</p>
<p>如果你的库遇到异常, 应该立即失败, 想开发者输出Exception, 而不是卡在那里. 要避免写出会阻塞主线程的代码.</p>
<h3 id="优雅地处理错误"><a href="#优雅地处理错误" class="headerlink" title="优雅地处理错误"></a>优雅地处理错误</h3><p>当你的库出错的时候, 尽量做检查, 使得代码不会让整个应用崩溃, 而是只有你的库提供的功能被关闭了.</p>
<h3 id="捕获特定的exceptions"><a href="#捕获特定的exceptions" class="headerlink" title="捕获特定的exceptions"></a>捕获特定的exceptions</h3><h3 id="处理不良的网络连接"><a href="#处理不良的网络连接" class="headerlink" title="处理不良的网络连接"></a>处理不良的网络连接</h3><p>如果你的库中有网络请求, 请处理网络连接不良的情况.</p>
<p>如果有可能, 批处理你的网络请求, 这会节约很多电量. 看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html" target="_blank" rel="external">这里</a>.</p>
<p>使用<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>而不是json或xml, 来减小网络请求的数据量.</p>
<p>更多的网络优化看这里: <a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>.</p>
<h3 id="尽量不要依赖很大的库"><a href="#尽量不要依赖很大的库" class="headerlink" title="尽量不要依赖很大的库"></a>尽量不要依赖很大的库</h3><p>主要是因为方法数的限制.</p>
<h3 id="不要依赖你不需要的库"><a href="#不要依赖你不需要的库" class="headerlink" title="不要依赖你不需要的库"></a>不要依赖你不需要的库</h3><p>除了不依赖没有用到的库, 还可以把添加依赖的选择权留给你的用户.</p>
<p>让用户来选择性地添加你依赖的库, 如果他选择不添加, 你的相关feature可以关闭.</p>
<p>可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOKHttpOnClasspath</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class.forName(<span class="string">"com.squareup.okhttp3.OkHttpClient"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">       ex.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而你添加的时候可以这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   // for gradle version 2.12 and below</div><div class="line">   provided &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">   // or for gradle version 2.12+</div><div class="line">   compileOnly &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种只能用于纯Java的依赖, 如果是aar就不行.</p>
<h3 id="不要拖慢启动时间"><a href="#不要拖慢启动时间" class="headerlink" title="不要拖慢启动时间"></a>不要拖慢启动时间</h3><p>在应用启动初始化你的库时, 不要花太多时间.</p>
<p>两种解决方案: 一种是新启一个线程来做初始化; 另一种是到使用之前才进行初始化.</p>
<h3 id="删除功能的时候要优雅"><a href="#删除功能的时候要优雅" class="headerlink" title="删除功能的时候要优雅"></a>删除功能的时候要优雅</h3><p>升级版本的时候, 不要删除public的方法.<br>可以把方法标记为<code>@Deprecated</code>, 然后在未来的版本中慢慢删除它.</p>
<h3 id="让你的代码可测试"><a href="#让你的代码可测试" class="headerlink" title="让你的代码可测试"></a>让你的代码可测试</h3><p>使用mock来测试你的代码, 在代码中国避免final的类和static的方法.</p>
<p>写代码的时候public的API用接口, 这样更容易更换实现, 更好测试.</p>
<h3 id="文档记录所有的事"><a href="#文档记录所有的事" class="headerlink" title="文档记录所有的事"></a>文档记录所有的事</h3><p>包括如何使用你的库, 库中每一个feature都是什么.</p>
<ul>
<li>Repo根目录有一个Readme.</li>
<li>所有的public方法应该有javadoc注释. 说明目的, 参数, 返回值.</li>
<li>有一个sample app, 展示如何使用你的库.</li>
<li>在你的release界面, 确保有一个详尽的change log.</li>
</ul>
<h3 id="提供一个最简单的sample"><a href="#提供一个最简单的sample" class="headerlink" title="提供一个最简单的sample"></a>提供一个最简单的sample</h3><p>越简单越容易让人明白.</p>
<h3 id="考虑加一个Licence"><a href="#考虑加一个Licence" class="headerlink" title="考虑加一个Licence"></a>考虑加一个Licence</h3><h3 id="收集反馈"><a href="#收集反馈" class="headerlink" title="收集反馈"></a>收集反馈</h3><h2 id="How-to-Create-a-Bubble-Selection-Animation-on-Android"><a href="#How-to-Create-a-Bubble-Selection-Animation-on-Android" class="headerlink" title="How to Create a Bubble Selection Animation on Android"></a><a href="https://medium.com/@igalata13/how-to-create-a-bubble-selection-animation-on-android-627044da4854#.1ncs9qy84" target="_blank" rel="external">How to Create a Bubble Selection Animation on Android</a></h2><p>作者他们想要在Android上实现Apple music中的选择气泡效果.</p>
<p>这种动画效果用于让用户在一系列的选择项中做出选择, 气泡自由浮动, 一旦被选中就会变大一点.</p>
<p>作者选择的是用Kotlin, OpenGL和JBox2D(物理引擎).</p>
<p>详细介绍的内容包括: 如何用GLSL写vertex shader和fragment shader; 如何贴图; 用JBox2D来实现气泡的动画(需要自己实现重力); 检测用户手势移动气泡; 发现用户点击的气泡.</p>
<p>项目在Github: <a href="https://github.com/igalata/Bubble-Picker" target="_blank" rel="external">Bubble-Picker</a>.</p>
<h2 id="Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since"><a href="#Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since" class="headerlink" title="Reducing networking footprint with OkHttp, Etags and If-Modified-Since"></a><a href="https://android.jlelse.eu/reducing-your-networking-footprint-with-okhttp-etags-and-if-modified-since-b598b8dd81a1#.260pws449" target="_blank" rel="external">Reducing networking footprint with OkHttp, Etags and If-Modified-Since</a></h2><h3 id="If-Modified-Since和Last-Modified"><a href="#If-Modified-Since和Last-Modified" class="headerlink" title="If-Modified-Since和Last-Modified"></a>If-Modified-Since和Last-Modified</h3><p>Header中使用了If-Modified-Since和Last-Modified, 如果两次请求之间内容并未改变, 第二次, server就会返回<code>304 NOT MODIFIED</code>, 并且响应不含body.</p>
<p><img src="/images/if-modified-since-and-last-modified.png" alt="if-modified-since and last-modified"></p>
<h3 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h3><p>Etag工作的原理类似, 它实现起来不容易出错, 但是需要server跑一个完整的查询, 并且每次都创建一个hash.</p>
<p><img src="/images/Etag-and-If-None-Match.png" alt="Etag and if-none-match"></p>
<p>server将会在返回response之前根据响应内容创建一个hash, 然后把它作为Etag header; 客户端在做下一次请求时, 把这个Etag作为If-None-Match header发给server. 客户端在准备下一个响应的时候, 比较新的hash和请求中发来的是否相同, 如果相同, 则返回无内容的<code>304 NOT MODIFIED</code>.</p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>如果你使用了Retrofit2, 或OkHttp3, 在客户端使能Last-Modified或Etags是很容易的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_SIZE_BYTES = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>;</div><div class="line">...</div><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient().newBuilder();</div><div class="line">builder.cache(<span class="keyword">new</span> Cache(context.getCacheDir(), CACHE_SIZE_BYTES));</div><div class="line">...</div></pre></td></tr></table></figure>
<p>根据server的响应, Last-Modified或Etags将会自动启用.</p>
<p>如果你还想减少处理的时间:</p>
<p><strong>减少处理</strong>:<br>在304状态下, Retrofit2和OkHttp3将会假装这个响应和上一次的相同, 所以被缓存的响应会被返回, 你可以检测响应返回值, 如果是304就不做处理.<br>但是有时候你可能需要每次都重新parse, 这就不用检查<code>HTTP_NOT_MODIFIED</code>了, 看你的需要.</p>
<p>注意在Retrofit2中要用raw()中的response来检查, 因为<code>response.networkResponse().code()</code>返回的是被缓存了的状态值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (response.isSuccessful() &amp;&amp;</div><div class="line">    response.raw().networkResponse() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">    response.raw().networkResponse().code() ==</div><div class="line">           HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</div><div class="line">    <span class="comment">// not modified, no need to do anything.</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// parse response here</span></div></pre></td></tr></table></figure>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>如果你的Etag或Last-Modified不工作.</p>
<p><strong>检查你的Headers.</strong></p>
<p>可以用<a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho</a>或<a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="external">OkHttp logging interceptor</a>来检查你的headers.</p>
<p>正确的输出是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cache-Control: private, must-revalidate</div></pre></td></tr></table></figure></p>
<p>所有请求和响应的Last-Modified和Etag headers都会被显示出来.</p>
<p><strong>同时使用Etags和Last-Modified.</strong></p>
<p>OkHttp3会按照严格的顺序检查cache headers:</p>
<ul>
<li>1.如果上一个响应包含Etag, 那么同样的Etag值将会被加在下一个请求的If-Not-Match中.</li>
<li>2.如果第一点不满足, 但上一个响应包含Last-Modified, 那么这个值将会被记载下一个请求的If-Modified-Since中.</li>
</ul>
<p>所以如果同时使用了两种, Etag会屏蔽Last-Modified.</p>
<h2 id="Exporting-types-from-Android-app-using-ClassyShark"><a href="#Exporting-types-from-Android-app-using-ClassyShark" class="headerlink" title="Exporting types from Android app using ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-types-from-android-app-using-classyshark-7cd2be18cdf7#.5q7p9qoya" target="_blank" rel="external">Exporting types from Android app using ClassyShark</a></h2><p>如何导出<code>ClassyShark</code>的类型分析.</p>
<h2 id="Fingerprint-authentication"><a href="#Fingerprint-authentication" class="headerlink" title="Fingerprint authentication"></a><a href="http://josiassena.com/android-fingerprint-authentication/" target="_blank" rel="external">Fingerprint authentication</a></h2><p>一个指纹认证的代码例子.</p>
<h2 id="Reactive-Apps-with-MVI-Part-5"><a href="#Reactive-Apps-with-MVI-Part-5" class="headerlink" title="Reactive Apps with MVI - Part 5"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-5" target="_blank" rel="external">Reactive Apps with MVI - Part 5</a></h2><p>MVI模式系列文章第五篇.</p>
<p>之前在第一篇讲过单向数据流的重要性, 应用状态应该由业务逻辑驱动. 本篇我们将看到这样做带来的好处: 调试程序变得简单了.</p>
<p>我们经常会遇到无法复现的bug, 这往往是因为你只知道崩溃栈, 却不知道用户在出现这个bug之前的实际状态.</p>
<p>当我们用MVI的时候, 我们可以把每次用户激发的intent和model(也即状态)都打出log(用Crashlytics或者其他工具).<br>这样做以后, 我们从收集到的log中不仅能看到崩溃前最近的状态, 还能看到用户的整个操作历史.</p>
<p>而且用户的应用状态截图都被当做json发送过来, 我们可以拿到任何状态当做我们的初始状态.</p>
<p>这样做以后, 不仅复现崩溃更加容易, 我们还可以利用这些序列化的状态来写一些回归测试.</p>
<p>这样做也是有缺点的: 状态的序列化需要额外花费一些毫秒; 崩溃时传递的数据量增大了; 对用户的敏感信息, 要么忽略, 会导致信息不完整; 要么加密, 那就会需要更多的处理时间.</p>
<h2 id="Add-some-machine-learning-to-your-apps-with-TensorFlow"><a href="#Add-some-machine-learning-to-your-apps-with-TensorFlow" class="headerlink" title="Add some machine learning to your apps, with TensorFlow"></a><a href="http://nilhcem.com/android/custom-tensorflow-classifier" target="_blank" rel="external">Add some machine learning to your apps, with TensorFlow</a></h2><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a>是一个开源的机器学习的库, 由Google开发.</p>
<p>一个简单快速的开始方法就是用TensorFlow来建立一个图像分类器. 相对于使用<a href="https://cloud.google.com/vision/" target="_blank" rel="external">Google’s Cloud Vision API</a>来说, 我们可以做一个离线和简化版本, 在Android设备上检测和识别图像中物体.</p>
<p>本篇文章中, 我们会创建一个app, 来识别游戏中的角色.</p>
<p>官方有一个<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="external">Demo</a>, 如果你要跑它, 你需要安装NDK和Bazel.</p>
<p>作者创建了这个<a href="https://github.com/Nilhcem/tensorflow-classifier-android" target="_blank" rel="external">Repo</a>, 可以直接clone下来build, 更快.</p>
<p>不管你选择哪种方式, 能够运行之后, 这个sample使用了Inception, 一个提前训练好的可以检测1000个物体的model.</p>
<p>之后作者重新下载了一些图片, 对Inception进行了重新训练, 优化, 最后导入新的model并运行, 文中详细记录了过程.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="AutoplayVideos"><a href="#AutoplayVideos" class="headerlink" title="AutoplayVideos"></a><a href="https://github.com/Krupen/AutoplayVideos" target="_blank" rel="external">AutoplayVideos</a></h2><p>在RecyclerView中显示url对应的Video, 当view出现时自动播放, view不见或部分可见时自动暂停.</p>
<h2 id="PreferenceHolder"><a href="#PreferenceHolder" class="headerlink" title="PreferenceHolder"></a><a href="https://github.com/MarcinMoskala/PreferenceHolder" target="_blank" rel="external">PreferenceHolder</a></h2><p>一个Kotlin的SharedPreferences的包装库.</p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><a href="https://github.com/MarcinMoskala/ActivityStarter" target="_blank" rel="external">ActivityStarter</a></h2><p>提供了一种简化的方式来启动多参数的Activity.<br>用注解简化了从Bundle拿参数的过程, 也有相应的存取状态的方法. 可以用于Activity, Fragment, Service和BroadcastReceiver.</p>
<h2 id="BlockCanaryEx"><a href="#BlockCanaryEx" class="headerlink" title="BlockCanaryEx"></a><a href="https://github.com/lqcandqq13/BlockCanaryEx" target="_blank" rel="external">BlockCanaryEx</a></h2><p>基于<a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">BlockCanary</a>的扩展, 用于检测UI阻塞, 打印出了更多的方法信息, 并显示出最耗时的方法.</p>
<h2 id="EasySP"><a href="#EasySP" class="headerlink" title="EasySP"></a><a href="https://github.com/WhiteDG/EasySP" target="_blank" rel="external">EasySP</a></h2><p>一个简单的SharedPreferences辅助类, 支持流式操作.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-249&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-249&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #249&quot;&gt;&lt;/a&gt;Android Weekly Issue #249&lt;/h1&gt;&lt;p&gt;March 19th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-249&quot;&gt;Android Weekly Issue #249&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本期内容包括: 一个设计的实现Demo讨论; Kotlin的Coroutines可能还是没有RxJava好用; 在构建SDK/Libraries时需要注意的事项; 如何用OpenGL和JBox2D实现一个好看的多气泡选择器效果;&lt;br&gt;网络请求中Etag, If-Modified-Since的工作原理和用OkHttp的客户端实现; 用ClassyShark导出类型分析; 指纹认证实现代码; MVI模式对调试带来的好处; 用TensorFlow做一个图像识别处理器.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Retrofit" scheme="http://mengdd.github.io/tags/Retrofit/"/>
    
      <category term="Fingerprint" scheme="http://mengdd.github.io/tags/Fingerprint/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="TensorFlow" scheme="http://mengdd.github.io/tags/TensorFlow/"/>
    
      <category term="OkHttp" scheme="http://mengdd.github.io/tags/OkHttp/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="ClassyShark" scheme="http://mengdd.github.io/tags/ClassyShark/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="ViewSwitcher" scheme="http://mengdd.github.io/tags/ViewSwitcher/"/>
    
      <category term="Coroutines" scheme="http://mengdd.github.io/tags/Coroutines/"/>
    
      <category term="SDK" scheme="http://mengdd.github.io/tags/SDK/"/>
    
      <category term="Libraries" scheme="http://mengdd.github.io/tags/Libraries/"/>
    
      <category term="OpenGL" scheme="http://mengdd.github.io/tags/OpenGL/"/>
    
      <category term="JBox2D" scheme="http://mengdd.github.io/tags/JBox2D/"/>
    
      <category term="Network" scheme="http://mengdd.github.io/tags/Network/"/>
    
      <category term="Etag" scheme="http://mengdd.github.io/tags/Etag/"/>
    
      <category term="If-Modified-Since" scheme="http://mengdd.github.io/tags/If-Modified-Since/"/>
    
      <category term="Machine Learning" scheme="http://mengdd.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 248</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/17/android-weekly-notes-issue-248/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/17/android-weekly-notes-issue-248/</id>
    <published>2017-03-17T02:51:51.000Z</published>
    <updated>2017-03-31T09:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-248"><a href="#Android-Weekly-Issue-248" class="headerlink" title="Android Weekly Issue #248"></a>Android Weekly Issue #248</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-248" target="_blank" rel="external">Android Weekly Issue #248</a>.<br>本期内容包括: 为什么有时候应该让你的应用崩溃(而不是一味保护); Trello离线模式实现中两个id的问题; 如何让Dagger的component按照scope保存, 在屏幕旋转时不重建; 用Dagger构建Realm的数据库迁移逻辑;<br>利用各种mock工具写单元测试; Map上markers的动画实现; JUnit5中@DisplayName的使用; RxJava中的Single和Completable使用; 举例说明如何给FindBugs写自定义的探测器; Android中静态代码分析工具的使用; Trello离线实现中sync失败情况的处理.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Why-your-app-should-crash"><a href="#Why-your-app-should-crash" class="headerlink" title="Why your app should crash"></a><a href="http://jeroenmols.com/blog/2017/03/08/appcrash/" target="_blank" rel="external">Why your app should crash</a></h2><p>作者认为有时候让应用崩溃反而是有好处的.</p>
<p>以NPE为例, 有时候我们会习惯性地加很多null判断, 有的是多余的, 有的防御型的代码反而会掩盖了真实问题所在. 比如当一个不合理的情况发生时, 让用户看到一个不可理解的页面, 比如空白, 然后我们开发者根本不知道这种情况的发生.</p>
<p>与其这样掩盖错误, 不如让应用崩溃, 让开发者立即知道问题的原因.</p>
<p>实用建议:</p>
<ul>
<li>永远让应用对外来输入(比如service的响应, UI的输入, 进来的intents)保持健壮性.</li>
<li>在程序的入口点保证数据的完整性. 这样不合理的数据就不会到处都是, 所以你不用到处检查.</li>
<li>如果你不确定某个错误是否会在某个地方发生, 先假装它不会发生, 在测试阶段再验证.</li>
<li>如果某个方法在产品环境不能被调用, 或者只能被调用一次等, 抛出<code>IllegalStateException</code>.</li>
<li>永远在发布之前进行完整测试, 这样你就会在用户之前, catch住可怕的崩溃.</li>
</ul>
<h2 id="The-Two-ID-Problem"><a href="#The-Two-ID-Problem" class="headerlink" title="The Two ID Problem"></a><a href="http://tech.trello.com/sync-two-id-problem/" target="_blank" rel="external">The Two ID Problem</a></h2><p>还是Trello开发离线模式的系列文章, 本篇讲他们遇到的一个很tricky的问题: id问题.</p>
<p>在他们的项目里, 所有的models都有一个id, 用以和server通信, 以及定义model之间的关系.</p>
<p>如果是在离线模式下, 就不能依靠server来提供这个id, 客户端需要自己生成. </p>
<p>所以离线模式下有两种id, 一种是本地生成的, 一种是用来和server通信的. </p>
<p>他们想过几个办法, 比如在sync的时候将local的id转化为server id; 或者干脆存储一个id的Pair类, 但是都有难以维护或者性能缺陷等种种问题.</p>
<p>最后他们提出了一个叫<code>local-server barrier</code>的解决方案. 基本的原则就是, 在app中, 只使用local的id, 同server通信时, 使用server id. 好处: 首先保证了客户端代码的简洁, 只有网络通信层需要考虑到server id; 重构代码量小.</p>
<h2 id="Retaining-Dagger-components"><a href="#Retaining-Dagger-components" class="headerlink" title="Retaining Dagger components"></a><a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a></h2><p>如果你用dagger创建了component,  scope是Activity或者Fragment, 那么你可能遇到过这个问题: 旋转屏幕之后, 所有的依赖都重建了, 因为你创建了一个新的component.</p>
<p>如果你想要在configuration变化的时候不重建, 你就需要把component存储在一个全局的地方, 但是这样的话, 当你真的结束你的Activity和Fragment的时候, 你如何释放这些component呢?</p>
<p>你需要分层地(hierarchical)存储, <a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a>就是用来做分层存储东西的一个工具. </p>
<p>文中基本思想是把Application的component作为根节点, 然后Activity和Fragment的component作为树形结构的叶子节点逐级存储. Activity和Fragment的节点什么时候移除, 有一些判断条件和时机选择, 详见原文代码.</p>
<h2 id="The-Burden-of-Knowledge"><a href="#The-Burden-of-Knowledge" class="headerlink" title="The Burden of Knowledge"></a><a href="https://medium.com/@trionkidnapper/the-burden-of-knowledge-52cc73508081#.1nyndcoo6" target="_blank" rel="external">The Burden of Knowledge</a></h2><p>鼓励在team里分享知识.</p>
<h2 id="Realm-Migrations-Supercharged-with-Dagger"><a href="#Realm-Migrations-Supercharged-with-Dagger" class="headerlink" title="Realm Migrations Supercharged with Dagger"></a><a href="http://www.adavis.info/2017/03/realm-migrations-supercharged-with.html" target="_blank" rel="external">Realm Migrations Supercharged with Dagger</a></h2><p>使用Dagger2可以大幅度改善Realm中的数据迁移处理. 具体的做法是把每一步的迁移处理都放在一个统一接口的实现类里, 然后注入它们.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MigrationsModule</span> </span>&#123;</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion1Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version1Migration();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">2</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion2Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version2Migration();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以最后的迁移类看起来就是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Reusable</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Migration</span> <span class="keyword">implements</span> <span class="title">RealmMigration</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Migration(Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations) &#123;</div><div class="line">        <span class="keyword">this</span>.versionMigrations = versionMigrations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="keyword">final</span> DynamicRealm realm, <span class="keyword">long</span> oldVersion, <span class="keyword">long</span> newVersion)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) oldVersion; i &lt; newVersion; i++) &#123;</div><div class="line">            <span class="keyword">final</span> Provider&lt;VersionMigration&gt; provider = versionMigrations.get(i);</div><div class="line">            <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</div><div class="line">                VersionMigration versionMigration = provider.get();</div><div class="line">                versionMigration.migrate(realm, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的好处:</p>
<ul>
<li>1.以后再有数据库升级也不需要再改这个类了.</li>
<li>2.不需要逐个check每个版本号, 自动只从需要的版本号开始做迁移.</li>
<li>3.每个迁移模块都变成了可测试的单元.</li>
</ul>
<p>我觉得作者的这种处理结构很好, 不仅仅限于Realm数据库的迁移, 其他的数据库迁移也可以用类似的结构来处理.</p>
<h2 id="How-to-be-a-Mock-Star…"><a href="#How-to-be-a-Mock-Star…" class="headerlink" title="How to be a Mock-Star…"></a><a href="https://medium.com/fueled-android/how-to-be-a-mock-star-fc00714d8c2f#.aff30qzf6" target="_blank" rel="external">How to be a Mock-Star…</a></h2><p>介绍如何用<a href="http://site.mockito.org/" target="_blank" rel="external">mockito</a>来测试一个MVP的程序.</p>
<p>首先测试Presenter的部分, 这里Mock了数据源和各种错误响应.</p>
<p>测试Repository, 需要用到<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">MockWebServer</a>, 来模拟测试环境下的响应.</p>
<h2 id="Animating-Markers-with-MapOverlayLayout"><a href="#Animating-Markers-with-MapOverlayLayout" class="headerlink" title="Animating Markers with MapOverlayLayout"></a><a href="https://www.thedroidsonroids.com/blog/workcation-app-part-2-animating-markers-with-mapoverlaylayout/" target="_blank" rel="external">Animating Markers with MapOverlayLayout</a></h2><p>作者App的动画实现讨论第二发, 如何让地图上的markers带缩放和渐变动画 -&gt; 用<code>MapOverlayLayout</code>.</p>
<p>文中有详细的实现代码, 基本思路就是在这个<code>MapOverlayLayout</code>中保存一个View的列表, 然后在自定义View中实现每个marker在相应动作时的动画.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2" class="headerlink" title="What Unit Tests are Trying to Tell us About Activities Pt 2"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt-2/" target="_blank" rel="external">What Unit Tests are Trying to Tell us About Activities Pt 2</a></h2><p>以Activity/Fragment作为基本构建单元, 让程序难以测试, 本文举例说明了这一点.</p>
<h2 id="JUnit-5-DisplayName"><a href="#JUnit-5-DisplayName" class="headerlink" title="JUnit 5: DisplayName"></a><a href="https://blog.stylingandroid.com/junit-5-displayname/" target="_blank" rel="external">JUnit 5: DisplayName</a></h2><p>JUnit 5提供了<code>@DisplayName</code>, 这样测试报告里case显示的名字将是<code>@DisplayName</code>定义的字符串. </p>
<p>相比原先的方法名来说, 这个字符串是可以带空格的, 所以比之前的可读性增强了.</p>
<h2 id="Clearer-RxJava-intentions-with-Single-and-Completable"><a href="#Clearer-RxJava-intentions-with-Single-and-Completable" class="headerlink" title="Clearer RxJava intentions with Single and Completable"></a><a href="https://medium.com/@ValCanBuild/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8#.kpyh1sal0" target="_blank" rel="external">Clearer RxJava intentions with Single and Completable</a></h2><p>RxJava中我们经常用到的类就是<code>Observable</code>, 然后处理三个事件: <code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>.</p>
<p>但是有些时候我们并不需要关心全部这三个事件, 这时候我们就可以用<code>Single&lt;T&gt;</code>和<code>Completable</code>.</p>
<p><code>Single&lt;T&gt;</code>返回一个值或者一个error.<br>它和<code>Observable</code>之间可以互相转换: 用<code>toObservable()</code>和<code>singleOrError()</code>方法.</p>
<p><code>Completable</code>, 只有<code>onCompleted()</code>和<code>onError()</code>. 它不发射任何值, 可以在它之后用<code>andThen()</code>来添加另一个Observable, 进行后续其他操作.</p>
<p><code>Observable</code>不能直接转换为<code>Completable</code>, 因为不知道<code>Observable</code>到底会不会停止. 可以把<code>Single</code>转换为<code>Completable</code>, 用<code>toCompletable()</code>方法.</p>
<h2 id="Custom-FindBugs-detectors-in-Android"><a href="#Custom-FindBugs-detectors-in-Android" class="headerlink" title="Custom FindBugs detectors in Android"></a><a href="https://rhye.org/post/custom-android-findbugs/" target="_blank" rel="external">Custom FindBugs detectors in Android</a></h2><p>Android中有两种工具可以做进一步的编译期检查: <a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">Android Lint</a>和<a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">FindBugs</a>. </p>
<p>FindBugs是一个静态的分析工具. 本文的主要任务是讲解如何实现一个自定义的检测器来检测一种特定的错误.</p>
<p>作者的例子是<code>try-with-resources</code>模式的代码.<br>这是Java 7新加的模式<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Cursor c = db.query(...)) &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>try语句中声明的资源将会在这个block结束的时候自动close.</p>
<p>但是这个特性最低需要API 19.<br>所以为了兼容旧版本, 我们不得不使用finally来自己close:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.query(...);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    c.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有时候我们会忘记close导致了泄露, 所以需要实现一个自定义的findbugs检测器来检查这种错误. 具体实现步骤和讨论见原文.</p>
<h2 id="Static-Code-Analysis-Tools"><a href="#Static-Code-Analysis-Tools" class="headerlink" title="Static Code Analysis Tools"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-static-code-analysis-tools-b6dd83282921#.e7sc5x1if" target="_blank" rel="external">Static Code Analysis Tools</a></h2><p>Android中流行的静态代码检测工具:</p>
<ul>
<li>Lint</li>
<li>PMD</li>
<li>FindBugs</li>
</ul>
<p>本文介绍它们如何配置和使用.</p>
<h2 id="Sync-Failure-Handling"><a href="#Sync-Failure-Handling" class="headerlink" title="Sync Failure Handling"></a><a href="http://tech.trello.com/sync-failure-handling/" target="_blank" rel="external">Sync Failure Handling</a></h2><p>Trello离线模式文章, sync失败的处理.</p>
<p>在发请求的时候可能会发生各种各样的错误, 分为暂时性的和永久性的两类.<br>对于永久性的错误, 我们可以直接放弃delta; 但是对于暂时性的错误, 我们需要重试. 这里就需要考虑重试的时间和重试的次数.</p>
<p>另外还有一种情况是客户端发了请求, server也收到了, 但是客户端在收响应的时候失败了, 所以客户端可能会找机会重新发请求, 为了保证幂等性, 我们的每一个请求都有一个唯一的id, 如果server发现同样的id, 只处理第一个.</p>
<p>对于多个用户编辑的冲突处理, 当前用的是简单的以后者为准的方式.</p>
<p>撤销本地不合理数据, 以server数据为准, 更新本地数据, 这就需要在sync开始的时候先讲本地改动上传. </p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="LottieFiles"><a href="#LottieFiles" class="headerlink" title="LottieFiles"></a><a href="http://www.lottiefiles.com/" target="_blank" rel="external">LottieFiles</a></h2><p>免费的Lottie动画.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="DiscreteScrollView"><a href="#DiscreteScrollView" class="headerlink" title="DiscreteScrollView"></a><a href="https://github.com/yarolegovich/DiscreteScrollView" target="_blank" rel="external">DiscreteScrollView</a></h2><p>可滚动的列表, 中间的项目放大. (基于RecyclerView, 长得有点像ViewPager.)</p>
<h2 id="SimpleRatingBar"><a href="#SimpleRatingBar" class="headerlink" title="SimpleRatingBar"></a><a href="https://github.com/borjabravo10/SimpleRatingBar" target="_blank" rel="external">SimpleRatingBar</a></h2><p>五星评价View, 用kotlin实现的.</p>
<h2 id="InstaCropper"><a href="#InstaCropper" class="headerlink" title="InstaCropper"></a><a href="https://github.com/yasharpm/InstaCropper" target="_blank" rel="external">InstaCropper</a></h2><p>剪切图像的View, 类似于Instagram的crop.</p>
<h2 id="GuildWars2-APIViewer"><a href="#GuildWars2-APIViewer" class="headerlink" title="GuildWars2_APIViewer"></a><a href="https://github.com/huhx0015/GuildWars2_APIViewer" target="_blank" rel="external">GuildWars2_APIViewer</a></h2><p>一个app, 用来查看Guild Wars 2的API响应.<br>用了Dagger2, Retrofit2, RxJava2, MVVM架构.</p>
<h2 id="here-be-dragons"><a href="#here-be-dragons" class="headerlink" title="here-be-dragons"></a><a href="https://github.com/anupcowkur/here-be-dragons" target="_blank" rel="external">here-be-dragons</a></h2><p>一个Intellij/Android Studio插件, 你可以在一个方法上标记<code>@SideEffect</code>, 之后你调用这个方法的代码行左边会显示出一个龙的图标.</p>
<h2 id="RoboGif"><a href="#RoboGif" class="headerlink" title="RoboGif"></a><a href="https://github.com/izacus/RoboGif" target="_blank" rel="external">RoboGif</a></h2><p>一个python的小工具, 可以把Android设备上的录屏生成一个GIF图.</p>
<h2 id="service-tree"><a href="#service-tree" class="headerlink" title="service-tree"></a><a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a></h2><p>一个存储service的树形结构. (本期文章<a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a>有讲.)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-248&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-248&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #248&quot;&gt;&lt;/a&gt;Android Weekly Issue #248&lt;/h1&gt;&lt;p&gt;March 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-248&quot;&gt;Android Weekly Issue #248&lt;/a&gt;.&lt;br&gt;本期内容包括: 为什么有时候应该让你的应用崩溃(而不是一味保护); Trello离线模式实现中两个id的问题; 如何让Dagger的component按照scope保存, 在屏幕旋转时不重建; 用Dagger构建Realm的数据库迁移逻辑;&lt;br&gt;利用各种mock工具写单元测试; Map上markers的动画实现; JUnit5中@DisplayName的使用; RxJava中的Single和Completable使用; 举例说明如何给FindBugs写自定义的探测器; Android中静态代码分析工具的使用; Trello离线实现中sync失败情况的处理.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Dagger" scheme="http://mengdd.github.io/tags/Dagger/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/tags/Realm/"/>
    
      <category term="Crash" scheme="http://mengdd.github.io/tags/Crash/"/>
    
      <category term="MockWebServer" scheme="http://mengdd.github.io/tags/MockWebServer/"/>
    
      <category term="Google Map" scheme="http://mengdd.github.io/tags/Google-Map/"/>
    
      <category term="FindBugs" scheme="http://mengdd.github.io/tags/FindBugs/"/>
    
      <category term="Lint" scheme="http://mengdd.github.io/tags/Lint/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 247</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/</id>
    <published>2017-03-08T06:49:43.000Z</published>
    <updated>2017-03-08T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-247"><a href="#Android-Weekly-Issue-247" class="headerlink" title="Android Weekly Issue #247"></a>Android Weekly Issue #247</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-247" target="_blank" rel="external">Android Weekly Issue #247</a>.</p>
<p>本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;<br>RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Offline-support-“Try-again-later”-no-more"><a href="#Offline-support-“Try-again-later”-no-more" class="headerlink" title="Offline support: “Try again, later”, no more"></a><a href="https://medium.com/@yonatanvlevin/offline-support-try-again-later-no-more-afc33eba79dc#.p90haop40" target="_blank" rel="external">Offline support: “Try again, later”, no more</a></h2><p>作者他们的应用很好地处理了离线模式, 他们的基本原则是, 应用中不需要显示任何的loading控件.</p>
<p>在离线装填下, 在用户看来仍是可以提交请求的, 只不过出现了一个sync的小图标, 一旦当用户再次连上网络, 他的请求就会被发送出去.</p>
<p>然后作者讲了他们的程序设计:<br>首先是MVP结构, 使用了Content Provider包装的SQLite数据库. (此处列举了使用Content Provider的若干优点).</p>
<p>后台的同步工作, 他们选择了<code>GCMNetworkManager</code>.</p>
<p>基本流程是这样: 但用户提交请求, 首先存储在数据库中, 状态为pending, 然后后台service发送请求, 如果成功, 则更新数据库中的状态为synced; 如果失败, 则用<code>GcmNetworkManager</code>schedule一个task, 在网络连接恢复时再做一次尝试, 成功和失败的处理同上一步.</p>
<h2 id="Story-Code"><a href="#Story-Code" class="headerlink" title="Story Code"></a><a href="https://publicobject.com/2017/02/06/story-code/" target="_blank" rel="external">Story Code</a></h2><p>作者讲了一种方法, 以一种叙事的方式来写一个测试故事, 然后把它分成很多个小的测试cases. 这样可以用来驱动API的设计和其实现等.</p>
<h2 id="Testing-RxJava2"><a href="#Testing-RxJava2" class="headerlink" title="Testing RxJava2"></a><a href="https://www.infoq.com/articles/Testing-RxJava2" target="_blank" rel="external">Testing RxJava2</a></h2><p>本文介绍RxJava2中内置的关于测试的支持.</p>
<p>测试一个<code>Observable</code>可以用<code>TestObserver</code>; 测试<code>Flowable</code>可以用<code>TestSubscriber</code>.</p>
<p>如何测试在不同线程上的工作?<br>有几种选择:</p>
<ul>
<li>把Observable变为blocking的. -&gt; <code>blockingIterable()</code>, 缺点: 测试慢.</li>
<li>强制测试等待, 直到某个条件达成. -&gt; <code>awaitTerminalEvent()</code>. 此处还推荐一个库: <a href="https://github.com/awaitility/awaitility" target="_blank" rel="external">awaitility</a>.</li>
<li>把schedular换为一个immediate的. <code>RxJavaPlugins.setComputationSchedulerHandler(scheduler -&gt; Schedulers.trampoline());</code>. 需要最后reset一下, 可以用JUnit的TestRule来进行简化.</li>
</ul>
<p>用<code>TestScheduler</code>可以操纵时间, 进行白盒测试.<br>利用它在测试中可以精确控制时间过去了多少, 我们可以测试在中间的时间点的状态.<br>值得注意的是它控制的并不是真实的时间, 真实的时间还是立即就度过了的, 所以不会降低测试的速度.</p>
<p>我们也可以利用<code>TestRule</code>和<code>RxJavaPlugins</code>来把这个scheduler设置为测试时候要切换成的scheduler.</p>
<h2 id="Syncing-Changes"><a href="#Syncing-Changes" class="headerlink" title="Syncing Changes"></a><a href="http://tech.trello.com/syncing-changes/" target="_blank" rel="external">Syncing Changes</a></h2><p>Trello的离线模式实现文章系列之二. 基本的原则是在离线的时候把改动(deltas)存在数据库里, 之后有机会再同步给server.</p>
<p>本文介绍了他们如何计算delta和将它们按时间上传到服务器.</p>
<h2 id="Reactive-Apps-With-MVI-Part-4"><a href="#Reactive-Apps-With-MVI-Part-4" class="headerlink" title="Reactive Apps With MVI - Part 4"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-4" target="_blank" rel="external">Reactive Apps With MVI - Part 4</a></h2><p>MVI系列文章的第四篇. 本篇讲如何构建独立的UI单元.</p>
<p>作者认为Presenter之间的Parent-Child关系是一种code smell, 因为这样引入了一种强耦合的关系, 不好读, 不好维护.</p>
<p>你也许要问那Presenter之间如何通信呢? 答案是, 它们根本就不需要通信, 它们只需要更新和观测同一个Model(可以说业务逻辑), 让底层来通知它们事件的发生就可以了.</p>
<h2 id="Resources-for-Learning-how-to-Test-Android-Apps"><a href="#Resources-for-Learning-how-to-Test-Android-Apps" class="headerlink" title="Resources for Learning how to Test Android Apps"></a><a href="https://www.philosophicalhacker.com/post/some-resources-for-learning-how-to-test-android-apps/" target="_blank" rel="external">Resources for Learning how to Test Android Apps</a></h2><p>关于Android测试的相关资源分享.</p>
<h2 id="Unboxing-the-FlexboxLayout"><a href="#Unboxing-the-FlexboxLayout" class="headerlink" title="Unboxing the FlexboxLayout"></a><a href="https://blog.devcenter.co/unboxing-the-flexboxlayout-a7cfd125f023#.ulop7q1jz" target="_blank" rel="external">Unboxing the FlexboxLayout</a></h2><p>作者想实现一个动态关键字的流式布局, 可以根据parent的宽度自动换行.</p>
<p>他想了几种方法, 都不太合适, 所以最后选择了<code>FlexboxLayout</code>.</p>
<p>作者尝试了单独使用<code>FlexboxLayout</code>和 将<code>FlexboxLayoutManager()</code>设置为<code>RecyclerView</code>的Layout Manager两种办法来实现他想要的效果.</p>
<h2 id="Configuring-Android-Project-Version-Name-amp-Code"><a href="#Configuring-Android-Project-Version-Name-amp-Code" class="headerlink" title="Configuring Android Project - Version Name &amp; Code"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-version-name-code-b168952f3323#.v20pogayh" target="_blank" rel="external">Configuring Android Project - Version Name &amp; Code</a></h2><p>首先介绍了<a href="https://git-scm.com/docs/git-describe" target="_blank" rel="external">git-describe</a>命令.</p>
<p><code>git describe -tags</code>可以输出当前最近的tag和它之后有几个提交, 还有最新提交的hash.</p>
<p>作者建议使用这个库: <a href="https://github.com/ajoberstar/grgit" target="_blank" rel="external">grgit</a>, 写一个script-git-version.gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;org.ajoberstar:grgit:1.5.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import org.ajoberstar.grgit.Grgit</div><div class="line"></div><div class="line">ext &#123;</div><div class="line">    git = Grgit.open(currentDir: projectDir)</div><div class="line">    gitVersionName = git.describe()</div><div class="line">    gitVersionCode = git.tag.list().size()</div><div class="line">    gitVersionCodeTime = git.head().time</div><div class="line">&#125;</div><div class="line"></div><div class="line">task printVersion() &#123;</div><div class="line">    println(&quot;Version Name: $gitVersionName&quot;)</div><div class="line">    println(&quot;Version Code: $gitVersionCode&quot;)</div><div class="line">    println(&quot;Version Code Time: $gitVersionCodeTime&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在主文件中apply这个文件.</p>
<p>执行printVersion task后会输出类似这样的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Version Name: 1.0-2-gdca226a</div><div class="line">Version Code: 2</div><div class="line">Version Code Time: 1484407970</div></pre></td></tr></table></figure>
<p>这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">    dev &#123;</div><div class="line">        versionCode gitVersionCodeTime</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    prod &#123;</div><div class="line">        versionCode gitVersionCode</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就自动生成了版本号和版本名.<br>你还可以进一步设计, 在版本名中包括分支名, 时间戳之类的.</p>
<h2 id="Workcation-App-Part-1-Fragment-custom-transition"><a href="#Workcation-App-Part-1-Fragment-custom-transition" class="headerlink" title="Workcation App - Part 1. Fragment custom transition"></a><a href="https://www.thedroidsonroids.com/blog/android/workcation-app-part-1-fragments-custom-transition/" target="_blank" rel="external">Workcation App - Part 1. Fragment custom transition</a></h2><p>作者的系列文章, 讨论他的项目中的动画的实现.<br>本文是第一篇, 介绍进入map的转场动画.</p>
<p>首先, 在map加载完毕后, 存一个截图放在缓存里, 然后用一个自定义的Transition来做缩放和渐变的动画, 最后把它设置为fragment的转场动画.</p>
<h2 id="Model-View-Presenter-Android-guidelines"><a href="#Model-View-Presenter-Android-guidelines" class="headerlink" title="Model-View-Presenter: Android guidelines"></a><a href="https://medium.com/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf#.s1d1l3dkt" target="_blank" rel="external">Model-View-Presenter: Android guidelines</a></h2><p>MVP实现的一些guidelines和最佳实践.</p>
<ul>
<li>1.View要无脑和被动.</li>
<li>2.Presenter要和framework无关, 不依赖任何Android的类.</li>
<li>3.写一个协议描述View和Presenter的交互.</li>
<li>4.定义命名规则来区分职责.</li>
<li>5.不要在Presenter里创建生命周期的回调方法.</li>
<li>6.Presenter和View是一对一的关系. 可以定义<code>attach()</code>和<code>detach()</code>或<code>start()</code>和<code>stop()</code>来关联和解除关联.</li>
<li>7.不要在Presenter里用Bundle保存状态. 因为不能包含Android的类.</li>
<li>8.不要保存Presenter. 因为Presenter并不是一个数据类.</li>
<li>9.在Model中提供cache来恢复View的状态.</li>
</ul>
<h2 id="5-Not-So-Obvious-Things-About-RxJava"><a href="#5-Not-So-Obvious-Things-About-RxJava" class="headerlink" title="5 Not So Obvious Things About RxJava"></a><a href="https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc#.dl9lo390z" target="_blank" rel="external">5 Not So Obvious Things About RxJava</a></h2><p>RxJava使用学习中的五点(RxJava1.2.6).</p>
<ul>
<li>什么时候用<code>map()</code>或者<code>flatMap()</code>.</li>
<li>不使用<code>Observable.create()</code>来创建observables. 使用其他更方便的方法, 比如<code>syncOnSubscribe</code>, <code>fromCallable</code>, <code>fromEmitter</code>.</li>
<li>如何处理Backpressure.</li>
<li>如和能让流不因为errors而停下来.</li>
<li>如何分享Observable到多个订阅者 -&gt; <code>share()</code>或<code>publish()</code>.</li>
</ul>
<h2 id="Simplify-Concurrency-with-Reactive-Modelling-on-Android"><a href="#Simplify-Concurrency-with-Reactive-Modelling-on-Android" class="headerlink" title="Simplify Concurrency with Reactive Modelling on Android"></a><a href="https://www.toptal.com/android/simplify-concurrency-reactive-modelling-android" target="_blank" rel="external">Simplify Concurrency with Reactive Modelling on Android</a></h2><p>用RxJava来处理Android上的并发和异步.<br>作者的文章中举了很详尽的各种例子.</p>
<h2 id="JUnit-5-Getting-Started"><a href="#JUnit-5-Getting-Started" class="headerlink" title="JUnit 5: Getting Started"></a><a href="https://blog.stylingandroid.com/junit-5-getting-started/" target="_blank" rel="external">JUnit 5: Getting Started</a></h2><p>使用JUnit 5做测试.<br>本文讲了一些在Android上setup可能会遇到的问题及怎么解决.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FastHub"><a href="#FastHub" class="headerlink" title="FastHub"></a><a href="https://github.com/k0shk0sh/FastHub" target="_blank" rel="external">FastHub</a></h2><p>一个Android的Github客户端.</p>
<h2 id="gradle-android-javafmt-plugin"><a href="#gradle-android-javafmt-plugin" class="headerlink" title="gradle-android-javafmt-plugin"></a><a href="https://github.com/f2prateek/gradle-android-javafmt-plugin" target="_blank" rel="external">gradle-android-javafmt-plugin</a></h2><p>一个gradle plugin, 自动format代码.</p>
<h2 id="HtmlCompat"><a href="#HtmlCompat" class="headerlink" title="HtmlCompat"></a><a href="https://github.com/Pixplicity/HtmlCompat" target="_blank" rel="external">HtmlCompat</a></h2><p>Android中Html类的兼容库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-247&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-247&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #247&quot;&gt;&lt;/a&gt;Android Weekly Issue #247&lt;/h1&gt;&lt;p&gt;March 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-247&quot;&gt;Android Weekly Issue #247&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;&lt;br&gt;RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="Offline" scheme="http://mengdd.github.io/tags/Offline/"/>
    
      <category term="Version Name" scheme="http://mengdd.github.io/tags/Version-Name/"/>
    
      <category term="Git" scheme="http://mengdd.github.io/tags/Git/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 246</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/</id>
    <published>2017-03-01T09:45:13.000Z</published>
    <updated>2017-03-01T09:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-246"><a href="#Android-Weekly-Issue-246" class="headerlink" title="Android Weekly Issue #246"></a>Android Weekly Issue #246</h1><p>February 26th, 2017<br><a href="http://androidweekly.net/issues/issue-246" target="_blank" rel="external">Android Weekly Issue #246</a><br>本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;<br>In-App Billing的实现; 如何用组合而非继承的方式来组织应用.</p>
<p>代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Shared-Element-Transitions-with-RecyclerView"><a href="#Shared-Element-Transitions-with-RecyclerView" class="headerlink" title="Shared Element Transitions with RecyclerView"></a><a href="http://mikescamell.com/shared-element-transitions-part-4-recyclerview/" target="_blank" rel="external">Shared Element Transitions with RecyclerView</a></h2><p>作者介绍了如何在RecyclerView中实现shared element动画.</p>
<h2 id="Sharing-files-through-Intents-part-2"><a href="#Sharing-files-through-Intents-part-2" class="headerlink" title="Sharing files through Intents (part 2)"></a><a href="https://medium.com/@quiro91/sharing-files-through-intents-part-2-fixing-the-permissions-before-lollipop-ceb9bb0eec3a#.ci4hqoauq" target="_blank" rel="external">Sharing files through Intents (part 2)</a></h2><p>之前介绍过因为Android 7 Nougat对文件权限的限制, 不能再依靠Intent来发送<code>file://uri</code>数据了, 应该用<code>FileProvider</code>. 但是你采用了这些新方法之后, 在一些Android的旧版本上有可能会遇到问题.</p>
<p>你可能遇到这种异常: <code>java.lang.SecurityException: Permission Denial</code>.</p>
<p>在API 16及以上, 系统有一个方法<code>migrateExtraStreamToClipData()</code>会根据你的Intent的action帮你迁移数据到ClipData, 并自动帮你加上权限. 见代码: <a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/content/Intent.java#9037" target="_blank" rel="external">Intent</a>. 但是之前的版本却没有.</p>
<p>所以解决办法是在原本的代码中加上这两句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">    takePictureIntent.setClipData(ClipData.newRawUri(<span class="string">""</span>, photoURI));</div><div class="line">    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION|Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以要包括LOLLIPOP是因为<code>migrateExtraStreamToClipData()</code>这个方法是在preview版本之后才加上的, 所以不能保证所有的LOLLIPOP的设备都有这个方法.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1" class="headerlink" title="What Unit Tests are Trying to Tell us about Activities: Pt. 1"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt1/" target="_blank" rel="external">What Unit Tests are Trying to Tell us about Activities: Pt. 1</a></h2><p>“android-centric”的构架是指用Activity/Fragment作为屏幕基本构架单元的程序架构. 作者的系列文章要讨论为什么这种架构是对测试不友好的.</p>
<h2 id="Build-flexible-layouts-with-FlexboxLayout"><a href="#Build-flexible-layouts-with-FlexboxLayout" class="headerlink" title="Build flexible layouts with FlexboxLayout"></a><a href="https://android-developers.googleblog.com/2017/02/build-flexible-layouts-with.html" target="_blank" rel="external">Build flexible layouts with FlexboxLayout</a></h2><p>Google去年开源了<a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a>, 目的是将CSS中的<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">Flexible Layout module</a>引入到Android中来. 本文介绍了FlexboxLayout十分有用的几种情况, 附有demos.</p>
<h2 id="Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally"><a href="#Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally" class="headerlink" title="Making RxJava code tidier with doOnSubscribe and doFinally"></a><a href="https://medium.com/@ValCanBuild/making-rxjava-code-tidier-with-doonsubscribe-and-dofinally-3748f223d32d#.58wup7kxn" target="_blank" rel="external">Making RxJava code tidier with doOnSubscribe and doFinally</a></h2><p>使用<code>doOnSubscribe()</code>和<code>doFinally()</code>(RxJava 2)可以让RxJava的代码更加简洁.</p>
<ul>
<li><p><code>doOnSubscribe()</code>中的代码在subscribe的时候被调用.</p>
</li>
<li><p><code>doFinally()</code>在<code>Observable</code>调用<code>onError()</code>或<code>onCompleted()</code>之后, 或者流被下游放弃的时候调用.</p>
</li>
</ul>
<p>作者举的例子是用它们来show loading和hide loading, 这样它们也作为流的一部分, 而且subscriber可以只处理其他相关逻辑.</p>
<h2 id="Implementing-In-App-Billing-in-Android"><a href="#Implementing-In-App-Billing-in-Android" class="headerlink" title="Implementing In-App Billing in Android"></a><a href="https://hackernoon.com/implementing-in-app-billing-in-android-4896232c7d6b?gi=575af60d0286#.scggjiasz" target="_blank" rel="external">Implementing In-App Billing in Android</a></h2><p>关于Android In-App Billing的实现.</p>
<p>首先你会搜到<a href="https://developer.android.com/google/play/billing/index.html" target="_blank" rel="external">官方文档</a>.</p>
<p>作者在本文中介绍了其他的一些可选方案.</p>
<h2 id="Composite-Views-in-Android-Composition-over-Inheritance"><a href="#Composite-Views-in-Android-Composition-over-Inheritance" class="headerlink" title="Composite Views in Android: Composition over Inheritance"></a><a href="https://medium.com/@manuelvicnt/composite-views-in-android-composition-over-inheritance-4a7114609560#.n55x4611x" target="_blank" rel="external">Composite Views in Android: Composition over Inheritance</a></h2><p>作者介绍了这个库: <a href="https://github.com/passsy/CompositeAndroid" target="_blank" rel="external">CompositeAndroid</a>, 它解决了一个什么问题呢? </p>
<p>在App中, 如果多个Activity或者多个Fragment有一些共同的功能, 那么我们很可能就会创建一个基类Activity或者基类Fragment, 然后继承它. 当一些功能只被一些类共享时, 我们可能会继续不断创建基类, 产生一个无法维护的继承树.</p>
<p>解决的办法就是使用这个库, Activity只需要继承<code>CompositeActivity</code>, 所有共有的功能都会被当做插件加进来.<br>这样我们遵守了一个原则: <code>组合优于继承</code>.</p>
<p>但是这个库也有一些缺点: 它还在alpha阶段; 如果你使用了一些不常用的生命周期, 可能会有问题; 它是基于support library的, 所以如果这个库不更新support库的版本, 你也无法更新.</p>
<p>所以作者提出了一个简单的解决方案, 不使用CompositeAndroid. 文中举例展示了他的实现.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ShapeShifter"><a href="#ShapeShifter" class="headerlink" title="ShapeShifter"></a><a href="https://github.com/alexjlockwood/ShapeShifter" target="_blank" rel="external">ShapeShifter</a></h2><p>创建路径变形动画的一个web-app, 支持导出到<code>AnimatedVectorDrawable</code>.</p>
<h2 id="Shuttle"><a href="#Shuttle" class="headerlink" title="Shuttle"></a><a href="https://github.com/timusus/Shuttle" target="_blank" rel="external">Shuttle</a></h2><p>一个开源的本地音乐播放器.</p>
<h2 id="cortado"><a href="#cortado" class="headerlink" title="cortado"></a><a href="https://github.com/blipinsk/cortado" target="_blank" rel="external">cortado</a></h2><p>在Espresso上提供了一个抽象层, 使用更流畅.</p>
<h2 id="fragment-navigation-2-0"><a href="#fragment-navigation-2-0" class="headerlink" title="fragment-navigation-2.0"></a><a href="https://github.com/gyorgygabor/fragment-navigation-2.0" target="_blank" rel="external">fragment-navigation-2.0</a></h2><p>Fragment导航库.</p>
<h2 id="flexbox-layout"><a href="#flexbox-layout" class="headerlink" title="flexbox-layout"></a><a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a></h2><p>Flexbox for Android.</p>
<h2 id="kotlin-coroutines-retrofit"><a href="#kotlin-coroutines-retrofit" class="headerlink" title="kotlin-coroutines-retrofit"></a><a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="external">kotlin-coroutines-retrofit</a></h2><p>This is small library that provides Kotlin Coroutines suspending extension Call.await() for Retrofit 2.</p>
<h2 id="StatefulLayout"><a href="#StatefulLayout" class="headerlink" title="StatefulLayout"></a><a href="https://github.com/gturedi/StatefulLayout" target="_blank" rel="external">StatefulLayout</a></h2><p>一个内置包含loading, 错误, 空状态的布局.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-246&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-246&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #246&quot;&gt;&lt;/a&gt;Android Weekly Issue #246&lt;/h1&gt;&lt;p&gt;February 26th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-246&quot;&gt;Android Weekly Issue #246&lt;/a&gt;&lt;br&gt;本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;&lt;br&gt;In-App Billing的实现; 如何用组合而非继承的方式来组织应用.&lt;/p&gt;
&lt;p&gt;代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="Shared Element" scheme="http://mengdd.github.io/tags/Shared-Element/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="In-App Billing" scheme="http://mengdd.github.io/tags/In-App-Billing/"/>
    
      <category term="Music Player" scheme="http://mengdd.github.io/tags/Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Realm数据库使用指南</title>
    <link href="http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/"/>
    <id>http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/</id>
    <published>2017-02-27T09:32:23.000Z</published>
    <updated>2017-02-28T01:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Realm数据库使用指南"><a href="#Android-Realm数据库使用指南" class="headerlink" title="Android Realm数据库使用指南"></a>Android Realm数据库使用指南</h1><p>Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. </p>
<p>本文面向Android开发, 所以只讨论Java实现.<br>目前Realm Java的最新版本是2.3.1.</p>
<p>官方文档在此: <a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">realm java doc</a>, 花一个下午就可以基本过一遍, 之后随时查用. </p>
<p>我写了一个小程序<a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a>, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.</p>
<p>本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.</p>
<a id="more"></a>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>在项目的根build.gradle的文件中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;io.realm:realm-gradle-plugin:2.3.0&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在app的build.gradle文件中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;realm-android&apos;</div></pre></td></tr></table></figure></p>
<p>Done.</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Model类只要继承<code>RealmObject</code>即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">RealmObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String          name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             age;</div><div class="line"></div><div class="line">    <span class="meta">@Ignore</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             sessionId;</div><div class="line"></div><div class="line">    <span class="comment">// Standard getters &amp; setters generated by your IDE…</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getSessionId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sessionId; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setSessionId</span><span class="params">(<span class="keyword">int</span> sessionId)</span> </span>&#123; <span class="keyword">this</span>.sessionId = sessionId; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>Model类中可以包含的字段类型包括基本数据类型(及它们的装箱类型)和Date类, 另外也可以包含<code>RealmObject</code>的子类或者是<code>RealmList&lt;? extends RealmObject&gt;</code>.</p>
<h3 id="字段性质"><a href="#字段性质" class="headerlink" title="字段性质"></a>字段性质</h3><p>在字段上加注解可以定义字段的性质:</p>
<p><code>@Required</code>表明字段非null.<br>原生类型和<code>RealmList</code>类型默认是非null的.<br><code>RealmObject</code>字段永远是可以为null的.</p>
<p><code>@Ignore</code>表示字段不会被存储.</p>
<p><code>@Index</code>加索引.</p>
<p><code>@PrimaryKey</code>加主键, 主键只能有一个, 主键默认加索引.</p>
<p>但是注意主键默认没有加<code>@Required</code>, 如果主键要求非null, 需要显式添加<code>@Required</code>.</p>
<h3 id="主键使用"><a href="#主键使用" class="headerlink" title="主键使用"></a>主键使用</h3><p>有主键才能使用<code>copyToRealmOrUpdate()</code>这个方法.<br>主键类型必须是String或者整型(byte, short, int, long)或者它们的装箱类型(Byte, Short, Integer, Long).</p>
<p>有主键的对象创建的时候不能使用<code>createObject(Class&lt;E&gt; clazz)</code>方法, 而应该使用<code>createObject(Class&lt;E&gt; clazz, Object primaryKeyValue)</code>附上主键.</p>
<p>或者用<br><code>copyToRealm(obj)</code>或<code>copyToRealmOrUpdate(obj)</code>, 前者遇到主键冲突时会崩溃, 后者遇到主键冲突会更新已有对象.</p>
<h3 id="自动更新的对象"><a href="#自动更新的对象" class="headerlink" title="自动更新的对象"></a>自动更新的对象</h3><p>Realm中的数据对象是自动更新(Auto-Updating)的, 对象一旦被查询出来, 后续发生的任何数据改变也会立即反映在结果中, 不需要刷新对象.</p>
<p>这是一个非常有用的特性, 结合数据变化的通知可以很方便地刷新UI.</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Realm model对象间可以很方便地建立关系.<br>你可以在Model中存储另一个对象的引用, 建立多对一的关系; 也可以存储一组对象<code>RealmList&lt;T&gt;</code>, 建立一对多或多对多的关系.</p>
<p><code>RealmList&lt;T&gt;</code>的getter永远也不会返回null, 它只会返回一个为空的list.<br>把这个字段设置为null可以清空这个list.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Realm在使用之前需要调用初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Realm.init(context);</div></pre></td></tr></table></figure></p>
<p>建议把它放在Application的<code>onCreate()</code>里.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类: <code>RealmConfiguration</code>定义了Realm的创建配置.<br>最基本的配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div></pre></td></tr></table></figure></p>
<p>它会创建一个叫<code>default.realm</code>的文件, 放在<code>Context.getFilesDir()</code>的目录下.</p>
<p>如果我们想自定义一个配置, 可以这样写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The RealmConfiguration is created using the builder pattern.</span></div><div class="line"><span class="comment">// The Realm file will be located in Context.getFilesDir() with name "myrealm.realm"</span></div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">  .name(<span class="string">"myrealm.realm"</span>)</div><div class="line">  .encryptionKey(getKey())</div><div class="line">  .schemaVersion(<span class="number">42</span>)</div><div class="line">  .modules(<span class="keyword">new</span> MySchemaModule())</div><div class="line">  .migration(<span class="keyword">new</span> MyMigration())</div><div class="line">  .build();</div><div class="line"><span class="comment">// Use the config</span></div><div class="line">Realm realm = Realm.getInstance(config);</div></pre></td></tr></table></figure></p>
<p>所以我们是可以有多个配置, 访问多个Realm实例的.</p>
<p>我们可以把配置设置为默认配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Realm.init(<span class="keyword">this</span>);</div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div><div class="line">Realm.setDefaultConfiguration(config);</div></pre></td></tr></table></figure></p>
<p>之后用<code>Realm.getDefaultInstance()</code>取到的就是这个默认配置对应的实例.</p>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>迁移的策略是通过config指定的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">    .schemaVersion(<span class="number">2</span>) <span class="comment">// Must be bumped when the schema changes</span></div><div class="line">    .migration(<span class="keyword">new</span> MyMigration()) <span class="comment">// Migration to run instead of throwing an exception</span></div><div class="line">    .build()</div></pre></td></tr></table></figure></p>
<p>其中<code>MyMigration</code>实现了<code>RealmMigration</code>接口, 在<code>migrate()</code>方法中根据新旧版本号进行一步一步地升级.</p>
<p>具体例子见<a href="https://github.com/realm/realm-java/blob/master/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java" target="_blank" rel="external">Migration</a>.</p>
<p>开发的时候为了方便我用的是<code>.deleteRealmIfMigrationNeeded()</code>, 这样在需要数据库迁移的时候直接就删了数据重新开始了.</p>
<h2 id="关于Realm的close"><a href="#关于Realm的close" class="headerlink" title="关于Realm的close()"></a>关于Realm的close()</h2><p>一个打开的Realm实例会持有一些资源, 有一些是Java不能自动管理的, 所以就需要打开实例的代码负责在不需要的时候将其关闭.</p>
<p>Realm的instance是引用计数的(reference counted cache), 在同一个线程中获取后续实例是免费的, 但是底层的资源只有当所有实例被释放了之后才能释放. 也即你调用了多少次<code>getInstance()</code>, 就需要调用相应次数的<code>close()</code>方法.</p>
<p>比较建议的方法是在Activity或Fragment的生命周期中处理Realm实例的开启和释放:</p>
<ul>
<li>在Activity的<code>onCreate()</code>中<code>getInstance()</code>, <code>onDestroy()</code>中<code>close()</code>.</li>
<li>在Fragment的<code>onCreateView()</code>中<code>getInstance()</code>, <code>onDestroyView()</code>中<code>close()</code>.</li>
</ul>
<p>如果多个Fragment相关的都是同一个数据库实例, 那么在Activity中处理更好一些.</p>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>写操作一般的流程是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Obtain a Realm instance</span></div><div class="line">Realm realm = Realm.getDefaultInstance();</div><div class="line"></div><div class="line">realm.beginTransaction();</div><div class="line"></div><div class="line"><span class="comment">//... add or update objects here ...</span></div><div class="line"></div><div class="line">realm.commitTransaction();</div></pre></td></tr></table></figure></p>
<p>这里创建对象可以用<code>createObject()</code>方法或者<code>copyToRealm()</code>方法.<br>前者是先创建再set值, 后者是先new对象再更新数据库.</p>
<p>如果不想自己处理<code>beginTransaction()</code>, <code>cancelTransaction()</code>和<code>commitTransaction()</code>, 可以直接调用<code>realm.executeTransaction()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">realm.executeTransaction(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">        User user = realm.createObject(User.class);</div><div class="line">        user.setName(<span class="string">"John"</span>);</div><div class="line">        user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>因为transactions之间是互相阻塞的.<br>异步执行可以用这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">realm.executeTransactionAsync(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm bgRealm)</span> </span>&#123;</div><div class="line">                User user = bgRealm.createObject(User.class);</div><div class="line">                user.setName(<span class="string">"John"</span>);</div><div class="line">                user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnSuccess() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction was a success.</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnError() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction failed and was automatically canceled.</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这两个回调是Optional的, 它们只能在有Looper的线程调用.</p>
<p>注意: 这个方法的返回值对象可以用于在Activity/Fragment生命周期结束的时候取消未完的操作.</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>所有的写操作都要放在transaction中进行, 如上, 不同的操作只是其中具体方法不同.</p>
<p>删除操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> RealmResults&lt;User&gt; users = getUsers();</div><div class="line"><span class="comment">// method 1:</span></div><div class="line">users.get(<span class="number">0</span>).deleteFromRealm();</div><div class="line"><span class="comment">// method 2:</span></div><div class="line">users.deleteFromRealm(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// delete all</span></div><div class="line">users.deleteAllFromRealm();</div></pre></td></tr></table></figure></p>
<p>更新操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.copyToRealmOrUpdate(obj);</div></pre></td></tr></table></figure></p>
<p>注意: 这个方法需要Model有主键, 会更新obj的主键对应的对象, 如果不存在则新建对象.</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询可以流式地写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Or alternatively do the same all at once (the "Fluent interface"):</span></div><div class="line">RealmResults&lt;User&gt; result2 = realm.where(User.class)</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"John"</span>)</div><div class="line">                                  .or()</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"Peter"</span>)</div><div class="line">                                  .findAll();</div></pre></td></tr></table></figure></p>
<p>查询条件默认是and的关系, or则需要显式指定.</p>
<p>这个<code>RealmResults</code>是继承Java的<code>AbstractList</code>的, 是有序的集合, 可以通过索引访问.<br><code>RealmResults</code>永远不会为null, 当查不到结果时, 它的<code>size()</code>返回0.</p>
<h3 id="查询的线程"><a href="#查询的线程" class="headerlink" title="查询的线程"></a>查询的线程</h3><p>基本上所有的查询都是很快进行的, 足够在UI线程上同步进行.<br>所以绝大多数情况在UI线程上使用<code>findAll()</code>是没有问题的.</p>
<p>如果你要进行非常复杂的查询, 或者你的查询是在非常大的数据集上进行的, 你可以选择异步查询, 使用<code>findAllAsync()</code>.</p>
<h3 id="查询条件是一个集合-gt-in"><a href="#查询条件是一个集合-gt-in" class="headerlink" title="查询条件是一个集合 -&gt; in()"></a>查询条件是一个集合 -&gt; <code>in()</code></h3><p>如果想要查询的某一个字段的值是在一个集合中, 比如我有一个id的集合, 我现在想把id在这个集合中的项目全都查出来, 这就可以使用in操作符:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;TodoList&gt; toDeleteLists = realm.where(TodoList.class).in(<span class="string">"id"</span>, ids).findAll();</div></pre></td></tr></table></figure></p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>查询的时候可以利用link或关系来查询, 比如一个Person类中含有一个<code>RealmList&lt;Dog&gt; dogs</code>的字段.<br>查询的时候可以这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;Person&gt; persons = realm.where(Person.class)</div><div class="line">                                .equalTo(<span class="string">"dogs.color"</span>, <span class="string">"Brown"</span>)</div><div class="line">                                .findAll();</div></pre></td></tr></table></figure></p>
<p>利用字段名<code>dogs.</code>来查询一个dog的属性, 再查出拥有这种特定属性dog的人.</p>
<p>但是反向地, 我们能不能查询主人是满足特定属性的人的所有dogs呢? 目前(2017.2.17)这种查询仍是不支持的. 这里有讨论:  <a href="https://github.com/realm/realm-java/issues/607" target="_blank" rel="external">realm-java-issue-607</a>.</p>
<p> 所以两种解决办法: 一是做两次查询; 二是在Dog类的model里加入对Person的引用.</p>
<h2 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h2><p>可以添加一个listener, 在数据改变的时候收到更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Realm realm;</div><div class="line">    <span class="keyword">private</span> RealmChangeListener realmListener;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">      realm = Realm.getDefaultInstance();</div><div class="line">      realmListener = <span class="keyword">new</span> RealmChangeListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">            <span class="comment">// ... do something with the updates (UI, etc.) ...</span></div><div class="line">        &#125;&#125;;</div><div class="line">      realm.addChangeListener(realmListener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">// Remove the listener.</span></div><div class="line">        realm.removeChangeListener(realmListener);</div><div class="line">        <span class="comment">// Close the Realm instance.</span></div><div class="line">        realm.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意listener需要在不用的时候删除掉. </p>
<p>可以用这样删除所有的listeners:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.removeAllChangeListeners();</div></pre></td></tr></table></figure></p>
<p>Listener不一定要和Realm绑定, 也可以和具体的<code>RealmObject</code>或者<code>RealmResults</code>绑定.<br>当Listener被调用的时候, 它绑定的对象是自动更新的, 不需要手动刷新.</p>
<h2 id="查看数据库的工具"><a href="#查看数据库的工具" class="headerlink" title="查看数据库的工具"></a>查看数据库的工具</h2><p>用Stetho不能直接查看Realm的数据库, 看不到.<br>需要用这个工具配置一下: <a href="https://github.com/uPhyca/stetho-realm" target="_blank" rel="external">stetho-realm</a>.<br>之后就可以在浏览器中查看Realm的数据库了.</p>
<p>(但是感觉这个工具不是很好用, 有时候不显示数据, 有时候显示的是旧数据.)</p>
<p>也可以用官方提供的Realm Browser来查看, 但是只有Mac版.<br>如何查看看这里: <a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803" target="_blank" rel="external">StackOverflow answer</a>.</p>
<h2 id="实际使用的感想和遇到的问题"><a href="#实际使用的感想和遇到的问题" class="headerlink" title="实际使用的感想和遇到的问题"></a>实际使用的感想和遇到的问题</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>建立Model之间的关系很方便也很直接, 查询的时候自动关联了其中的关系.</li>
<li>自动更新(Auto-Updating)的特性很有用, 不用再关心数据的刷新, 只用关心UI的刷新. </li>
</ul>
<p>比如一旦给Adapter绑定了数据, 之后的数据更新只需要在onChange()里面通知Adapter调用<code>notifyDataSetChanged()</code>即可.</p>
<p>当然我并没有用<code>RealmBaseAdapter</code>和<code>RealmRecyclerViewAdapter</code>, 估计这两个更好用, 官方有例子, 这里不再赘述.</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这里有的也不能说是缺点, 只是使用起来觉得不方便的地方. </p>
<ul>
<li>限制了创建对象和操作对象必须在同一个线程.<br>违反了这条会报错: <code>java.lang.IllegalStateException: Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.</code> 比如我们在UI线程查询出来的对象, 想要异步地删除或者更新, 我们必须在新的线程重新查询.</li>
<li>没有主键自增的功能, 见<a href="https://github.com/realm/realm-java/issues/469" target="_blank" rel="external">Issue #469</a>, 需要自己控制主键自增.</li>
<li>从List中删除了一项之后, 最后的一项会移动过来补到被删除的那一项原来的位置. 这是因为人家就是这么设计的<a href="http://stackoverflow.com/questions/37480785/realm-order-of-records-was-changed" target="_blank" rel="external">stackoverflow</a>. 默认情况下是没有排序的, 数据按照添加的顺序返回, 但是这并不是一种保证, 所以当删除了中间的元素, 后面的会补上这个位置, 以保证底层的数据是放在一起的. 解决办法就是指定一个排序规则.</li>
<li>查询出来的对象不可以临时改变其数据, 否则会报错: <code>java.lang.IllegalStateException: Changing Realm data can only be done from inside a transaction.</code></li>
<li>不支持反向link的查询. (见前面链式查询部分的介绍).</li>
<li>不支持级联删除. 即从数据库中删除一个对象的时候, 不会删除其中<code>RealmObject</code>子类或<code>RealmList</code>类型的字段在数据库中对应的数据. <a href="https://github.com/realm/realm-java/issues/1104" target="_blank" rel="external">Issue #1104</a>, <a href="https://github.com/realm/realm-java/issues/2717" target="_blank" rel="external">Issue #2717</a>. 这点也可以理解, 因为model之间的关系可能是多对多的. 所以需要实现级联删除的地方需要手动处理.</li>
<li>测试不方便: <code>RealmResults</code>对象即不能被mock也不能被new; 所有的Model对象也不能被mock. 因为<code>Mockito can only mock non-private &amp; non-final classes.</code></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/realm/realm-java" target="_blank" rel="external">Github repo realm-java</a></li>
<li><a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">Realm Java Doc</a></li>
</ul>
<p>我的练习Demo:</p>
<ul>
<li><a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Realm数据库使用指南&quot;&gt;&lt;a href=&quot;#Android-Realm数据库使用指南&quot; class=&quot;headerlink&quot; title=&quot;Android Realm数据库使用指南&quot;&gt;&lt;/a&gt;Android Realm数据库使用指南&lt;/h1&gt;&lt;p&gt;Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. &lt;/p&gt;
&lt;p&gt;本文面向Android开发, 所以只讨论Java实现.&lt;br&gt;目前Realm Java的最新版本是2.3.1.&lt;/p&gt;
&lt;p&gt;官方文档在此: &lt;a href=&quot;https://realm.io/docs/java/latest/&quot;&gt;realm java doc&lt;/a&gt;, 花一个下午就可以基本过一遍, 之后随时查用. &lt;/p&gt;
&lt;p&gt;我写了一个小程序&lt;a href=&quot;https://github.com/mengdd/TodoRealm&quot;&gt;TodoRealm&lt;/a&gt;, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.&lt;/p&gt;
&lt;p&gt;本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/categories/Android/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/categories/Android/Database/Realm/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/tags/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/tags/Realm/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 245</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/</id>
    <published>2017-02-22T07:35:47.000Z</published>
    <updated>2017-03-09T05:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-245"><a href="#Android-Weekly-Issue-245" class="headerlink" title="Android Weekly Issue #245"></a>Android Weekly Issue #245</h1><p>February 19th, 2017<br><a href="http://androidweekly.net/issues/issue-245" target="_blank" rel="external">Android Weekly Issue #245</a><br>本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);<br>用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中<code>Subscription</code>注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.</p>
<p>本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Write-awesome-unit-tests"><a href="#Write-awesome-unit-tests" class="headerlink" title="Write awesome unit tests"></a><a href="http://jeroenmols.com/blog/2017/02/16/unittests/" target="_blank" rel="external">Write awesome unit tests</a></h2><p>作者关于写好单元测试提供了三条简单的规则以及每条规则对应的一些建议.</p>
<h3 id="1-尽快尽早地跑测试"><a href="#1-尽快尽早地跑测试" class="headerlink" title="1. 尽快尽早地跑测试."></a>1. 尽快尽早地跑测试.</h3><p>尽量在每次改动之后都跑跑测试, 及早发现问题. 你的测试跑得越快你就越有可能经常跑它们.</p>
<p>为了让测试跑得很快:</p>
<ul>
<li>让测试跑在JVM上而不是设备上.</li>
<li>仅测试独立的逻辑模块.</li>
<li>不要包含UI, 数据库, 或者网络测试在你的主测试套件中.</li>
<li>测试中不要使用wait/sleep.</li>
</ul>
<h3 id="2-小并且关注点集中的测试"><a href="#2-小并且关注点集中的测试" class="headerlink" title="2. 小并且关注点集中的测试"></a>2. 小并且关注点集中的测试</h3><p>对每一个bug来说, 应该有且只有一个测试挂掉, 并且测试失败的原因应该能从测试方法名上看出来.</p>
<p>这样就迫使你每一个测试只检查一件事情, 导致你的测试小并且简单易懂, 也好维护. </p>
<p>实现tips:</p>
<ul>
<li>测试中只有一条assert/verify语句.</li>
<li>有更多的小测试, 而不是几个大测试.</li>
<li>测试的名字能清楚地描述失败的原因.</li>
</ul>
<h3 id="3-100-的可靠性"><a href="#3-100-的可靠性" class="headerlink" title="3. 100%的可靠性"></a>3. 100%的可靠性</h3><p>你的测试应该是完全值得信赖的, 不应该随机失败, 否则你将会对测试失去信任, 也不再会认真对待测试的失败.</p>
<p>所以你的测试应该是100%可靠的, 只在真的有问题的时候才失败.</p>
<p>建议是:</p>
<ul>
<li>在JVM上跑测试, 因为到设备的连接可能会中断.</li>
<li>在测试的时候mock网络通信.</li>
<li>把UI/集成测试移出你的单元测试套件.</li>
</ul>
<h2 id="Helping-to-Mock-Tests-in-Kotlin"><a href="#Helping-to-Mock-Tests-in-Kotlin" class="headerlink" title="Helping to Mock Tests in Kotlin"></a><a href="https://medium.com/@orogersilva/helping-androiddev-to-mock-tests-in-kotlin-ab3be5204559#.wetcvdvbt" target="_blank" rel="external">Helping to Mock Tests in Kotlin</a></h2><p>因为Kotlin中的类默认是<code>final</code>的, 要继承的话需要显示地声明<code>open</code>.</p>
<p>如果只是为了在单元测试中mock就要加个open吗? 不.</p>
<p>本篇文章就介绍如何如何mock Kotlin的对象, 而不用该它的声明.</p>
<p>首先, <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="external">Set up</a>; 然后, 使用这个库<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>.</p>
<p>文中详细介绍了使用细节, 以及对<code>any()</code>方法的讨论.</p>
<h2 id="How-and-Why-I-Kill-God-Objects"><a href="#How-and-Why-I-Kill-God-Objects" class="headerlink" title="How and Why I Kill God Objects"></a><a href="https://www.philosophicalhacker.com/post/towards-godless-android-development-how-and-why-i-kill-god-objects/" target="_blank" rel="external">How and Why I Kill God Objects</a></h2><p>在面向对象编程中, God Objects是应该被避免的.</p>
<p>在Android开发中, 最常见的一种God对象是Context. 本文介绍如何清除这个God对象, 同样的方法也可以用来处理其他对象.</p>
<p>首先说为什么要干掉Context?<br>在做TDD的过程中, 我们希望是面向接口的, 而且我们不应该mock非我们拥有的类型.<br>所以我们不应该直接mock外部的API, 而是应该创建一个自己的接口层.</p>
<p>作者发现很多类其实并不真正需要一个Context, 它们只是需要得到string或者存储的键值对.</p>
<p>之后文中举例介绍了如何通过定义接口摆脱Context.</p>
<h2 id="How-to-Make-Calls-and-Use-SMS-in-Android-Apps"><a href="#How-to-Make-Calls-and-Use-SMS-in-Android-Apps" class="headerlink" title="How to Make Calls and Use SMS in Android Apps"></a><a href="https://code.tutsplus.com/tutorials/how-to-make-calls-and-use-sms-in-android-apps--cms-28168" target="_blank" rel="external">How to Make Calls and Use SMS in Android Apps</a></h2><p><strong>如何拨打电话</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String dial = <span class="string">"tel:"</span> + phoneNo;</div><div class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(dial)));</div></pre></td></tr></table></figure></p>
<p>(不需要权限).</p>
<p>如果想在app里直接拨出去电话, 需要权限<code>android.permission.CALL_PHON</code>, 并且改用<code>ACTION_CALL</code>.</p>
<p><strong>监控电话事件</strong>:</p>
<p>需要权限<code>android.permission.READ_PHONE_STATE</code>.来监控来电, 打出去的电话需要这个权限: <code>android.permission.PROCESS_OUTGOING_CALLS</code>.</p>
<p>具体实现就是在<code>TelephonyManager</code>注册监听器<code>PhoneStateListener</code>. 如果是在Activity中需要在对应的生命周期注销监听器.</p>
<p>如果需要后台监控, 则需要用到<code>BroadcastReceiver</code>, 过滤actions为<code>android.intent.action.PHONE_STATE</code>和<code>android.intent.action.NEW_OUTGOING_CALL</code>.<br>除了获取相应的电话号码, 还可以进一步阻止电话的拨出.</p>
<p><strong>发送短信</strong>:</p>
<p>发短信也是两种方法, 启动一个短信客户端程序, 或者直接从程序里发.</p>
<p>启动其他程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent smsIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, Uri.parse(<span class="string">"smsto:"</span> + phoneNo));</div><div class="line">smsIntent.putExtra(<span class="string">"sms_body"</span>, message);</div><div class="line">startActivity(smsIntent);</div></pre></td></tr></table></figure></p>
<p>自己发: 需要权限<code>android.permission.SEND_SMS</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SmsManager smsManager = SmsManager.getDefault();</div><div class="line">smsManager.sendTextMessage(phoneNo, <span class="keyword">null</span>, message, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>注意Android 6.0以上的设备, 本文提到的这些危险权限都是需要动态请求的.</p>
<p><strong>收短信</strong>:<br>通过<code>BroadcastReceiver</code>, 需要权限<code>android.permission.RECEIVE_SMS</code>.</p>
<h2 id="Android-Things-Electricity-Monitoring-App"><a href="#Android-Things-Electricity-Monitoring-App" class="headerlink" title="Android Things - Electricity Monitoring App"></a><a href="https://riggaroo.co.za/android-things-electricity-monitoring-app/" target="_blank" rel="external">Android Things - Electricity Monitoring App</a></h2><p>作者分享了一个她的Android Things的应用(和Github repo), 可以监控她家的用电情况.</p>
<h2 id="Using-Keystore-system-to-store-and-retrieve-sensitive-information"><a href="#Using-Keystore-system-to-store-and-retrieve-sensitive-information" class="headerlink" title="Using Keystore system to store and retrieve sensitive information"></a><a href="https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454b#.nu3gw39qp" target="_blank" rel="external">Using Keystore system to store and retrieve sensitive information</a></h2><p>利用Android的Keystore来存储一些敏感信息.</p>
<h2 id="The-lost-droid-and-the-magic-Dagger"><a href="#The-lost-droid-and-the-magic-Dagger" class="headerlink" title="The lost droid and the magic Dagger"></a><a href="https://medium.com/rocknnull/the-lost-droid-and-the-magic-dagger-an-intro-to-dependency-injection-for-android-c686f4399117#.k5vgmxsjh" target="_blank" rel="external">The lost droid and the magic Dagger</a></h2><p>一篇依赖注入的介绍文章.<br>先介绍依赖注入是什么, 有什么优点, 接着介绍Dagger 2的使用.</p>
<h2 id="Wear-2-0-Match-Timer-–-Part-1"><a href="#Wear-2-0-Match-Timer-–-Part-1" class="headerlink" title="Wear 2.0: Match Timer – Part 1"></a><a href="https://blog.stylingandroid.com/wear-2-0-match-timer-part-1/" target="_blank" rel="external">Wear 2.0: Match Timer – Part 1</a></h2><p>作者把他的Wear应用升级到了Wear 2.0.</p>
<h2 id="ViewPager-without-Fragments"><a href="#ViewPager-without-Fragments" class="headerlink" title="ViewPager without Fragments"></a><a href="http://www.ottodroid.net/?p=523" target="_blank" rel="external">ViewPager without Fragments</a></h2><p>一些开发者可能不想选择Fragment, 这篇文章里有相关讨论: <a href="https://medium.com/square-corner-blog/advocating-against-android-fragments-81fd0b462c97#.e4k145h1b" target="_blank" rel="external">Advocating Against Android Fragments</a>.</p>
<p>作者推荐了一些在不用Fragment的情况下构建App的库: <a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">Conductor</a>, <a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>, <a href="https://github.com/square/flow" target="_blank" rel="external">flow</a>, <a href="https://github.com/square/mortar" target="_blank" rel="external">mortar</a>.</p>
<p>而本篇文章想要展示另一种方法, 既不用Fragment, 也不用上述的第三方库来构建一个App -&gt; 用ViewPager.</p>
<p>在PagerAdapter里管理了一个Presenter的List, 每一个Presenter管理一个View. 具体实现见原文.</p>
<h2 id="Stress-testing-Android-apps"><a href="#Stress-testing-Android-apps" class="headerlink" title="Stress-testing Android apps"></a><a href="https://android.jlelse.eu/stress-testing-android-apps-601311ebf590#.8kqor9m39" target="_blank" rel="external">Stress-testing Android apps</a></h2><p>之前大神JakeWharton有一个Sample App: <a href="https://github.com/JakeWharton/u2020" target="_blank" rel="external">JakeWharton/u2020</a>, 里面有一个debug drawer, 可以用来模拟不同的测试情形, 比如网络连接不好, 延迟, 或者网络错误等等.</p>
<p>作者他们的App也有一个类似的debug drawer, 他们讨论出了一个需要测试的情形的checklist:</p>
<ul>
<li>网络延迟</li>
<li>错误率</li>
<li>离线模式</li>
<li>屏幕旋转</li>
<li>应用在后台被杀死</li>
<li>应用升级</li>
<li>Key Bashing</li>
<li>多窗口模式 (Android N)</li>
<li>TransactionTooLargeException (Android N)</li>
</ul>
<p>作者甚至发现其中的一些项目组合起来测试非常有趣.</p>
<ul>
<li>网络延迟: 可结合方向改变/app后台被杀死测试.</li>
<li>错误率: 可以检查错误是否被正确处理并被报告.</li>
<li>离线模式: 关掉网络或者打开飞行模式, 检测正在执行的网络请求是否会引起崩溃; 是否正确通知了用户连接丢失了; 所有应该被cach的内容是否被正确cach了.</li>
<li>方向改变: 检查:  正在进行的请求会怎么办? app的状态是否被正确恢复了? 是否加载了当前方向对应的正确资源?</li>
<li>App在后台被杀死: 可以通过命令: <code>adb shell am kill YOUR_PACKAGNE_NAME</code>或者”Do not keep activities”来模拟这种情形. 相关阅读: <a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">Optimizing for Doze and App Standby</a>.</li>
<li>App更新: 升级后之前的数据是否被保存了?</li>
<li>Key Bashing: 剧烈的滑动和敲击可能产生一些奇怪的错误. 可以跑Monkey来测试一下你的应用: <code>adb shell monkey -p YOUR_PACKAGNE_NAME</code>.</li>
<li>多窗口模式(Android N): 列出了一些多窗口的测试项目, 详情见原文.</li>
<li>TransactionTooLargeException (Android N): Bundle中的数据不能太大, 超过限制, 在Android N以上会直接抛异常.</li>
</ul>
<h2 id="How-to-leak-memory-with-Subscriptions-in-RxJava"><a href="#How-to-leak-memory-with-Subscriptions-in-RxJava" class="headerlink" title="How to leak memory with Subscriptions in RxJava"></a><a href="https://medium.com/@scanarch/how-to-leak-memory-with-subscriptions-in-rxjava-ae0ef01ad361#.20w4lbkxq" target="_blank" rel="external">How to leak memory with Subscriptions in RxJava</a></h2><p>文中举了一个例子, 用RxJava结合MVP, 做网络请求, 更新UI, 很常见的使用情形. </p>
<p>在生命周期结束的时候调用RxJava的<code>Subscription.unsubscribe()</code>来注销, 以结束还在进行的网络请求.</p>
<p>看上去没有什么问题, 但是程序实际运行, 反复旋转屏幕进行测试, <code>StrictMode</code>报告出了Activity的<code>InstanceCountViolation</code>, dump memory的确看到了多个Activity的实例. 这是为什么呢? </p>
<p>作者深究原因, 发现<code>Subscriber</code>的子类存储的都是final的字段, 比如这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext;</div><div class="line">    <span class="keyword">final</span> Action1&lt;Throwable&gt; onError;</div><div class="line">    <span class="keyword">final</span> Action0 onCompleted;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionSubscriber</span><span class="params">(Action1&lt;? <span class="keyword">super</span> T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.onNext = onNext;</div><div class="line">        <span class="keyword">this</span>.onError = onError;</div><div class="line">        <span class="keyword">this</span>.onCompleted = onCompleted;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它们都是final的, 所以最后即便执行了注销操作, 也是没有办法把它们置为null的.</p>
<p>在生命周期结束的时候注销的操作是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    subscription.unsubscribe();</div><div class="line">    view = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>subscription</code>是<code>subscribe()</code>方法的返回值, 被保存在Presenter的一个字段里, 它实际就是<code>Subscriber</code>对象.</p>
<p>这里的问题就是, 在<code>destroy()</code>之后, 该引用并没有被置为null, 导致了下面的引用链:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Presenter -&gt; subscription字段, 也即匿名的`Subscriber`对象 -&gt; final字段 -&gt; 对view的引用 -&gt; 对Activity的引用.</div></pre></td></tr></table></figure>
<p>从而造成了内存泄露.</p>
<p>解决的办法有两个:</p>
<ul>
<li>在<code>subscription.unsubscribe();</code>之后把<code>subscription</code>字段置为null.</li>
<li>使用<code>CompositeSubscription</code>, 它可以管理多个<code>Subscription</code>对象, 用它的<code>clear()</code>方法, 它会unsubscribe所有项目并且清除所有的引用.</li>
</ul>
<p>文后还列了相关的资料, 作者发现问题并寻找原因的思路很值得学习.</p>
<h2 id="Your-Unit-tests-might-not-be-as-reliable-as-you-thought"><a href="#Your-Unit-tests-might-not-be-as-reliable-as-you-thought" class="headerlink" title="Your Unit tests might not be as reliable as you thought"></a><a href="https://afterecho.uk/blog/your-unit-tests-might-not-be-as-reliable-as-you-thought.html" target="_blank" rel="external">Your Unit tests might not be as reliable as you thought</a></h2><p>作者举了个例子, 说明即便你的单元测试过了, 也不保证你的产品代码一定没问题.</p>
<p>他的例子是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SimpleDateFormat fmt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>);</div></pre></td></tr></table></figure></p>
<p>失败的原因是因为<code>XXX</code>格式是在Android 4.3以上才支持的, 它是在<code>java.text</code>包下的. 所以实际在高版本的设备还运行正常, 换个低版本的设备就崩溃了.</p>
<p>所以单元测试并不一定可靠, 因为跑单元测试的JVM和Android设备上的JVM有可能不一样.</p>
<h2 id="Airplane-Mode-Enabling-Trello-Mobile-Offline"><a href="#Airplane-Mode-Enabling-Trello-Mobile-Offline" class="headerlink" title="Airplane Mode: Enabling Trello Mobile Offline"></a><a href="http://tech.trello.com/sync-architecture/" target="_blank" rel="external">Airplane Mode: Enabling Trello Mobile Offline</a></h2><p>Trello移动移动现在有离线模式了. 作者介绍了他们的心路历程和架构变化. (比较简单和笼统的介绍).</p>
<h2 id="Self-guided-resources-to-Android-development"><a href="#Self-guided-resources-to-Android-development" class="headerlink" title="Self-guided resources to Android development"></a><a href="https://twitter.com/corey_latislaw/status/831624360175603713?s=03" target="_blank" rel="external">Self-guided resources to Android development</a></h2><p>这是一条Twitter, 作者分享了Android的学习资源. (可惜我打不开里面说的链接, 不知为何.)</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Alerter"><a href="#Alerter" class="headerlink" title="Alerter"></a><a href="https://github.com/Tapadoo/Alerter" target="_blank" rel="external">Alerter</a></h2><p>一个加在Window的Decor View上面的顶部提示栏, 类似于Snackbar和Toast一类的东东. 可定制外观, icon, 加多行字, 可添加click事件.</p>
<h2 id="sensey"><a href="#sensey" class="headerlink" title="sensey"></a><a href="https://github.com/nisrulz/sensey" target="_blank" rel="external">sensey</a></h2><p>一个好用的手势检测库.</p>
<h2 id="mkloader"><a href="#mkloader" class="headerlink" title="mkloader"></a><a href="https://github.com/nntuyen/mkloader" target="_blank" rel="external">mkloader</a></h2><p>好看并且平滑的自定义loading view. 目前支持好几种图案.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-245&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-245&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #245&quot;&gt;&lt;/a&gt;Android Weekly Issue #245&lt;/h1&gt;&lt;p&gt;February 19th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-245&quot;&gt;Android Weekly Issue #245&lt;/a&gt;&lt;br&gt;本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&amp;gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);&lt;br&gt;用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中&lt;code&gt;Subscription&lt;/code&gt;注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.&lt;/p&gt;
&lt;p&gt;本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Memory Leak" scheme="http://mengdd.github.io/tags/Memory-Leak/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Unit Test" scheme="http://mengdd.github.io/tags/Unit-Test/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="God Objects" scheme="http://mengdd.github.io/tags/God-Objects/"/>
    
      <category term="Call" scheme="http://mengdd.github.io/tags/Call/"/>
    
      <category term="SMS" scheme="http://mengdd.github.io/tags/SMS/"/>
    
      <category term="Keystore" scheme="http://mengdd.github.io/tags/Keystore/"/>
    
      <category term="Wear 2.0" scheme="http://mengdd.github.io/tags/Wear-2-0/"/>
    
      <category term="ViewPager" scheme="http://mengdd.github.io/tags/ViewPager/"/>
    
      <category term="Alert" scheme="http://mengdd.github.io/tags/Alert/"/>
    
      <category term="Gesture" scheme="http://mengdd.github.io/tags/Gesture/"/>
    
      <category term="Loading" scheme="http://mengdd.github.io/tags/Loading/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 244</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/</id>
    <published>2017-02-13T06:53:29.000Z</published>
    <updated>2017-02-13T07:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-244"><a href="#Android-Weekly-Issue-244" class="headerlink" title="Android Weekly Issue #244"></a>Android Weekly Issue #244</h1><p>February 12th, 2017<br><a href="http://androidweekly.net/issues/issue-244" target="_blank" rel="external">Android Weekly Issue #244</a><br>本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送<code>file:// URI</code>, 应用需要改用<code>FileProvider</code>实现原有功能.<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-Fragments-Tutorial-An-Introduction"><a href="#Android-Fragments-Tutorial-An-Introduction" class="headerlink" title="Android Fragments Tutorial: An Introduction"></a><a href="https://www.raywenderlich.com/149112/android-fragments-tutorial-introduction" target="_blank" rel="external">Android Fragments Tutorial: An Introduction</a></h2><p>一篇如何使用Fragments的讲解.</p>
<h2 id="Exporting-data-from-ClassyShark"><a href="#Exporting-data-from-ClassyShark" class="headerlink" title="Exporting data from ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-data-from-classyshark-e3cf3fe3fab8#.e2r76detr" target="_blank" rel="external">Exporting data from ClassyShark</a></h2><p>用<a href="https://github.com/google/android-classyshark" target="_blank" rel="external">ClassyShark</a>的APK dashboardA检查apk的问题(重复依赖, 过期依赖等).<br>本文介绍如何一次性导出全部的数据.</p>
<h2 id="Post-mortem-Firebase-vs-permissions"><a href="#Post-mortem-Firebase-vs-permissions" class="headerlink" title="Post-mortem : Firebase vs permissions"></a><a href="http://jeremie-martinez.com/2017/02/08/firebase-permissions/" target="_blank" rel="external">Post-mortem : Firebase vs permissions</a></h2><p>两周前Firebase发布了一个新功能: <a href="https://firebase.google.com/docs/app-indexing/android/personal-content" target="_blank" rel="external">Personal App Indexing</a>. 之后遇到了一些权限相关的问题, 本文讨论遇到的具体问题和解决方法, 然后他们发布了一个hotfix版本.</p>
<h2 id="Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails"><a href="#Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails" class="headerlink" title="Did you get one of these Google Play Developer Policy Violation Emails?"></a><a href="https://medium.com/@ali.muzaffar/did-you-get-one-of-these-google-play-developer-policy-violation-emails-6c529ceb082d#.glctt861o" target="_blank" rel="external">Did you get one of these Google Play Developer Policy Violation Emails?</a></h2><p>如果你的应用使用了一些”dangerous permissions”, 你需要在应用或者Google Play上附有privacy policy, 否则你就会收到Google Play的邮件.</p>
<p>作者他的Demo app也收到了这种邮件, 所以他提供了他的解决方法.</p>
<p>他找到了这个<a href="https://privacypolicytemplate.net/" target="_blank" rel="external">网站</a>, 这是他最后写成的<a href="https://gist.github.com/alphamu/c42f6c3fce530ca5e804e672fed70d78" target="_blank" rel="external">Gist</a>. 利用<a href="https://rawgit.com/" target="_blank" rel="external">RawGit</a>可以将github上的文件url转成用HTML显示的url. 之后在app中设置一个链接, 点击打开这个url就可以了.</p>
<h2 id="Pushing-the-limits-of-Kotlin-annotation-processing"><a href="#Pushing-the-limits-of-Kotlin-annotation-processing" class="headerlink" title="Pushing the limits of Kotlin annotation processing"></a><a href="https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711#.7crkk5m68" target="_blank" rel="external">Pushing the limits of Kotlin annotation processing</a></h2><p>关于Kotlin的annotation processor支持, 是一个很复杂的问题, 作者讨论了关于这个问题的历史进展和当前的局限性.</p>
<h2 id="Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming"><a href="#Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming" class="headerlink" title="Pull vs Push &amp; Imperative vs Reactive - Reactive Programming"></a><a href="http://www.uwanttolearn.com/android/pull-vs-push-imperative-vs-reactive-reactive-programming-android-rxjava2-hell-part2/" target="_blank" rel="external">Pull vs Push &amp; Imperative vs Reactive - Reactive Programming</a></h2><p>作者用浅显的代码例子解释了Pull和Push模式的区别, 一个是自己不停地查询读取, 另一个是等改变发生的时候收到通知. </p>
<h2 id="Why-Android-Testing-is-so-Hard-Historical-Edition"><a href="#Why-Android-Testing-is-so-Hard-Historical-Edition" class="headerlink" title="Why Android Testing is so Hard: Historical Edition"></a><a href="https://www.philosophicalhacker.com/post/why-android-testing-is-so-hard-historical-edition/" target="_blank" rel="external">Why Android Testing is so Hard: Historical Edition</a></h2><p>为什么Android项目这么难测试呢? 作者认为主要有三方面的历史原因: </p>
<ul>
<li>Performance方面的考虑. </li>
<li>对Android组件的误解.</li>
<li>Android和Unit Testing出现的时机.</li>
</ul>
<h2 id="Sharing-files-though-Intents-are-you-ready-for-Nougat"><a href="#Sharing-files-though-Intents-are-you-ready-for-Nougat" class="headerlink" title="Sharing files though Intents: are you ready for Nougat?"></a><a href="https://medium.com/@quiro91/sharing-files-though-intents-are-you-ready-for-nougat-70f7e9294a0b#.h3f06hxg7A" target="_blank" rel="external">Sharing files though Intents: are you ready for Nougat?</a></h2><p>Android 7 Nougat引入了一些文件系统的权限变化, 来增强安全性.</p>
<p>如果你已经把<code>targetSdkVersion</code>升到了24+, 并且你用Intent发送一个<code>file:// URI</code>, 你将会得到一个<code>FileUriExposedException</code>.</p>
<p>解决办法是使用<code>FileProvider</code>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="SlidingSquaresLoader"><a href="#SlidingSquaresLoader" class="headerlink" title="SlidingSquaresLoader"></a><a href="https://github.com/biodunalfet/SlidingSquaresLoader" target="_blank" rel="external">SlidingSquaresLoader</a></h2><p>一个有趣的动画方块的loading图案.</p>
<h2 id="ason"><a href="#ason" class="headerlink" title="ason"></a><a href="https://github.com/afollestad/ason" target="_blank" rel="external">ason</a></h2><p>一个JSON库, 简化了序列化, 更易使用.</p>
<h2 id="Intro-To-RxJava"><a href="#Intro-To-RxJava" class="headerlink" title="Intro-To-RxJava"></a><a href="https://github.com/PareshMayani/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a></h2><p>上一期有一篇文章提过的RxJava练习项目.</p>
<h2 id="chuck"><a href="#chuck" class="headerlink" title="chuck"></a><a href="https://github.com/jgilfelt/chuck" target="_blank" rel="external">chuck</a></h2><p>An in-app HTTP inspector for Android OkHttp clients.<br>截取请求和响应, 点击通知可以查看UI显示.</p>
<h2 id="android-parcelable-intellij-plugin-kotlin"><a href="#android-parcelable-intellij-plugin-kotlin" class="headerlink" title="android-parcelable-intellij-plugin-kotlin"></a><a href="https://github.com/nekocode/android-parcelable-intellij-plugin-kotlin" target="_blank" rel="external">android-parcelable-intellij-plugin-kotlin</a></h2><p>为kotlin的类生成Parcelable代码的插件.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-244&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-244&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #244&quot;&gt;&lt;/a&gt;Android Weekly Issue #244&lt;/h1&gt;&lt;p&gt;February 12th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-244&quot;&gt;Android Weekly Issue #244&lt;/a&gt;&lt;br&gt;本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送&lt;code&gt;file:// URI&lt;/code&gt;, 应用需要改用&lt;code&gt;FileProvider&lt;/code&gt;实现原有功能.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="ClassyShark" scheme="http://mengdd.github.io/tags/ClassyShark/"/>
    
      <category term="Permission" scheme="http://mengdd.github.io/tags/Permission/"/>
    
      <category term="Privacy Policy" scheme="http://mengdd.github.io/tags/Privacy-Policy/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 243</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/</id>
    <published>2017-02-07T04:52:37.000Z</published>
    <updated>2017-02-07T04:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-243"><a href="#Android-Weekly-Issue-243" class="headerlink" title="Android Weekly Issue #243"></a>Android Weekly Issue #243</h1><p>February 5th, 2017<br><a href="http://androidweekly.net/issues/issue-243" target="_blank" rel="external">Android Weekly Issue #243</a><br>本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;<br>Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Constraint-Layout-Animations"><a href="#Constraint-Layout-Animations" class="headerlink" title="Constraint Layout Animations"></a><a href="http://www.uwanttolearn.com/android/constraint-layout-animations-dynamic-constraints-ui-java-hell/" target="_blank" rel="external">Constraint Layout Animations</a></h2><p>作者举例说明了如何在Java代码中动态地改变约束条件, 从而使<code>ConstraintLayout</code>中的View动起来.</p>
<h2 id="Android-Testing-with-Kotlin"><a href="#Android-Testing-with-Kotlin" class="headerlink" title="Android Testing with Kotlin"></a><a href="http://fernandocejas.com/2017/02/03/android-testing-with-kotlin/" target="_blank" rel="external">Android Testing with Kotlin</a></h2><p>如果你想逐渐地迁移代码到Kotlin, 你可以从测试开始, 这样你也不用更改产品环境的代码, 就先熟悉了Kotlin.</p>
<p>本篇文章详细讲了如何setup, 然后写各种测试:</p>
<h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>需要JUnit, <a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>和<a href="https://github.com/MarkusAmshove/Kluent" target="_blank" rel="external">Kluent</a>.</p>
<p>对于在<code>setUp()</code>方法中初始化的变量, 需要标记为<code>lateinit</code>.</p>
<h3 id="Robolectric测试"><a href="#Robolectric测试" class="headerlink" title="Robolectric测试"></a>Robolectric测试</h3><p>作者封装了一个基类, 把所有Mockito相关的东东包装在里面. 这样在Mockito升级的时候不用更改每一个测试文件.</p>
<h3 id="Espresso测试"><a href="#Espresso测试" class="headerlink" title="Espresso测试"></a>Espresso测试</h3><p>同样, 这里作者也创建了几个基类, 将所有Espresso相关的东东包装起来.</p>
<h2 id="Practical-challenges-for-RxJava-learners"><a href="#Practical-challenges-for-RxJava-learners" class="headerlink" title="Practical challenges for RxJava learners"></a><a href="https://medium.com/@sergii/practical-challenges-for-rxjava-learners-1821c454de9#.9icb22hrr" target="_blank" rel="external">Practical challenges for RxJava learners</a></h2><p>作者建议通过实践来检验和学习RxJava技能, 之前他用过这个Repo: <a href="https://github.com/Froussios/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a>, 现在他又新推出了这个<a href="https://github.com/sergiiz/RxBasicsKata" target="_blank" rel="external">Repo</a>, 针对RxJava2的.</p>
<h2 id="Coordinators-solving-a-problem-you-didn’t-even-know-you-had"><a href="#Coordinators-solving-a-problem-you-didn’t-even-know-you-had" class="headerlink" title="Coordinators: solving a problem you didn’t even know you had"></a><a href="https://hackernoon.com/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf#.mcx15cssl" target="_blank" rel="external">Coordinators: solving a problem you didn’t even know you had</a></h2><p>Square发布了一个库叫<a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a>, 这个库是用来分离View中的一些控制逻辑.</p>
<h2 id="Review-Reporter-Part-1"><a href="#Review-Reporter-Part-1" class="headerlink" title="Review-Reporter: Part 1 "></a><a href="https://medium.com/azimolabs/review-reporter-part-1-connecting-to-google-play-8abd37edc49f#.a0s5gx66j" target="_blank" rel="external">Review-Reporter: Part 1 </a></h2><p>作者他们做了一个小项目: <a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a>, 可以自动把Google Play上新的用户回复发到slack, firebase, Jira上. 本篇文章讲了他们是怎么做的.</p>
<h2 id="How-to-test-a-Service"><a href="#How-to-test-a-Service" class="headerlink" title="How to test a Service"></a><a href="https://medium.com/@josiassena/android-how-to-unit-test-a-service-67e5340544a5#.qg3751nxg" target="_blank" rel="external">How to test a Service</a></h2><p>Android官方文档介绍了如何测试Service: <a href="https://developer.android.com/training/testing/integration-testing/service-testing.html" target="_blank" rel="external">Testing your Service</a>. 本文作者介绍他是如何做的.</p>
<h2 id="Introducing-Lottie"><a href="#Introducing-Lottie" class="headerlink" title="Introducing Lottie"></a><a href="https://medium.com/airbnb-engineering/introducing-lottie-4ff4a0afac0e#.e7wojthmp" target="_blank" rel="external">Introducing Lottie</a></h2><p><a href="http://airbnb.design/lottie/" target="_blank" rel="external">Lottie</a>是一个iOS, Android和React Native的库, 可以实时渲染After Effects的动画, 让native的应用像使用静态文件一样简单地使用复杂的动画.</p>
<h2 id="Learning-to-use-and-abuse-Mutability"><a href="#Learning-to-use-and-abuse-Mutability" class="headerlink" title="Learning to use and abuse Mutability"></a><a href="https://medium.com/google-developer-experts/learning-to-use-and-abuse-mutability-b4c71576299#.diungnuw6" target="_blank" rel="external">Learning to use and abuse Mutability</a></h2><blockquote>
<p>An immutable class is a class whose state cannot be changed once it has been created.</p>
</blockquote>
<p>这篇文章分享了作者关于Java中的mutability &amp; immutability的一些想法.</p>
<h2 id="A-Curious-Case-of-Multiple-Locales"><a href="#A-Curious-Case-of-Multiple-Locales" class="headerlink" title="A Curious Case of Multiple Locales"></a><a href="https://blog.egorand.me/a-curious-case-of-multiple-locales/" target="_blank" rel="external">A Curious Case of Multiple Locales</a></h2><p>Android N的一个新feature就是可以在设置中选择多种语言.</p>
<p>比如一个用户, 她会说意大利语和德语, 她使用的是一个低于Android 7的手机, 她把手机语言设置为意大利语.</p>
<p>有一个app, 支持两种语言, 默认是英语, 然后还支持德语.</p>
<p>但是这个应用在这个用户的手机上打开时, 发现自己并不支持意大利语, 于是会显示英语(默认)而不是德语, 因为应用又不知道这个用户还会德语.</p>
<p>后来用户把手机升级了, 用了Android 7的系统, 她发现可以设置支持多种语言, 于是, 于是她设置了两种语言, 意大利语和德语. 在新手机上装之前那个app的时候发现现在显示的是德语.</p>
<p>因为应用现在知道了用户还会讲德语.</p>
<p>现在, 假设我们需要进行向下兼容以前的旧版本设备, 我们加入了<code>appcompat-v7</code>, 用户更新后, 英语又出现了. </p>
<p>这是因为<code>appcompat-v7</code>中含有一些意大利语的资源, 因为所有的资源在build的时候都会merge到一起, 所以现在app也包含了这些资源. 系统认为现在app能够支持用户的第一语言了, 然后就查找对应的资源, 当然没查找到, 于是就使用了默认资源, 也就是英语.</p>
<p>我们有什么办法可以解决这个问题呢? 答案是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;  </div><div class="line">  ...</div><div class="line"></div><div class="line">  resConfigs &quot;en&quot;, &quot;de&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就告诉了Gradle我们只支持这两种语言, 所有其他的资源都不会被打包进来.</p>
<p>验证的方法是使用Android Studio的<code>Analyze APK</code>来查看string有多少种configurations.</p>
<h2 id="Use-StrictMode-To-Find-Things-You-Did-By-Accident"><a href="#Use-StrictMode-To-Find-Things-You-Did-By-Accident" class="headerlink" title="Use StrictMode To Find Things You Did By Accident"></a><a href="https://blog.mindorks.com/use-strictmode-to-find-things-you-did-by-accident-in-android-development-4cf0e7c8d997#.l5tbilx16" target="_blank" rel="external">Use StrictMode To Find Things You Did By Accident</a></h2><p><code>StrictMode</code>是一个开发工具, 用于发现一些问题, 好让你来修复它们. </p>
<p>一个常用的情景是用来捕捉主线程的IO操作, 避免ANR弹框.</p>
<p>如何使用呢? 很简单, 只需要在应用启动时初始化一下, 可以是你的Application, Activity或其他组件的<code>onCreate()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</div><div class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</div><div class="line">                .detectDiskReads()</div><div class="line">                .detectDiskWrites()</div><div class="line">                .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></div><div class="line">                .penaltyLog()</div><div class="line">                .build());</div><div class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</div><div class="line">                .detectLeakedSqlLiteObjects()</div><div class="line">                .detectLeakedClosableObjects()</div><div class="line">                .penaltyLog()</div><div class="line">                .penaltyDeath()</div><div class="line">                .build());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以决定检测到问题时要发生什么, 比如:</p>
<ul>
<li><code>penaltyDeath()</code>: 整个进程崩溃.</li>
<li><code>penaltyDialog()</code>: 显示Dialog.</li>
<li><code>penaltyLog()</code>: 显示log.</li>
</ul>
<p>更多的处理见: <a href="https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html" target="_blank" rel="external">StrictMode.ThreadPolicy.Builder</a>.</p>
<p>StrictMode文档: <a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">StrictMode</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-material-stepper"><a href="#android-material-stepper" class="headerlink" title="android-material-stepper"></a><a href="https://github.com/stepstone-tech/android-material-stepper" target="_blank" rel="external">android-material-stepper</a></h2><p>一个Material steppers的库, 类似于配合ViewPager使用的indicators.</p>
<h2 id="AOSP-Support-Library-Contribution-Guide"><a href="#AOSP-Support-Library-Contribution-Guide" class="headerlink" title="AOSP Support Library Contribution Guide"></a><a href="https://android.googlesource.com/platform/frameworks/support/" target="_blank" rel="external">AOSP Support Library Contribution Guide</a></h2><p>Google开放了对support library的bug修改和文档更新.</p>
<h2 id="sqlite-android"><a href="#sqlite-android" class="headerlink" title="sqlite-android"></a><a href="https://github.com/requery/sqlite-android" target="_blank" rel="external">sqlite-android</a></h2><p>一个Android的SQLite库, 包含了最新的SQLite版本.</p>
<h2 id="Review-Reporter"><a href="#Review-Reporter" class="headerlink" title="Review-Reporter"></a><a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a></h2><p>Google Play反馈的自动提示, 支持提示到Slack和Jira.</p>
<h2 id="SimpleRecyclerView"><a href="#SimpleRecyclerView" class="headerlink" title="SimpleRecyclerView"></a><a href="https://github.com/jaychang0917/SimpleRecyclerView" target="_blank" rel="external">SimpleRecyclerView</a></h2><p>更简单好用的RecyclerView.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-243&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-243&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #243&quot;&gt;&lt;/a&gt;Android Weekly Issue #243&lt;/h1&gt;&lt;p&gt;February 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-243&quot;&gt;Android Weekly Issue #243&lt;/a&gt;&lt;br&gt;本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;&lt;br&gt;Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Service" scheme="http://mengdd.github.io/tags/Service/"/>
    
      <category term="Lottie" scheme="http://mengdd.github.io/tags/Lottie/"/>
    
      <category term="Mutability" scheme="http://mengdd.github.io/tags/Mutability/"/>
    
      <category term="Locales" scheme="http://mengdd.github.io/tags/Locales/"/>
    
      <category term="StrictMode" scheme="http://mengdd.github.io/tags/StrictMode/"/>
    
  </entry>
  
</feed>
