<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng&#39;s pages</title>
  <subtitle>Android developer and maybe other intersting things.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mengdd.github.io/"/>
  <updated>2017-03-08T06:56:54.000Z</updated>
  <id>http://mengdd.github.io/</id>
  
  <author>
    <name>Dandan Meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Weekly Notes Issue 247</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/</id>
    <published>2017-03-08T06:49:43.000Z</published>
    <updated>2017-03-08T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-247"><a href="#Android-Weekly-Issue-247" class="headerlink" title="Android Weekly Issue #247"></a>Android Weekly Issue #247</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-247" target="_blank" rel="external">Android Weekly Issue #247</a>.</p>
<p>本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;<br>RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Offline-support-“Try-again-later”-no-more"><a href="#Offline-support-“Try-again-later”-no-more" class="headerlink" title="Offline support: “Try again, later”, no more"></a><a href="https://medium.com/@yonatanvlevin/offline-support-try-again-later-no-more-afc33eba79dc#.p90haop40" target="_blank" rel="external">Offline support: “Try again, later”, no more</a></h2><p>作者他们的应用很好地处理了离线模式, 他们的基本原则是, 应用中不需要显示任何的loading控件.</p>
<p>在离线装填下, 在用户看来仍是可以提交请求的, 只不过出现了一个sync的小图标, 一旦当用户再次连上网络, 他的请求就会被发送出去.</p>
<p>然后作者讲了他们的程序设计:<br>首先是MVP结构, 使用了Content Provider包装的SQLite数据库. (此处列举了使用Content Provider的若干优点).</p>
<p>后台的同步工作, 他们选择了<code>GCMNetworkManager</code>.</p>
<p>基本流程是这样: 但用户提交请求, 首先存储在数据库中, 状态为pending, 然后后台service发送请求, 如果成功, 则更新数据库中的状态为synced; 如果失败, 则用<code>GcmNetworkManager</code>schedule一个task, 在网络连接恢复时再做一次尝试, 成功和失败的处理同上一步.</p>
<h2 id="Story-Code"><a href="#Story-Code" class="headerlink" title="Story Code"></a><a href="https://publicobject.com/2017/02/06/story-code/" target="_blank" rel="external">Story Code</a></h2><p>作者讲了一种方法, 以一种叙事的方式来写一个测试故事, 然后把它分成很多个小的测试cases. 这样可以用来驱动API的设计和其实现等.</p>
<h2 id="Testing-RxJava2"><a href="#Testing-RxJava2" class="headerlink" title="Testing RxJava2"></a><a href="https://www.infoq.com/articles/Testing-RxJava2" target="_blank" rel="external">Testing RxJava2</a></h2><p>本文介绍RxJava2中内置的关于测试的支持.</p>
<p>测试一个<code>Observable</code>可以用<code>TestObserver</code>; 测试<code>Flowable</code>可以用<code>TestSubscriber</code>.</p>
<p>如何测试在不同线程上的工作?<br>有几种选择:</p>
<ul>
<li>把Observable变为blocking的. -&gt; <code>blockingIterable()</code>, 缺点: 测试慢.</li>
<li>强制测试等待, 直到某个条件达成. -&gt; <code>awaitTerminalEvent()</code>. 此处还推荐一个库: <a href="https://github.com/awaitility/awaitility" target="_blank" rel="external">awaitility</a>.</li>
<li>把schedular换为一个immediate的. <code>RxJavaPlugins.setComputationSchedulerHandler(scheduler -&gt; Schedulers.trampoline());</code>. 需要最后reset一下, 可以用JUnit的TestRule来进行简化.</li>
</ul>
<p>用<code>TestScheduler</code>可以操纵时间, 进行白盒测试.<br>利用它在测试中可以精确控制时间过去了多少, 我们可以测试在中间的时间点的状态.<br>值得注意的是它控制的并不是真实的时间, 真实的时间还是立即就度过了的, 所以不会降低测试的速度.</p>
<p>我们也可以利用<code>TestRule</code>和<code>RxJavaPlugins</code>来把这个scheduler设置为测试时候要切换成的scheduler.</p>
<h2 id="Syncing-Changes"><a href="#Syncing-Changes" class="headerlink" title="Syncing Changes"></a><a href="http://tech.trello.com/syncing-changes/" target="_blank" rel="external">Syncing Changes</a></h2><p>Trello的离线模式实现文章系列之二. 基本的原则是在离线的时候把改动(deltas)存在数据库里, 之后有机会再同步给server.</p>
<p>本文介绍了他们如何计算delta和将它们按时间上传到服务器.</p>
<h2 id="Reactive-Apps-With-MVI-Part-4"><a href="#Reactive-Apps-With-MVI-Part-4" class="headerlink" title="Reactive Apps With MVI - Part 4"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-4" target="_blank" rel="external">Reactive Apps With MVI - Part 4</a></h2><p>MVI系列文章的第四篇. 本篇讲如何构建独立的UI单元.</p>
<p>作者认为Presenter之间的Parent-Child关系是一种code smell, 因为这样引入了一种强耦合的关系, 不好读, 不好维护.</p>
<p>你也许要问那Presenter之间如何通信呢? 答案是, 它们根本就不需要通信, 它们只需要更新和观测同一个Model(可以说业务逻辑), 让底层来通知它们事件的发生就可以了.</p>
<h2 id="Resources-for-Learning-how-to-Test-Android-Apps"><a href="#Resources-for-Learning-how-to-Test-Android-Apps" class="headerlink" title="Resources for Learning how to Test Android Apps"></a><a href="https://www.philosophicalhacker.com/post/some-resources-for-learning-how-to-test-android-apps/" target="_blank" rel="external">Resources for Learning how to Test Android Apps</a></h2><p>关于Android测试的相关资源分享.</p>
<h2 id="Unboxing-the-FlexboxLayout"><a href="#Unboxing-the-FlexboxLayout" class="headerlink" title="Unboxing the FlexboxLayout"></a><a href="https://blog.devcenter.co/unboxing-the-flexboxlayout-a7cfd125f023#.ulop7q1jz" target="_blank" rel="external">Unboxing the FlexboxLayout</a></h2><p>作者想实现一个动态关键字的流式布局, 可以根据parent的宽度自动换行.</p>
<p>他想了几种方法, 都不太合适, 所以最后选择了<code>FlexboxLayout</code>.</p>
<p>作者尝试了单独使用<code>FlexboxLayout</code>和 将<code>FlexboxLayoutManager()</code>设置为<code>RecyclerView</code>的Layout Manager两种办法来实现他想要的效果.</p>
<h2 id="Configuring-Android-Project-Version-Name-amp-Code"><a href="#Configuring-Android-Project-Version-Name-amp-Code" class="headerlink" title="Configuring Android Project - Version Name &amp; Code"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-version-name-code-b168952f3323#.v20pogayh" target="_blank" rel="external">Configuring Android Project - Version Name &amp; Code</a></h2><p>首先介绍了<a href="https://git-scm.com/docs/git-describe" target="_blank" rel="external">git-describe</a>命令.</p>
<p><code>git describe -tags</code>可以输出当前最近的tag和它之后有几个提交, 还有最新提交的hash.</p>
<p>作者建议使用这个库: <a href="https://github.com/ajoberstar/grgit" target="_blank" rel="external">grgit</a>, 写一个script-git-version.gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;org.ajoberstar:grgit:1.5.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import org.ajoberstar.grgit.Grgit</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    git = Grgit.open(currentDir: projectDir)</span><br><span class="line">    gitVersionName = git.describe()</span><br><span class="line">    gitVersionCode = git.tag.list().size()</span><br><span class="line">    gitVersionCodeTime = git.head().time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printVersion() &#123;</span><br><span class="line">    println(&quot;Version Name: $gitVersionName&quot;)</span><br><span class="line">    println(&quot;Version Code: $gitVersionCode&quot;)</span><br><span class="line">    println(&quot;Version Code Time: $gitVersionCodeTime&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主文件中apply这个文件.</p>
<p>执行printVersion task后会输出类似这样的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Version Name: 1.0-2-gdca226a</span><br><span class="line">Version Code: 2</span><br><span class="line">Version Code Time: 1484407970</span><br></pre></td></tr></table></figure>
<p>这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    dev &#123;</span><br><span class="line">        versionCode gitVersionCodeTime</span><br><span class="line">        versionName gitVersionName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prod &#123;</span><br><span class="line">        versionCode gitVersionCode</span><br><span class="line">        versionName gitVersionName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就自动生成了版本号和版本名.<br>你还可以进一步设计, 在版本名中包括分支名, 时间戳之类的.</p>
<h2 id="Workcation-App-Part-1-Fragment-custom-transition"><a href="#Workcation-App-Part-1-Fragment-custom-transition" class="headerlink" title="Workcation App - Part 1. Fragment custom transition"></a><a href="https://www.thedroidsonroids.com/blog/android/workcation-app-part-1-fragments-custom-transition/" target="_blank" rel="external">Workcation App - Part 1. Fragment custom transition</a></h2><p>作者的系列文章, 讨论他的项目中的动画的实现.<br>本文是第一篇, 介绍进入map的转场动画.</p>
<p>首先, 在map加载完毕后, 存一个截图放在缓存里, 然后用一个自定义的Transition来做缩放和渐变的动画, 最后把它设置为fragment的转场动画.</p>
<h2 id="Model-View-Presenter-Android-guidelines"><a href="#Model-View-Presenter-Android-guidelines" class="headerlink" title="Model-View-Presenter: Android guidelines"></a><a href="https://medium.com/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf#.s1d1l3dkt" target="_blank" rel="external">Model-View-Presenter: Android guidelines</a></h2><p>MVP实现的一些guidelines和最佳实践.</p>
<ul>
<li>1.View要无脑和被动.</li>
<li>2.Presenter要和framework无关, 不依赖任何Android的类.</li>
<li>3.写一个协议描述View和Presenter的交互.</li>
<li>4.定义命名规则来区分职责.</li>
<li>5.不要在Presenter里创建生命周期的回调方法.</li>
<li>6.Presenter和View是一对一的关系. 可以定义<code>attach()</code>和<code>detach()</code>或<code>start()</code>和<code>stop()</code>来关联和解除关联.</li>
<li>7.不要在Presenter里用Bundle保存状态. 因为不能包含Android的类.</li>
<li>8.不要保存Presenter. 因为Presenter并不是一个数据类.</li>
<li>9.在Model中提供cache来恢复View的状态.</li>
</ul>
<h2 id="5-Not-So-Obvious-Things-About-RxJava"><a href="#5-Not-So-Obvious-Things-About-RxJava" class="headerlink" title="5 Not So Obvious Things About RxJava"></a><a href="https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc#.dl9lo390z" target="_blank" rel="external">5 Not So Obvious Things About RxJava</a></h2><p>RxJava使用学习中的五点(RxJava1.2.6).</p>
<ul>
<li>什么时候用<code>map()</code>或者<code>flatMap()</code>.</li>
<li>不使用<code>Observable.create()</code>来创建observables. 使用其他更方便的方法, 比如<code>syncOnSubscribe</code>, <code>fromCallable</code>, <code>fromEmitter</code>.</li>
<li>如何处理Backpressure.</li>
<li>如和能让流不因为errors而停下来.</li>
<li>如何分享Observable到多个订阅者 -&gt; <code>share()</code>或<code>publish()</code>.</li>
</ul>
<h2 id="Simplify-Concurrency-with-Reactive-Modelling-on-Android"><a href="#Simplify-Concurrency-with-Reactive-Modelling-on-Android" class="headerlink" title="Simplify Concurrency with Reactive Modelling on Android"></a><a href="https://www.toptal.com/android/simplify-concurrency-reactive-modelling-android" target="_blank" rel="external">Simplify Concurrency with Reactive Modelling on Android</a></h2><p>用RxJava来处理Android上的并发和异步.<br>作者的文章中举了很详尽的各种例子.</p>
<h2 id="JUnit-5-Getting-Started"><a href="#JUnit-5-Getting-Started" class="headerlink" title="JUnit 5: Getting Started"></a><a href="https://blog.stylingandroid.com/junit-5-getting-started/" target="_blank" rel="external">JUnit 5: Getting Started</a></h2><p>使用JUnit 5做测试.<br>本文讲了一些在Android上setup可能会遇到的问题及怎么解决.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FastHub"><a href="#FastHub" class="headerlink" title="FastHub"></a><a href="https://github.com/k0shk0sh/FastHub" target="_blank" rel="external">FastHub</a></h2><p>一个Android的Github客户端.</p>
<h2 id="gradle-android-javafmt-plugin"><a href="#gradle-android-javafmt-plugin" class="headerlink" title="gradle-android-javafmt-plugin"></a><a href="https://github.com/f2prateek/gradle-android-javafmt-plugin" target="_blank" rel="external">gradle-android-javafmt-plugin</a></h2><p>一个gradle plugin, 自动format代码.</p>
<h2 id="HtmlCompat"><a href="#HtmlCompat" class="headerlink" title="HtmlCompat"></a><a href="https://github.com/Pixplicity/HtmlCompat" target="_blank" rel="external">HtmlCompat</a></h2><p>Android中Html类的兼容库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-247&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-247&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #247&quot;&gt;&lt;/a&gt;Android Weekly Issue #247&lt;/h1&gt;&lt;p&gt;March 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-247&quot;&gt;Android Weekly Issue #247&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;&lt;br&gt;RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="Offline" scheme="http://mengdd.github.io/tags/Offline/"/>
    
      <category term="Version Name" scheme="http://mengdd.github.io/tags/Version-Name/"/>
    
      <category term="Git" scheme="http://mengdd.github.io/tags/Git/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 246</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/</id>
    <published>2017-03-01T09:45:13.000Z</published>
    <updated>2017-03-01T09:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-246"><a href="#Android-Weekly-Issue-246" class="headerlink" title="Android Weekly Issue #246"></a>Android Weekly Issue #246</h1><p>February 26th, 2017<br><a href="http://androidweekly.net/issues/issue-246" target="_blank" rel="external">Android Weekly Issue #246</a><br>本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;<br>In-App Billing的实现; 如何用组合而非继承的方式来组织应用.</p>
<p>代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Shared-Element-Transitions-with-RecyclerView"><a href="#Shared-Element-Transitions-with-RecyclerView" class="headerlink" title="Shared Element Transitions with RecyclerView"></a><a href="http://mikescamell.com/shared-element-transitions-part-4-recyclerview/" target="_blank" rel="external">Shared Element Transitions with RecyclerView</a></h2><p>作者介绍了如何在RecyclerView中实现shared element动画.</p>
<h2 id="Sharing-files-through-Intents-part-2"><a href="#Sharing-files-through-Intents-part-2" class="headerlink" title="Sharing files through Intents (part 2)"></a><a href="https://medium.com/@quiro91/sharing-files-through-intents-part-2-fixing-the-permissions-before-lollipop-ceb9bb0eec3a#.ci4hqoauq" target="_blank" rel="external">Sharing files through Intents (part 2)</a></h2><p>之前介绍过因为Android 7 Nougat对文件权限的限制, 不能再依靠Intent来发送<code>file://uri</code>数据了, 应该用<code>FileProvider</code>. 但是你采用了这些新方法之后, 在一些Android的旧版本上有可能会遇到问题.</p>
<p>你可能遇到这种异常: <code>java.lang.SecurityException: Permission Denial</code>.</p>
<p>在API 16及以上, 系统有一个方法<code>migrateExtraStreamToClipData()</code>会根据你的Intent的action帮你迁移数据到ClipData, 并自动帮你加上权限. 见代码: <a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/content/Intent.java#9037" target="_blank" rel="external">Intent</a>. 但是之前的版本却没有.</p>
<p>所以解决办法是在原本的代码中加上这两句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    takePictureIntent.setClipData(ClipData.newRawUri(<span class="string">""</span>, photoURI));</span><br><span class="line">    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION|Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以要包括LOLLIPOP是因为<code>migrateExtraStreamToClipData()</code>这个方法是在preview版本之后才加上的, 所以不能保证所有的LOLLIPOP的设备都有这个方法.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1" class="headerlink" title="What Unit Tests are Trying to Tell us about Activities: Pt. 1"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt1/" target="_blank" rel="external">What Unit Tests are Trying to Tell us about Activities: Pt. 1</a></h2><p>“android-centric”的构架是指用Activity/Fragment作为屏幕基本构架单元的程序架构. 作者的系列文章要讨论为什么这种架构是对测试不友好的.</p>
<h2 id="Build-flexible-layouts-with-FlexboxLayout"><a href="#Build-flexible-layouts-with-FlexboxLayout" class="headerlink" title="Build flexible layouts with FlexboxLayout"></a><a href="https://android-developers.googleblog.com/2017/02/build-flexible-layouts-with.html" target="_blank" rel="external">Build flexible layouts with FlexboxLayout</a></h2><p>Google去年开源了<a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a>, 目的是将CSS中的<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">Flexible Layout module</a>引入到Android中来. 本文介绍了FlexboxLayout十分有用的几种情况, 附有demos.</p>
<h2 id="Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally"><a href="#Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally" class="headerlink" title="Making RxJava code tidier with doOnSubscribe and doFinally"></a><a href="https://medium.com/@ValCanBuild/making-rxjava-code-tidier-with-doonsubscribe-and-dofinally-3748f223d32d#.58wup7kxn" target="_blank" rel="external">Making RxJava code tidier with doOnSubscribe and doFinally</a></h2><p>使用<code>doOnSubscribe()</code>和<code>doFinally()</code>(RxJava 2)可以让RxJava的代码更加简洁.</p>
<ul>
<li><p><code>doOnSubscribe()</code>中的代码在subscribe的时候被调用.</p>
</li>
<li><p><code>doFinally()</code>在<code>Observable</code>调用<code>onError()</code>或<code>onCompleted()</code>之后, 或者流被下游放弃的时候调用.</p>
</li>
</ul>
<p>作者举的例子是用它们来show loading和hide loading, 这样它们也作为流的一部分, 而且subscriber可以只处理其他相关逻辑.</p>
<h2 id="Implementing-In-App-Billing-in-Android"><a href="#Implementing-In-App-Billing-in-Android" class="headerlink" title="Implementing In-App Billing in Android"></a><a href="https://hackernoon.com/implementing-in-app-billing-in-android-4896232c7d6b?gi=575af60d0286#.scggjiasz" target="_blank" rel="external">Implementing In-App Billing in Android</a></h2><p>关于Android In-App Billing的实现.</p>
<p>首先你会搜到<a href="https://developer.android.com/google/play/billing/index.html" target="_blank" rel="external">官方文档</a>.</p>
<p>作者在本文中介绍了其他的一些可选方案.</p>
<h2 id="Composite-Views-in-Android-Composition-over-Inheritance"><a href="#Composite-Views-in-Android-Composition-over-Inheritance" class="headerlink" title="Composite Views in Android: Composition over Inheritance"></a><a href="https://medium.com/@manuelvicnt/composite-views-in-android-composition-over-inheritance-4a7114609560#.n55x4611x" target="_blank" rel="external">Composite Views in Android: Composition over Inheritance</a></h2><p>作者介绍了这个库: <a href="https://github.com/passsy/CompositeAndroid" target="_blank" rel="external">CompositeAndroid</a>, 它解决了一个什么问题呢? </p>
<p>在App中, 如果多个Activity或者多个Fragment有一些共同的功能, 那么我们很可能就会创建一个基类Activity或者基类Fragment, 然后继承它. 当一些功能只被一些类共享时, 我们可能会继续不断创建基类, 产生一个无法维护的继承树.</p>
<p>解决的办法就是使用这个库, Activity只需要继承<code>CompositeActivity</code>, 所有共有的功能都会被当做插件加进来.<br>这样我们遵守了一个原则: <code>组合优于继承</code>.</p>
<p>但是这个库也有一些缺点: 它还在alpha阶段; 如果你使用了一些不常用的生命周期, 可能会有问题; 它是基于support library的, 所以如果这个库不更新support库的版本, 你也无法更新.</p>
<p>所以作者提出了一个简单的解决方案, 不使用CompositeAndroid. 文中举例展示了他的实现.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ShapeShifter"><a href="#ShapeShifter" class="headerlink" title="ShapeShifter"></a><a href="https://github.com/alexjlockwood/ShapeShifter" target="_blank" rel="external">ShapeShifter</a></h2><p>创建路径变形动画的一个web-app, 支持导出到<code>AnimatedVectorDrawable</code>.</p>
<h2 id="Shuttle"><a href="#Shuttle" class="headerlink" title="Shuttle"></a><a href="https://github.com/timusus/Shuttle" target="_blank" rel="external">Shuttle</a></h2><p>一个开源的本地音乐播放器.</p>
<h2 id="cortado"><a href="#cortado" class="headerlink" title="cortado"></a><a href="https://github.com/blipinsk/cortado" target="_blank" rel="external">cortado</a></h2><p>在Espresso上提供了一个抽象层, 使用更流畅.</p>
<h2 id="fragment-navigation-2-0"><a href="#fragment-navigation-2-0" class="headerlink" title="fragment-navigation-2.0"></a><a href="https://github.com/gyorgygabor/fragment-navigation-2.0" target="_blank" rel="external">fragment-navigation-2.0</a></h2><p>Fragment导航库.</p>
<h2 id="flexbox-layout"><a href="#flexbox-layout" class="headerlink" title="flexbox-layout"></a><a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a></h2><p>Flexbox for Android.</p>
<h2 id="kotlin-coroutines-retrofit"><a href="#kotlin-coroutines-retrofit" class="headerlink" title="kotlin-coroutines-retrofit"></a><a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="external">kotlin-coroutines-retrofit</a></h2><p>This is small library that provides Kotlin Coroutines suspending extension Call.await() for Retrofit 2.</p>
<h2 id="StatefulLayout"><a href="#StatefulLayout" class="headerlink" title="StatefulLayout"></a><a href="https://github.com/gturedi/StatefulLayout" target="_blank" rel="external">StatefulLayout</a></h2><p>一个内置包含loading, 错误, 空状态的布局.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-246&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-246&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #246&quot;&gt;&lt;/a&gt;Android Weekly Issue #246&lt;/h1&gt;&lt;p&gt;February 26th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-246&quot;&gt;Android Weekly Issue #246&lt;/a&gt;&lt;br&gt;本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;&lt;br&gt;In-App Billing的实现; 如何用组合而非继承的方式来组织应用.&lt;/p&gt;
&lt;p&gt;代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="Shared Element" scheme="http://mengdd.github.io/tags/Shared-Element/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="In-App Billing" scheme="http://mengdd.github.io/tags/In-App-Billing/"/>
    
      <category term="Music Player" scheme="http://mengdd.github.io/tags/Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Realm数据库使用指南</title>
    <link href="http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/"/>
    <id>http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/</id>
    <published>2017-02-27T09:32:23.000Z</published>
    <updated>2017-02-28T01:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Realm数据库使用指南"><a href="#Android-Realm数据库使用指南" class="headerlink" title="Android Realm数据库使用指南"></a>Android Realm数据库使用指南</h1><p>Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. </p>
<p>本文面向Android开发, 所以只讨论Java实现.<br>目前Realm Java的最新版本是2.3.1.</p>
<p>官方文档在此: <a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">realm java doc</a>, 花一个下午就可以基本过一遍, 之后随时查用. </p>
<p>我写了一个小程序<a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a>, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.</p>
<p>本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.</p>
<a id="more"></a>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>在项目的根build.gradle的文件中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;io.realm:realm-gradle-plugin:2.3.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在app的build.gradle文件中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;realm-android&apos;</span><br></pre></td></tr></table></figure></p>
<p>Done.</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Model类只要继承<code>RealmObject</code>即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">RealmObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String          name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             sessionId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Standard getters &amp; setters generated by your IDE…</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getSessionId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sessionId; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setSessionId</span><span class="params">(<span class="keyword">int</span> sessionId)</span> </span>&#123; <span class="keyword">this</span>.sessionId = sessionId; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>Model类中可以包含的字段类型包括基本数据类型(及它们的装箱类型)和Date类, 另外也可以包含<code>RealmObject</code>的子类或者是<code>RealmList&lt;? extends RealmObject&gt;</code>.</p>
<h3 id="字段性质"><a href="#字段性质" class="headerlink" title="字段性质"></a>字段性质</h3><p>在字段上加注解可以定义字段的性质:</p>
<p><code>@Required</code>表明字段非null.<br>原生类型和<code>RealmList</code>类型默认是非null的.<br><code>RealmObject</code>字段永远是可以为null的.</p>
<p><code>@Ignore</code>表示字段不会被存储.</p>
<p><code>@Index</code>加索引.</p>
<p><code>@PrimaryKey</code>加主键, 主键只能有一个, 主键默认加索引.</p>
<p>但是注意主键默认没有加<code>@Required</code>, 如果主键要求非null, 需要显式添加<code>@Required</code>.</p>
<h3 id="主键使用"><a href="#主键使用" class="headerlink" title="主键使用"></a>主键使用</h3><p>有主键才能使用<code>copyToRealmOrUpdate()</code>这个方法.<br>主键类型必须是String或者整型(byte, short, int, long)或者它们的装箱类型(Byte, Short, Integer, Long).</p>
<p>有主键的对象创建的时候不能使用<code>createObject(Class&lt;E&gt; clazz)</code>方法, 而应该使用<code>createObject(Class&lt;E&gt; clazz, Object primaryKeyValue)</code>附上主键.</p>
<p>或者用<br><code>copyToRealm(obj)</code>或<code>copyToRealmOrUpdate(obj)</code>, 前者遇到主键冲突时会崩溃, 后者遇到主键冲突会更新已有对象.</p>
<h3 id="自动更新的对象"><a href="#自动更新的对象" class="headerlink" title="自动更新的对象"></a>自动更新的对象</h3><p>Realm中的数据对象是自动更新(Auto-Updating)的, 对象一旦被查询出来, 后续发生的任何数据改变也会立即反映在结果中, 不需要刷新对象.</p>
<p>这是一个非常有用的特性, 结合数据变化的通知可以很方便地刷新UI.</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Realm model对象间可以很方便地建立关系.<br>你可以在Model中存储另一个对象的引用, 建立多对一的关系; 也可以存储一组对象<code>RealmList&lt;T&gt;</code>, 建立一对多或多对多的关系.</p>
<p><code>RealmList&lt;T&gt;</code>的getter永远也不会返回null, 它只会返回一个为空的list.<br>把这个字段设置为null可以清空这个list.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Realm在使用之前需要调用初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realm.init(context);</span><br></pre></td></tr></table></figure></p>
<p>建议把它放在Application的<code>onCreate()</code>里.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类: <code>RealmConfiguration</code>定义了Realm的创建配置.<br>最基本的配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</span><br></pre></td></tr></table></figure></p>
<p>它会创建一个叫<code>default.realm</code>的文件, 放在<code>Context.getFilesDir()</code>的目录下.</p>
<p>如果我们想自定义一个配置, 可以这样写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The RealmConfiguration is created using the builder pattern.</span></span><br><span class="line"><span class="comment">// The Realm file will be located in Context.getFilesDir() with name "myrealm.realm"</span></span><br><span class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</span><br><span class="line">  .name(<span class="string">"myrealm.realm"</span>)</span><br><span class="line">  .encryptionKey(getKey())</span><br><span class="line">  .schemaVersion(<span class="number">42</span>)</span><br><span class="line">  .modules(<span class="keyword">new</span> MySchemaModule())</span><br><span class="line">  .migration(<span class="keyword">new</span> MyMigration())</span><br><span class="line">  .build();</span><br><span class="line"><span class="comment">// Use the config</span></span><br><span class="line">Realm realm = Realm.getInstance(config);</span><br></pre></td></tr></table></figure></p>
<p>所以我们是可以有多个配置, 访问多个Realm实例的.</p>
<p>我们可以把配置设置为默认配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Realm.init(<span class="keyword">this</span>);</span><br><span class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</span><br><span class="line">Realm.setDefaultConfiguration(config);</span><br></pre></td></tr></table></figure></p>
<p>之后用<code>Realm.getDefaultInstance()</code>取到的就是这个默认配置对应的实例.</p>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>迁移的策略是通过config指定的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</span><br><span class="line">    .schemaVersion(<span class="number">2</span>) <span class="comment">// Must be bumped when the schema changes</span></span><br><span class="line">    .migration(<span class="keyword">new</span> MyMigration()) <span class="comment">// Migration to run instead of throwing an exception</span></span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></p>
<p>其中<code>MyMigration</code>实现了<code>RealmMigration</code>接口, 在<code>migrate()</code>方法中根据新旧版本号进行一步一步地升级.</p>
<p>具体例子见<a href="https://github.com/realm/realm-java/blob/master/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java" target="_blank" rel="external">Migration</a>.</p>
<p>开发的时候为了方便我用的是<code>.deleteRealmIfMigrationNeeded()</code>, 这样在需要数据库迁移的时候直接就删了数据重新开始了.</p>
<h2 id="关于Realm的close"><a href="#关于Realm的close" class="headerlink" title="关于Realm的close()"></a>关于Realm的close()</h2><p>一个打开的Realm实例会持有一些资源, 有一些是Java不能自动管理的, 所以就需要打开实例的代码负责在不需要的时候将其关闭.</p>
<p>Realm的instance是引用计数的(reference counted cache), 在同一个线程中获取后续实例是免费的, 但是底层的资源只有当所有实例被释放了之后才能释放. 也即你调用了多少次<code>getInstance()</code>, 就需要调用相应次数的<code>close()</code>方法.</p>
<p>比较建议的方法是在Activity或Fragment的生命周期中处理Realm实例的开启和释放:</p>
<ul>
<li>在Activity的<code>onCreate()</code>中<code>getInstance()</code>, <code>onDestroy()</code>中<code>close()</code>.</li>
<li>在Fragment的<code>onCreateView()</code>中<code>getInstance()</code>, <code>onDestroyView()</code>中<code>close()</code>.</li>
</ul>
<p>如果多个Fragment相关的都是同一个数据库实例, 那么在Activity中处理更好一些.</p>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>写操作一般的流程是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain a Realm instance</span></span><br><span class="line">Realm realm = Realm.getDefaultInstance();</span><br><span class="line"></span><br><span class="line">realm.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//... add or update objects here ...</span></span><br><span class="line"></span><br><span class="line">realm.commitTransaction();</span><br></pre></td></tr></table></figure></p>
<p>这里创建对象可以用<code>createObject()</code>方法或者<code>copyToRealm()</code>方法.<br>前者是先创建再set值, 后者是先new对象再更新数据库.</p>
<p>如果不想自己处理<code>beginTransaction()</code>, <code>cancelTransaction()</code>和<code>commitTransaction()</code>, 可以直接调用<code>realm.executeTransaction()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">realm.executeTransaction(<span class="keyword">new</span> Realm.Transaction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm realm)</span> </span>&#123;</span><br><span class="line">        User user = realm.createObject(User.class);</span><br><span class="line">        user.setName(<span class="string">"John"</span>);</span><br><span class="line">        user.setEmail(<span class="string">"john@corporation.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>因为transactions之间是互相阻塞的.<br>异步执行可以用这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">realm.executeTransactionAsync(<span class="keyword">new</span> Realm.Transaction() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm bgRealm)</span> </span>&#123;</span><br><span class="line">                User user = bgRealm.createObject(User.class);</span><br><span class="line">                user.setName(<span class="string">"John"</span>);</span><br><span class="line">                user.setEmail(<span class="string">"john@corporation.com"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnSuccess() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Transaction was a success.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnError() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Transaction failed and was automatically canceled.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这两个回调是Optional的, 它们只能在有Looper的线程调用.</p>
<p>注意: 这个方法的返回值对象可以用于在Activity/Fragment生命周期结束的时候取消未完的操作.</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>所有的写操作都要放在transaction中进行, 如上, 不同的操作只是其中具体方法不同.</p>
<p>删除操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RealmResults&lt;User&gt; users = getUsers();</span><br><span class="line"><span class="comment">// method 1:</span></span><br><span class="line">users.get(<span class="number">0</span>).deleteFromRealm();</span><br><span class="line"><span class="comment">// method 2:</span></span><br><span class="line">users.deleteFromRealm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete all</span></span><br><span class="line">users.deleteAllFromRealm();</span><br></pre></td></tr></table></figure></p>
<p>更新操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realm.copyToRealmOrUpdate(obj);</span><br></pre></td></tr></table></figure></p>
<p>注意: 这个方法需要Model有主键, 会更新obj的主键对应的对象, 如果不存在则新建对象.</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询可以流式地写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Or alternatively do the same all at once (the "Fluent interface"):</span></span><br><span class="line">RealmResults&lt;User&gt; result2 = realm.where(User.class)</span><br><span class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"John"</span>)</span><br><span class="line">                                  .or()</span><br><span class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"Peter"</span>)</span><br><span class="line">                                  .findAll();</span><br></pre></td></tr></table></figure></p>
<p>查询条件默认是and的关系, or则需要显式指定.</p>
<p>这个<code>RealmResults</code>是继承Java的<code>AbstractList</code>的, 是有序的集合, 可以通过索引访问.<br><code>RealmResults</code>永远不会为null, 当查不到结果时, 它的<code>size()</code>返回0.</p>
<h3 id="查询的线程"><a href="#查询的线程" class="headerlink" title="查询的线程"></a>查询的线程</h3><p>基本上所有的查询都是很快进行的, 足够在UI线程上同步进行.<br>所以绝大多数情况在UI线程上使用<code>findAll()</code>是没有问题的.</p>
<p>如果你要进行非常复杂的查询, 或者你的查询是在非常大的数据集上进行的, 你可以选择异步查询, 使用<code>findAllAsync()</code>.</p>
<h3 id="查询条件是一个集合-gt-in"><a href="#查询条件是一个集合-gt-in" class="headerlink" title="查询条件是一个集合 -&gt; in()"></a>查询条件是一个集合 -&gt; <code>in()</code></h3><p>如果想要查询的某一个字段的值是在一个集合中, 比如我有一个id的集合, 我现在想把id在这个集合中的项目全都查出来, 这就可以使用in操作符:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealmResults&lt;TodoList&gt; toDeleteLists = realm.where(TodoList.class).in(<span class="string">"id"</span>, ids).findAll();</span><br></pre></td></tr></table></figure></p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>查询的时候可以利用link或关系来查询, 比如一个Person类中含有一个<code>RealmList&lt;Dog&gt; dogs</code>的字段.<br>查询的时候可以这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RealmResults&lt;Person&gt; persons = realm.where(Person.class)</span><br><span class="line">                                .equalTo(<span class="string">"dogs.color"</span>, <span class="string">"Brown"</span>)</span><br><span class="line">                                .findAll();</span><br></pre></td></tr></table></figure></p>
<p>利用字段名<code>dogs.</code>来查询一个dog的属性, 再查出拥有这种特定属性dog的人.</p>
<p>但是反向地, 我们能不能查询主人是满足特定属性的人的所有dogs呢? 目前(2017.2.17)这种查询仍是不支持的. 这里有讨论:  <a href="https://github.com/realm/realm-java/issues/607" target="_blank" rel="external">realm-java-issue-607</a>.</p>
<p> 所以两种解决办法: 一是做两次查询; 二是在Dog类的model里加入对Person的引用.</p>
<h2 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h2><p>可以添加一个listener, 在数据改变的时候收到更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Realm realm;</span><br><span class="line">    <span class="keyword">private</span> RealmChangeListener realmListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      realm = Realm.getDefaultInstance();</span><br><span class="line">      realmListener = <span class="keyword">new</span> RealmChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(Realm realm)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ... do something with the updates (UI, etc.) ...</span></span><br><span class="line">        &#125;&#125;;</span><br><span class="line">      realm.addChangeListener(realmListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// Remove the listener.</span></span><br><span class="line">        realm.removeChangeListener(realmListener);</span><br><span class="line">        <span class="comment">// Close the Realm instance.</span></span><br><span class="line">        realm.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意listener需要在不用的时候删除掉. </p>
<p>可以用这样删除所有的listeners:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realm.removeAllChangeListeners();</span><br></pre></td></tr></table></figure></p>
<p>Listener不一定要和Realm绑定, 也可以和具体的<code>RealmObject</code>或者<code>RealmResults</code>绑定.<br>当Listener被调用的时候, 它绑定的对象是自动更新的, 不需要手动刷新.</p>
<h2 id="查看数据库的工具"><a href="#查看数据库的工具" class="headerlink" title="查看数据库的工具"></a>查看数据库的工具</h2><p>用Stetho不能直接查看Realm的数据库, 看不到.<br>需要用这个工具配置一下: <a href="https://github.com/uPhyca/stetho-realm" target="_blank" rel="external">stetho-realm</a>.<br>之后就可以在浏览器中查看Realm的数据库了.</p>
<p>(但是感觉这个工具不是很好用, 有时候不显示数据, 有时候显示的是旧数据.)</p>
<p>也可以用官方提供的Realm Browser来查看, 但是只有Mac版.<br>如何查看看这里: <a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803" target="_blank" rel="external">StackOverflow answer</a>.</p>
<h2 id="实际使用的感想和遇到的问题"><a href="#实际使用的感想和遇到的问题" class="headerlink" title="实际使用的感想和遇到的问题"></a>实际使用的感想和遇到的问题</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>建立Model之间的关系很方便也很直接, 查询的时候自动关联了其中的关系.</li>
<li>自动更新(Auto-Updating)的特性很有用, 不用再关心数据的刷新, 只用关心UI的刷新. </li>
</ul>
<p>比如一旦给Adapter绑定了数据, 之后的数据更新只需要在onChange()里面通知Adapter调用<code>notifyDataSetChanged()</code>即可.</p>
<p>当然我并没有用<code>RealmBaseAdapter</code>和<code>RealmRecyclerViewAdapter</code>, 估计这两个更好用, 官方有例子, 这里不再赘述.</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这里有的也不能说是缺点, 只是使用起来觉得不方便的地方. </p>
<ul>
<li>限制了创建对象和操作对象必须在同一个线程.<br>违反了这条会报错: <code>java.lang.IllegalStateException: Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.</code> 比如我们在UI线程查询出来的对象, 想要异步地删除或者更新, 我们必须在新的线程重新查询.</li>
<li>没有主键自增的功能, 见<a href="https://github.com/realm/realm-java/issues/469" target="_blank" rel="external">Issue #469</a>, 需要自己控制主键自增.</li>
<li>从List中删除了一项之后, 最后的一项会移动过来补到被删除的那一项原来的位置. 这是因为人家就是这么设计的<a href="http://stackoverflow.com/questions/37480785/realm-order-of-records-was-changed" target="_blank" rel="external">stackoverflow</a>. 默认情况下是没有排序的, 数据按照添加的顺序返回, 但是这并不是一种保证, 所以当删除了中间的元素, 后面的会补上这个位置, 以保证底层的数据是放在一起的. 解决办法就是指定一个排序规则.</li>
<li>查询出来的对象不可以临时改变其数据, 否则会报错: <code>java.lang.IllegalStateException: Changing Realm data can only be done from inside a transaction.</code></li>
<li>不支持反向link的查询. (见前面链式查询部分的介绍).</li>
<li>不支持级联删除. 即从数据库中删除一个对象的时候, 不会删除其中<code>RealmObject</code>子类或<code>RealmList</code>类型的字段在数据库中对应的数据. <a href="https://github.com/realm/realm-java/issues/1104" target="_blank" rel="external">Issue #1104</a>, <a href="https://github.com/realm/realm-java/issues/2717" target="_blank" rel="external">Issue #2717</a>. 这点也可以理解, 因为model之间的关系可能是多对多的. 所以需要实现级联删除的地方需要手动处理.</li>
<li>测试不方便: <code>RealmResults</code>对象即不能被mock也不能被new; 所有的Model对象也不能被mock. 因为<code>Mockito can only mock non-private &amp; non-final classes.</code></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/realm/realm-java" target="_blank" rel="external">Github repo realm-java</a></li>
<li><a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">Realm Java Doc</a></li>
</ul>
<p>我的练习Demo:</p>
<ul>
<li><a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Realm数据库使用指南&quot;&gt;&lt;a href=&quot;#Android-Realm数据库使用指南&quot; class=&quot;headerlink&quot; title=&quot;Android Realm数据库使用指南&quot;&gt;&lt;/a&gt;Android Realm数据库使用指南&lt;/h1&gt;&lt;p&gt;Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. &lt;/p&gt;
&lt;p&gt;本文面向Android开发, 所以只讨论Java实现.&lt;br&gt;目前Realm Java的最新版本是2.3.1.&lt;/p&gt;
&lt;p&gt;官方文档在此: &lt;a href=&quot;https://realm.io/docs/java/latest/&quot;&gt;realm java doc&lt;/a&gt;, 花一个下午就可以基本过一遍, 之后随时查用. &lt;/p&gt;
&lt;p&gt;我写了一个小程序&lt;a href=&quot;https://github.com/mengdd/TodoRealm&quot;&gt;TodoRealm&lt;/a&gt;, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.&lt;/p&gt;
&lt;p&gt;本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/categories/Android/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/categories/Android/Database/Realm/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/tags/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/tags/Realm/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 245</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/</id>
    <published>2017-02-22T07:35:47.000Z</published>
    <updated>2017-03-09T05:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-245"><a href="#Android-Weekly-Issue-245" class="headerlink" title="Android Weekly Issue #245"></a>Android Weekly Issue #245</h1><p>February 19th, 2017<br><a href="http://androidweekly.net/issues/issue-245" target="_blank" rel="external">Android Weekly Issue #245</a><br>本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);<br>用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中<code>Subscription</code>注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.</p>
<p>本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Write-awesome-unit-tests"><a href="#Write-awesome-unit-tests" class="headerlink" title="Write awesome unit tests"></a><a href="http://jeroenmols.com/blog/2017/02/16/unittests/" target="_blank" rel="external">Write awesome unit tests</a></h2><p>作者关于写好单元测试提供了三条简单的规则以及每条规则对应的一些建议.</p>
<h3 id="1-尽快尽早地跑测试"><a href="#1-尽快尽早地跑测试" class="headerlink" title="1. 尽快尽早地跑测试."></a>1. 尽快尽早地跑测试.</h3><p>尽量在每次改动之后都跑跑测试, 及早发现问题. 你的测试跑得越快你就越有可能经常跑它们.</p>
<p>为了让测试跑得很快:</p>
<ul>
<li>让测试跑在JVM上而不是设备上.</li>
<li>仅测试独立的逻辑模块.</li>
<li>不要包含UI, 数据库, 或者网络测试在你的主测试套件中.</li>
<li>测试中不要使用wait/sleep.</li>
</ul>
<h3 id="2-小并且关注点集中的测试"><a href="#2-小并且关注点集中的测试" class="headerlink" title="2. 小并且关注点集中的测试"></a>2. 小并且关注点集中的测试</h3><p>对每一个bug来说, 应该有且只有一个测试挂掉, 并且测试失败的原因应该能从测试方法名上看出来.</p>
<p>这样就迫使你每一个测试只检查一件事情, 导致你的测试小并且简单易懂, 也好维护. </p>
<p>实现tips:</p>
<ul>
<li>测试中只有一条assert/verify语句.</li>
<li>有更多的小测试, 而不是几个大测试.</li>
<li>测试的名字能清楚地描述失败的原因.</li>
</ul>
<h3 id="3-100-的可靠性"><a href="#3-100-的可靠性" class="headerlink" title="3. 100%的可靠性"></a>3. 100%的可靠性</h3><p>你的测试应该是完全值得信赖的, 不应该随机失败, 否则你将会对测试失去信任, 也不再会认真对待测试的失败.</p>
<p>所以你的测试应该是100%可靠的, 只在真的有问题的时候才失败.</p>
<p>建议是:</p>
<ul>
<li>在JVM上跑测试, 因为到设备的连接可能会中断.</li>
<li>在测试的时候mock网络通信.</li>
<li>把UI/集成测试移出你的单元测试套件.</li>
</ul>
<h2 id="Helping-to-Mock-Tests-in-Kotlin"><a href="#Helping-to-Mock-Tests-in-Kotlin" class="headerlink" title="Helping to Mock Tests in Kotlin"></a><a href="https://medium.com/@orogersilva/helping-androiddev-to-mock-tests-in-kotlin-ab3be5204559#.wetcvdvbt" target="_blank" rel="external">Helping to Mock Tests in Kotlin</a></h2><p>因为Kotlin中的类默认是<code>final</code>的, 要继承的话需要显示地声明<code>open</code>.</p>
<p>如果只是为了在单元测试中mock就要加个open吗? 不.</p>
<p>本篇文章就介绍如何如何mock Kotlin的对象, 而不用该它的声明.</p>
<p>首先, <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="external">Set up</a>; 然后, 使用这个库<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>.</p>
<p>文中详细介绍了使用细节, 以及对<code>any()</code>方法的讨论.</p>
<h2 id="How-and-Why-I-Kill-God-Objects"><a href="#How-and-Why-I-Kill-God-Objects" class="headerlink" title="How and Why I Kill God Objects"></a><a href="https://www.philosophicalhacker.com/post/towards-godless-android-development-how-and-why-i-kill-god-objects/" target="_blank" rel="external">How and Why I Kill God Objects</a></h2><p>在面向对象编程中, God Objects是应该被避免的.</p>
<p>在Android开发中, 最常见的一种God对象是Context. 本文介绍如何清除这个God对象, 同样的方法也可以用来处理其他对象.</p>
<p>首先说为什么要干掉Context?<br>在做TDD的过程中, 我们希望是面向接口的, 而且我们不应该mock非我们拥有的类型.<br>所以我们不应该直接mock外部的API, 而是应该创建一个自己的接口层.</p>
<p>作者发现很多类其实并不真正需要一个Context, 它们只是需要得到string或者存储的键值对.</p>
<p>之后文中举例介绍了如何通过定义接口摆脱Context.</p>
<h2 id="How-to-Make-Calls-and-Use-SMS-in-Android-Apps"><a href="#How-to-Make-Calls-and-Use-SMS-in-Android-Apps" class="headerlink" title="How to Make Calls and Use SMS in Android Apps"></a><a href="https://code.tutsplus.com/tutorials/how-to-make-calls-and-use-sms-in-android-apps--cms-28168" target="_blank" rel="external">How to Make Calls and Use SMS in Android Apps</a></h2><p><strong>如何拨打电话</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dial = <span class="string">"tel:"</span> + phoneNo;</span><br><span class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(dial)));</span><br></pre></td></tr></table></figure></p>
<p>(不需要权限).</p>
<p>如果想在app里直接拨出去电话, 需要权限<code>android.permission.CALL_PHON</code>, 并且改用<code>ACTION_CALL</code>.</p>
<p><strong>监控电话事件</strong>:</p>
<p>需要权限<code>android.permission.READ_PHONE_STATE</code>.来监控来电, 打出去的电话需要这个权限: <code>android.permission.PROCESS_OUTGOING_CALLS</code>.</p>
<p>具体实现就是在<code>TelephonyManager</code>注册监听器<code>PhoneStateListener</code>. 如果是在Activity中需要在对应的生命周期注销监听器.</p>
<p>如果需要后台监控, 则需要用到<code>BroadcastReceiver</code>, 过滤actions为<code>android.intent.action.PHONE_STATE</code>和<code>android.intent.action.NEW_OUTGOING_CALL</code>.<br>除了获取相应的电话号码, 还可以进一步阻止电话的拨出.</p>
<p><strong>发送短信</strong>:</p>
<p>发短信也是两种方法, 启动一个短信客户端程序, 或者直接从程序里发.</p>
<p>启动其他程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent smsIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, Uri.parse(<span class="string">"smsto:"</span> + phoneNo));</span><br><span class="line">smsIntent.putExtra(<span class="string">"sms_body"</span>, message);</span><br><span class="line">startActivity(smsIntent);</span><br></pre></td></tr></table></figure></p>
<p>自己发: 需要权限<code>android.permission.SEND_SMS</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmsManager smsManager = SmsManager.getDefault();</span><br><span class="line">smsManager.sendTextMessage(phoneNo, <span class="keyword">null</span>, message, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>注意Android 6.0以上的设备, 本文提到的这些危险权限都是需要动态请求的.</p>
<p><strong>收短信</strong>:<br>通过<code>BroadcastReceiver</code>, 需要权限<code>android.permission.RECEIVE_SMS</code>.</p>
<h2 id="Android-Things-Electricity-Monitoring-App"><a href="#Android-Things-Electricity-Monitoring-App" class="headerlink" title="Android Things - Electricity Monitoring App"></a><a href="https://riggaroo.co.za/android-things-electricity-monitoring-app/" target="_blank" rel="external">Android Things - Electricity Monitoring App</a></h2><p>作者分享了一个她的Android Things的应用(和Github repo), 可以监控她家的用电情况.</p>
<h2 id="Using-Keystore-system-to-store-and-retrieve-sensitive-information"><a href="#Using-Keystore-system-to-store-and-retrieve-sensitive-information" class="headerlink" title="Using Keystore system to store and retrieve sensitive information"></a><a href="https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454b#.nu3gw39qp" target="_blank" rel="external">Using Keystore system to store and retrieve sensitive information</a></h2><p>利用Android的Keystore来存储一些敏感信息.</p>
<h2 id="The-lost-droid-and-the-magic-Dagger"><a href="#The-lost-droid-and-the-magic-Dagger" class="headerlink" title="The lost droid and the magic Dagger"></a><a href="https://medium.com/rocknnull/the-lost-droid-and-the-magic-dagger-an-intro-to-dependency-injection-for-android-c686f4399117#.k5vgmxsjh" target="_blank" rel="external">The lost droid and the magic Dagger</a></h2><p>一篇依赖注入的介绍文章.<br>先介绍依赖注入是什么, 有什么优点, 接着介绍Dagger 2的使用.</p>
<h2 id="Wear-2-0-Match-Timer-–-Part-1"><a href="#Wear-2-0-Match-Timer-–-Part-1" class="headerlink" title="Wear 2.0: Match Timer – Part 1"></a><a href="https://blog.stylingandroid.com/wear-2-0-match-timer-part-1/" target="_blank" rel="external">Wear 2.0: Match Timer – Part 1</a></h2><p>作者把他的Wear应用升级到了Wear 2.0.</p>
<h2 id="ViewPager-without-Fragments"><a href="#ViewPager-without-Fragments" class="headerlink" title="ViewPager without Fragments"></a><a href="http://www.ottodroid.net/?p=523" target="_blank" rel="external">ViewPager without Fragments</a></h2><p>一些开发者可能不想选择Fragment, 这篇文章里有相关讨论: <a href="https://medium.com/square-corner-blog/advocating-against-android-fragments-81fd0b462c97#.e4k145h1b" target="_blank" rel="external">Advocating Against Android Fragments</a>.</p>
<p>作者推荐了一些在不用Fragment的情况下构建App的库: <a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">Conductor</a>, <a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>, <a href="https://github.com/square/flow" target="_blank" rel="external">flow</a>, <a href="https://github.com/square/mortar" target="_blank" rel="external">mortar</a>.</p>
<p>而本篇文章想要展示另一种方法, 既不用Fragment, 也不用上述的第三方库来构建一个App -&gt; 用ViewPager.</p>
<p>在PagerAdapter里管理了一个Presenter的List, 每一个Presenter管理一个View. 具体实现见原文.</p>
<h2 id="Stress-testing-Android-apps"><a href="#Stress-testing-Android-apps" class="headerlink" title="Stress-testing Android apps"></a><a href="https://android.jlelse.eu/stress-testing-android-apps-601311ebf590#.8kqor9m39" target="_blank" rel="external">Stress-testing Android apps</a></h2><p>之前大神JakeWharton有一个Sample App: <a href="https://github.com/JakeWharton/u2020" target="_blank" rel="external">JakeWharton/u2020</a>, 里面有一个debug drawer, 可以用来模拟不同的测试情形, 比如网络连接不好, 延迟, 或者网络错误等等.</p>
<p>作者他们的App也有一个类似的debug drawer, 他们讨论出了一个需要测试的情形的checklist:</p>
<ul>
<li>网络延迟</li>
<li>错误率</li>
<li>离线模式</li>
<li>屏幕旋转</li>
<li>应用在后台被杀死</li>
<li>应用升级</li>
<li>Key Bashing</li>
<li>多窗口模式 (Android N)</li>
<li>TransactionTooLargeException (Android N)</li>
</ul>
<p>作者甚至发现其中的一些项目组合起来测试非常有趣.</p>
<ul>
<li>网络延迟: 可结合方向改变/app后台被杀死测试.</li>
<li>错误率: 可以检查错误是否被正确处理并被报告.</li>
<li>离线模式: 关掉网络或者打开飞行模式, 检测正在执行的网络请求是否会引起崩溃; 是否正确通知了用户连接丢失了; 所有应该被cach的内容是否被正确cach了.</li>
<li>方向改变: 检查:  正在进行的请求会怎么办? app的状态是否被正确恢复了? 是否加载了当前方向对应的正确资源?</li>
<li>App在后台被杀死: 可以通过命令: <code>adb shell am kill YOUR_PACKAGNE_NAME</code>或者”Do not keep activities”来模拟这种情形. 相关阅读: <a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">Optimizing for Doze and App Standby</a>.</li>
<li>App更新: 升级后之前的数据是否被保存了?</li>
<li>Key Bashing: 剧烈的滑动和敲击可能产生一些奇怪的错误. 可以跑Monkey来测试一下你的应用: <code>adb shell monkey -p YOUR_PACKAGNE_NAME</code>.</li>
<li>多窗口模式(Android N): 列出了一些多窗口的测试项目, 详情见原文.</li>
<li>TransactionTooLargeException (Android N): Bundle中的数据不能太大, 超过限制, 在Android N以上会直接抛异常.</li>
</ul>
<h2 id="How-to-leak-memory-with-Subscriptions-in-RxJava"><a href="#How-to-leak-memory-with-Subscriptions-in-RxJava" class="headerlink" title="How to leak memory with Subscriptions in RxJava"></a><a href="https://medium.com/@scanarch/how-to-leak-memory-with-subscriptions-in-rxjava-ae0ef01ad361#.20w4lbkxq" target="_blank" rel="external">How to leak memory with Subscriptions in RxJava</a></h2><p>文中举了一个例子, 用RxJava结合MVP, 做网络请求, 更新UI, 很常见的使用情形. </p>
<p>在生命周期结束的时候调用RxJava的<code>Subscription.unsubscribe()</code>来注销, 以结束还在进行的网络请求.</p>
<p>看上去没有什么问题, 但是程序实际运行, 反复旋转屏幕进行测试, <code>StrictMode</code>报告出了Activity的<code>InstanceCountViolation</code>, dump memory的确看到了多个Activity的实例. 这是为什么呢? </p>
<p>作者深究原因, 发现<code>Subscriber</code>的子类存储的都是final的字段, 比如这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext;</span><br><span class="line">    <span class="keyword">final</span> Action1&lt;Throwable&gt; onError;</span><br><span class="line">    <span class="keyword">final</span> Action0 onCompleted;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionSubscriber</span><span class="params">(Action1&lt;? <span class="keyword">super</span> T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onNext = onNext;</span><br><span class="line">        <span class="keyword">this</span>.onError = onError;</span><br><span class="line">        <span class="keyword">this</span>.onCompleted = onCompleted;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为它们都是final的, 所以最后即便执行了注销操作, 也是没有办法把它们置为null的.</p>
<p>在生命周期结束的时候注销的操作是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">    view = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>subscription</code>是<code>subscribe()</code>方法的返回值, 被保存在Presenter的一个字段里, 它实际就是<code>Subscriber</code>对象.</p>
<p>这里的问题就是, 在<code>destroy()</code>之后, 该引用并没有被置为null, 导致了下面的引用链:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Presenter -&gt; subscription字段, 也即匿名的`Subscriber`对象 -&gt; final字段 -&gt; 对view的引用 -&gt; 对Activity的引用.</span><br></pre></td></tr></table></figure>
<p>从而造成了内存泄露.</p>
<p>解决的办法有两个:</p>
<ul>
<li>在<code>subscription.unsubscribe();</code>之后把<code>subscription</code>字段置为null.</li>
<li>使用<code>CompositeSubscription</code>, 它可以管理多个<code>Subscription</code>对象, 用它的<code>clear()</code>方法, 它会unsubscribe所有项目并且清除所有的引用.</li>
</ul>
<p>文后还列了相关的资料, 作者发现问题并寻找原因的思路很值得学习.</p>
<h2 id="Your-Unit-tests-might-not-be-as-reliable-as-you-thought"><a href="#Your-Unit-tests-might-not-be-as-reliable-as-you-thought" class="headerlink" title="Your Unit tests might not be as reliable as you thought"></a><a href="https://afterecho.uk/blog/your-unit-tests-might-not-be-as-reliable-as-you-thought.html" target="_blank" rel="external">Your Unit tests might not be as reliable as you thought</a></h2><p>作者举了个例子, 说明即便你的单元测试过了, 也不保证你的产品代码一定没问题.</p>
<p>他的例子是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat fmt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>);</span><br></pre></td></tr></table></figure></p>
<p>失败的原因是因为<code>XXX</code>格式是在Android 4.3以上才支持的, 它是在<code>java.text</code>包下的. 所以实际在高版本的设备还运行正常, 换个低版本的设备就崩溃了.</p>
<p>所以单元测试并不一定可靠, 因为跑单元测试的JVM和Android设备上的JVM有可能不一样.</p>
<h2 id="Airplane-Mode-Enabling-Trello-Mobile-Offline"><a href="#Airplane-Mode-Enabling-Trello-Mobile-Offline" class="headerlink" title="Airplane Mode: Enabling Trello Mobile Offline"></a><a href="http://tech.trello.com/sync-architecture/" target="_blank" rel="external">Airplane Mode: Enabling Trello Mobile Offline</a></h2><p>Trello移动移动现在有离线模式了. 作者介绍了他们的心路历程和架构变化. (比较简单和笼统的介绍).</p>
<h2 id="Self-guided-resources-to-Android-development"><a href="#Self-guided-resources-to-Android-development" class="headerlink" title="Self-guided resources to Android development"></a><a href="https://twitter.com/corey_latislaw/status/831624360175603713?s=03" target="_blank" rel="external">Self-guided resources to Android development</a></h2><p>这是一条Twitter, 作者分享了Android的学习资源. (可惜我打不开里面说的链接, 不知为何.)</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Alerter"><a href="#Alerter" class="headerlink" title="Alerter"></a><a href="https://github.com/Tapadoo/Alerter" target="_blank" rel="external">Alerter</a></h2><p>一个加在Window的Decor View上面的顶部提示栏, 类似于Snackbar和Toast一类的东东. 可定制外观, icon, 加多行字, 可添加click事件.</p>
<h2 id="sensey"><a href="#sensey" class="headerlink" title="sensey"></a><a href="https://github.com/nisrulz/sensey" target="_blank" rel="external">sensey</a></h2><p>一个好用的手势检测库.</p>
<h2 id="mkloader"><a href="#mkloader" class="headerlink" title="mkloader"></a><a href="https://github.com/nntuyen/mkloader" target="_blank" rel="external">mkloader</a></h2><p>好看并且平滑的自定义loading view. 目前支持好几种图案.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-245&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-245&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #245&quot;&gt;&lt;/a&gt;Android Weekly Issue #245&lt;/h1&gt;&lt;p&gt;February 19th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-245&quot;&gt;Android Weekly Issue #245&lt;/a&gt;&lt;br&gt;本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&amp;gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);&lt;br&gt;用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中&lt;code&gt;Subscription&lt;/code&gt;注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.&lt;/p&gt;
&lt;p&gt;本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Memory Leak" scheme="http://mengdd.github.io/tags/Memory-Leak/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Unit Test" scheme="http://mengdd.github.io/tags/Unit-Test/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="God Objects" scheme="http://mengdd.github.io/tags/God-Objects/"/>
    
      <category term="Call" scheme="http://mengdd.github.io/tags/Call/"/>
    
      <category term="SMS" scheme="http://mengdd.github.io/tags/SMS/"/>
    
      <category term="Keystore" scheme="http://mengdd.github.io/tags/Keystore/"/>
    
      <category term="Wear 2.0" scheme="http://mengdd.github.io/tags/Wear-2-0/"/>
    
      <category term="ViewPager" scheme="http://mengdd.github.io/tags/ViewPager/"/>
    
      <category term="Alert" scheme="http://mengdd.github.io/tags/Alert/"/>
    
      <category term="Gesture" scheme="http://mengdd.github.io/tags/Gesture/"/>
    
      <category term="Loading" scheme="http://mengdd.github.io/tags/Loading/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 244</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/</id>
    <published>2017-02-13T06:53:29.000Z</published>
    <updated>2017-02-13T07:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-244"><a href="#Android-Weekly-Issue-244" class="headerlink" title="Android Weekly Issue #244"></a>Android Weekly Issue #244</h1><p>February 12th, 2017<br><a href="http://androidweekly.net/issues/issue-244" target="_blank" rel="external">Android Weekly Issue #244</a><br>本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送<code>file:// URI</code>, 应用需要改用<code>FileProvider</code>实现原有功能.<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-Fragments-Tutorial-An-Introduction"><a href="#Android-Fragments-Tutorial-An-Introduction" class="headerlink" title="Android Fragments Tutorial: An Introduction"></a><a href="https://www.raywenderlich.com/149112/android-fragments-tutorial-introduction" target="_blank" rel="external">Android Fragments Tutorial: An Introduction</a></h2><p>一篇如何使用Fragments的讲解.</p>
<h2 id="Exporting-data-from-ClassyShark"><a href="#Exporting-data-from-ClassyShark" class="headerlink" title="Exporting data from ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-data-from-classyshark-e3cf3fe3fab8#.e2r76detr" target="_blank" rel="external">Exporting data from ClassyShark</a></h2><p>用<a href="https://github.com/google/android-classyshark" target="_blank" rel="external">ClassyShark</a>的APK dashboardA检查apk的问题(重复依赖, 过期依赖等).<br>本文介绍如何一次性导出全部的数据.</p>
<h2 id="Post-mortem-Firebase-vs-permissions"><a href="#Post-mortem-Firebase-vs-permissions" class="headerlink" title="Post-mortem : Firebase vs permissions"></a><a href="http://jeremie-martinez.com/2017/02/08/firebase-permissions/" target="_blank" rel="external">Post-mortem : Firebase vs permissions</a></h2><p>两周前Firebase发布了一个新功能: <a href="https://firebase.google.com/docs/app-indexing/android/personal-content" target="_blank" rel="external">Personal App Indexing</a>. 之后遇到了一些权限相关的问题, 本文讨论遇到的具体问题和解决方法, 然后他们发布了一个hotfix版本.</p>
<h2 id="Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails"><a href="#Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails" class="headerlink" title="Did you get one of these Google Play Developer Policy Violation Emails?"></a><a href="https://medium.com/@ali.muzaffar/did-you-get-one-of-these-google-play-developer-policy-violation-emails-6c529ceb082d#.glctt861o" target="_blank" rel="external">Did you get one of these Google Play Developer Policy Violation Emails?</a></h2><p>如果你的应用使用了一些”dangerous permissions”, 你需要在应用或者Google Play上附有privacy policy, 否则你就会收到Google Play的邮件.</p>
<p>作者他的Demo app也收到了这种邮件, 所以他提供了他的解决方法.</p>
<p>他找到了这个<a href="https://privacypolicytemplate.net/" target="_blank" rel="external">网站</a>, 这是他最后写成的<a href="https://gist.github.com/alphamu/c42f6c3fce530ca5e804e672fed70d78" target="_blank" rel="external">Gist</a>. 利用<a href="https://rawgit.com/" target="_blank" rel="external">RawGit</a>可以将github上的文件url转成用HTML显示的url. 之后在app中设置一个链接, 点击打开这个url就可以了.</p>
<h2 id="Pushing-the-limits-of-Kotlin-annotation-processing"><a href="#Pushing-the-limits-of-Kotlin-annotation-processing" class="headerlink" title="Pushing the limits of Kotlin annotation processing"></a><a href="https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711#.7crkk5m68" target="_blank" rel="external">Pushing the limits of Kotlin annotation processing</a></h2><p>关于Kotlin的annotation processor支持, 是一个很复杂的问题, 作者讨论了关于这个问题的历史进展和当前的局限性.</p>
<h2 id="Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming"><a href="#Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming" class="headerlink" title="Pull vs Push &amp; Imperative vs Reactive - Reactive Programming"></a><a href="http://www.uwanttolearn.com/android/pull-vs-push-imperative-vs-reactive-reactive-programming-android-rxjava2-hell-part2/" target="_blank" rel="external">Pull vs Push &amp; Imperative vs Reactive - Reactive Programming</a></h2><p>作者用浅显的代码例子解释了Pull和Push模式的区别, 一个是自己不停地查询读取, 另一个是等改变发生的时候收到通知. </p>
<h2 id="Why-Android-Testing-is-so-Hard-Historical-Edition"><a href="#Why-Android-Testing-is-so-Hard-Historical-Edition" class="headerlink" title="Why Android Testing is so Hard: Historical Edition"></a><a href="https://www.philosophicalhacker.com/post/why-android-testing-is-so-hard-historical-edition/" target="_blank" rel="external">Why Android Testing is so Hard: Historical Edition</a></h2><p>为什么Android项目这么难测试呢? 作者认为主要有三方面的历史原因: </p>
<ul>
<li>Performance方面的考虑. </li>
<li>对Android组件的误解.</li>
<li>Android和Unit Testing出现的时机.</li>
</ul>
<h2 id="Sharing-files-though-Intents-are-you-ready-for-Nougat"><a href="#Sharing-files-though-Intents-are-you-ready-for-Nougat" class="headerlink" title="Sharing files though Intents: are you ready for Nougat?"></a><a href="https://medium.com/@quiro91/sharing-files-though-intents-are-you-ready-for-nougat-70f7e9294a0b#.h3f06hxg7A" target="_blank" rel="external">Sharing files though Intents: are you ready for Nougat?</a></h2><p>Android 7 Nougat引入了一些文件系统的权限变化, 来增强安全性.</p>
<p>如果你已经把<code>targetSdkVersion</code>升到了24+, 并且你用Intent发送一个<code>file:// URI</code>, 你将会得到一个<code>FileUriExposedException</code>.</p>
<p>解决办法是使用<code>FileProvider</code>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="SlidingSquaresLoader"><a href="#SlidingSquaresLoader" class="headerlink" title="SlidingSquaresLoader"></a><a href="https://github.com/biodunalfet/SlidingSquaresLoader" target="_blank" rel="external">SlidingSquaresLoader</a></h2><p>一个有趣的动画方块的loading图案.</p>
<h2 id="ason"><a href="#ason" class="headerlink" title="ason"></a><a href="https://github.com/afollestad/ason" target="_blank" rel="external">ason</a></h2><p>一个JSON库, 简化了序列化, 更易使用.</p>
<h2 id="Intro-To-RxJava"><a href="#Intro-To-RxJava" class="headerlink" title="Intro-To-RxJava"></a><a href="https://github.com/PareshMayani/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a></h2><p>上一期有一篇文章提过的RxJava练习项目.</p>
<h2 id="chuck"><a href="#chuck" class="headerlink" title="chuck"></a><a href="https://github.com/jgilfelt/chuck" target="_blank" rel="external">chuck</a></h2><p>An in-app HTTP inspector for Android OkHttp clients.<br>截取请求和响应, 点击通知可以查看UI显示.</p>
<h2 id="android-parcelable-intellij-plugin-kotlin"><a href="#android-parcelable-intellij-plugin-kotlin" class="headerlink" title="android-parcelable-intellij-plugin-kotlin"></a><a href="https://github.com/nekocode/android-parcelable-intellij-plugin-kotlin" target="_blank" rel="external">android-parcelable-intellij-plugin-kotlin</a></h2><p>为kotlin的类生成Parcelable代码的插件.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-244&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-244&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #244&quot;&gt;&lt;/a&gt;Android Weekly Issue #244&lt;/h1&gt;&lt;p&gt;February 12th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-244&quot;&gt;Android Weekly Issue #244&lt;/a&gt;&lt;br&gt;本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送&lt;code&gt;file:// URI&lt;/code&gt;, 应用需要改用&lt;code&gt;FileProvider&lt;/code&gt;实现原有功能.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="ClassyShark" scheme="http://mengdd.github.io/tags/ClassyShark/"/>
    
      <category term="Permission" scheme="http://mengdd.github.io/tags/Permission/"/>
    
      <category term="Privacy Policy" scheme="http://mengdd.github.io/tags/Privacy-Policy/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 243</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/</id>
    <published>2017-02-07T04:52:37.000Z</published>
    <updated>2017-02-07T04:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-243"><a href="#Android-Weekly-Issue-243" class="headerlink" title="Android Weekly Issue #243"></a>Android Weekly Issue #243</h1><p>February 5th, 2017<br><a href="http://androidweekly.net/issues/issue-243" target="_blank" rel="external">Android Weekly Issue #243</a><br>本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;<br>Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Constraint-Layout-Animations"><a href="#Constraint-Layout-Animations" class="headerlink" title="Constraint Layout Animations"></a><a href="http://www.uwanttolearn.com/android/constraint-layout-animations-dynamic-constraints-ui-java-hell/" target="_blank" rel="external">Constraint Layout Animations</a></h2><p>作者举例说明了如何在Java代码中动态地改变约束条件, 从而使<code>ConstraintLayout</code>中的View动起来.</p>
<h2 id="Android-Testing-with-Kotlin"><a href="#Android-Testing-with-Kotlin" class="headerlink" title="Android Testing with Kotlin"></a><a href="http://fernandocejas.com/2017/02/03/android-testing-with-kotlin/" target="_blank" rel="external">Android Testing with Kotlin</a></h2><p>如果你想逐渐地迁移代码到Kotlin, 你可以从测试开始, 这样你也不用更改产品环境的代码, 就先熟悉了Kotlin.</p>
<p>本篇文章详细讲了如何setup, 然后写各种测试:</p>
<h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>需要JUnit, <a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>和<a href="https://github.com/MarkusAmshove/Kluent" target="_blank" rel="external">Kluent</a>.</p>
<p>对于在<code>setUp()</code>方法中初始化的变量, 需要标记为<code>lateinit</code>.</p>
<h3 id="Robolectric测试"><a href="#Robolectric测试" class="headerlink" title="Robolectric测试"></a>Robolectric测试</h3><p>作者封装了一个基类, 把所有Mockito相关的东东包装在里面. 这样在Mockito升级的时候不用更改每一个测试文件.</p>
<h3 id="Espresso测试"><a href="#Espresso测试" class="headerlink" title="Espresso测试"></a>Espresso测试</h3><p>同样, 这里作者也创建了几个基类, 将所有Espresso相关的东东包装起来.</p>
<h2 id="Practical-challenges-for-RxJava-learners"><a href="#Practical-challenges-for-RxJava-learners" class="headerlink" title="Practical challenges for RxJava learners"></a><a href="https://medium.com/@sergii/practical-challenges-for-rxjava-learners-1821c454de9#.9icb22hrr" target="_blank" rel="external">Practical challenges for RxJava learners</a></h2><p>作者建议通过实践来检验和学习RxJava技能, 之前他用过这个Repo: <a href="https://github.com/Froussios/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a>, 现在他又新推出了这个<a href="https://github.com/sergiiz/RxBasicsKata" target="_blank" rel="external">Repo</a>, 针对RxJava2的.</p>
<h2 id="Coordinators-solving-a-problem-you-didn’t-even-know-you-had"><a href="#Coordinators-solving-a-problem-you-didn’t-even-know-you-had" class="headerlink" title="Coordinators: solving a problem you didn’t even know you had"></a><a href="https://hackernoon.com/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf#.mcx15cssl" target="_blank" rel="external">Coordinators: solving a problem you didn’t even know you had</a></h2><p>Square发布了一个库叫<a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a>, 这个库是用来分离View中的一些控制逻辑.</p>
<h2 id="Review-Reporter-Part-1"><a href="#Review-Reporter-Part-1" class="headerlink" title="Review-Reporter: Part 1 "></a><a href="https://medium.com/azimolabs/review-reporter-part-1-connecting-to-google-play-8abd37edc49f#.a0s5gx66j" target="_blank" rel="external">Review-Reporter: Part 1 </a></h2><p>作者他们做了一个小项目: <a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a>, 可以自动把Google Play上新的用户回复发到slack, firebase, Jira上. 本篇文章讲了他们是怎么做的.</p>
<h2 id="How-to-test-a-Service"><a href="#How-to-test-a-Service" class="headerlink" title="How to test a Service"></a><a href="https://medium.com/@josiassena/android-how-to-unit-test-a-service-67e5340544a5#.qg3751nxg" target="_blank" rel="external">How to test a Service</a></h2><p>Android官方文档介绍了如何测试Service: <a href="https://developer.android.com/training/testing/integration-testing/service-testing.html" target="_blank" rel="external">Testing your Service</a>. 本文作者介绍他是如何做的.</p>
<h2 id="Introducing-Lottie"><a href="#Introducing-Lottie" class="headerlink" title="Introducing Lottie"></a><a href="https://medium.com/airbnb-engineering/introducing-lottie-4ff4a0afac0e#.e7wojthmp" target="_blank" rel="external">Introducing Lottie</a></h2><p><a href="http://airbnb.design/lottie/" target="_blank" rel="external">Lottie</a>是一个iOS, Android和React Native的库, 可以实时渲染After Effects的动画, 让native的应用像使用静态文件一样简单地使用复杂的动画.</p>
<h2 id="Learning-to-use-and-abuse-Mutability"><a href="#Learning-to-use-and-abuse-Mutability" class="headerlink" title="Learning to use and abuse Mutability"></a><a href="https://medium.com/google-developer-experts/learning-to-use-and-abuse-mutability-b4c71576299#.diungnuw6" target="_blank" rel="external">Learning to use and abuse Mutability</a></h2><blockquote>
<p>An immutable class is a class whose state cannot be changed once it has been created.</p>
</blockquote>
<p>这篇文章分享了作者关于Java中的mutability &amp; immutability的一些想法.</p>
<h2 id="A-Curious-Case-of-Multiple-Locales"><a href="#A-Curious-Case-of-Multiple-Locales" class="headerlink" title="A Curious Case of Multiple Locales"></a><a href="https://blog.egorand.me/a-curious-case-of-multiple-locales/" target="_blank" rel="external">A Curious Case of Multiple Locales</a></h2><p>Android N的一个新feature就是可以在设置中选择多种语言.</p>
<p>比如一个用户, 她会说意大利语和德语, 她使用的是一个低于Android 7的手机, 她把手机语言设置为意大利语.</p>
<p>有一个app, 支持两种语言, 默认是英语, 然后还支持德语.</p>
<p>但是这个应用在这个用户的手机上打开时, 发现自己并不支持意大利语, 于是会显示英语(默认)而不是德语, 因为应用又不知道这个用户还会德语.</p>
<p>后来用户把手机升级了, 用了Android 7的系统, 她发现可以设置支持多种语言, 于是, 于是她设置了两种语言, 意大利语和德语. 在新手机上装之前那个app的时候发现现在显示的是德语.</p>
<p>因为应用现在知道了用户还会讲德语.</p>
<p>现在, 假设我们需要进行向下兼容以前的旧版本设备, 我们加入了<code>appcompat-v7</code>, 用户更新后, 英语又出现了. </p>
<p>这是因为<code>appcompat-v7</code>中含有一些意大利语的资源, 因为所有的资源在build的时候都会merge到一起, 所以现在app也包含了这些资源. 系统认为现在app能够支持用户的第一语言了, 然后就查找对应的资源, 当然没查找到, 于是就使用了默认资源, 也就是英语.</p>
<p>我们有什么办法可以解决这个问题呢? 答案是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  resConfigs &quot;en&quot;, &quot;de&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就告诉了Gradle我们只支持这两种语言, 所有其他的资源都不会被打包进来.</p>
<p>验证的方法是使用Android Studio的<code>Analyze APK</code>来查看string有多少种configurations.</p>
<h2 id="Use-StrictMode-To-Find-Things-You-Did-By-Accident"><a href="#Use-StrictMode-To-Find-Things-You-Did-By-Accident" class="headerlink" title="Use StrictMode To Find Things You Did By Accident"></a><a href="https://blog.mindorks.com/use-strictmode-to-find-things-you-did-by-accident-in-android-development-4cf0e7c8d997#.l5tbilx16" target="_blank" rel="external">Use StrictMode To Find Things You Did By Accident</a></h2><p><code>StrictMode</code>是一个开发工具, 用于发现一些问题, 好让你来修复它们. </p>
<p>一个常用的情景是用来捕捉主线程的IO操作, 避免ANR弹框.</p>
<p>如何使用呢? 很简单, 只需要在应用启动时初始化一下, 可以是你的Application, Activity或其他组件的<code>onCreate()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                .detectDiskReads()</span><br><span class="line">                .detectDiskWrites()</span><br><span class="line">                .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></span><br><span class="line">                .penaltyLog()</span><br><span class="line">                .build());</span><br><span class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">                .detectLeakedSqlLiteObjects()</span><br><span class="line">                .detectLeakedClosableObjects()</span><br><span class="line">                .penaltyLog()</span><br><span class="line">                .penaltyDeath()</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以决定检测到问题时要发生什么, 比如:</p>
<ul>
<li><code>penaltyDeath()</code>: 整个进程崩溃.</li>
<li><code>penaltyDialog()</code>: 显示Dialog.</li>
<li><code>penaltyLog()</code>: 显示log.</li>
</ul>
<p>更多的处理见: <a href="https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html" target="_blank" rel="external">StrictMode.ThreadPolicy.Builder</a>.</p>
<p>StrictMode文档: <a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">StrictMode</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-material-stepper"><a href="#android-material-stepper" class="headerlink" title="android-material-stepper"></a><a href="https://github.com/stepstone-tech/android-material-stepper" target="_blank" rel="external">android-material-stepper</a></h2><p>一个Material steppers的库, 类似于配合ViewPager使用的indicators.</p>
<h2 id="AOSP-Support-Library-Contribution-Guide"><a href="#AOSP-Support-Library-Contribution-Guide" class="headerlink" title="AOSP Support Library Contribution Guide"></a><a href="https://android.googlesource.com/platform/frameworks/support/" target="_blank" rel="external">AOSP Support Library Contribution Guide</a></h2><p>Google开放了对support library的bug修改和文档更新.</p>
<h2 id="sqlite-android"><a href="#sqlite-android" class="headerlink" title="sqlite-android"></a><a href="https://github.com/requery/sqlite-android" target="_blank" rel="external">sqlite-android</a></h2><p>一个Android的SQLite库, 包含了最新的SQLite版本.</p>
<h2 id="Review-Reporter"><a href="#Review-Reporter" class="headerlink" title="Review-Reporter"></a><a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a></h2><p>Google Play反馈的自动提示, 支持提示到Slack和Jira.</p>
<h2 id="SimpleRecyclerView"><a href="#SimpleRecyclerView" class="headerlink" title="SimpleRecyclerView"></a><a href="https://github.com/jaychang0917/SimpleRecyclerView" target="_blank" rel="external">SimpleRecyclerView</a></h2><p>更简单好用的RecyclerView.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-243&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-243&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #243&quot;&gt;&lt;/a&gt;Android Weekly Issue #243&lt;/h1&gt;&lt;p&gt;February 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-243&quot;&gt;Android Weekly Issue #243&lt;/a&gt;&lt;br&gt;本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;&lt;br&gt;Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Service" scheme="http://mengdd.github.io/tags/Service/"/>
    
      <category term="Lottie" scheme="http://mengdd.github.io/tags/Lottie/"/>
    
      <category term="Mutability" scheme="http://mengdd.github.io/tags/Mutability/"/>
    
      <category term="Locales" scheme="http://mengdd.github.io/tags/Locales/"/>
    
      <category term="StrictMode" scheme="http://mengdd.github.io/tags/StrictMode/"/>
    
  </entry>
  
  <entry>
    <title>Say Hello to ConstraintLayout</title>
    <link href="http://mengdd.github.io/Android/2017/02/06/hello-constraint-layout/"/>
    <id>http://mengdd.github.io/Android/2017/02/06/hello-constraint-layout/</id>
    <published>2017-02-06T07:49:03.000Z</published>
    <updated>2017-02-06T07:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConstraintLayout介绍"><a href="#ConstraintLayout介绍" class="headerlink" title="ConstraintLayout介绍"></a>ConstraintLayout介绍</h2><p><code>ConstraintLayout</code>让你可以在很平的view结构(没有多层布局嵌套)中构建一个复杂的布局结构. 有点像<code>RelativeLayout</code>, 所有的view都是根据它和兄弟View和父layout的关系布局的, 但是它比<code>RelativeLayout</code>要更加灵活, 在Layout Editor中也更加好用.</p>
<a id="more"></a>
<p>在Layout Editor中你可以直接靠拖拽来构建<code>ConstraintLayout</code>.</p>
<p>为了在<code>ConstraintLayout</code>中定义一个view的位置, 你必须给view加上两条或多条约束(constraints). 每一条约束代表了一种和其他View(或parent, 或不可见的guideline)之间的联系或者对齐关系.</p>
<p>每一条约束都规定了这个view沿着水平或竖直轴的一个位置, 所以每个View在每个轴上都必须至少有一条约束(但是通常需要更多).</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>首先确认下载support库, 在<code>Tools &gt; Android &gt; SDK Manager</code>的<code>SDK Tools</code>tab下:<br>展开<code>Support Repository</code>, check <code>ConstraintLayout for Android</code>和<code>Solver for ConstraintLayout</code>.<br>Check <code>Show Package Details</code>, 显示版本信息.</p>
<p>比如当前我最新的版本信息是1.0.0-beta4, 我在module的build.gradle中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后点击Sync即可.</p>
<h2 id="转换已有布局"><a href="#转换已有布局" class="headerlink" title="转换已有布局"></a>转换已有布局</h2><p>我们可以新建布局, 然后让它的根节点是<code>android.support.constraint.ConstraintLayout</code>.</p>
<p>除此之外, 我们还可以直接转换已有布局.<br>打开Layout, 切换到<code>Design</code>tab, 然后在<code>Component Tree</code>窗口, 右击布局然后选择最底部的<code>Convert XXXLayout(这里是你布局节点的类型) to ConstraintLayout</code>.</p>
<h2 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h2><p>在Design模式下, 从Palette窗口中拖一个View到editor中去. 当你把一个View加入到ConstraintLayout中之后, 它会展示出一个bounding box, 四角的四个小方块用来拖拽调节大小, 每一个边上都有一个小圆点用来建立约束.<br>这些小方块和小圆点都被称为<code>handles</code>.</p>
<p>点击View, 然后点击并拖住一个约束handle, 把它拖拽到一个可用的anchor point(另一个View的边缘, layout的边缘, 或者一个guideline).当你松手的时候, 约束就生效了. (有一个默认的<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-margins" target="_blank" rel="external">margin</a>)</p>
<p>有几个规则:</p>
<ul>
<li>每个View都至少有两条约束: 一个水平的一个竖直的.</li>
<li>你只能在共享平面的handle和anchor point之间建立约束. 比如一个View的竖直平面只能和另一个竖直平面建立约束, baseline也只能和其他baseline建立约束.</li>
<li>每一个handle只能被用来建立一个约束, 但是你可以对一个anchor point建立(来自多个View的)多个约束.</li>
</ul>
<p>要删掉一个约束, 只需要选择这个view, 点击那个对应的handle.</p>
<p>如果你给同一个View加了两个相反的约束, 约束的线条就会变成弹簧状, 来显示两个相反方向的约束.  当View内容的尺寸固定或者是wrap的时候, 在这种情况下View就会在两个约束下居中显示, 如果你想让它展开, 那么就应该修改它的尺寸为<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-size" target="_blank" rel="external">Any Size</a>; 如果你想要保持当前的尺寸, 你可以<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-constraint-bias" target="_blank" rel="external">调节约束的权重</a>.</p>
<p>通常情况下可以加的有这几种约束:</p>
<ul>
<li>Parent constraint: View的边和Parent的边的关系.</li>
<li>Position constraint: View之间水平和竖直的位置关系, 拖动可改变相对的margin距离.</li>
<li>Alignment constraint: View边之间的对齐关系, 对齐后可以调节偏移量.</li>
<li>Baseline alignment constraint: 对齐View的text baseline, 要创建baseline约束, 首先选中View, 然后把鼠标放在baseline上方两秒钟, 等它变白就可以拖到另一个baseline去建立约束了.</li>
<li>Constrain to a guideline: 可以创建竖直或水平的guideline, 然后往上绑定约束, guideline对于用户来说是不可见的. 放置guideline的时候可以根据相对于layout边缘dp单位的距离, 也可以根据百分比.<br>Toolbar上有Guideline的按钮, 点击可选择水平或竖直.<br>点击Guideline尾部的小圆圈可以切换它到底是根据距离还是百分比放置的, 然后拖动它放到一个想要的位置.</li>
</ul>
<h2 id="使用Autoconnect和Infer-Constraints"><a href="#使用Autoconnect和Infer-Constraints" class="headerlink" title="使用Autoconnect和Infer Constraints"></a>使用Autoconnect和Infer Constraints</h2><p>当打开<code>Autoconnect</code>模式之后, 每一个<strong>新加的View</strong>都会自动创建约束. Autoconnect模式默认是关闭的.</p>
<p>点击<code>Infer Constraints</code>会给layout中当前所有的View创建约束, 这是一个一次性的action. 它会选择建立最有效的约束, 所以它可能会建立离得很远的两个view之间的约束. 不像Autoconnect模式开启下, 只给新加的View建立约束, 并且只选择最近的元素.</p>
<h2 id="调整View大小"><a href="#调整View大小" class="headerlink" title="调整View大小"></a>调整View大小</h2><p>可以通过拖拽View四个角的handles来改变View的大小, 但是这样生成的是hard-coded的尺寸, 对于适配来讲这样是不好的.</p>
<p>你可以点击View然后在Properties窗口编辑尺寸.<br><img src="/images/constraint-layout-properties-window.png" alt="ConstraintLayout Properties Window"></p>
<p>有三种尺寸模式:</p>
<ul>
<li>Wrap Content:  用<code>&gt;&gt;&gt;</code>图形表示.</li>
<li>Any Size: 用弹簧图形表示. 说明View会一直展开到满足所有约束, 实际的值是0dp. 可以把它想象成”match constraints”. 如果此时只有单边的约束, 那么它只展开到能放下自己的内容为止. </li>
<li>Fixed: 用图形<code>|-|</code>表示, 固定尺寸.</li>
</ul>
<p>可以通过点击图形符号来切换这些模式.</p>
<p>注意: 在<code>ConstraintLayout</code>中的View中不应该使用<code>match_parent</code>, 而是用”Any Size”(0dp).</p>
<h2 id="调整约束偏差"><a href="#调整约束偏差" class="headerlink" title="调整约束偏差"></a>调整约束偏差</h2><p>当你给一个View的对立两边都添加了约束, 而View的尺寸是fixed或者wrap_content, 那么默认情况下View就会居中显示在两个anchor point之间(bias=50%).<br>你可以通过拖拽View或者在Properties窗口中拖拽bias slider来改变它的偏移权重.</p>
<h2 id="调节View边距"><a href="#调节View边距" class="headerlink" title="调节View边距"></a>调节View边距</h2><p>可以在toolbar上点击默认边距(8)来修改.</p>
<p>注意这个修改只对修改后新添加的View生效.</p>
<p>每一个View的边距都可以通过Properties窗口修改: 点击约束线条上的margin数字.</p>
<p>注意提供的值都是8的倍数, 以确保你遵循了Material Design的建议.</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="https://developer.android.com/training/constraint-layout/index.html" target="_blank" rel="external">Build a Responsive UI with ConstraintLayout</a></li>
<li>Demo: <a href="https://github.com/mengdd/HelloConstraintLayout" target="_blank" rel="external">HelloConstraintLayout</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ConstraintLayout介绍&quot;&gt;&lt;a href=&quot;#ConstraintLayout介绍&quot; class=&quot;headerlink&quot; title=&quot;ConstraintLayout介绍&quot;&gt;&lt;/a&gt;ConstraintLayout介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConstraintLayout&lt;/code&gt;让你可以在很平的view结构(没有多层布局嵌套)中构建一个复杂的布局结构. 有点像&lt;code&gt;RelativeLayout&lt;/code&gt;, 所有的view都是根据它和兄弟View和父layout的关系布局的, 但是它比&lt;code&gt;RelativeLayout&lt;/code&gt;要更加灵活, 在Layout Editor中也更加好用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 242</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/03/android-weekly-notes-issue-242/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/03/android-weekly-notes-issue-242/</id>
    <published>2017-02-03T09:27:49.000Z</published>
    <updated>2017-02-03T09:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-242"><a href="#Android-Weekly-Issue-242" class="headerlink" title="Android Weekly Issue #242"></a>Android Weekly Issue #242</h1><p>January 29th, 2017<br><a href="http://androidweekly.net/issues/issue-242" target="_blank" rel="external">Android Weekly Issue #242</a><br>本期内容包括: Android中常用的设计模式; 基于NoSQL的移动对象数据库–ObjectBox; MVC, MVP和MVVM模式的讨论; 一个Google Actions的Java SDK; 一个带黏性动画的FAB的实现; Kotlin 1.1的新功能; Firebase的实时数据库讨论; Model-View-Intent模式应用的实现; 关于实现gradient时透明颜色的使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Common-Design-Patterns-for-Android"><a href="#Common-Design-Patterns-for-Android" class="headerlink" title="Common Design Patterns for Android"></a><a href="https://www.raywenderlich.com/109843/common-design-patterns-for-android" target="_blank" rel="external">Common Design Patterns for Android</a></h2><h3 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h3><ul>
<li>Builder</li>
<li>依赖注入: 举例: Dagger </li>
<li>Singleton</li>
</ul>
<h3 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h3><ul>
<li>Adapter</li>
<li>Facade: 举例: Retrofit</li>
</ul>
<h3 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h3><ul>
<li>Command: 举例: EventBus</li>
<li>Observer: 举例: RxAndroid</li>
<li>Model View Controller</li>
<li>Model View ViewModel</li>
</ul>
<h2 id="ObjectBox-The-new-Mobile-Database"><a href="#ObjectBox-The-new-Mobile-Database" class="headerlink" title="ObjectBox - The new Mobile Database"></a><a href="http://greenrobot.org/announcement/introducing-objectbox-beta/" target="_blank" rel="external">ObjectBox - The new Mobile Database</a></h2><p><a href="http://greenrobot.org/objectbox/" target="_blank" rel="external">ObjectBox</a>是greenrobot发布的一个新的mobile对象数据库, 主要关注于性能, 据说superfast.</p>
<p>在ObjectBox中, 主要是把NoSQL技术迁移到mobile端使用. 之前他们创建的greenDAO, 据说是最快的Object/Relational Mapper (ORM) for Android and SQLite.</p>
<p>ObjectBox的5大特性:</p>
<ul>
<li>Superfast.</li>
<li>Object API.</li>
<li>Instant unit testing.</li>
<li>Simple threading.</li>
<li>No manual schema migrations.</li>
</ul>
<p><a href="http://greenrobot.org/objectbox/documentation/" target="_blank" rel="external">文档</a><br><a href="https://github.com/greenrobot/ObjectBoxExamples" target="_blank" rel="external">Demo</a></p>
<h2 id="MVC-vs-MVP-vs-MVVM-on-Android"><a href="#MVC-vs-MVP-vs-MVVM-on-Android" class="headerlink" title="MVC vs. MVP vs. MVVM on Android"></a><a href="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/" target="_blank" rel="external">MVC vs. MVP vs. MVVM on Android</a></h2><p>MVC, MVP, MVVM模式的介绍.</p>
<h2 id="Building-Google-Actions-with-Java"><a href="#Building-Google-Actions-with-Java" class="headerlink" title="Building Google Actions with Java"></a><a href="https://medium.com/@froger_mcs/building-google-actions-with-java-696cffedbd01#.d6uuck1ho" target="_blank" rel="external">Building Google Actions with Java</a></h2><p>非官方的<a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google Actions Java SDK</a>, 本文为开发者介绍其如何使用.</p>
<h2 id="Android-Gooey-FAB-is-EASY"><a href="#Android-Gooey-FAB-is-EASY" class="headerlink" title="Android Gooey FAB is EASY"></a><a href="http://myhexaville.com/2017/01/18/android-gooey-fab-easy/" target="_blank" rel="external">Android Gooey FAB is EASY</a></h2><p>实现一个胶黏的FAB.<br>首先作者展示了效果, 点击FAB, 从中逐渐分离中一个新的小按钮. 作者讨论了这种效果可能的实现方法:</p>
<ul>
<li>用bitmap的mesh transformation, 这是能高度自定义的.</li>
<li>创建自定义View, 自己绘制Path.</li>
<li>最简单的办法: 用Animated Vector Drawable, 即本文所介绍的方法.</li>
</ul>
<p>源码在这里: <a href="https://github.com/IhorKlimov/Android-Animations" target="_blank" rel="external">Android-Animations</a></p>
<h2 id="What-Comes-in-Kotlin-1-1-for-Android-Developers"><a href="#What-Comes-in-Kotlin-1-1-for-Android-Developers" class="headerlink" title="What Comes in Kotlin 1.1 for Android Developers?"></a><a href="https://blog.elpassion.com/what-comes-in-kotlin-1-1-for-android-developers-831d559f780f#.wlmujxwi3" target="_blank" rel="external">What Comes in Kotlin 1.1 for Android Developers?</a></h2><p>Kotlin 1.1的新features.</p>
<ul>
<li>Coroutines. 改善Kotlin中的异步编程.</li>
<li>Type Aliases. 可以为类型起别名.</li>
<li>Inlining Property Accessors.</li>
<li>Less Restrictive Inheritance. sealed类的子类不用再放在同一个类中; 非final的类现在也可以继承data类了.</li>
<li>Destructuring and Underscores.</li>
<li>Methods Count. 作者对比了一个sample程序, 用kotlin的不同版本, 发现用最新版kotlin确实会增加一些方法数, 但它仍然算是一个很轻量的库.</li>
</ul>
<h2 id="Understanding-the-Power-of-Firebase-Security-Rules"><a href="#Understanding-the-Power-of-Firebase-Security-Rules" class="headerlink" title="Understanding the Power of Firebase Security Rules"></a><a href="https://medium.com/@dftaiwo/understanding-the-power-of-firebase-security-rules-part-1-f46aae773a24#.cw34j1v2z" target="_blank" rel="external">Understanding the Power of Firebase Security Rules</a></h2><p>作者要写关于Firebase的一系列文章: 第一和第二篇主要介绍实时数据库的规则, 第三篇介绍Storage的规则.</p>
<p>关于实时数据库规则的主要内容包括:</p>
<ul>
<li>识别你的用户.</li>
<li>控制数据访问权限.</li>
<li>验证创建, 更新和删除操作.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-3"><a href="#Reactive-apps-with-Model-View-Intent-Part-3" class="headerlink" title="Reactive apps with Model-View-Intent - Part 3"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-3" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 3</a></h2><p>上一篇中介绍了用Model-View-Intent模式来构建一个单相数据流的简单屏. 这篇文章接着讲如何用MVI和state reducer来构建一个复杂屏.</p>
<p>(感觉太复杂了我没仔细看).</p>
<h2 id="Android-Dev-Tip-3-A-gotcha-with-color-transparent"><a href="#Android-Dev-Tip-3-A-gotcha-with-color-transparent" class="headerlink" title="Android Dev Tip #3: A gotcha with color/transparent"></a><a href="https://android.jlelse.eu/android-dev-tip-3-99da754151ad#.rarx8jafm" target="_blank" rel="external">Android Dev Tip #3: A gotcha with color/transparent</a></h2><p>如果你要在xml中用gradient写一个渐变色, 对于透明色<code>@android:color/transparent.</code>的使用一定要注意.</p>
<p>透明色<code>@android:color/transparent.</code>的色值是<code>#00000000</code>, 所以它实际上代表的是一个透明的黑色.</p>
<p>在gradient进行插值的时候, 会对ARGB每一个通道的色值都分别进行插值然后叠加.</p>
<p>所以如果你想要保持颜色不变, 只改变透明度, 也即Alpha通道的值, 你就应该把透明色中RGB颜色设置为和原来的颜色一样. </p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PreviewSeekBar"><a href="#PreviewSeekBar" class="headerlink" title="PreviewSeekBar"></a><a href="https://github.com/rubensousa/PreviewSeekBar" target="_blank" rel="external">PreviewSeekBar</a></h2><p>一个带Preview的SeekBar.</p>
<h2 id="AndroidTestingBox"><a href="#AndroidTestingBox" class="headerlink" title="AndroidTestingBox"></a><a href="https://roroche.github.io/AndroidTestingBox/" target="_blank" rel="external">AndroidTestingBox</a></h2><p>一个Android项目, 用于实验各种测试工具.</p>
<h2 id="FunctionalRx2"><a href="#FunctionalRx2" class="headerlink" title="FunctionalRx2"></a><a href="https://github.com/pakoito/FunctionalRx2" target="_blank" rel="external">FunctionalRx2</a></h2><p>a collection of constructs to simplify a functional programming approach to Java and Android.</p>
<h2 id="gradle-completion"><a href="#gradle-completion" class="headerlink" title="gradle-completion"></a><a href="https://github.com/eriwen/gradle-completion" target="_blank" rel="external">gradle-completion</a></h2><p>gradle的tab补全, for bash and zsh.</p>
<h2 id="ObjectBox"><a href="#ObjectBox" class="headerlink" title="ObjectBox"></a><a href="https://github.com/greenrobot/ObjectBox" target="_blank" rel="external">ObjectBox</a></h2><p>超快的移动平台对象数据库.</p>
<h2 id="superlightstack"><a href="#superlightstack" class="headerlink" title="superlightstack"></a><a href="https://github.com/nextdimension/superlightstack" target="_blank" rel="external">superlightstack</a></h2><p>一个轻量级的库, 用于创建View的stack, 并处理转换和状态维持.</p>
<h2 id="PicassoFaceDetectionTransformation"><a href="#PicassoFaceDetectionTransformation" class="headerlink" title="PicassoFaceDetectionTransformation"></a><a href="https://github.com/aryarohit07/PicassoFaceDetectionTransformation" target="_blank" rel="external">PicassoFaceDetectionTransformation</a></h2><p>一个配合picasso使用的图像转换库, 可以根据人脸检测自动确定范围而切图.</p>
<p>(Readme中附有配合Glide和Fresco使用的版本.)</p>
<h2 id="cwac-netsecurity"><a href="#cwac-netsecurity" class="headerlink" title="cwac-netsecurity"></a><a href="https://github.com/commonsguy/cwac-netsecurity" target="_blank" rel="external">cwac-netsecurity</a></h2><p>This library contains a backport of the Android 7.0 network security configuration subsystem.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-242&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-242&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #242&quot;&gt;&lt;/a&gt;Android Weekly Issue #242&lt;/h1&gt;&lt;p&gt;January 29th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-242&quot;&gt;Android Weekly Issue #242&lt;/a&gt;&lt;br&gt;本期内容包括: Android中常用的设计模式; 基于NoSQL的移动对象数据库–ObjectBox; MVC, MVP和MVVM模式的讨论; 一个Google Actions的Java SDK; 一个带黏性动画的FAB的实现; Kotlin 1.1的新功能; Firebase的实时数据库讨论; Model-View-Intent模式应用的实现; 关于实现gradient时透明颜色的使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="MVC" scheme="http://mengdd.github.io/tags/MVC/"/>
    
      <category term="MVVM" scheme="http://mengdd.github.io/tags/MVVM/"/>
    
      <category term="Color" scheme="http://mengdd.github.io/tags/Color/"/>
    
      <category term="Design Patterns" scheme="http://mengdd.github.io/tags/Design-Patterns/"/>
    
      <category term="ObjectBox" scheme="http://mengdd.github.io/tags/ObjectBox/"/>
    
      <category term="Google Actions" scheme="http://mengdd.github.io/tags/Google-Actions/"/>
    
      <category term="FAB" scheme="http://mengdd.github.io/tags/FAB/"/>
    
      <category term="Model-View-Intent" scheme="http://mengdd.github.io/tags/Model-View-Intent/"/>
    
      <category term="Gradient" scheme="http://mengdd.github.io/tags/Gradient/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 241</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/25/android-weekly-notes-issue-241/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/25/android-weekly-notes-issue-241/</id>
    <published>2017-01-25T01:40:01.000Z</published>
    <updated>2017-01-25T01:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-241"><a href="#Android-Weekly-Issue-241" class="headerlink" title="Android Weekly Issue #241"></a>Android Weekly Issue #241</h1><p>January 22nd, 2017<br><a href="http://androidweekly.net/issues/issue-241" target="_blank" rel="external">Android Weekly Issue #241</a><br>本期内容包括: 经典导航模式Master/Detail的设计和实现; APK的大小讨论和增量下载大小的预估工具; Model-View-Intent模式的讨论和实现; 分多个modules对build时间的影响; 测试中能够利用的一些Android特有的接缝设计(manifest, build config, resource).</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Case-Study-Master-Detail-Pattern-Revisited"><a href="#Case-Study-Master-Detail-Pattern-Revisited" class="headerlink" title="Case Study. Master/Detail Pattern Revisited"></a><a href="http://goneremote.io/master-detail-pattern/" target="_blank" rel="external">Case Study. Master/Detail Pattern Revisited</a></h2><p>Master/Detail是一种经典的导航流, master屏包含一个list, detail显示某一项的详细信息. <a href="https://developer.android.com/training/implementing-navigation/descendant.html" target="_blank" rel="external">Android Doc</a>.</p>
<p>作者讲了他适配多种屏幕(包括平板)的设计, 以及简单的实现.</p>
<h2 id="Tracking-app-update-sizes"><a href="#Tracking-app-update-sizes" class="headerlink" title="Tracking app update sizes"></a><a href="https://medium.com/google-developers/tracking-app-update-sizes-1a1f57634f7b#.v2ecs8u4t" target="_blank" rel="external">Tracking app update sizes</a></h2><p>以前作者有一系列的<a href="https://medium.com/google-developers/smallerapk-part-1-anatomy-of-an-apk-da83c25e7003#.dv2tfqdyq" target="_blank" rel="external">文章</a>讲过apk的组成以及如何减少apk的大小.</p>
<p>事实上app的大小可以分下面四种:</p>
<ul>
<li>提交到Google Play的APK文件大小.</li>
<li>初始的下载大小.</li>
<li>在设备上的安装大小.</li>
<li>更新下载大小.</li>
</ul>
<p>之前的一些文章可能都在讨论如何减少初始的大小, 但是大多数情况用户可能只安装你的应用一次, 之后就只是从Play Store更新, 所以应用的更新大小也是很重要的.</p>
<p>事实上Android Studio(2.2+)改善了打包apk的机制, (<a href="https://android-developers.googleblog.com/2016/11/understanding-apk-packaging-in-android-studio-2-2.html" target="_blank" rel="external">apk packaging</a>), 使得每一个build都尽可能地相似, 这样Play Store就能计算出一个较小的delta更新. 另外, Play Store也引入了新的算法, 比如最近的<a href="https://android-developers.googleblog.com/2016/12/saving-data-reducing-the-size-of-app-updates-by-65-percent.html" target="_blank" rel="external">File-By-File patching</a>, 同样也有效减小了更新的大小.</p>
<p>所以我们要注意的就是不要介入和干扰当前Android Studio和Play Store的这些优化, 比如不要用自定义的ZIP加密设置来自己压缩APK. 也不要用Zopfli来再次压缩APK.</p>
<p>Play Store上会显示应用的下载大小, 如果用户已经安装了, 则显示的是更新大小.</p>
<p>对于开发者来说, 如果能在发布前知道这些信息就更好了, 所以作者他们开源了这个库: <a href="https://github.com/googlesamples/apk-patch-size-estimator" target="_blank" rel="external">apk-patch-size-estimator</a></p>
<p>这是一个命令行的工具, 可以集成到CI里, 也可以手动比较两个apk文件.</p>
<p>这个工具实现了当前Play Store的算法, 可以帮你估计出初始的apk下载大小和更新下载大小.</p>
<p>(注意下载大小和apk文件大小不同因为Play Store可能会做进一步压缩.)</p>
<p>同样, Android Studio中也有一个图形化的 APK Analyzer工具, 可以做apk的比较, 让你看到到底是哪一部分的尺寸增长了.</p>
<h2 id="Reactive-Apps-with-Model-View-Intent-Part-2"><a href="#Reactive-Apps-with-Model-View-Intent-Part-2" class="headerlink" title="Reactive Apps with Model-View-Intent - Part 2"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-2" target="_blank" rel="external">Reactive Apps with Model-View-Intent - Part 2</a></h2><p>上一篇文章讨论了一个好的Model层可以解决很多问题. 这篇来介绍<code>Model-View-Intent</code>模式.</p>
<h3 id="Model-View-Intent模式"><a href="#Model-View-Intent模式" class="headerlink" title="Model-View-Intent模式"></a>Model-View-Intent模式</h3><p>Model-View-Intent模式是在一个JavaScript的framework <code>cycle.js</code>中提出的.</p>
<p><img src="/images/view-model-intent.png" alt="view-model-intent"></p>
<ul>
<li><code>intent()</code>: 这个方法接收用户输入, 然后输出将会作为参数传给<code>model()</code>.</li>
<li><code>model()</code>: 接收<code>intent()</code>的输出作为自己的输入, 来操纵Model, 这个方法的输出是一个新的Model(状态变化). 所以它不应该更新一个已经存在的Model. 因为我们想要不可变性. 注意这里是唯一一个允许创建新Model的地方.</li>
<li><code>view()</code>: 接收<code>model()</code>方法返回的model作为输入, 然后将其展示出来.</li>
</ul>
<h3 id="用RxJava连接"><a href="#用RxJava连接" class="headerlink" title="用RxJava连接"></a>用RxJava连接</h3><p>我们希望数据流是单向的, 于是我们用了RxJava, 它很适合这种基于事件的编程, 在这里主要是UI事件.</p>
<p>作者之后举了一个实现的例子, 在这个例子中他们的Model层用了ViewState后缀. <code>SearchInteractor</code>用来执行搜索, 返回的结果是<code>Observable&lt;SearchViewState&gt;</code>.</p>
<p>这个模式中定义的View接口里包含了<code>render()</code>方法, 根据传入的状态model显示UI; 这个View接口其实还包含了<code>intent()</code>的方法, 返回的是一个<code>Observable</code>, UI中用了<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>.</p>
<p>最后一步就是, 如何将View的intent和业务逻辑联系起来呢? 这里用到了一个额外的组件: <code>Presenter</code>.</p>
<p>这个Presenter看起来像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchPresenter</span> <span class="keyword">extends</span> <span class="title">MviBasePresenter</span>&lt;<span class="title">SearchView</span>, <span class="title">SearchViewState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SearchInteractor searchInteractor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindIntents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable&lt;SearchViewState&gt; search =</span><br><span class="line">        intent(SearchView::searchIntent)</span><br><span class="line">            .switchMap(searchInteractor::search) <span class="comment">// I have used flatMap() in the video above, but switchMap() makes more sense here</span></span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line"></span><br><span class="line">    subscribeViewState(search, SearchView::render);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MviBasePresenter</code>是<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>中的一个类.<br>这个类做的事情就是当View第一次attach到Prensenter上时, 调用<code>bindIntent()</code>方法将来自view的intent绑定到业务逻辑上, 只有第一次会绑定, 当View再次attach时不会发生.</p>
<p>而<code>subscribeViewState()</code>方法则处理了定于管理, 避免内存泄露(具体原因见原文).</p>
<h2 id="How-modularization-affects-build-time-of-an-Android-application"><a href="#How-modularization-affects-build-time-of-an-Android-application" class="headerlink" title="How modularization affects build time of an Android application"></a><a href="https://medium.com/@nikita.kozlov/how-modularisation-affects-build-time-of-an-android-application-43a984ce9968#.hzgv3h6cm" target="_blank" rel="external">How modularization affects build time of an Android application</a></h2><p>一个Android应用至少有一个application module, build这个module之后得到一个.apk文件.</p>
<p>application module之间不能相互依赖, 它只能依赖于library, build library module的结果是得到一个.aar(Android Archive Library)文件.</p>
<p>build的过程可以粗略分为5个阶段:</p>
<ul>
<li>1.准备依赖.</li>
<li>2.Merge资源和manifest.</li>
<li>3.编译. 从annotation processors开始, 把源码编译成字节码.</li>
<li>4.后处理. 所有以<code>transform</code>开头的gradle tasks都属于这个阶段. 其中最重要的是<code>transformClassesWithMultidexlist</code>和<code>transformClassesWithDex</code>, 它们生成了.dex文件.</li>
<li>5.打包发布. 对library来说是生成.aar, 对application来说是生成.apk.</li>
</ul>
<p>我们都知道gradle只有在输入变化了的情况下才会重跑task. 而且如果一个module没有变化, 也不会被重新build, 那么就出现了一种假设: 多个module应用的增量build要比单个module的快, 因为只有被改变了的module才会重新编译.</p>
<p>作者想验证这种假设是否正确.<br>他用的工具就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradle assembleDebug --profile</span><br></pre></td></tr></table></figure></p>
<p>做了一系列实验之后证明这个假设还是有道理的.</p>
<p>实验过程中的一些发现:</p>
<p>1.当应用被拆分为多个modules之后, 改变application module中的代码, build时间会减少; 但是library中的代码, build时间反而会增加. 这是因为library build的时候debug和release的tasks都执行了(并不知道为什么).</p>
<p>当library module被这样添加的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile project(path: &apos;:app2&apos;)</span><br><span class="line">    compile project(path: &apos;:app3&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管app当前的build type是什么, app永远依赖的是library的release版本.</p>
<p>这是一个Gradle当前的限制. 参见<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Library-Publication" target="_blank" rel="external">Library-Publication</a>.</p>
<p>幸运的是, 我们可以改变这一行为:<br>首先在library中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        defaultPublishConfig &apos;release&apos;</span><br><span class="line">        publishNonDefault true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让它也可以发布debug版.<br>在app中依赖的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugCompile project(path: &apos;:app2&apos;, configuration: &quot;debug&quot;)</span><br><span class="line">    releaseCompile project(path: &apos;:app2&apos;, configuration: &quot;release&quot;)</span><br><span class="line"></span><br><span class="line">    debugCompile project(path: &apos;:app3&apos;, configuration: &quot;debug&quot;)</span><br><span class="line">    releaseCompile project(path: &apos;:app3&apos;, configuration: &quot;release&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样debug和release都只依赖各自对应版本的library了.</p>
<p>2.不管我们改动的是library中的代码还是application中的代码, application module永远都会被重新编译, 所以减小app module的尺寸很有意义.</p>
<p>3.上面这些都是library之间互相独立的情况, 如果library之间还有相互依赖, 那么build时间也会变长.</p>
<p>4.如果应用超出了DEX的方法数限制, 用了multidex, 也会增加build时间, Android 5.0开始使用了一个叫做ART的runtime, 在这方面有一些优化, 可以减少build时间, 所以我们可以在开发的时候设置最小API是21: <a href="https://developer.android.com/studio/build/multidex.html#dev-build" target="_blank" rel="external">Optimize multidex in development builds</a>.</p>
<h2 id="Exploiting-Android-Seams-for-Testing-and-Flexibility"><a href="#Exploiting-Android-Seams-for-Testing-and-Flexibility" class="headerlink" title="Exploiting Android Seams for Testing and Flexibility"></a><a href="https://www.philosophicalhacker.com/post/exploiting-android-specific-seams-for-testing-and-flexibility/" target="_blank" rel="external">Exploiting Android Seams for Testing and Flexibility</a></h2><p>如何让Android应用代码可测试? 答案是创建一些接缝. 这篇文章中, 作者将一些Android特有的接缝, 来让我们的应用更加灵活和易测.</p>
<h3 id="Manifest接缝"><a href="#Manifest接缝" class="headerlink" title="Manifest接缝"></a>Manifest接缝</h3><p>使用<a href="https://developer.android.com/studio/build/manifest-merge.html#merge_rule_markers" target="_blank" rel="external">Merge rule markers</a>可以方便地更改manifest.</p>
<p>比如在build variant是mock的时候, 由于我们在src/mock/AndroidManifest.xml里这样写:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/mock/AndroidManifest.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span><br><span class="line">  <span class="attr">android:name</span>=<span class="string">".StubConfigActivity"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span><br><span class="line">  <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">tools:node</span>=<span class="string">"remove"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>所以在build mock的时候, 启动Activity会被替换成上面这个<code>StubConfigActivity</code>.</p>
<p>还有更多的可能值得探索, 比如你可以替换filter的内容, 从而改变默认intent启动的Activity.</p>
<h3 id="BuildConfig接缝"><a href="#BuildConfig接缝" class="headerlink" title="BuildConfig接缝"></a>BuildConfig接缝</h3><p>在gradle中可以根据不同的build variant来定义<code>BuildConfig</code>中的变量值. </p>
<p>默认情况下<code>BuildConfig</code>中会包含一些有用的变量比如<code>DEBUG</code>和<code>FLAVOR</code>.</p>
<p>我们可以创建更多额外的变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">  mock &#123;</span><br><span class="line">    buildConfigField(&apos;Boolean&apos;, &apos;MOCK&apos;, &quot;true&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个简单的应用case是我们可以定义不同的base url:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">  buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;api.awesomecompany.com\&quot;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">productFlavors &#123;</span><br><span class="line">  sandbox &#123;</span><br><span class="line">    buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;localhost:8080\&quot;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Resource接缝"><a href="#Resource接缝" class="headerlink" title="Resource接缝"></a>Resource接缝</h3><p>不同build variants的资源就像manifest一样, 最后会被merged. 但是对于资源我们没有markers可以控制它们如何merge. </p>
<p>我们可以利用默认的merge行为: <a href="https://developer.android.com/studio/write/add-resources.html#resource_merging" target="_blank" rel="external">Resource merging</a>.</p>
<p>优先级是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以把默认的资源放在main里, 然后在特定的build variant再创建一份覆盖它们.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Reptar"><a href="#Reptar" class="headerlink" title="Reptar"></a><a href="https://github.com/Commit451/Reptar" target="_blank" rel="external">Reptar</a></h2><p>RxJava2.x的有用的类的集合.</p>
<h2 id="Toasty"><a href="#Toasty" class="headerlink" title="Toasty"></a><a href="https://github.com/GrenderG/Toasty" target="_blank" rel="external">Toasty</a></h2><p>前面加了一个icon的Toast, 带背景颜色, 除了内置的error, info, success, warning等几种形式, 还可以自定义.</p>
<h2 id="Google-Actions-Java-SDK"><a href="#Google-Actions-Java-SDK" class="headerlink" title="Google-Actions-Java-SDK"></a><a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google-Actions-Java-SDK</a></h2><p>非官方的Google Actions Java SDK.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-241&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-241&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #241&quot;&gt;&lt;/a&gt;Android Weekly Issue #241&lt;/h1&gt;&lt;p&gt;January 22nd, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-241&quot;&gt;Android Weekly Issue #241&lt;/a&gt;&lt;br&gt;本期内容包括: 经典导航模式Master/Detail的设计和实现; APK的大小讨论和增量下载大小的预估工具; Model-View-Intent模式的讨论和实现; 分多个modules对build时间的影响; 测试中能够利用的一些Android特有的接缝设计(manifest, build config, resource).&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="APK" scheme="http://mengdd.github.io/tags/APK/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Master/Detail" scheme="http://mengdd.github.io/tags/Master-Detail/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="Build Time" scheme="http://mengdd.github.io/tags/Build-Time/"/>
    
      <category term="Toast" scheme="http://mengdd.github.io/tags/Toast/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 240</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/24/android-weekly-notes-issue-240/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/24/android-weekly-notes-issue-240/</id>
    <published>2017-01-24T02:50:19.000Z</published>
    <updated>2017-01-24T02:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-240"><a href="#Android-Weekly-Issue-240" class="headerlink" title="Android Weekly Issue #240"></a>Android Weekly Issue #240</h1><p>January 15th, 2017<br><a href="http://androidweekly.net/issues/issue-240" target="_blank" rel="external">Android Weekly Issue #240</a><br>Hello, 各位亲, 从本篇笔记开始, 以后并不包含Android Weekly的每一篇文章了, 只是选一些我感兴趣的做笔记. 想要看全部文章的还请点击上面的链接.</p>
<p>本期内容包括: 一个Android的RxJava教程; 关于测试中的注释讨论; Dagger2的实现细节讨论; Kotlin语言设计中和Effective Java相关的点和优化; Reactive app的构建模式, 一个好的model层的重要性; 怎样写数据库测试.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="RxAndroid-Tutorial"><a href="#RxAndroid-Tutorial" class="headerlink" title="RxAndroid Tutorial"></a><a href="https://www.raywenderlich.com/141980/rxandroid-tutorial" target="_blank" rel="external">RxAndroid Tutorial</a></h2><p>一个RxAndroid的Tutorial, 内容包括:</p>
<ul>
<li>Reactive Programming是什么. -&gt; 把reactive programming比喻成excel里面的表达式.</li>
<li>observable是什么.</li>
<li>如何把按钮点击和输入文字改变事件事件变为observables.</li>
<li>转换.</li>
<li>过滤.</li>
<li>指定线程.</li>
<li>把多个observables联合成一个.</li>
</ul>
<h2 id="Clean-tests-Part-2-Comments"><a href="#Clean-tests-Part-2-Comments" class="headerlink" title="Clean tests, Part 2: Comments"></a><a href="https://android.jlelse.eu/clean-tests-part-2-comments-4016ee82f186#.15u9kq7jz" target="_blank" rel="external">Clean tests, Part 2: Comments</a></h2><p>上一篇文章里作者讨论了测试代码的命名, 这篇讨论注释.<br>在测试里我们经常会见到这样的注释:</p>
<ul>
<li>// GIVEN</li>
<li>// WHEN</li>
<li>// THEN</li>
</ul>
<p>注意每一次添加注释的时候都应该想清楚自己的代码是不是能够自解释, 而不是依赖于注释. 这条原则同样适用于产品代码和测试代码.</p>
<p>为每一个测试重复这三行其实没有什么意义, 因为这个顺序是显而易见的.</p>
<p>理想情况下, 简单的测试并不需要这些注释就显得很好看了, 如果是复杂的测试, 一般执行应该是一行, 验证也应该是一行, 如果需要太多验证我们应该考虑把它们抽取成多个测试方法. 而关于准备阶段, 如果我们真的需要很多准备的代码, 这是一种code smell, 可能说明我们要测试的这个方法做了太多事情, 可能我们应该先重构一下再进行测试.</p>
<p>我们也应该好好利用<code>setUp()</code>方法, 让我们的测试看起来更干净.</p>
<p>最后建议用一些比较好的assert库让最后的断言语句看起来更易懂.</p>
<h2 id="Android-Dagger2-Critical-things-to-know-before-you-implement"><a href="#Android-Dagger2-Critical-things-to-know-before-you-implement" class="headerlink" title="Android Dagger2: Critical things to know before you implement"></a><a href="https://blog.mindorks.com/android-dagger2-critical-things-to-know-before-you-implement-275663aecc3e#.nxpqzmohn" target="_blank" rel="external">Android Dagger2: Critical things to know before you implement</a></h2><p>关于Dagger2的实现, 你应该搞清楚的几个关键点.</p>
<ul>
<li>实现单例的时候, 如果提供了@Provides方法, 那么@Singleton也要在这个provides方法上声明, 声明在类上是没有用的. (类的单例声明只和构造@Inject配合使用).</li>
<li>在component中提供了get方法后, 如果这个get方法没有被调用, 则对象不会被实例化.</li>
<li>Scope可以定义在该scope下的单例.</li>
</ul>
<h2 id="How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin"><a href="#How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin" class="headerlink" title="How “Effective Java” may have influenced the design of Kotlin"></a><a href="https://medium.com/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974#.nqwl31wn6" target="_blank" rel="external">How “Effective Java” may have influenced the design of Kotlin</a></h2><p>Kotlin的设计中考虑到的和Effective Java相关的几个点:</p>
<ul>
<li>Kotlin的构造默认参数值进一步简化了Builder模式.</li>
<li>更容易创建单例: 用object声明.</li>
<li>用了data声明后, 再也不用自己写<code>equals()</code>和<code>hashCode()</code>了.</li>
<li>properties自带了默认的get/set, 使用更加简洁, 也支持后续扩展.</li>
<li>Kotlin中的override关键字是强制的而不是可选的.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-1"><a href="#Reactive-apps-with-Model-View-Intent-Part-1" class="headerlink" title="Reactive apps with Model-View-Intent - Part 1"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-1" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 1</a></h2><p>作者用RxJava + Model-View-Intent (MVI)构建的Reactive App, 也即UI响应状态变化的App.</p>
<p>首先作者列举了Android流行的模式MVC, MVP, MVVM, 这里面都会有一个Model. 但是作者发现大多数时候程序并没有Model这一层.</p>
<p>构建一个好的Model层可以解决很多问题:</p>
<ul>
<li>状态.</li>
<li>屏幕方向旋转.</li>
<li>后退导航.</li>
<li>进程死亡.</li>
<li>不可变和单向的数据流.</li>
<li>可调试和重复的状态.</li>
<li>可测试性.</li>
</ul>
<p>最基本的理念就是把这个Model层作为唯一的真实状态来源.</p>
<h2 id="Testing-SQLite-on-Android-–-Medium"><a href="#Testing-SQLite-on-Android-–-Medium" class="headerlink" title="Testing SQLite on Android – Medium"></a><a href="https://medium.com/@MAFI8919/testing-sqlite-on-android-bfa0733e11e7#.a4hufzbc7" target="_blank" rel="external">Testing SQLite on Android – Medium</a></h2><p>如何写SQLite数据库测试.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Desertplaceholder"><a href="#Desertplaceholder" class="headerlink" title="Desertplaceholder"></a><a href="https://github.com/JetradarMobile/desertplaceholder" target="_blank" rel="external">Desertplaceholder</a></h2><p>一个沙漠空白页面.</p>
<h2 id="Android-SwitchIcon"><a href="#Android-SwitchIcon" class="headerlink" title="Android-SwitchIcon"></a><a href="https://github.com/zagum/Android-SwitchIcon" target="_blank" rel="external">Android-SwitchIcon</a></h2><p>Google launcher风格的Switch icon, enable时点亮, disable时灰去.</p>
<h2 id="SlidesCodeHighlighter"><a href="#SlidesCodeHighlighter" class="headerlink" title="SlidesCodeHighlighter"></a><a href="https://github.com/romannurik/SlidesCodeHighlighter" target="_blank" rel="external">SlidesCodeHighlighter</a></h2><p>一个web应用, 让你可以把带有高亮的代码拷贝进slides.</p>
<h2 id="GithubWidget"><a href="#GithubWidget" class="headerlink" title="GithubWidget"></a><a href="https://github.com/Nightonke/GithubWidget" target="_blank" rel="external">GithubWidget</a></h2><p>一个Github Widget, 显示Contributions, stars, followers, trending etc.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-240&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-240&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #240&quot;&gt;&lt;/a&gt;Android Weekly Issue #240&lt;/h1&gt;&lt;p&gt;January 15th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-240&quot;&gt;Android Weekly Issue #240&lt;/a&gt;&lt;br&gt;Hello, 各位亲, 从本篇笔记开始, 以后并不包含Android Weekly的每一篇文章了, 只是选一些我感兴趣的做笔记. 想要看全部文章的还请点击上面的链接.&lt;/p&gt;
&lt;p&gt;本期内容包括: 一个Android的RxJava教程; 关于测试中的注释讨论; Dagger2的实现细节讨论; Kotlin语言设计中和Effective Java相关的点和优化; Reactive app的构建模式, 一个好的model层的重要性; 怎样写数据库测试.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="SQLite" scheme="http://mengdd.github.io/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 239</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/10/android-weekly-notes-issue-239/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/10/android-weekly-notes-issue-239/</id>
    <published>2017-01-10T06:10:31.000Z</published>
    <updated>2017-03-09T05:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-239"><a href="#Android-Weekly-Issue-239" class="headerlink" title="Android Weekly Issue #239"></a>Android Weekly Issue #239</h1><p>January 8th, 2017<br><a href="http://androidweekly.net/issues/issue-239" target="_blank" rel="external">Android Weekly Issue #239</a><br>本期内容包括: Android Things开发; Android中有用却不常见的一些API介绍(拼写检查, 文字识别, 时间log, 截图, 创建PDF); Gradle依赖管理冲突和解决办法; Looper, Handler和HandlerThread; 兼顾Wear1.0和2.0的部署方式; 打开PDF的实现方法; 单元测试的命名; Robolectric的弊病; 迁移到RxJava2的好处和面临的挑战. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preparing-your-computer-for-Android-dev"><a href="#Preparing-your-computer-for-Android-dev" class="headerlink" title="Preparing your computer for Android dev"></a><a href="https://medium.com/@rafael_toledo/preparing-your-android-environment-for-development-android-tutorials-pt-1-5f76ca2b8a32#.yxa0bvkp5" target="_blank" rel="external">Preparing your computer for Android dev</a></h2><p>在Windows, OSX和Linux上设置开发环境.</p>
<h2 id="Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things"><a href="#Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things" class="headerlink" title="Beginner’s guide to Raspberry Pi 3 B and Android Things"></a><a href="http://www.andtuts.com/a-beginners-guide-to-raspberry-pi-3-b-and-android-things/" target="_blank" rel="external">Beginner’s guide to Raspberry Pi 3 B and Android Things</a></h2><p>如何Set up with Android Things.</p>
<h2 id="Creating-new-project-and-emulator-on-Android-Studio"><a href="#Creating-new-project-and-emulator-on-Android-Studio" class="headerlink" title="Creating new project and emulator on Android Studio"></a><a href="https://medium.com/@rafael_toledo/creating-a-new-project-and-an-emulator-on-android-studio-android-tutorials-2-35bd965ac42b#.lwlhy72wf" target="_blank" rel="external">Creating new project and emulator on Android Studio</a></h2><p>如何创建新项目和模拟器.</p>
<h2 id="Discovering-Android-API"><a href="#Discovering-Android-API" class="headerlink" title="Discovering Android API"></a><a href="https://blog.autsoft.hu/discovering-the-android-api-part-1/" target="_blank" rel="external">Discovering Android API</a></h2><p>Android是基于Java的, Java本身已经有四千多个类, Android API也有很多个类, 有一些不太常见但是却很有用的API我们应该了解一下.</p>
<p>这篇文章就旨在发现那些不常见却很有用的API, 并且附有一个<a href="https://github.com/peekler/GDG" target="_blank" rel="external">Demo</a>.</p>
<h3 id="No-1-Spell-Checker"><a href="#No-1-Spell-Checker" class="headerlink" title="No.1 - Spell Checker"></a>No.1 - Spell Checker</h3><p><a href="https://developer.android.com/reference/android/view/textservice/TextServicesManager.html" target="_blank" rel="external">TextServicesManager</a>从API 14开始支持, 可以发现拼写错误, 并返回正确的单词拼写.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextServicesManager tsm = (TextServicesManager) getSystemService(Context.TEXT_SERVICES_MANAGER_SERVICE);  </span><br><span class="line">SpellCheckerSession spellCheckerSession = tsm.newSpellCheckerSession(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="No-2-Text-Recognizer"><a href="#No-2-Text-Recognizer" class="headerlink" title="No.2 - Text Recognizer"></a>No.2 - Text Recognizer</h3><p>Google Play Services Vision API中的文字识别.</p>
<p>Version API中包括了人脸识别, 二维码扫描和文字识别.</p>
<p>这个例子中可以从图像中扫描出文字信息.</p>
<h3 id="No-3-TimingLogger"><a href="#No-3-TimingLogger" class="headerlink" title="No.3 - TimingLogger"></a>No.3 - TimingLogger</h3><p><a href="https://developer.android.com/reference/android/util/TimingLogger.html" target="_blank" rel="external">TimingLogger</a>是用来测量流逝时间的一个好工具.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TimingLogger timings = <span class="keyword">new</span> TimingLogger(TAG, <span class="string">"methodA"</span>);</span><br><span class="line"><span class="comment">// ... do some work A ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work A"</span>);</span><br><span class="line"><span class="comment">// ... do some work B ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work B"</span>);</span><br><span class="line"><span class="comment">// ... do some work C ...</span></span><br><span class="line">timings.addSplit(<span class="string">"work C"</span>);</span><br><span class="line">timings.dumpToLog();</span><br></pre></td></tr></table></figure></p>
<p>最后一句执行后, 会在log中一次性输出下面的log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/TAG     ( 3459): methodA: begin</span><br><span class="line">D/TAG     ( 3459): methodA:      9 ms, work A</span><br><span class="line">D/TAG     ( 3459): methodA:      1 ms, work B</span><br><span class="line">D/TAG     ( 3459): methodA:      6 ms, work C</span><br><span class="line">D/TAG     ( 3459): methodA: end, 16 ms</span><br></pre></td></tr></table></figure></p>
<p>注意需要在adb中使能TAG:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setprop log.tag.TAG_MYJOB VERBOSE</span><br></pre></td></tr></table></figure></p>
<p>假设本例子中TAG = “TAG_MYJOB”.</p>
<h3 id="No-4-Taking-screenshots"><a href="#No-4-Taking-screenshots" class="headerlink" title="No.4 - Taking screenshots"></a>No.4 - Taking screenshots</h3><p>有一些库可以提供截屏, 比如<a href="https://github.com/jraska/Falcon" target="_blank" rel="external">Falcon</a>. </p>
<p>在Android 21之上用<a href="https://developer.android.com/reference/android/media/projection/MediaProjection.html" target="_blank" rel="external">MediaProjection</a>甚至可以录屏.</p>
<p>但是得到屏幕图像更简单的一种方法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View viewRoot = getWindow().getDecorView().getRootView();  </span><br><span class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">true</span>);  </span><br><span class="line">Bitmap screenShotAsBitmap = Bitmap.createBitmap(viewRoot.getDrawingCache());  </span><br><span class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">false</span>);  </span><br><span class="line"><span class="comment">// use screenShotAsBitmap as you need</span></span><br></pre></td></tr></table></figure></p>
<h3 id="No-5-PDF-Creation-API"><a href="#No-5-PDF-Creation-API" class="headerlink" title="No.5 - PDF Creation API"></a>No.5 - PDF Creation API</h3><p>从API 19开始Android就提供了API可以创建PDF文档.<br>文中的例子是创建了一个PDF文档, 然后把当前屏幕内容放进去.</p>
<h2 id="Avoiding-Conflicts-in-android-gradle-dependencies"><a href="#Avoiding-Conflicts-in-android-gradle-dependencies" class="headerlink" title="Avoiding Conflicts in android gradle dependencies"></a><a href="https://blog.mindorks.com/avoiding-conflicts-in-android-gradle-dependencies-28e4200ca235#.x66q6p4v4" target="_blank" rel="external">Avoiding Conflicts in android gradle dependencies</a></h2><p>如果两个依赖又都依赖了同一个库, 但是是不同的版本, 那会发生什么呢?</p>
<p>比如下面这个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">androidTestCompile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</span><br><span class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</span><br></pre></td></tr></table></figure></p>
<p>这两个库都依赖于”org.hamcrest:hamcrest-core”, 但是版本却不同.</p>
<p>这种情况下, 最终被包含进build的是最高版本的库.</p>
<p>在依赖被声明的module里运行下面这个命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew dependencies.</span><br></pre></td></tr></table></figure></p>
<p>会显式地看到gradle自动把第二个依赖中的hamcrest库从1.1升级到了1.3.</p>
<p>前面, 两个依赖都是test依赖, 所以gradle自动解决了冲突.  如果两个依赖属于不同的配置, 如, 把第一个<code>androidTestCompile</code>改为<code>compile</code>, gradle将会报错.</p>
<p>原因是:</p>
<blockquote>
<p>When instrumentation tests are run, both the main APK and test APK share the same classpath. Gradle build will fail if the main APK and the test APK use the same library (e.g. Guava) but in different versions. If gradle didn’t catch that, your app could behave differently during tests and during normal run (including crashing in one of the cases).</p>
</blockquote>
<p><strong>解决依赖冲突</strong><br>一旦有了依赖冲突, 就需要开发者决定最后到底用什么版本的库, 有几种解决方法:</p>
<ul>
<li>方法1: 从依赖中排除这个库.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Now junit will not include hamcrest library. Therefore there will be no </span><br><span class="line">//dependency conflict. </span><br><span class="line"> compile (&apos;junit:junit:4.12&apos;)&#123;</span><br><span class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">androidTestCompile (&apos;org.mockito:mockito-core:1.10.19&apos;)&#123;</span><br><span class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真实的项目中可能有多个依赖依赖于同一个库, 那么我们就需要写多个排除语句.</p>
<ul>
<li>方法2: 显式地声明冲突库的版本.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</span><br><span class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</span><br><span class="line">androidTestCompile &apos;org.hamcrest:hamcrest-core:1.3&apos; //(We explictly mention </span><br><span class="line">//that include version 1.3)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方法不用写exclude, 但是当升级直接依赖库的时候需要注意更新这种间接依赖库的版本.</p>
<ul>
<li>方法3: 强制解析.</li>
</ul>
<p>强制设置所有configuration的依赖版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        resolutionStrategy.force &apos;org.hamcrest:hamcrest-core:1.1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方法的时候需要小心, 因为与方法2不同, 它是把所有configuration中的版本都强制设置了. 当直接依赖更新的时候, 要注意更新间接依赖的版本.</p>
<h2 id="Looper-Handler-and-HandlerThread"><a href="#Looper-Handler-and-HandlerThread" class="headerlink" title="Looper, Handler, and HandlerThread"></a><a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a#.zf2nhog1x" target="_blank" rel="external">Looper, Handler, and HandlerThread</a></h2><p>这篇文章讨论Looper, Handler和HandlerThread.</p>
<p>首先, 读者应该了解Java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" target="_blank" rel="external">Thread</a>和<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" target="_blank" rel="external">Runnable</a>.</p>
<p>然后让我们带着问题来探索和复习:</p>
<h3 id="Java的Thread存在什么问题"><a href="#Java的Thread存在什么问题" class="headerlink" title="Java的Thread存在什么问题?"></a>Java的Thread存在什么问题?</h3><p>Java的Thread是一次性的, 当它执行完<code>run()</code>方法之后, 它就死了.</p>
<h3 id="我们可以改善这个问题吗"><a href="#我们可以改善这个问题吗" class="headerlink" title="我们可以改善这个问题吗?"></a>我们可以改善这个问题吗?</h3><p>线程本身是个双刃剑, 我们可以把任务分发到多个线程来加速, 但同时线程过多又会降低速度. 线程创建也会花费时间, 所以最好我们能有一个固定优化数量的线程, 然后用它们来执行任务.</p>
<p><strong>线程复用模型</strong>:</p>
<ul>
<li>1.一个线程保持活跃, 通过它的<code>run()</code>方法不断循环.</li>
<li>2.任务由该线程连续执行, 并保持在一个队列中(MessageQueue).</li>
<li>3.当完成之后结束这个线程.</li>
</ul>
<h3 id="Android是以什么方式来做这件事的呢"><a href="#Android是以什么方式来做这件事的呢" class="headerlink" title="Android是以什么方式来做这件事的呢?"></a>Android是以什么方式来做这件事的呢?</h3><p>Android用<code>Looper</code>, <code>Handler</code>和<code>HandlerThread</code>实现了上述模型.<br>系统可以用这样的图表示:<br><img src="/images/Android-Looper-Handler.jpeg" alt="Android Looper Handler"></p>
<ul>
<li>1.<code>MessageQueue</code>是一个队列, 里面含有需要被处理的任务(消息).</li>
<li>2.<code>Handler</code>利用<code>Looper</code>往队列中加任务, 同时也在任务出队列的时候进行处理.</li>
<li>3.<code>Looper</code>是一个工人, 保持一个线程的活跃, 循环消息队列, 把消息发给对应的handler去处理.(一个线程只能对应一个唯一的<code>Looper</code>, 但是可以有多个关联的<code>Handler</code>).</li>
<li>4.最后<code>Looper.quit()</code>会让线程终止.</li>
</ul>
<p>为一个线程创建<code>Looper</code>和<code>MessageQueue</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; </span><br><span class="line">               <span class="comment">// process incoming messages here</span></span><br><span class="line">               <span class="comment">// this will run in non-ui/background thread</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建<code>Handler</code>的时候自动和当前线程的Looper关联, 但是也可以通过构造传入Looper来使Handler关联到特定的线程.</p>
<p>用<code>Handler</code>发消息有两种方式: <code>Message</code>和<code>Runnable</code>.</p>
<p>自己创建一个线程并提供Looper和消息队列的方式是不好的, 所以Android提供了<code>HandlerThread</code>来简化这个过程, 它内部的实现和我们之前做的差不多, 但是是以一种更加稳健的方式. 所以我们应该使用<code>HandlerThread</code>而不是自己实现.</p>
<p>大多数时候你只需要继承<code>HandlerThread</code>来创建它的子类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handler = <span class="keyword">new</span> Handler(getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">                <span class="comment">// this will run in non-ui/background thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li><code>Looper</code>只有在<code>HandlerThread</code>的<code>start()</code>方法被调用(线程开始跑)后才会进入prepared状态.</li>
<li>只有在<code>HandlerThread</code>的<code>Looper</code>处于parepared状态以后, <code>Handler</code>才可以关联.</li>
</ul>
<p>另一种创建<code>HandlerThread</code>的方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"MyHandlerThread"</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br></pre></td></tr></table></figure></p>
<p>注意: <code>HandlerThread</code>需要调用<code>quit()</code>方法来停止线程执行和释放资源.</p>
<p>作者文后还附有一个练习的demo.</p>
<h2 id="Android-Wear-packaging"><a href="#Android-Wear-packaging" class="headerlink" title="Android Wear packaging"></a><a href="https://www.novoda.com/blog/android-wear-packaging/" target="_blank" rel="external">Android Wear packaging</a></h2><p>Android Wear 2.0将在2017年发布, 本文讨论了如何同时支持1.0和2.0的应用部署.</p>
<h2 id="Simple-Things-–-Part-1"><a href="#Simple-Things-–-Part-1" class="headerlink" title="Simple Things – Part 1"></a><a href="https://blog.stylingandroid.com/simple-things-part-1/" target="_blank" rel="external">Simple Things – Part 1</a></h2><p>Android Things应用.</p>
<h2 id="Options-for-Viewing-PDFs"><a href="#Options-for-Viewing-PDFs" class="headerlink" title="Options for Viewing PDFs"></a><a href="https://commonsware.com/blog/2017/01/04/options-viewing-pdfs.html" target="_blank" rel="external">Options for Viewing PDFs</a></h2><p>显示PDF传统的方法是通过ACTION_VIEW发出去, 用一个第三方应用打开.</p>
<p>但是有一些开发者不愿意这样做.</p>
<p>还有一种方法是把文件上传, 然后用Google Docs URL用WebView打开它. </p>
<p>除了这些传统的方法, 还有一些选项, 虽然它们各自都有一些问题.</p>
<p>比如用<code>PdfRenderer</code>, 它是Android 5.0加入的.</p>
<p>Mozilka在Firefox上用的是<a href="https://mozilla.github.io/pdf.js/" target="_blank" rel="external">PDF.js</a>, 在Android 4.4+的WebView上可用, 它会给apk带来2MB左右的增加.</p>
<p>Google在Chrominum上用的是<a href="https://pdfium.googlesource.com/pdfium/" target="_blank" rel="external">pdfium</a>, 这是C++. <a href="https://github.com/barteksc/AndroidPdfViewer" target="_blank" rel="external">barteksc/AndroidPdfViewer</a>封装了Pdfium, 处理了渲染和基本的手势, 在一些较老的Android版本上也使用, 但是大约每个CPU架构会给APK增加5MB, 默认情况下你会增加30MB.</p>
<h2 id="Clean-tests-Part-1-Naming"><a href="#Clean-tests-Part-1-Naming" class="headerlink" title="Clean tests, Part 1: Naming"></a><a href="https://android.jlelse.eu/clean-tests-part-1-naming-cce94edf0522#.5nmmqx81y" target="_blank" rel="external">Clean tests, Part 1: Naming</a></h2><p>关于怎么写干净的单元测试, 本文作者提出了几点他对于命名的看法.</p>
<ul>
<li>不要用”test”开头写测试名.</li>
<li>不要把被测试的方法名字写在测试名里.</li>
<li>测试是一种规范.</li>
</ul>
<h2 id="Why-I-Don’t-use-Robolectric"><a href="#Why-I-Don’t-use-Robolectric" class="headerlink" title="Why I Don’t use Robolectric"></a><a href="http://www.philosophicalhacker.com/post/why-i-dont-use-roboletric/" target="_blank" rel="external">Why I Don’t use Robolectric</a></h2><p>作者觉得Robolectric不好的几点:</p>
<ul>
<li>Robolectric mock了一些我们并不拥有的type.</li>
<li>Robolectric turns TDD on its head.</li>
</ul>
<p>所以最好的做法是我们在写Android代码的时候将逻辑代码抽象出来, 与framework分离, 这样在测试的时候不依赖于Android SDK的类, 也不需要robolectric来模拟一个中间层.</p>
<h2 id="The-Next-Step-for-Reactive-Android-Programming"><a href="#The-Next-Step-for-Reactive-Android-Programming" class="headerlink" title="The Next Step for Reactive Android Programming"></a><a href="http://futurice.com/blog/the-next-step-for-reactive-android-programming" target="_blank" rel="external">The Next Step for Reactive Android Programming</a></h2><p>RxJava 2已经推出了, 本篇文章讨论从RxJava 1迁移到RxJava 2会带来的好处和挑战.</p>
<p>好处:</p>
<ul>
<li>兼容了<a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="external">Reactive Streams</a>.</li>
<li>Backpressure的处理.</li>
<li>Performance.</li>
</ul>
<p>挑战:</p>
<ul>
<li>流中不能再使用null.</li>
<li>方法数限制. RxJava 1(5500), RxJava 2(9200).</li>
<li>自定义操作符变得很难写.</li>
</ul>
<p>Note: 可以对比简单的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java" target="_blank" rel="external">map</a>和复杂的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java" target="_blank" rel="external">flatMap</a>.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introducing-Auto-Layout-for-Sketch"><a href="#Introducing-Auto-Layout-for-Sketch" class="headerlink" title="Introducing Auto-Layout for Sketch"></a><a href="https://medium.com/sketch-app-sources/introducing-auto-layout-for-sketch-24e7b5d068f9#.tusju2z7k" target="_blank" rel="external">Introducing Auto-Layout for Sketch</a></h2><p>一个Sketch插件, 让你查看不同屏幕上的效果.</p>
<h2 id="Designing-for-Both-Android-and-iOS"><a href="#Designing-for-Both-Android-and-iOS" class="headerlink" title="Designing for Both Android and iOS"></a><a href="https://webdesign.tutsplus.com/articles/a-tale-of-two-platforms-designing-for-both-android-and-ios--cms-23616" target="_blank" rel="external">Designing for Both Android and iOS</a></h2><p>Android和iOS的设计, 很详细的介绍, 最后附有一些resources.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="flowless"><a href="#flowless" class="headerlink" title="flowless"></a><a href="https://github.com/Zhuinden/flowless" target="_blank" rel="external">flowless</a></h2><p>一个框架, 给你Activity的UI状态命名, 管理并记录状态转换.</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a><a href="https://github.com/NYTimes/Store" target="_blank" rel="external">Store</a></h2><p>异步数据加载和缓存的库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-239&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-239&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #239&quot;&gt;&lt;/a&gt;Android Weekly Issue #239&lt;/h1&gt;&lt;p&gt;January 8th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-239&quot;&gt;Android Weekly Issue #239&lt;/a&gt;&lt;br&gt;本期内容包括: Android Things开发; Android中有用却不常见的一些API介绍(拼写检查, 文字识别, 时间log, 截图, 创建PDF); Gradle依赖管理冲突和解决办法; Looper, Handler和HandlerThread; 兼顾Wear1.0和2.0的部署方式; 打开PDF的实现方法; 单元测试的命名; Robolectric的弊病; 迁移到RxJava2的好处和面临的挑战. &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Wear" scheme="http://mengdd.github.io/tags/Wear/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Test" scheme="http://mengdd.github.io/tags/Test/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Handler" scheme="http://mengdd.github.io/tags/Handler/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="Looper" scheme="http://mengdd.github.io/tags/Looper/"/>
    
      <category term="HandlerThread" scheme="http://mengdd.github.io/tags/HandlerThread/"/>
    
      <category term="PDF" scheme="http://mengdd.github.io/tags/PDF/"/>
    
      <category term="Robolectric" scheme="http://mengdd.github.io/tags/Robolectric/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 238</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/03/android-weekly-notes-issue-238/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/03/android-weekly-notes-issue-238/</id>
    <published>2017-01-03T10:02:01.000Z</published>
    <updated>2017-03-09T05:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-238"><a href="#Android-Weekly-Issue-238" class="headerlink" title="Android Weekly Issue #238"></a>Android Weekly Issue #238</h1><p>January 1st, 2017<br><a href="http://androidweekly.net/issues/issue-238" target="_blank" rel="external">Android Weekly Issue #238</a><br>本期内容包括: Firebase发送Notification; RecyclerView的预取; 后台工作的实现方式讨论; RecyclerView分组数据; 跨平台应用工具Flutter介绍; Gradle依赖管理;<br>写测试的一些注意事项; Android Things应用搭建及一些思考; 如何搭建CI等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Mastering-Firebase-Notifications"><a href="#Mastering-Firebase-Notifications" class="headerlink" title="Mastering Firebase Notifications"></a><a href="https://medium.com/@Miqubel/mastering-firebase-notifications-36a3ffe57c41#.ykkpzrs4l" target="_blank" rel="external">Mastering Firebase Notifications</a></h2><p>用Firebase发通知:</p>
<ul>
<li>Console Notifications.</li>
<li>使用命令行, 发送curl命令.</li>
<li><code>FirebaseMessagingService</code>在应用前台的时候处理通知.</li>
<li>如果应用前后台的时候都需要处理, 则发送data而不是notification.<br>官方文档<a href="https://firebase.google.com/docs/cloud-messaging/android/receive" target="_blank" rel="external">Firebase cloud-messaging</a>.</li>
</ul>
<h2 id="RecyclerView-Prefetch"><a href="#RecyclerView-Prefetch" class="headerlink" title="RecyclerView Prefetch"></a><a href="https://medium.com/google-developers/recyclerview-prefetch-c2f269075710#.21takened" target="_blank" rel="external">RecyclerView Prefetch</a></h2><p>作者研究了RecyclerView的渲染时间, 发现在滚动的时候很多的时间会花在新item的创建和bind上, 这样会推迟UI线程的其他工作, 还有RenderThread的后续工作, 如果超出了frame boundary, 就有可能会造成明显的卡顿.</p>
<p>而同时前一帧, UI线程可能处于空闲状态.</p>
<p>那么我们有没有可能以一种预取的方式, 把即将出现的View在提前的空闲阶段准备好呢?</p>
<p>pre-fetch的优化已经在<a href="https://developer.android.com/topic/libraries/support-library/revisions.html#rev25-0-0" target="_blank" rel="external">Support Library v25</a>加入, <a href="https://developer.android.com/topic/libraries/support-library/revisions.html#25-1-0" target="_blank" rel="external">v25.1.0</a>有进一步的加强. 如果你没有自定义LayoutManager, 也没有嵌套<code>RecyclerView</code>, 那么你升级support library之后就自动获得了这项优化. 其他两种情况你还需要调用一些方法.</p>
<p>你可以设置<code>LayoutManager.setItemPrefetchEnabled()</code>来对比开启和关闭预取功能前后的不同. 性能测量用<a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="external">Systrace</a>和<a href="https://developer.android.com/studio/profile/dev-options-rendering.html" target="_blank" rel="external">GPU profiling</a>.</p>
<h2 id="Things-to-consider-before-running-background-tasks"><a href="#Things-to-consider-before-running-background-tasks" class="headerlink" title="Things to consider before running background tasks"></a><a href="https://blog.yipl.com.np/things-to-consider-before-running-background-tasks-e71f00d2ad3a#.baugcaodi" target="_blank" rel="external">Things to consider before running background tasks</a></h2><p>完成后台任务的几种方式和各自的优缺点分析.</p>
<ul>
<li>Thread.</li>
<li>AsyncTask.</li>
<li>Service.</li>
<li>IntentService.</li>
<li>Loader.</li>
<li>JobService and JobScheduler. GCM Network Manager.</li>
<li>RxJava.</li>
</ul>
<h2 id="Android-RecyclerView-Grouping-Data"><a href="#Android-RecyclerView-Grouping-Data" class="headerlink" title="Android RecyclerView - Grouping Data"></a><a href="https://krtkush.github.io/2016/07/08/android-recyclerview-grouping-data.html" target="_blank" rel="external">Android RecyclerView - Grouping Data</a></h2><p>作者展示了如何将RecyclerView中的数据分组展示, 在他的例子中是按照时间分组, 每一组开始是该组的时间占据一行.</p>
<p>其实主要是前期的数据处理, 首先创建一个HashMap, 分组依据作为key, 符合该依据的数据作为值存在对应key的value list里; 然后给日期和数据创建一个共同的基类, 把HashMap再重新展开成一个List, 里面穿插好数据. 最后用RecyclerView按照数据类型不同显示两种布局.</p>
<h2 id="Flutter-Intro"><a href="#Flutter-Intro" class="headerlink" title="Flutter Intro"></a><a href="https://medium.com/@develodroid/flutter-i-intro-and-install-a8bf6dfcc7c8#.f9ktsu3r8" target="_blank" rel="external">Flutter Intro</a></h2><p><a href="https://flutter.io/" target="_blank" rel="external">Flutter</a>是一个Google推出的新工具, 用来构建跨平台的应用.</p>
<p>本文介绍了如何setup和创建一个Hello World.</p>
<h2 id="How-to-add-Gradle-dependencies-using-‘foreach’"><a href="#How-to-add-Gradle-dependencies-using-‘foreach’" class="headerlink" title="How to add Gradle dependencies using ‘foreach’"></a><a href="https://hackernoon.com/android-how-to-add-gradle-dependencies-using-foreach-c4cbcc070458#.aplxhrmn3" target="_blank" rel="external">How to add Gradle dependencies using ‘foreach’</a></h2><p>一种管理依赖的方式, 把所有的依赖定义在同一个文件的不同分组里, 然后在每个module各自添加自己的分组即可.</p>
<h2 id="Best-practices-to-improve-app-engagement"><a href="#Best-practices-to-improve-app-engagement" class="headerlink" title="Best practices to improve app engagement"></a><a href="https://android-developers.googleblog.com/2016/12/important-best-practices-to-improve-app-engagement.html" target="_blank" rel="external">Best practices to improve app engagement</a></h2><p>如何提高app的用户参与度.</p>
<h2 id="The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android"><a href="#The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android" class="headerlink" title="The Do’s and Don’ts of Writing Test cases in Android"></a><a href="https://blog.mindorks.com/the-dos-and-don-ts-of-writing-test-cases-in-android-70f1b5dab3e1#.7ol81s1wo" target="_blank" rel="external">The Do’s and Don’ts of Writing Test cases in Android</a></h2><p>作者分享了在写测试的时候需要注意的几点:</p>
<ul>
<li>首先明确我们要测试的是什么, 预先条件是否满足, 如果是因为前置条件不满足, 那么并不是我们的测试本身失败了.</li>
<li>每个测试都是独立完成的, 测试的执行顺序不应该影响结果.</li>
<li>在测试中不要写条件语句. 条件语句是在实际代码中的, 每一个条件都应该对应一个单独的测试case.</li>
<li>测试应该不受外部因素影响, 比如server和网络. 因为如果因为这类原因测试失败了, 并不代表我们的代码有bug.</li>
</ul>
<h2 id="Making-Rainbow-HAT-Work-with-the-Android-Things"><a href="#Making-Rainbow-HAT-Work-with-the-Android-Things" class="headerlink" title="Making Rainbow HAT Work with the Android Things"></a><a href="https://blog.egorand.me/making-rainbow-hat-work-with-the-android-things-2/" target="_blank" rel="external">Making Rainbow HAT Work with the Android Things</a></h2><p>一个Android Things应用.</p>
<h2 id="Christmas-Voice-–-Part-2"><a href="#Christmas-Voice-–-Part-2" class="headerlink" title="Christmas Voice – Part 2"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-2/" target="_blank" rel="external">Christmas Voice – Part 2</a></h2><p>一个小应用, 录音, 做转换并播放.</p>
<h2 id="Will-Android-do-for-the-IoT-what-it-did-for-mobile"><a href="#Will-Android-do-for-the-IoT-what-it-did-for-mobile" class="headerlink" title="Will Android do for the IoT what it did for mobile?"></a><a href="https://medium.com/@carl.whalley/will-android-do-for-iot-what-it-did-for-mobile-c9ac79d06c#.41phc9zbb" target="_blank" rel="external">Will Android do for the IoT what it did for mobile?</a></h2><p>关于Android Things的一些看法.</p>
<h2 id="Set-up-a-CI-server-for-Android-dev"><a href="#Set-up-a-CI-server-for-Android-dev" class="headerlink" title="Set up a CI server for Android dev"></a><a href="https://medium.com/@pamartineza/how-to-set-up-a-continuous-integration-server-for-android-development-ubuntu-jenkins-sonarqube-43c1ed6b08d3#.lzs2m4zg8" target="_blank" rel="external">Set up a CI server for Android dev</a></h2><p>如何搭建Android项目的CI, (Ubuntu + Jenkins + SonarQube).</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Material-Growth-amp-communications"><a href="#Material-Growth-amp-communications" class="headerlink" title="Material: Growth &amp; communications"></a><a href="https://material.io/guidelines/growth-communications/introduction.html#" target="_blank" rel="external">Material: Growth &amp; communications</a></h2><p>如何进行用户引导, feature发现和手势教育.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PanoramaImageView"><a href="#PanoramaImageView" class="headerlink" title="PanoramaImageView"></a><a href="https://github.com/gjiazhe/PanoramaImageView" target="_blank" rel="external">PanoramaImageView</a></h2><p>一个ImageView, 在设备转动的时候可以自动滚动内容.</p>
<h2 id="TextDecorator"><a href="#TextDecorator" class="headerlink" title="TextDecorator"></a><a href="https://github.com/nntuyen/text-decorator" target="_blank" rel="external">TextDecorator</a></h2><p>可以给文字分段加上各种装饰, 下划线, 点击事件等.</p>
<h2 id="Delightful-SQLBrite"><a href="#Delightful-SQLBrite" class="headerlink" title="Delightful-SQLBrite"></a><a href="https://github.com/geralt-encore/Delightful-SQLBrite" target="_blank" rel="external">Delightful-SQLBrite</a></h2><p>一个示例应用, 展示<a href="https://github.com/square/sqldelight" target="_blank" rel="external">SQLDelight</a>和<a href="https://github.com/square/sqlbrite" target="_blank" rel="external">SQLBrite</a>结合使用.</p>
<h2 id="mainframer"><a href="#mainframer" class="headerlink" title="mainframer"></a><a href="https://github.com/gojuno/mainframer" target="_blank" rel="external">mainframer</a></h2><p>一个远程build的脚本.</p>
<h2 id="material-about-library"><a href="#material-about-library" class="headerlink" title="material-about-library"></a><a href="https://github.com/daniel-stoneuk/material-about-library" target="_blank" rel="external">material-about-library</a></h2><p>创建一个Material风格about页面的库.</p>
<h2 id="android-snowfall"><a href="#android-snowfall" class="headerlink" title="android-snowfall"></a><a href="https://github.com/JetradarMobile/android-snowfall" target="_blank" rel="external">android-snowfall</a></h2><p>下雪View.</p>
<h2 id="Android-ExpandIcon"><a href="#Android-ExpandIcon" class="headerlink" title="Android-ExpandIcon"></a><a href="https://github.com/zagum/Android-ExpandIcon" target="_blank" rel="external">Android-ExpandIcon</a></h2><p>展开/合上的上下箭头icon, 支持点击和手势滑动切换.</p>
<h2 id="RxAnimations"><a href="#RxAnimations" class="headerlink" title="RxAnimations"></a><a href="https://github.com/0ximDigital/RxAnimations" target="_blank" rel="external">RxAnimations</a></h2><p>Rx形式的动画库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-238&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-238&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #238&quot;&gt;&lt;/a&gt;Android Weekly Issue #238&lt;/h1&gt;&lt;p&gt;January 1st, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-238&quot;&gt;Android Weekly Issue #238&lt;/a&gt;&lt;br&gt;本期内容包括: Firebase发送Notification; RecyclerView的预取; 后台工作的实现方式讨论; RecyclerView分组数据; 跨平台应用工具Flutter介绍; Gradle依赖管理;&lt;br&gt;写测试的一些注意事项; Android Things应用搭建及一些思考; 如何搭建CI等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="Notification" scheme="http://mengdd.github.io/tags/Notification/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="Background work" scheme="http://mengdd.github.io/tags/Background-work/"/>
    
      <category term="Flutter" scheme="http://mengdd.github.io/tags/Flutter/"/>
    
      <category term="CI" scheme="http://mengdd.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 237</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/12/30/android-weekly-notes-issue-237/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/12/30/android-weekly-notes-issue-237/</id>
    <published>2016-12-30T07:30:25.000Z</published>
    <updated>2016-12-30T07:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-237"><a href="#Android-Weekly-Issue-237" class="headerlink" title="Android Weekly Issue #237"></a>Android Weekly Issue #237</h1><p>December 25th, 2016<br><a href="http://androidweekly.net/issues/issue-237" target="_blank" rel="external">Android Weekly Issue #237</a><br>这是本年的最后一篇issue, 感谢大家.<br>本期内容包括: ConstraintLayout的使用; Android Things的应用; 如何利用第三方库使得Java具有Kotlin的一些新特性; Firebase是如何利用<code>ContentProvider</code>进行初始化的; Kotlin上的并发处理; 其他还有一些关于程序架构, 代码优化相关的讨论.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Building-interfaces-with-ConstraintLayout"><a href="#Building-interfaces-with-ConstraintLayout" class="headerlink" title="Building interfaces with ConstraintLayout"></a><a href="https://medium.com/google-developers/building-interfaces-with-constraintlayout-3958fa38a9f7#.al6p1anu7" target="_blank" rel="external">Building interfaces with ConstraintLayout</a></h2><p>本文介绍<code>ConstraintLayout</code>的chains和ratios. 另外还提到很多使用<code>ConstraintLayout</code>的实现细节.</p>
<p>所谓chains就是几个View之间建立的双向约束.</p>
<p>ratios是帮助你设置View的宽高比, 它所做的事情和<a href="https://developer.android.com/reference/android/support/percent/PercentFrameLayout.html" target="_blank" rel="external">PercentFrameLayout</a>差不多, 但是不用添加额外的ViewGroup.</p>
<h2 id="Electronic-Candle-using-Android-Things"><a href="#Electronic-Candle-using-Android-Things" class="headerlink" title="Electronic Candle using Android Things"></a><a href="https://plus.google.com/+DaveSmithDev/posts/4JN7ZaSKxaM" target="_blank" rel="external">Electronic Candle using Android Things</a></h2><p>用ObjectAnimator和Android Things搭建的一个电子蜡烛.</p>
<h2 id="ExoPlayer-2-1-What’s-new"><a href="#ExoPlayer-2-1-What’s-new" class="headerlink" title="ExoPlayer 2.1 - What’s new"></a><a href="https://medium.com/google-exoplayer/exoplayer-2-1-whats-new-2832c09fedab#.po64o4uha" target="_blank" rel="external">ExoPlayer 2.1 - What’s new</a></h2><p>ExoPlayer 2.1有什么新功能.<br>这是他们的<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="external">release notes</a>.</p>
<h2 id="Living-Android-without-Kotlin"><a href="#Living-Android-without-Kotlin" class="headerlink" title="Living (Android) without Kotlin"></a><a href="https://hackernoon.com/living-android-without-kotlin-db7391a2b170#.7fm956ryk" target="_blank" rel="external">Living (Android) without Kotlin</a></h2><p>如果你因为种种原因不能在项目中使用kotlin, 这篇文章告诉你如何借助于一些工具和库用Java实现Kotlin的一些features.</p>
<h2 id="Christmas-Voice-–-Part-1"><a href="#Christmas-Voice-–-Part-1" class="headerlink" title="Christmas Voice – Part 1"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-1/" target="_blank" rel="external">Christmas Voice – Part 1</a></h2><p>作者发布了一个改变声音的应用, 并且将其开源了: <a href="https://github.com/StylingAndroid/ChristmasVoice" target="_blank" rel="external">ChristmasVoice</a>.</p>
<h2 id="How-does-Firebase-initialize-on-Android"><a href="#How-does-Firebase-initialize-on-Android" class="headerlink" title="How does Firebase initialize on Android?"></a><a href="https://firebase.googleblog.com/2016/12/how-does-firebase-initialize-on-android.html" target="_blank" rel="external">How does Firebase initialize on Android?</a></h2><p>Firebase在Android上是如何初始化的?</p>
<p>很多SDK在初始化的时候会要求应用传入<code>Context</code>. Firebase简化了这一步骤. 解决方案就是用了<code>ContentProvider</code>, 既解决了时间问题, 也得到了sdk需要的<code>Context</code>. 并且不需要应用的开发者添加任何额外的初始化代码.</p>
<p>选择<code>ContentProvider</code>主要有两点原因:</p>
<ul>
<li><code>ContentProvider</code>初始化早.<br>当一个Android进程启动的时候, 首先会初始化每一个ContentProvider, 然后是Application, 最后是被Intent启动的组件. </li>
</ul>
<p>在ContentProvider初始化的时候, 就可以拿到Context了.</p>
<ul>
<li><code>ContentProvider</code>可以merge到最终的manifest里.<br><a href="https://developer.android.com/studio/build/manifest-merge.html" target="_blank" rel="external">Manifest merge</a>是在build的时候来定义你的应用最终的manifest. 最终的manifest会包含所有依赖的库的manifest中声明的组件.</li>
</ul>
<p>如果你也想选择用<code>ContentProvider</code>来做应用或库的初始化, 请注意authority的唯一性问题和<code>ContentProvider</code>只在主进程运行的问题.</p>
<h2 id="Seductive-Code"><a href="#Seductive-Code" class="headerlink" title="Seductive Code"></a><a href="https://publicobject.com/2016/12/19/seductive-code/" target="_blank" rel="external">Seductive Code</a></h2><p>当我们在改善代码可读性的时候, 很有可能会影响到性能和可维护性. </p>
<p>作者举例说明了他在实际编程中遇到的几个问题.</p>
<h2 id="Testing-Android-Things-–-Unit-amp-Vendor-tests"><a href="#Testing-Android-Things-–-Unit-amp-Vendor-tests" class="headerlink" title="Testing Android Things – Unit &amp; Vendor tests"></a><a href="http://blog.blundellapps.co.uk/testing-android-things-iot-meets-java/" target="_blank" rel="external">Testing Android Things – Unit &amp; Vendor tests</a></h2><p>如何开发Android Things应用, 才能让测试更加容易. 本文以一个很小的LED灯闪烁程序为例.</p>
<h2 id="Engineering-the-Architecture-Behind-Uber’s-New-Rider-App"><a href="#Engineering-the-Architecture-Behind-Uber’s-New-Rider-App" class="headerlink" title="Engineering the Architecture Behind Uber’s New Rider App"></a><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">Engineering the Architecture Behind Uber’s New Rider App</a></h2><p>Uber团队重新打造了他们的ride app, 提出了一个新的构架模式: Riblets.</p>
<p>关于架构的选型, 已有的类型可以查看这个<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tmcojtwgg" target="_blank" rel="external">iOS Architecture Patterns</a>.</p>
<h2 id="Rebuilding-the-Buffer-Android-Composer"><a href="#Rebuilding-the-Buffer-Android-Composer" class="headerlink" title="Rebuilding the Buffer Android Composer"></a><a href="https://overflow.buffer.com/2016/12/22/rebuild-android-composer/" target="_blank" rel="external">Rebuilding the Buffer Android Composer</a></h2><p>作者重构了自己应用的代码, 应用了clean architecture, 本文讲述了其过程.</p>
<h2 id="Papercut"><a href="#Papercut" class="headerlink" title="Papercut"></a><a href="http://stu.ie/?page_id=3133" target="_blank" rel="external">Papercut</a></h2><p><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a>是一个库, 用来标记那些我们觉得需要删除或者需要重构的代码.</p>
<h2 id="Concurrency-Primitives-in-Kotlin"><a href="#Concurrency-Primitives-in-Kotlin" class="headerlink" title="Concurrency Primitives in Kotlin"></a><a href="https://blog.egorand.me/concurrency-primitives-in-kotlin/" target="_blank" rel="external">Concurrency Primitives in Kotlin</a></h2><p>作者最近看了一本书, 讲Android的并发, 觉得很好, 想要用Kotlin来重写书中的例子, 结果发现:</p>
<ul>
<li>Kotlin中没有<code>synchronized</code>关键字.</li>
<li>Kotlin中没有<code>volatile</code>关键字.</li>
<li>Kotlin中的<code>Any</code>, 类比于Java中的<code>Object</code>, 但是却没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法.</li>
</ul>
<p>所以Kotlin中的并发是怎么处理呢? 这里有个问题: <a href="https://discuss.kotlinlang.org/t/concurrency-in-kotlin/858" target="_blank" rel="external">Kotlin forum</a>, Kotlin语言的开发人员表示这些应该由库来处理, 而不是语言本身.</p>
<p>尽管Kotlin不支持, 但是它还是提供了一些底层的并发工具.</p>
<ul>
<li>创建线程. 因为Kotlin可以调用Java代码, 所以仍然可以通过两种方法来创建线程.</li>
<li><code>@Synchronized</code>注解和<code>synchronized()</code>方法.</li>
<li><code>@Volatile</code>注解.</li>
<li>没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法, 但是可以把<code>Object</code>对象作为锁, 然后调用锁的这些方法.</li>
</ul>
<p><a href="http://stackoverflow.com/questions/35520583/why-there-are-no-concurrency-keywords-in-kotlin" target="_blank" rel="external">stackoverflow</a>上有一个相关问题, 答案很不错, 列了处理并发的一些有用的库.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KataScreenshotAndroid"><a href="#KataScreenshotAndroid" class="headerlink" title="KataScreenshotAndroid"></a><a href="https://github.com/Karumi/KataScreenshotAndroid" target="_blank" rel="external">KataScreenshotAndroid</a></h2><p>一个Screen Kata应用, 用来练习做UI测试的.</p>
<h2 id="Papercut-1"><a href="#Papercut-1" class="headerlink" title="Papercut"></a><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a></h2><p>一个用来标记需要重构或者移除代码的工具库.</p>
<h2 id="Squint"><a href="#Squint" class="headerlink" title="Squint"></a><a href="https://github.com/IntruderShanky/Squint" target="_blank" rel="external">Squint</a></h2><p>一个可以自定义的对角线切割View.</p>
<h2 id="Colorful"><a href="#Colorful" class="headerlink" title="Colorful"></a><a href="https://github.com/garretyoder/Colorful" target="_blank" rel="external">Colorful</a></h2><p>一个动态的主题库, 让你可以方便地修改应用的颜色.</p>
<h2 id="scytale"><a href="#scytale" class="headerlink" title="scytale"></a><a href="https://github.com/yakivmospan/scytale" target="_blank" rel="external">scytale</a></h2><p>包装了JCA API和AndroidKeyStore API, 让创建, 加密和管理任何Android API的keys变得更容易.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-237&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-237&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #237&quot;&gt;&lt;/a&gt;Android Weekly Issue #237&lt;/h1&gt;&lt;p&gt;December 25th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-237&quot;&gt;Android Weekly Issue #237&lt;/a&gt;&lt;br&gt;这是本年的最后一篇issue, 感谢大家.&lt;br&gt;本期内容包括: ConstraintLayout的使用; Android Things的应用; 如何利用第三方库使得Java具有Kotlin的一些新特性; Firebase是如何利用&lt;code&gt;ContentProvider&lt;/code&gt;进行初始化的; Kotlin上的并发处理; 其他还有一些关于程序架构, 代码优化相关的讨论.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="ExoPlayer" scheme="http://mengdd.github.io/tags/ExoPlayer/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Java" scheme="http://mengdd.github.io/tags/Java/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="ContentProvider" scheme="http://mengdd.github.io/tags/ContentProvider/"/>
    
      <category term="Architecture" scheme="http://mengdd.github.io/tags/Architecture/"/>
    
      <category term="Concurrency" scheme="http://mengdd.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 236</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/Design/2016/12/21/android-weekly-notes-issue-236/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/Design/2016/12/21/android-weekly-notes-issue-236/</id>
    <published>2016-12-21T02:27:39.000Z</published>
    <updated>2016-12-21T02:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-236"><a href="#Android-Weekly-Issue-236" class="headerlink" title="Android Weekly Issue #236"></a>Android Weekly Issue #236</h1><p>December 18th, 2016<br><a href="http://androidweekly.net/issues/issue-236" target="_blank" rel="external">Android Weekly Issue #236</a></p>
<p>本期内容包括: Google的物联网平台Android Things; FileProvider; Android Studio的Layout Preview使用; Retrofit2使用; Google Sign-In和SmartLock; 把敏感信息放入NDK的解决方式.</p>
<p>设计部分讨论了调色板的灵感来源和几个开发app的时候应该注意的问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Getting-started-with-Android-Things"><a href="#Getting-started-with-Android-Things" class="headerlink" title="Getting started with Android Things"></a><a href="https://medium.com/@alexsimo/getting-started-with-android-things-b73be3295b42#.c1arra4ps" target="_blank" rel="external">Getting started with Android Things</a></h2><p>Internet of Things (物联网, IoT), 是互联网, 传统电信网等咨询承载体, 让所有能行使独立功能的物品之间实现互联互通的网络.</p>
<p>2016年12月, Google发布了Android Things的开发者预览版, 这是一个专门为IoT设备定制的Android系统.</p>
<p>本篇文章一步一步地教你如何写一个IoT的基本程序, 跑在Raspberry Pi 3 Model B上.</p>
<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><a href="https://blog.stylingandroid.com/fileprovider/" target="_blank" rel="external">FileProvider</a></h2><p>上次我们提到了用<code>DownloadManager</code>下载的东西可以和其他应用分享, 那么如果我们下载的时候没有用<code>DownloadManager</code>呢? </p>
<p>比较常见的情况是我们的应用需要分享内容到其他应用, 或者是文件的类型是我们应用不能自己处理的, 需要找一个支持这种文件类型的其他应用来帮我们打开它.</p>
<p>怎么解决呢? 答案是用<code>FileProvider</code>.</p>
<p>上一期有一篇文章也说过Android 7开始废弃了”file://“, 解决方案就是用<code>FileProvider</code>, 所以实现是一样的, 这里就不重复了.</p>
<h2 id="Working-with-the-Layout-Preview"><a href="#Working-with-the-Layout-Preview" class="headerlink" title="Working with the Layout Preview"></a><a href="https://www.novoda.com/blog/layout-preview-101/" target="_blank" rel="external">Working with the Layout Preview</a></h2><p>Layout Preview向你展示了你的xml将如何在设备上显示. 你可以用它查看布局在不同的配置下如何显示, 比如可以切换横竖屏, 语言等等.</p>
<p>但是它同样也有一些问题:</p>
<p><strong>Issue #1: Preview显示空白</strong><br>当你的布局是由动态获取的数据来填充的, preview不知道如何填充, 所以你看到的是空白的. </p>
<p>一个好的practice是使用<code>tools</code>命名空间, 指定一些只在preview阶段使用的属性. 这样你就可以指定一些text或src用来预览.</p>
<p><strong>Tip #2: 使得动态内容在Preview可见</strong><br>如果你的图片是动态资源, 你也可以设置一些最大宽高给parent view, 以防真实的图片比期待的大太多或者是比例不对. 你可以设置<code>tools:layout_height</code> 和<code>tools:layout_width</code>, 还有<code>tools:background</code>在preview中查看view占多大.</p>
<p>本文还推荐了另一个阅读资料: <a href="https://tips.seebrock3r.me/tools-of-the-trade-part-1-f3c1c73de898#.e038jlqyy" target="_blank" rel="external">Tools of the trade — Part 1</a></p>
<p><strong>Tip #3: 修复坏掉的Previews</strong><br>当你创建一个自定义View的时候, 你需要确保你的View不需要任何外部依赖即可被实例化, 否则Preview可能看不到你的View. 因为Preview不是运行在你的app上的, 它只是运行在IDE的JVM上, 所以View framework之外的东西它是访问不到的.</p>
<p>解决办法是在你的自定义View中做一些特殊处理, 比如把依赖注入放在<code>!isInEditMode()</code>里, 或者用<code>tools:</code>命名空间加一些默认值.</p>
<p><strong>Tip #4: <merge> 布局没有被渲染</merge></strong></p>
<p><merge>里面的控件在preview里会被重叠在一起.<br>解决的办法是使用<code>tools:showIn=&quot;layout&quot;</code>, 指定<merge>具体是显示在哪个布局里. 如果你有多个布局都用到这个<merge>, 你可以选一个.</merge></merge></merge></p>
<p>从Android Studio 2.2开始, 你可以使用<code>tools:parentTag</code>来指定parent的类型, 比如<code>tools:parentTag=&quot;LinearLayout&quot;</code>.</p>
<p><strong>Tip #5: 在Preview中显示隐藏的View</strong><br>如果你在layout中把view的visibility设置为gone, 那么它是不会在Preview中显示的. </p>
<p>解决办法: 使用<code>tools:visibility=&quot;visible&quot;</code>.</p>
<h2 id="Android-Things-Tutorials"><a href="#Android-Things-Tutorials" class="headerlink" title="Android Things Tutorials"></a><a href="https://blog.mindorks.com/android-things-tutorials-getting-started-8464c11009ff#.dhacx13kq" target="_blank" rel="external">Android Things Tutorials</a></h2><p>Android Things教程.</p>
<h2 id="Get-Started-With-Retrofit-2-HTTP-Client"><a href="#Get-Started-With-Retrofit-2-HTTP-Client" class="headerlink" title="Get Started With Retrofit 2 HTTP Client"></a><a href="https://code.tutsplus.com/tutorials/getting-started-with-retrofit-2--cms-27792" target="_blank" rel="external">Get Started With Retrofit 2 HTTP Client</a></h2><p>本篇文章以实例讲述如何使用Retrofit, 虽然都是基础内容, 但讲解很详细.</p>
<h2 id="Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock"><a href="#Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock" class="headerlink" title="Improving sign-in experience with Google Sign-In and SmartLock"></a><a href="https://medium.com/@p.tournaris/android-improving-sign-in-experience-with-google-sign-in-and-smartlock-f0bfd789602a#.dqh1aptm4" target="_blank" rel="external">Improving sign-in experience with Google Sign-In and SmartLock</a></h2><p>Google提供了两种方式来帮助我们改善用户的登录体验:<br>Google Sign-In(之前被称为Google+ Sign-In)和SmartLock.</p>
<p>这篇文章举例解释了Google Sign-In和SmartLock的实现.</p>
<p>Google Sign-In的部分比较简单.</p>
<p>SmartLock让我们可以:</p>
<ul>
<li>让用户保存credentials.</li>
<li>在打开应用的时候请求credentials.</li>
<li>使用存在Chrome上的credentials, 这样我们的网站和app就可以共享credentials.</li>
<li>显示Email提示, 让用户选择email地址.</li>
<li>所有的这些信息都保存在Google的server里, 用户可以保存或删除.</li>
</ul>
<p>Demo app: <a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">charbgr/AuthManager</a></p>
<h2 id="Storing-your-secure-information-in-the-NDK"><a href="#Storing-your-secure-information-in-the-NDK" class="headerlink" title="Storing your secure information in the NDK"></a><a href="https://www.androidsecurity.info/2016/12/15/storing-your-secure-information-in-the-ndk/" target="_blank" rel="external">Storing your secure information in the NDK</a></h2><p>这篇文章说敏感信息放在Java代码里不安全, 很容易被人反编译查看出来, 如果放在NDK里面就好一些, 你打开查看的只能是二进制文件, 很难找到.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introduction-to-Natural-palettes"><a href="#Introduction-to-Natural-palettes" class="headerlink" title="Introduction to Natural palettes"></a><a href="https://stories.uplabs.com/introduction-to-natural-palettes-9503bfeee3d5#.z9y0xf7zc" target="_blank" rel="external">Introduction to Natural palettes</a></h2><p>作者从大自然的图像中得到颜色组合的灵感.<br>文章中举了几个例子, 如何用相关的照片找到相关主题的调色板.</p>
<p>另推荐一个网站: <a href="http://color.romanuke.com/" target="_blank" rel="external">IN COLOR<br> BALANCE</a></p>
<h2 id="Make-your-Android-app-look-better"><a href="#Make-your-Android-app-look-better" class="headerlink" title="Make your Android app look better"></a><a href="https://hackernoon.com/make-your-android-app-look-less-shitty-5dd63c4938f1#.4q5ro3ty8" target="_blank" rel="external">Make your Android app look better</a></h2><p>让你的App看起来更好的几点建议:</p>
<ul>
<li>使用同一个图标集的图标.<br>(这里推荐了一些图片工具和网站.)</li>
<li>使用Material Design设计的keylines, 使用固定的格子大小.</li>
<li>使用颜色的时候小心一些. (这里推荐了一些调色板网站)</li>
<li>选择字体要明智一些.</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Material-Components"><a href="#Material-Components" class="headerlink" title="Material Components"></a><a href="https://github.com/material-components" target="_blank" rel="external">Material Components</a></h2><p>模块化和可定制的Material Design UI组件. Android, iOS, Web.</p>
<h2 id="Android-oss-from-Kickstarter"><a href="#Android-oss-from-Kickstarter" class="headerlink" title="Android-oss from Kickstarter"></a><a href="https://github.com/kickstarter/android-oss" target="_blank" rel="external">Android-oss from Kickstarter</a></h2><p>Kickstarter开源了他们的Android应用.</p>
<h2 id="stencil"><a href="#stencil" class="headerlink" title="stencil"></a><a href="https://github.com/thoughtbot/stencil" target="_blank" rel="external">stencil</a></h2><p>一个kotlin写的Android库, 实现一种文字路径的动画.</p>
<h2 id="AuthManager"><a href="#AuthManager" class="headerlink" title="AuthManager"></a><a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">AuthManager</a></h2><p>包装了Google Sign-In和SmartLock的Manager.</p>
<h2 id="FolioReader-Android"><a href="#FolioReader-Android" class="headerlink" title="FolioReader-Android"></a><a href="https://github.com/FolioReader/FolioReader-Android" target="_blank" rel="external">FolioReader-Android</a></h2><p>一个ePub阅读器和解析框架.</p>
<h2 id="BufferTextInputLayout"><a href="#BufferTextInputLayout" class="headerlink" title="BufferTextInputLayout"></a><a href="https://github.com/bufferapp/BufferTextInputLayout" target="_blank" rel="external">BufferTextInputLayout</a></h2><p>对Support Library中的<code>TextInputLayout</code>的扩展, 增加了字数统计.</p>
<h2 id="TextLayoutBuilder"><a href="#TextLayoutBuilder" class="headerlink" title="TextLayoutBuilder"></a><a href="https://facebookincubator.github.io/TextLayoutBuilder/" target="_blank" rel="external">TextLayoutBuilder</a></h2><p>使用Builder模式来配置创建一个Layout的属性.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-236&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-236&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #236&quot;&gt;&lt;/a&gt;Android Weekly Issue #236&lt;/h1&gt;&lt;p&gt;December 18th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-236&quot;&gt;Android Weekly Issue #236&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本期内容包括: Google的物联网平台Android Things; FileProvider; Android Studio的Layout Preview使用; Retrofit2使用; Google Sign-In和SmartLock; 把敏感信息放入NDK的解决方式.&lt;/p&gt;
&lt;p&gt;设计部分讨论了调色板的灵感来源和几个开发app的时候应该注意的问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
      <category term="Design" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/Design/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Security" scheme="http://mengdd.github.io/tags/Security/"/>
    
      <category term="Design" scheme="http://mengdd.github.io/tags/Design/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="IoT" scheme="http://mengdd.github.io/tags/IoT/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="IDE" scheme="http://mengdd.github.io/tags/IDE/"/>
    
      <category term="Retrofit2" scheme="http://mengdd.github.io/tags/Retrofit2/"/>
    
      <category term="Sign In" scheme="http://mengdd.github.io/tags/Sign-In/"/>
    
      <category term="SmartLock" scheme="http://mengdd.github.io/tags/SmartLock/"/>
    
      <category term="NDK" scheme="http://mengdd.github.io/tags/NDK/"/>
    
      <category term="Color" scheme="http://mengdd.github.io/tags/Color/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 235</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/12/16/android-weekly-notes-issue-235/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/12/16/android-weekly-notes-issue-235/</id>
    <published>2016-12-16T06:14:34.000Z</published>
    <updated>2016-12-16T06:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-235"><a href="#Android-Weekly-Issue-235" class="headerlink" title="Android Weekly Issue #235"></a>Android Weekly Issue #235</h1><p>December 11th, 2016<br><a href="http://androidweekly.net/issues/issue-235" target="_blank" rel="external">Android Weekly Issue #235</a><br>本期内容包括: 开发一个自定义View并发布为开源库的完整流程介绍; 用<code>AnimatedVectorDrawable</code>实现的动画; 什么样的程序是可测试的; <code>DownloadManager</code>介绍; Okhttp的重试; Android 7取消了<code>file://</code>; Android Studio即将推出的build cache功能; 支持离线模式的app构架; 如何写自定义的lint规则; Epoxy, 一个处理复杂RecyclerView屏的库; <code>FragmentPagerAdapter</code>和<code>FragmentStatePagerAdapter</code>的比较等. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Make-an-android-custom-view-publish-and-open-source"><a href="#Make-an-android-custom-view-publish-and-open-source" class="headerlink" title="Make an android custom view, publish and open source "></a><a href="https://medium.com/dualcores-studio/make-an-android-custom-view-publish-and-open-source-99a3d86df228#.zc8s14lek" target="_blank" rel="external">Make an android custom view, publish and open source </a></h2><p>作者开发了一个环形的SeekBar, 并把它作为一个库发布到了JCenter.</p>
<p><strong>作者首先讲了自定义View的实现</strong>:<br>首先是关于View生命周期的介绍, 在写自定义View的时候有几个关键的生命周期回调需要处理:<br><img src="/images/view-lifecycle-diagram-lite-version.png" alt="view-lifecycle-diagram-lite-version"></p>
<p>作者实现的几个关键步骤讲解:</p>
<ul>
<li>自定义属性并获取.</li>
<li>在<code>onMeasure()</code>中控制尺寸.</li>
<li>在<code>onDraw()</code>中绘制: 避免在<code>onDraw()</code>中分配内存; 用<code>invalidate()</code>方法来激发重绘.</li>
<li>在<code>onTouchEvent()</code>处理用户手势. 在他的环形SeekBar的实现里, 这里涉及到了点击坐标到角度的转换. </li>
</ul>
<p><strong>将自定义View库开源到Github</strong>:<br>开源到Github有个好的README很重要, 这里有几个tips:</p>
<ul>
<li>提供截图, Gif或者Video.</li>
<li>提供安装/使用说明.<br>作者自己的库: <a href="https://github.com/enginebai/SwagPoints" target="_blank" rel="external">SwagPoints</a></li>
</ul>
<p><strong>发布库</strong>:</p>
<ul>
<li>去<a href="https://bintray.com/" target="_blank" rel="external">JFrog Bintray</a>注册.</li>
<li>创建repository, package, 和版本号.</li>
<li>生成并上传, 用了<a href="https://github.com/blundell/release-android-library" target="_blank" rel="external">这个library</a>.</li>
<li>添加到Jcenter.</li>
<li>被接受之后收到邮件, 就可以使用了.</li>
</ul>
<h2 id="Animation-Jump-through"><a href="#Animation-Jump-through" class="headerlink" title="Animation: Jump-through"></a><a href="https://medium.com/google-developers/animation-jump-through-861f4f5b3de4#.k238d5tw2" target="_blank" rel="external">Animation: Jump-through</a></h2><p>用<code>AnimatedVectorDrawable</code>实现的一个很fancy的位置标志动画.</p>
<h2 id="What-makes-Android-Apps-Testable"><a href="#What-makes-Android-Apps-Testable" class="headerlink" title="What makes Android Apps Testable"></a><a href="http://www.philosophicalhacker.com/post/what-makes-android-apps-testable/" target="_blank" rel="external">What makes Android Apps Testable</a></h2><p>如果程序的架构不适合测试, 那么硬要写一些测试很可能就会面临这样的局面: 要么就是发现没法写测试, 要么就是为了写测试而破坏了代码, 做了一些奇怪的事情.</p>
<p>那么到底是什么样的程序才是适合写测试, 或者是可测试的呢?</p>
<p>有一个有趣的定义是seam(接缝), 在接缝处你可以改变程序的行为, 而不用编辑当前程序. 如果程序没有接缝, 你将无法设置测试的初始条件和验证测试结果.</p>
<p>本文中举了一个实际的例子, 开始的时候程序没有seam, 所以导致无法测试, 后来把静态方法改为实例的方法之后, 我们就可以通过Mockito来模拟行为, 设置条件, 最后通过验证某一方法的调用与否来进行验证.</p>
<h2 id="DownloadManager-–-Part-3"><a href="#DownloadManager-–-Part-3" class="headerlink" title="DownloadManager – Part 3"></a><a href="https://blog.stylingandroid.com/downloadmanager-part-3/" target="_blank" rel="external">DownloadManager – Part 3</a></h2><p>用<code>DownloadManager</code>来处理下载.<br>首先它在设备上有自己的UI, 还有notification, 还有Downloads app能让用户管理下载文件.</p>
<p> 我们可以查询到文件的一些信息, 比如MIME type, 文件尺寸, 下载状态等.</p>
<p> 我们还可以用<code>getUriForDownloadedFile()</code>方法来获取一个URI, 配合MIME type, 发送Intent, 来打开一个相关的查看程序.</p>
<p> 关于储存文件的合适地点:</p>
<ul>
<li>文件小, 仅app自己使用 -&gt; 私有数据区域(默认行为).</li>
<li>文件大, 仅app自己使用 -&gt; 外部存储的私有数据区域(不需要权限). <code>setDestinationInExternalFilesDir()</code>.</li>
<li>文件需要被别的应用访问 -&gt; 外部存储的共有区域, 需要<code>WRITE_EXTERNAL_STORAGE</code>权限. <code>setDestinationInExternalPublicDir()</code>.</li>
</ul>
<h2 id="OkHttp-is-quietly-retrying-requests-Is-your-API-ready"><a href="#OkHttp-is-quietly-retrying-requests-Is-your-API-ready" class="headerlink" title="OkHttp is quietly retrying requests. Is your API ready?"></a><a href="https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace#.ldxyyly7t" target="_blank" rel="external">OkHttp is quietly retrying requests. Is your API ready?</a></h2><p>在网路较慢或不稳定的时候, OkHttp有可能会重复发送请求, 直到成功. </p>
<p>这个重试的逻辑是通过<a href="https://github.com/square/okhttp/blob/07309c1c7d9e296014268ebd155ebf7ef8679f6c/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java" target="_blank" rel="external">RetryAndFollowUpInterceptor.java</a>实现的.</p>
<p>那么, 我们可以关掉这个重试行为吗? 有一些issues就在讨论这个问题: <a href="https://github.com/square/okhttp/issues/1043" target="_blank" rel="external">Issue # 1043</a>. 后来有两个pull requests:  <a href="https://github.com/square/okhttp/pull/1259" target="_blank" rel="external">PR #1259</a>和<a href="https://github.com/square/okhttp/pull/2479" target="_blank" rel="external">PR #2479</a>改进了这个问题, 减少(但并没有消除)了不必要的retry请求.</p>
<p>全局关闭重试行为: <code>OkHttpClient.Builder .retryOnConnectionFailure()</code>设置为false. 但是注意这样是很粗暴并具有破坏性的, 消除了retry逻辑带来的好处:</p>
<ul>
<li>如果Url有多个IP, 失败了一个还可以试另一个.</li>
<li>连接池中的连接偶尔会time out, 减少这种意外导致的后果.</li>
<li>可以顺次查找多个代理, 如果都失败了再转向直接连接.</li>
</ul>
<p><strong>解决真正的问题</strong>: 关闭静默重试在某些情形下有帮助, 但是其实它隐藏了真正的问题, 就是你的API是否是幂等的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">idempotent</a>. server端可以根据客户端的GUID来检测重复, 这样server就不会多次执行操作, 会通知发送者.</p>
<h2 id="File-scheme-is-now-not-allowed-with-Intent-on-N"><a href="#File-scheme-is-now-not-allowed-with-Intent-on-N" class="headerlink" title="File scheme is now not allowed with Intent on N"></a><a href="https://inthecheesefactory.com/blog/how-to-share-access-to-file-with-fileprovider-on-android-nougat/en" target="_blank" rel="external">File scheme is now not allowed with Intent on N</a></h2><p>Android N (Nougat, API 24)开始, 不再允许发送<code>file://</code>的Intent, 将会直接抛出<code>FileUriExposedException</code>异常.</p>
<p>所以当你把<code>targetSdkVersion</code>改为24之后, 你必须要确保你修复了这些问题再发布.</p>
<p>解决方案是什么呢? 用<code>content://</code>, 结合<code>FileProvider</code>:<br>首先在manifest里面声明:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span><br><span class="line">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span><br><span class="line">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.provider"</span></span><br><span class="line">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span><br><span class="line">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span><br><span class="line">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span><br><span class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在<code>res\xml\provider_paths.xml</code>文件里指明路径:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external_files"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最后, 把<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri photoURI = Uri.fromFile(createImageFile());</span><br></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uri photoURI = FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">        BuildConfig.APPLICATION_ID + <span class="string">".provider"</span>,</span><br><span class="line">        createImageFile());</span><br></pre></td></tr></table></figure></p>
<p>然后放在Intent里发送就好了.</p>
<p>注意, 如果你的<code>targetSdkVersion</code>还没有更新到24, 那么即便是在Nougat的手机上<code>file://</code>也仍然是能正常使用的.</p>
<h2 id="Use-Android-Studio-Gradle-Build-Cache-for-faster-builds"><a href="#Use-Android-Studio-Gradle-Build-Cache-for-faster-builds" class="headerlink" title="Use Android Studio Gradle Build Cache for faster builds"></a><a href="http://zeroturnaround.com/rebellabs/using-build-cache-in-android-studio-makes-gradle-build-faster/" target="_blank" rel="external">Use Android Studio Gradle Build Cache for faster builds</a></h2><p>Android Studio当前的最新版是2.3 Canary 2. 有一些新的改进, 但是其中最吸引人的是这个<a href="http://tools.android.com/tech-docs/build-cache" target="_blank" rel="external">build cache</a>. 它会使你的clean build更快.</p>
<p>本文后面解析了build cache的工作原理.</p>
<h2 id="Offline-App-Architecture-build-for-the-Next-Billion"><a href="#Offline-App-Architecture-build-for-the-Next-Billion" class="headerlink" title="Offline App Architecture, build for the Next Billion"></a><a href="https://hackernoon.com/so-you-want-to-develop-for-the-next-billion-9eb072c26bc8#.1zklimr3o" target="_blank" rel="external">Offline App Architecture, build for the Next Billion</a></h2><p>一个好的应用应该在网络不好甚至离线的时候仍然可以使用, 我们应该做些什么呢?</p>
<ul>
<li>确定连接状况. 可以使用这个<a href="https://github.com/facebook/network-connection-class" target="_blank" rel="external">network-connection-class
</a>. 如果你使用的是Okhttp, 可以加一个Intercepter来进行采样.</li>
<li>有效地缓存. 从网络取数据很慢并且昂贵, 所以有效地利用之前取到的数据是很关键的优化. (Cache-Control, Etag).</li>
<li>在本地操作, 在全局同步. 等网络请求的时候可以先显示本地数据, 而不是loading.</li>
<li>有效地处理线程.</li>
<li>优化图片. 网络不好的时候先用RGB_565, 等网络变好了再取高质量图片.</li>
<li>使用大Cookie. 尽量一次传输更多的数据(big cookie), 而不是频繁发送一些小请求(small cookies).</li>
</ul>
<h2 id="Writing-custom-lint-rules-and-integrating-them"><a href="#Writing-custom-lint-rules-and-integrating-them" class="headerlink" title="Writing custom lint rules and integrating them"></a><a href="https://medium.com/@mosesJay/writing-custom-lint-rules-and-integrating-them-with-android-studio-inspections-or-carefulnow-c54d72f00d30#.5y0o98bor" target="_blank" rel="external">Writing custom lint rules and integrating them</a></h2><p>如何创建自定义的lint规则.<br>事情的由来是作者发现了一个死循环调用, 然后他想做一个什么标记以防以后其他人会犯同样的错误.</p>
<p>然后他想到的是<a href="https://developer.android.com/studio/write/annotations.html#adding-nullness" target="_blank" rel="external">@Nullable注解</a>, 的检查, 实质是依靠<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">lint</a>来实现的.</p>
<p>于是他自己写了一个自定义的lint规则, 来提示使用用他的注解<code>@CarefulNow</code>标记的方法时应当注意.<br>详细的实现方式请看原文.</p>
<h2 id="Epoxy-Airbnb’s-View-Architecture-on-Android"><a href="#Epoxy-Airbnb’s-View-Architecture-on-Android" class="headerlink" title="Epoxy: Airbnb’s View Architecture on Android"></a><a href="https://medium.com/airbnb-engineering/epoxy-airbnbs-view-architecture-on-android-c3e1af150394#.uyvuayspc" target="_blank" rel="external">Epoxy: Airbnb’s View Architecture on Android</a></h2><p><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a>是一个Android库, 用来处理复杂的RecyclerView屏. 本文介绍了它在项目中实际的使用.</p>
<h2 id="Adventures-with-FragmentStatePagerAdapter"><a href="#Adventures-with-FragmentStatePagerAdapter" class="headerlink" title="Adventures with FragmentStatePagerAdapter"></a><a href="https://medium.com/inloop/adventures-with-fragmentstatepageradapter-4f56a643f8e0#.qk6aygake" target="_blank" rel="external">Adventures with FragmentStatePagerAdapter</a></h2><p>可能有很多Android开发者对于<br><a href="https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html" target="_blank" rel="external">FragmentPagerAdapter</a>和<a href="https://developer.android.com/reference/android/support/v4/app/FragmentStatePagerAdapter.html" target="_blank" rel="external">FragmentStatePagerAdapter</a>的区别不是太清楚或根本不知道, 本文作者就具体介绍了二者的不同.</p>
<p><strong>基本不同</strong></p>
<p><code>FragmentPagerAdapter</code><br>适用于项目个数确定的情形.<br>为什么呢? 因为一旦fragment的实例被创建, 它永远也不会从<code>FragmentManager</code>中移除, 直到Activity被销毁.</p>
<p>当Fragment不见的时候, 仅仅是<code>onDestroyView()</code>被调用, 当fragment再次回来时, 再调用<code>onCreateView()</code>.</p>
<p><code>FragmentStatePagerAdapter</code><br>当fragment的实例不可达的时候, 实例就会立即从<code>FragmentManager</code>移除. 被移除的fragment实例的状态由<code>FragmentStatePagerAdapter</code>保存, 当你再次回到该项的时候, fragment会重建新实例, 并且状态被恢复. 所以这种adapter适用于项目个数不确定或的情况.</p>
<p>所以使用<code>FragmentPagerAdapter</code>的时候需要注意内存问题.</p>
<p><strong>notifyDatasetChanged()的问题</strong>.</p>
<p><code>notifyDataSetChanged()</code>是用来处理数据集变化的情况, 比如一些项目增删的情况. 这个方法不是用来刷新当前显示的Fragment或其中的Views的.</p>
<p>文章中还有一些关于数据改变实现以及现有issue的讨论. 为了解决issue作者还发布了一个库<a href="https://github.com/inloop/UpdatableFragmentStatePagerAdapter" target="_blank" rel="external">UpdatableFragmentStatePagerAdapter</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KeepActivitiesTile"><a href="#KeepActivitiesTile" class="headerlink" title="KeepActivitiesTile"></a><a href="https://github.com/Stocard/KeepActivitiesTile" target="_blank" rel="external">KeepActivitiesTile</a></h2><p>一个quick settings tile来开启”Don’t keep activities”.</p>
<h2 id="WaveLoading"><a href="#WaveLoading" class="headerlink" title="WaveLoading"></a><a href="https://github.com/race604/WaveLoading" target="_blank" rel="external">WaveLoading</a></h2><p>一个波形的loading图, 水面上涨代表loading程度.</p>
<h2 id="coordinators"><a href="#coordinators" class="headerlink" title="coordinators"></a><a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a></h2><p>Simple MVWhatever for Android.</p>
<h2 id="epoxy"><a href="#epoxy" class="headerlink" title="epoxy"></a><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a></h2><p>一个处理复杂的RecyclerView屏的库.</p>
<h2 id="Screen-Record-for-Android"><a href="#Screen-Record-for-Android" class="headerlink" title="Screen Record for Android"></a><a href="https://gist.github.com/tasomaniac/93cefd97af13e2ea2b2f248affb373bd" target="_blank" rel="external">Screen Record for Android</a></h2><p>录屏脚本.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-235&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-235&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #235&quot;&gt;&lt;/a&gt;Android Weekly Issue #235&lt;/h1&gt;&lt;p&gt;December 11th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-235&quot;&gt;Android Weekly Issue #235&lt;/a&gt;&lt;br&gt;本期内容包括: 开发一个自定义View并发布为开源库的完整流程介绍; 用&lt;code&gt;AnimatedVectorDrawable&lt;/code&gt;实现的动画; 什么样的程序是可测试的; &lt;code&gt;DownloadManager&lt;/code&gt;介绍; Okhttp的重试; Android 7取消了&lt;code&gt;file://&lt;/code&gt;; Android Studio即将推出的build cache功能; 支持离线模式的app构架; 如何写自定义的lint规则; Epoxy, 一个处理复杂RecyclerView屏的库; &lt;code&gt;FragmentPagerAdapter&lt;/code&gt;和&lt;code&gt;FragmentStatePagerAdapter&lt;/code&gt;的比较等. &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="AnimatedVectorDrawable" scheme="http://mengdd.github.io/tags/AnimatedVectorDrawable/"/>
    
      <category term="Test" scheme="http://mengdd.github.io/tags/Test/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Custom View" scheme="http://mengdd.github.io/tags/Custom-View/"/>
    
      <category term="JCenter" scheme="http://mengdd.github.io/tags/JCenter/"/>
    
      <category term="DownloadManager" scheme="http://mengdd.github.io/tags/DownloadManager/"/>
    
      <category term="OkHttp" scheme="http://mengdd.github.io/tags/OkHttp/"/>
    
      <category term="Offline Architecture" scheme="http://mengdd.github.io/tags/Offline-Architecture/"/>
    
      <category term="lint" scheme="http://mengdd.github.io/tags/lint/"/>
    
      <category term="FragmentPagerAdapter" scheme="http://mengdd.github.io/tags/FragmentPagerAdapter/"/>
    
      <category term="FragmentStatePagerAdapter" scheme="http://mengdd.github.io/tags/FragmentStatePagerAdapter/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 234</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/React-Native/Java/2016/12/13/android-weekly-notes-issue-234/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/React-Native/Java/2016/12/13/android-weekly-notes-issue-234/</id>
    <published>2016-12-13T03:08:45.000Z</published>
    <updated>2016-12-13T03:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-234"><a href="#Android-Weekly-Issue-234" class="headerlink" title="Android Weekly Issue #234"></a>Android Weekly Issue #234</h1><p>December 4th, 2016<br><a href="http://androidweekly.net/issues/issue-234" target="_blank" rel="external">Android Weekly Issue #234</a><br>本期内容包括: ConstraintLayout的使用; React Native教程; fastlane管理模拟器; Android中的任务调度; 文字sticker的实现; 给Android library加flavor; 更好的关键帧动画; SQLDelight的使用; icon Animation; OkLog的使用等等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Guide-to-ConstraintLayout"><a href="#Guide-to-ConstraintLayout" class="headerlink" title="Guide to ConstraintLayout"></a><a href="https://medium.com/@loutry/guide-to-constraintlayout-407cd87bc013#.pdg54u72z" target="_blank" rel="external">Guide to ConstraintLayout</a></h2><p>这篇文章教你如何使用<code>ConstraintLayout</code>, 有很多实际的例子.</p>
<h2 id="React-Native-Express"><a href="#React-Native-Express" class="headerlink" title="React Native Express"></a><a href="http://www.reactnativeexpress.com/" target="_blank" rel="external">React Native Express</a></h2><p>一步一步地教你跨平台的Reactive Native, 比官方的文档要深入, 并且提供例子.</p>
<h2 id="Managing-Android-Virtual-Devices-during-test-session"><a href="#Managing-Android-Virtual-Devices-during-test-session" class="headerlink" title="Managing Android Virtual Devices during test session"></a><a href="https://medium.com/azimolabs/managing-android-virtual-devices-during-test-session-98a403acffc2#.cu4nfhl6u" target="_blank" rel="external">Managing Android Virtual Devices during test session</a></h2><p>作者他们用<a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">fastlane</a>管理模拟器, 并且开发了一个插件.</p>
<h2 id="You-don’t-have-to-use-WeakReference-to-avoid-memory-leaks"><a href="#You-don’t-have-to-use-WeakReference-to-avoid-memory-leaks" class="headerlink" title="You don’t have to use WeakReference to avoid memory leaks"></a><a href="https://medium.com/google-developer-experts/weakreference-in-android-dd1e66b9be9d#.vmxu20g30" target="_blank" rel="external">You don’t have to use WeakReference to avoid memory leaks</a></h2><p>并不是到处都要用<code>WeakReference</code>来避免内存泄漏.</p>
<h2 id="Effective-Java-for-Android"><a href="#Effective-Java-for-Android" class="headerlink" title="Effective Java for Android"></a><a href="https://medium.com/rocknnull/effective-java-for-android-cheatsheet-bf4e3433889a#.8t44xdb4t" target="_blank" rel="external">Effective Java for Android</a></h2><p>一个cheat-sheet, Effective Java中提到的内容, 作者列出了他认为在Android开发中最重要的几项:</p>
<ul>
<li>用private来限制不可实例化.</li>
<li>使用静态工厂方法.</li>
<li>使用Builders.</li>
<li>避免互换性.</li>
<li>静态内部类.</li>
<li>使用泛型.</li>
<li>返回空的集合而不是null.</li>
<li>字符串连接用StringBuilder, 不要用+.</li>
<li>可恢复的异常.</li>
</ul>
<h2 id="Scheduling-tasks-in-Android-made-easy"><a href="#Scheduling-tasks-in-Android-made-easy" class="headerlink" title="Scheduling tasks in Android made easy"></a><a href="https://blog.hypertrack.io/2016/12/01/scheduling-tasks-in-android-made-easy/" target="_blank" rel="external">Scheduling tasks in Android made easy</a></h2><p>分发异步任务的时候, 用很多选择: <code>AlarmManager</code>, <code>Handler</code>, <code>JobSheduler</code>, <code>GcmNetworkManager</code>. 作者他们的库: <a href="https://github.com/hypertrack/smart-scheduler-android" target="_blank" rel="external">smart-scheduler-android</a>就是用来有效地处理异步任务调度问题.</p>
<h2 id="How-to-create-beautiful-text-stickers-for-Android"><a href="#How-to-create-beautiful-text-stickers-for-Android" class="headerlink" title="How to create beautiful text stickers for Android"></a><a href="https://medium.com/uptech-team/how-to-create-beautiful-text-stickers-for-android-10eeea0cee09#.11x8ar94q" target="_blank" rel="external">How to create beautiful text stickers for Android</a></h2><p>之前作者有一篇文章讲了如何创建Snapchat一样的图片stickers.</p>
<p>本篇讲如何创建文字的stickers, 代码: <a href="https://github.com/uptechteam/MotionViews-Android" target="_blank" rel="external">MotionViews-Android</a>.</p>
<h2 id="Elite-Worship"><a href="#Elite-Worship" class="headerlink" title="Elite Worship"></a><a href="http://blog.sqisland.com/2016/12/elite-worship.html" target="_blank" rel="external">Elite Worship</a></h2><p>Chiu-Ki Chan分享了一些她的看法, 关于精英崇拜, 和如何让社区更加平等, 鼓励每一个人都参与进来.</p>
<h2 id="Product-Flavors-for-Android-Libraries"><a href="#Product-Flavors-for-Android-Libraries" class="headerlink" title="Product Flavors for Android Libraries"></a><a href="https://medium.com/@sahildave/product-flavors-for-android-library-d3b2d240fca2#.ravhhk30a" target="_blank" rel="external">Product Flavors for Android Libraries</a></h2><p>如何给Android Library加上不同的flavor使用.</p>
<h2 id="Keyframes-Delivering-scalable-high-quality-animations"><a href="#Keyframes-Delivering-scalable-high-quality-animations" class="headerlink" title="Keyframes: Delivering scalable, high-quality animations"></a><a href="https://code.facebook.com/posts/354469174916519" target="_blank" rel="external">Keyframes: Delivering scalable, high-quality animations</a></h2><p>Facebook分享了一个库<a href="https://github.com/facebookincubator/Keyframes" target="_blank" rel="external">Keyframes</a>用来导出AE的动画, 并且在移动设备上播放它.</p>
<h2 id="SQLDelight-Getting-Started"><a href="#SQLDelight-Getting-Started" class="headerlink" title="SQLDelight: Getting Started"></a><a href="https://medium.com/@tonyowen/sqldelight-getting-started-67054fe51306#.rske25ore" target="_blank" rel="external">SQLDelight: Getting Started</a></h2><p><a href="https://github.com/square/sqldelight" target="_blank" rel="external">sqldelight</a>是一个库, 可以用SQL语句来生成Java Model类.<br>SQLDelight也是一个Intellij插件.</p>
<p>作者介绍了如何使用SQLDelight, 注意生成models需要结合AutoValue.</p>
<h2 id="Your-ViewHolders-are-Dumb-Make-’em-Not-Dumb"><a href="#Your-ViewHolders-are-Dumb-Make-’em-Not-Dumb" class="headerlink" title="Your ViewHolders are Dumb. Make ’em Not Dumb"></a><a href="https://medium.com/@jonfhancock/your-viewholders-are-dumb-make-em-not-dumb-82e6f73f630c#.auaur0y3r" target="_blank" rel="external">Your ViewHolders are Dumb. Make ’em Not Dumb</a></h2><p>作者举例说明ViewHolder应该如何优化代码, 解放Adapter.</p>
<h2 id="An-Introduction-to-Icon-Animation-Techniques"><a href="#An-Introduction-to-Icon-Animation-Techniques" class="headerlink" title="An Introduction to Icon Animation Techniques"></a><a href="http://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html" target="_blank" rel="external">An Introduction to Icon Animation Techniques</a></h2><p>如何创建漂亮的icon动画.</p>
<h2 id="OkLog-2-0-—-improved-Android-network-logging"><a href="#OkLog-2-0-—-improved-Android-network-logging" class="headerlink" title="OkLog 2.0 — improved Android network logging"></a><a href="https://medium.com/@simonpercic/oklog-2-0-improved-android-network-logging-a72b2ffe4c66#.6h8w44eh8" target="_blank" rel="external">OkLog 2.0 — improved Android network logging</a></h2><p><a href="https://github.com/simonpercic/OkLog" target="_blank" rel="external">OkLog</a>是一个库, 可以在logcat中打印网络请求和响应, 点击进入页面查看, 本文介绍2.0版本的改进.</p>
<h2 id="How-to-Build-an-Android-App-for-Fire-TV-Part-4"><a href="#How-to-Build-an-Android-App-for-Fire-TV-Part-4" class="headerlink" title="How to Build an Android App for Fire TV (Part 4)"></a><a href="https://medium.com/amazon-appstore/developing-for-the-living-room-how-to-build-an-android-app-for-fire-tv-part-4-cbe572a6f1e6#.zfg39casg" target="_blank" rel="external">How to Build an Android App for Fire TV (Part 4)</a></h2><p>本文是为Fire TV搭建一个Android App系列文章的第四篇.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-PageFlip"><a href="#android-PageFlip" class="headerlink" title="android-PageFlip"></a><a href="https://github.com/eschao/android-PageFlip" target="_blank" rel="external">android-PageFlip</a></h2><p>3D的翻页效果.</p>
<h2 id="smart-scheduler-android"><a href="#smart-scheduler-android" class="headerlink" title="smart-scheduler-android"></a><a href="https://github.com/hypertrack/smart-scheduler-android" target="_blank" rel="external">smart-scheduler-android</a></h2><p>用于周期性和非周期性任务分发的工具类.</p>
<h2 id="PageLoader"><a href="#PageLoader" class="headerlink" title="PageLoader"></a><a href="https://github.com/arieridwan8/pageloader" target="_blank" rel="external">PageLoader</a></h2><p>一个简单的可定制化的loading页面库.</p>
<h2 id="fastlane-plugin-automated-test-emulator-run"><a href="#fastlane-plugin-automated-test-emulator-run" class="headerlink" title="fastlane-plugin-automated-test-emulator-run"></a><a href="https://github.com/AzimoLabs/fastlane-plugin-automated-test-emulator-run" target="_blank" rel="external">fastlane-plugin-automated-test-emulator-run</a></h2><p>fastlane插件, 用于启动模拟器进行自动化测试.</p>
<h2 id="Keyframes"><a href="#Keyframes" class="headerlink" title="Keyframes"></a><a href="https://github.com/facebookincubator/Keyframes" target="_blank" rel="external">Keyframes</a></h2><p>导出AE动画并在移动设备上播放的库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-234&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-234&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #234&quot;&gt;&lt;/a&gt;Android Weekly Issue #234&lt;/h1&gt;&lt;p&gt;December 4th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-234&quot;&gt;Android Weekly Issue #234&lt;/a&gt;&lt;br&gt;本期内容包括: ConstraintLayout的使用; React Native教程; fastlane管理模拟器; Android中的任务调度; 文字sticker的实现; 给Android library加flavor; 更好的关键帧动画; SQLDelight的使用; icon Animation; OkLog的使用等等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
      <category term="React Native" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/React-Native/"/>
    
      <category term="Java" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/React-Native/Java/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="React Native" scheme="http://mengdd.github.io/tags/React-Native/"/>
    
      <category term="fastlane" scheme="http://mengdd.github.io/tags/fastlane/"/>
    
      <category term="Effective Java" scheme="http://mengdd.github.io/tags/Effective-Java/"/>
    
      <category term="Sticker" scheme="http://mengdd.github.io/tags/Sticker/"/>
    
      <category term="Flavor" scheme="http://mengdd.github.io/tags/Flavor/"/>
    
      <category term="SQLDelight" scheme="http://mengdd.github.io/tags/SQLDelight/"/>
    
      <category term="OkLog" scheme="http://mengdd.github.io/tags/OkLog/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 233</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/Java/2016/12/01/android-weekly-notes-issue-233/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/Java/2016/12/01/android-weekly-notes-issue-233/</id>
    <published>2016-12-01T10:23:40.000Z</published>
    <updated>2016-12-13T03:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-233"><a href="#Android-Weekly-Issue-233" class="headerlink" title="Android Weekly Issue #233"></a>Android Weekly Issue #233</h1><p>November 27th, 2016<br><a href="http://androidweekly.net/issues/issue-233" target="_blank" rel="external">Android Weekly Issue #233</a><br>本期内容包括: 用Mockito做RxJava的单元测试; Android开发中的命令行使用; Android 7.1的App Shortcuts; 自定义View的绘制; 用Firebase的Remote Config进行feature逐步分发; APK分析工具的使用, APK瘦身讨论; RxJava处理网络请求和缓存; presenter的设计; 用Firebase发送push notification; transient关键字的使用等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Testing-asynchronous-RxJava-code-using-Mockito"><a href="#Testing-asynchronous-RxJava-code-using-Mockito" class="headerlink" title="Testing asynchronous RxJava code using Mockito"></a><a href="https://medium.com/@fabioCollini/testing-asynchronous-rxjava-code-using-mockito-8ad831a16877#.yhndxn3y1" target="_blank" rel="external">Testing asynchronous RxJava code using Mockito</a></h2><p>这篇文章讲了如何用Mockito给RxJava的异步请求代码写单元测试.<br>内容包括了:</p>
<ul>
<li>如何设置Mockito的默认返回值. (通过自定义的<code>MockitoConfiguration</code>类).</li>
<li>如何把异步变为同步测试. (1.用<code>blockingGet()</code>; 2.在RxJava2中, 可以使用<code>TestObserver</code>的<code>awaitTerminalEvent()</code>).</li>
<li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a>的使用.</li>
<li>测试异步代码. 使用Rule来替换原来的scheduler.</li>
<li><code>flatMap()</code>, <code>concatMap()</code>, <code>concatMapEager()</code>操作符的使用.</li>
<li>测试Timeout.</li>
<li>测试异常和retry逻辑.</li>
</ul>
<p>好用的工具: <a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a><br>用来更方便地写Java测试中的assert语句.</p>
<h2 id="Mastering-the-Terminal-side-of-Android-development"><a href="#Mastering-the-Terminal-side-of-Android-development" class="headerlink" title="Mastering the Terminal side of Android development"></a><a href="https://medium.com/@cesarmcferreira/mastering-the-terminal-side-of-android-development-e7520466c521#.5pjzgdn2s" target="_blank" rel="external">Mastering the Terminal side of Android development</a></h2><p>作者分享了在Android开发中他是如何使用命令行的.</p>
<p>使用更好的命令行程序: <a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a>.<br>它有很多有用的<a href="https://www.iterm2.com/features.html" target="_blank" rel="external">features</a>, 比如分屏, 自定义颜色, 粘贴历史等.</p>
<p><strong>on-my-zsh</strong>: </p>
<p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">on-my-zsh</a>内置了一个<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="external">git plugin</a>, 提供了很多aliases和功能.</p>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="external">zsh-autosuggestions</a>会在你输入的时候根据历史提供建议.</p>
<p>你可以用Ctrl + R在命令历史中进行逆向智能搜索(Reverse intelligent search). 你开始输入这个命令, 命令行会在历史中寻找并自动补全. 你可以按Enter来执行这个命令, 或者左右箭头来编辑命令, 或者继续按Ctrl + R在其他可能的命令中寻找.</p>
<p><strong>dryrun</strong></p>
<p>如果你在github上看到一个程序, 想要运行一下看看, 你不必再把它下载下来, 导入Android Studio了.</p>
<p>你只需要用<a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="external">dryrun</a>, 一句命令就可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dryrun REMOTE_GIT_URL</span><br></pre></td></tr></table></figure></p>
<p><strong>Build faster, build offline</strong></p>
<p>在build的时候使用–offline可以让所有依赖都使用缓存版本, 不再进行网络请求, 从而加快执行速度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDevelopDebug --offline</span><br><span class="line">./gradlew test --offline</span><br></pre></td></tr></table></figure></p>
<p>在Android Studio中也可以进行设置.<br>在<code>Settings -&gt; Build, Execution, Deployment -&gt; Build tools -&gt; Gradle</code>中勾选<code>Offline work</code>即可.</p>
<p><strong>alfi</strong><br><a href="https://github.com/cesarferreira/alfi" target="_blank" rel="external">alfi</a>是一个工具, 装了这个工具之后, 用一行命令就可以查到第三方库的依赖语句, 然后你就可以把它拷贝粘贴到<code>build.gradle</code>中去了.</p>
<p><strong>gradle tasks shortcuts</strong><br>gradle的task有缩写版的, 比如:</p>
<ul>
<li>iDD for installDevelopmentDebug</li>
<li>aDD for assembleDevelopmentDebug</li>
<li>cC for connectedCheck</li>
</ul>
<p><strong>Android Rocket Launcher</strong><br><a href="https://github.com/cesarferreira/android-rocket-launcher" target="_blank" rel="external">Android Rocket Launcher</a>增加新的tasks, 在命令行启动应用.</p>
<p><strong>直接在console输出单元测试结果</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  testOptions.unitTests.all &#123;</span><br><span class="line">    testLogging &#123;</span><br><span class="line">      events &apos;passed&apos;, &apos;skipped&apos;, &apos;failed&apos;, &apos;standardOut&apos;, &apos;standardError&apos;</span><br><span class="line">      outputs.upToDateWhen &#123; false &#125;</span><br><span class="line">      showStandardStreams = true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个工具<a href="https://github.com/JakeWharton/pidcat" target="_blank" rel="external">pidcat</a>可以指定包名显示log.</p>
<h2 id="Exploring-Android-Nougat-7-1-App-Shortcuts"><a href="#Exploring-Android-Nougat-7-1-App-Shortcuts" class="headerlink" title="Exploring Android Nougat 7.1 App Shortcuts"></a><a href="https://www.novoda.com/blog/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></h2><p>这篇文章讲Android 7.1推出的App Shortcuts如何实现.</p>
<h2 id="The-Quirks-of-Supporting-SDK-25"><a href="#The-Quirks-of-Supporting-SDK-25" class="headerlink" title="The Quirks of Supporting SDK 25"></a><a href="http://www.zdominguez.com/2016/11/the-quirks-of-supporting-sdk-25.html" target="_blank" rel="external">The Quirks of Supporting SDK 25</a></h2><p>作者分享了她在适配Nougat, API 25时学到的东西, 包括更换SDK版本, 圆形的启动icon, 还有app shortcuts. (根据文中的图标, 这个app居然是domain).</p>
<h2 id="Android-draw-a-custom-view"><a href="#Android-draw-a-custom-view" class="headerlink" title="Android: draw a custom view"></a><a href="https://medium.com/@romandanylyk96/android-draw-a-custom-view-ef79fe2ff54b#.i4ipiz2u7" target="_blank" rel="external">Android: draw a custom view</a></h2><p>作者自定义了一个ViewPager的page indicator: <a href="https://github.com/romandanylyk/PageIndicatorView" target="_blank" rel="external">PageIndicatorView</a>.</p>
<p>这篇文章讲述了如何自定义View, 首先是View的生命周期, 然后是具体如何实现, 如何避免一些常见的错误, 最后是如何添加View的动画.<br><img src="/images/view-lifecycle.png" alt="view-lifecycle"></p>
<p><strong>各个生命周期中应该干的事情</strong>:</p>
<ul>
<li>构造函数中: 解析自定义属性.</li>
<li><code>onAttachedToWindow()</code>中: 可以发现同一布局中相关的其他View, 其id是上一步通过自定义属性传入的.</li>
<li><code>onMeasure()</code>: 自定义View尺寸相关, 当覆盖这个方法时, 最后要调用<code>setMeasuredDimension(int width, int height)</code>.</li>
<li><code>onLayout()</code>: 一般这个方法是给ViewGroup的child指定位置和尺寸的, 对于自定义View来说, 没有child就没有必要覆盖这个方法.</li>
<li><code>onDraw()</code>: 这里是画东西的地方. 用canvas和Paint结合绘制. 需要注意的是<code>onDraw()</code>会被多次调用, 当你有一些变化, 滚动滑动等, 都会重绘, 所以这个方法中不要创建新对象. </li>
</ul>
<p><strong>View更新</strong><br>有两个方法可以让View重绘:</p>
<ul>
<li><code>invalidate()</code>: 只是重新绘制, 调用<code>onDraw()</code>方法.</li>
<li><code>requestLayout()</code>: 将会从<code>onMeasure()</code>开始, 可能会改变尺寸, 然后根据新尺寸重新绘制.</li>
</ul>
<p><strong>Animation</strong><br>自定义View的动画是一帧帧进行的, 这就意味着你每一步都要调用<code>invalidate()</code>来画它.</p>
<p>在自定义View中你的动画好助手是<code>ValueAnimator</code>, 它可以让你动画任何值.</p>
<h2 id="How-to-Stage-Rollout-Features-using-Firebase-Remote-Config"><a href="#How-to-Stage-Rollout-Features-using-Firebase-Remote-Config" class="headerlink" title="How to Stage Rollout Features using Firebase Remote Config"></a><a href="https://riggaroo.co.za/stage-rollout-features-firebase-remote-config-ios-android/" target="_blank" rel="external">How to Stage Rollout Features using Firebase Remote Config</a></h2><p><a href="https://support.google.com/googleplay/android-developer/answer/6346149?hl=en" target="_blank" rel="external">Staged Rollout</a>是Google Play Store的一个feature. 让你可以慢慢地把新版App发布给一部分用户, 并逐渐增大比例. 使用Firebase Remote Config, 我们可以做的更多,  我们可以控制某个feature的发布.</p>
<h2 id="Making-the-most-of-the-APK-analyzer"><a href="#Making-the-most-of-the-APK-analyzer" class="headerlink" title="Making the most of the APK analyzer"></a><a href="https://medium.com/google-developers/making-the-most-of-the-apk-analyzer-c066cb871ea2#.36ccm5y0c" target="_blank" rel="external">Making the most of the APK analyzer</a></h2><p>Android Studio中Build菜单有一项是<code>Analyze APK...</code>, 这是一个很有用的功能.</p>
<p><code>Raw File Size</code>是apk在磁盘上的大小.<br><code>Download size</code>是估计下载你的应用所需要的数据流量大小, 考虑到了Play Store的压缩.</p>
<p>文件和文件夹是按照大小降序排列的. 这对于Apk瘦身来说很有用, 很容易发现最占地方的原因.</p>
<p>比如作者发现了一些png很占地方, 于是就用<a href="https://developer.android.com/studio/write/vector-asset-studio.html" target="_blank" rel="external">PSD support in the Vector Asset import tool</a>把它们转成了<code>VectorDrawable</code>, 后向兼容用<code>VectorDrawableCompat</code>.</p>
<p>有一些没有压缩的WAV可以转成OGG. </p>
<p>在lib/里面, 发现它们要支持的三个ABI: x86, armeabi-v7a, armeabi, 解决的办法就是利用<a href="https://developer.android.com/studio/build/configure-apk-splits.html" target="_blank" rel="external">apk拆分</a>, 针对每一个ABI有一个不同的版本.</p>
<p>还有一个优化是把<code>android:extractNativeLibs</code> 属性设置为false, 这样系统就不会把.so文件在安装的时候从apk中拷贝到文件系统了. 这样应用的增量更新也会小一点.</p>
<p>这个功能有一个”Compare with”按钮, 利用它你可以比较两个apk的改变.</p>
<p>可以通过查看DEX文件来查看方法数限制 (Referenced Methods), 类混淆等问题.</p>
<h2 id="Rxify-The-Anti-Cache-then-Network-OR-Network-then-Cache-Problem"><a href="#Rxify-The-Anti-Cache-then-Network-OR-Network-then-Cache-Problem" class="headerlink" title="Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem"></a><a href="http://www.andevcon.com/news/rxify-the-anti-cache-then-network-or-network-then-cache-problem" target="_blank" rel="external"><code>Rxify</code> : The Anti Cache-then-Network OR Network-then-Cache Problem</a></h2><p>用RxJava处理网络请求和缓存.</p>
<ul>
<li>如果先使用Cache, 没有缓存的时候再进行网络请求. -&gt; 用<code>.concatWith()</code>和<code>.take(1)</code>.</li>
<li>如果优先取网络最新数据, 没网的时候才用缓存数据. -&gt; <code>.onErrorReturn()</code>.</li>
</ul>
<h2 id="Your-presenters-don’t-need-all-those-lifecycle-events"><a href="#Your-presenters-don’t-need-all-those-lifecycle-events" class="headerlink" title="Your presenters don’t need all those lifecycle events"></a><a href="https://medium.com/@anupcowkur/your-presenters-dont-need-all-those-lifecycle-events-721f500eeef4#.f7nupw3jo" target="_blank" rel="external">Your presenters don’t need all those lifecycle events</a></h2><p>作者认为在Presenter中放入太多生命周期的方法不太好, 他觉得最基本的只需要这两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewAttached</span><span class="params">(MVPView view)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewDetached</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然当你需要更多的时候可以加入更多, 但是我们不应该每个生命周期方法都加进去.</p>
<h2 id="How-to-send-notifications-using-Android-Firebase"><a href="#How-to-send-notifications-using-Android-Firebase" class="headerlink" title="How to send notifications using Android Firebase"></a><a href="http://www.survivingwithandroid.com/2016/09/android-firebase-push-notification.html" target="_blank" rel="external">How to send notifications using Android Firebase</a></h2><p>使用Firebase Messaging如何发送push notification.</p>
<h2 id="RxRecipes-Wrap-your-way-to-Rx"><a href="#RxRecipes-Wrap-your-way-to-Rx" class="headerlink" title="RxRecipes: Wrap your way to Rx"></a><a href="https://hackernoon.com/rxrecipes-wrap-your-way-to-rx-fd40eb5254b6#.hbtcjp4rm" target="_blank" rel="external">RxRecipes: Wrap your way to Rx</a></h2><p>使用<code>.fromCallable()</code>来把一个同步方法包装成一个Observable. </p>
<p>并比较了和<code>.just()</code>的区别. (<code>.just()</code>发射的东西在创建的时候就确定了, 而<code>.fromCallable()</code>是在subscribe的时候确定的.)</p>
<h2 id="Diving-deeper-into-the-Java-transient-modifier"><a href="#Diving-deeper-into-the-Java-transient-modifier" class="headerlink" title="Diving deeper into the Java transient modifier"></a><a href="https://medium.com/google-developer-experts/diving-deeper-into-the-java-transient-modifier-3b16eff68f42#.8pbk9i6fm" target="_blank" rel="external">Diving deeper into the Java transient modifier</a></h2><p><code>transient</code>修饰符加在字段上时, 在对象被序列化的时候, 这个字段将被排除在外, 反序列化时这个字段将被初始化一个默认值.</p>
<p>可能的使用场景: </p>
<ul>
<li>实现了Serializable的User对象中的password字段.</li>
<li>一个Serializable的类中的某个字段是通过其他字段推导或派生出来的, 这些派生的字段没有必要被序列化, 于是把它们标记为<code>transient</code>.</li>
</ul>
<p>注意transient和static是不能并存的, 因为static默认是transient的.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a><a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a></h2><p>腾讯的热补丁(hot-fix)解决方案, 支持不重新安装app的dex, library和资源更新.</p>
<h2 id="Android-Debug-Database"><a href="#Android-Debug-Database" class="headerlink" title="Android-Debug-Database"></a><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" target="_blank" rel="external">Android-Debug-Database</a></h2><p>在浏览器里看应用的数据库和shared preferences.</p>
<h2 id="blurkit-android"><a href="#blurkit-android" class="headerlink" title="blurkit-android"></a><a href="https://github.com/wonderkiln/blurkit-android" target="_blank" rel="external">blurkit-android</a></h2><p>实时模糊布局. 像iOS一样.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-233&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-233&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #233&quot;&gt;&lt;/a&gt;Android Weekly Issue #233&lt;/h1&gt;&lt;p&gt;November 27th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-233&quot;&gt;Android Weekly Issue #233&lt;/a&gt;&lt;br&gt;本期内容包括: 用Mockito做RxJava的单元测试; Android开发中的命令行使用; Android 7.1的App Shortcuts; 自定义View的绘制; 用Firebase的Remote Config进行feature逐步分发; APK分析工具的使用, APK瘦身讨论; RxJava处理网络请求和缓存; presenter的设计; 用Firebase发送push notification; transient关键字的使用等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
      <category term="Java" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/Java/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Java" scheme="http://mengdd.github.io/tags/Java/"/>
    
      <category term="Terminal" scheme="http://mengdd.github.io/tags/Terminal/"/>
    
      <category term="Android 7.1" scheme="http://mengdd.github.io/tags/Android-7-1/"/>
    
      <category term="App Shortcuts" scheme="http://mengdd.github.io/tags/App-Shortcuts/"/>
    
      <category term="Custom View" scheme="http://mengdd.github.io/tags/Custom-View/"/>
    
      <category term="Remote Config" scheme="http://mengdd.github.io/tags/Remote-Config/"/>
    
      <category term="APK analyzer" scheme="http://mengdd.github.io/tags/APK-analyzer/"/>
    
      <category term="Cache" scheme="http://mengdd.github.io/tags/Cache/"/>
    
      <category term="push notification" scheme="http://mengdd.github.io/tags/push-notification/"/>
    
      <category term="transient" scheme="http://mengdd.github.io/tags/transient/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java笔记一 创建和销毁对象</title>
    <link href="http://mengdd.github.io/Java/2016/11/25/effective-java-notes-1/"/>
    <id>http://mengdd.github.io/Java/2016/11/25/effective-java-notes-1/</id>
    <published>2016-11-25T08:50:40.000Z</published>
    <updated>2016-11-25T09:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-Java笔记一-创建和销毁对象"><a href="#Effective-Java笔记一-创建和销毁对象" class="headerlink" title="Effective Java笔记一 创建和销毁对象"></a>Effective Java笔记一 创建和销毁对象</h1><ul>
<li>第1条 考虑用静态工厂方法代替构造器</li>
<li>第2条 遇到多个构造器参数时要考虑用构建器</li>
<li>第3条 用私有构造器或者枚举类型强化Singleton属性</li>
<li>第4条 通过私有构造器强化不可实例化的能力</li>
<li>第5条 避免创建不必要的对象</li>
<li>第6条 消除过期的对象引用</li>
<li>第7条 避免使用终结方法</li>
</ul>
<a id="more"></a>
<h2 id="第1条-考虑用静态工厂方法代替构造器"><a href="#第1条-考虑用静态工厂方法代替构造器" class="headerlink" title="第1条 考虑用静态工厂方法代替构造器"></a>第1条 考虑用静态工厂方法代替构造器</h2><p>对于类而言, 最常用的获取实例的方法就是提供一个公有的构造器, 还有一种方法, 就是提供一个公有的静态工厂方法(static factory method), 返回类的实例.</p>
<p>(注意此处的静态工厂方法与设计模式中的工厂方法模式不同.)</p>
<p>提供静态工厂方法而不是公有构造, 这样做有几大<strong>优势</strong>:</p>
<ul>
<li>静态工厂方法<strong>有名称</strong>. 可以更确切地描述正被返回的对象.<br>当一个类需要多个带有相同签名的构造器时, 可以用静态工厂方法, 并且慎重地选择名称以便突出它们之间的区别.</li>
<li><strong>不必在每次调用它们的时候都创建一个新对象.</strong> 可以重复利用实例. 如果程序经常请求创建相同的对象, 并且创建对象的代价很高, 这项改动可以提升性能. (不可变类, 单例, 枚举).</li>
<li><strong>可以返回原类型的子类型对象.</strong> 适用于基于接口的框架, 可以隐藏实现类API, 也可以根据参数返回不同的子类型.<br>由于接口不能有静态方法, 因此按照惯例, 接口Type的静态工厂方法被放在一个名为Types的不可实例化的类中.<br>(Java的java.util.Collections). 服务提供者框架(Service Provider Framework, 如JDBC)的基础, 从实现中解耦.</li>
<li><strong>在创建参数化类型实例的时候, 使代码更简洁.</strong> </li>
</ul>
<p>静态工厂方法的<strong>缺点</strong>:</p>
<ul>
<li>类如果不含public或者protected的构造器, 就不能被子类化. 对于公有的静态工厂方法所返回的非公有类, 也同样如此.</li>
<li>静态工厂方法与其他的静态方法没有区别. 在API文档中没有明确标识出来. 可以使用一些惯用的名称来弥补这一劣势:<ul>
<li><code>valueOf()</code>: 类型转换方法, 返回的实例与参数具有相同的值.</li>
<li><code>of()</code>: valueOf()的一种更简洁的替代.</li>
<li><code>getInstance()</code>: 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例.</li>
<li><code>newInstance()</code>: 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同.</li>
<li><code>getType()</code>: 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用.</li>
<li><code>newType()</code>: 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.</li>
</ul>
</li>
</ul>
<h2 id="第2条-遇到多个构造器参数时要考虑用构建器"><a href="#第2条-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="第2条 遇到多个构造器参数时要考虑用构建器"></a>第2条 遇到多个构造器参数时要考虑用构建器</h2><p>静态工厂和构造器有一个共同的局限性: 它们都不能很好地扩展到大量的可选参数.</p>
<p>重载多个构造器方法可行, 但是当有许多参数的时候, 代码会很难写难读.</p>
<p>第二种替代方法是JavaBeans模式, 即一个无参数构造来创建对象, 然后调用setter方法来设置每个参数. 这种模式也有严重的缺点, 因为构造过程被分到了几个调用中, 在构造过程中JavaBean可能处于不一致的状态.<br>类无法通过检验构造器参数的有效性来保证一致性. 另一点是这种模式阻止了把类做成不可变的可能.</p>
<p>第三种方法就是<strong>Builder模式</strong>. 不直接生成想要的对象, 而是利用必要参数调用构造器(或者静态工厂)得到一个builder对象, 然后在builder对象上调用类似setter的方法, 来设置可选参数, 最后调用无参的<code>build()</code>方法来生成不可变的对象.</p>
<p>这个Builder是它构建的类的静态成员类.<br>Builder的setter方法返回Builder本身, 可以链式操作.</p>
<p><strong>Builder模式的优势</strong>: 可读性增强; 可以有多个可变参数;  易于做参数检查和构造约束检查; 比JavaBeans更加安全; 灵活性: 可以利用单个builder构建多个对象, 可以自动填充某些域, 比如自增序列号.</p>
<p>Builder模式的不足: 为了创建对象必须先创建Builder, 在某些十分注重性能的情况下, 可能就成了问题; Builder模式较冗长, 因此只有参数很多时才使用.</p>
<h2 id="第3条-用私有构造器或者枚举类型强化Singleton属性"><a href="#第3条-用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="第3条 用私有构造器或者枚举类型强化Singleton属性"></a>第3条 用私有构造器或者枚举类型强化Singleton属性</h2><p><code>Singleton(单例)</code>指仅仅被实例化一次的类. 通常用来代表那些本质上唯一的系统组件. </p>
<p>使类成为Singleton会使得它的客户端代码测试变得困难, 因为无法给它替换模拟实现, 除非它实现了一个充当其类型的接口.</p>
<p>单例的实现: 私有构造方法, 类中保留一个字段实例(static, final), 用public直接公开字段或者用一个public static的<code>getInstance()</code>方法返回该字段.</p>
<p>为了使单例实现序列化(<code>Serializable</code>), 仅仅在声明中加上<code>implements Serializable</code>是不够的, 为了维护并保证单例, 必须声明所有实例域都是<code>transient</code>的, 并提供一个<code>readResolve()</code>方法, 返回单例的实例. 否则每次反序列化一个实例时, 都会创建一个新的实例.</p>
<p>从Java 1.5起, <strong>可以使用枚举来实现单例</strong>: 只需要编写一个包含单个元素的枚举类型.<br>这种方法无偿地提供了序列化机制, 绝对防止多次实例化.</p>
<h2 id="第4条-通过私有构造器强化不可实例化的能力"><a href="#第4条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第4条 通过私有构造器强化不可实例化的能力"></a>第4条 通过私有构造器强化不可实例化的能力</h2><p>只包含静态方法和静态域的类名声不太好, 因为有些人会滥用它们来编写过程化的程序. 尽管如此, 它们确实也有特有的用处, 比如:<br><code>java.lang.Math</code>, <code>java.util.Arrays</code>把基本类型的值或数组类型上的相关方法组织起来; <code>java.util.Collections</code>把实现特定接口的对象上的静态方法组织起来; 还可以利用这种类把final类上的方法组织起来, 以取代扩展该类的做法.</p>
<p>这种工具类(utility class)不希望被实例化, 然而在缺少显式构造器的情况下, 系统会提供默认构造器, 可能会造成这些类被无意识地实例化.</p>
<p>通过做成抽象类来强制该类不可被实例化, 这是行不通的, 因为可能会造成”这个类是用来被继承的”的误解, 而继承它的子类又可以被实例化.</p>
<p>所以只要让这个类包含一个私有的构造器, 它就不能被实例化了. 进一步地, 可以在这个私有构造器中抛出异常. </p>
<p>这种做法还会导致这个类不能被子类化, 因为子类构造器必须显式或隐式地调用super构造器. 在这种情况下, 子类就没有可访问的超类构造器可调用了.</p>
<h2 id="第5条-避免创建不必要的对象"><a href="#第5条-避免创建不必要的对象" class="headerlink" title="第5条 避免创建不必要的对象"></a>第5条 避免创建不必要的对象</h2><p>一般来说, 最好能重用对象而不是每次需要的时候创建一个相同功能的新对象. 如果对象是<strong>不可变的(immutable)</strong>, 它就始终可以被重用.</p>
<p>比如应该用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"stringette"</span>;</span><br></pre></td></tr></table></figure></p>
<p>而不是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"stringette"</span>); <span class="comment">// Don't do this</span></span><br></pre></td></tr></table></figure></p>
<p>包含相同字符串的字面常量对象是会被重用的.</p>
<p>对于同时提供了静态工厂方法和构造方法的<strong>不可变类</strong>, 通常可以使用静态工厂方法而不是构造器, 以避免创建不必要的对象.<br>比如<code>Boolean.valueOf()</code>.</p>
<p>除了重用不可变对象以外, 也可以重用那些已知不会被修改的可变对象. 比如把一个方法中需要用到的不变的数据保存成常量对象(<code>static final</code>), 只在初始化的时候创建一次(<code>用static块</code>), 这样就不用每次调用方法都重复创建.</p>
<p>如果该方法永远不会调用, 那也不需要初始化相关的字段, 可以通过延迟初始化(lazily initializing)把这些对象的初始化放到方法第一次被调用的时候. (但是不建议这样做, 没有性能的显著提高, 并且会使方法看起来复杂.)</p>
<p>前面的例子中, 所讨论的对象显然是能够被重用的, 因为它们被初始化之后不会再改变. 其他有些情形则并不总是这么明显了. (适配器(adapter)模式, Map的接口keySet()方法返回同样的Set实例).</p>
<p>Java 1.5中加入了自动装箱(autoboxing), 会创建对象. 所以程序中优先使用基本类型而不是装箱基本类型, 要当心无意识的自动装箱. </p>
<p>小对象的构造器只做很少量的显式工作, 创建和回收都是很廉价的, 所以通过创建附加的对象提升程序的清晰简洁性也是好事.</p>
<p>通过维护自己的对象池(object pool)来避免创建对象并不是一种好的做法(代码, 内存), 除非池中的对象是非常重量级的. 正确使用的典型: 数据库连接池.</p>
<h2 id="第6条-消除过期的对象引用"><a href="#第6条-消除过期的对象引用" class="headerlink" title="第6条 消除过期的对象引用"></a>第6条 消除过期的对象引用</h2><p>一个内存泄露的例子: 一个用数组实现的Stack, 依靠size标记来管理栈的深度, 但是这样从栈中弹出来的过期对象并没有被释放. </p>
<p>称内存泄露为”无意识的对象保持(unintentional object retention)”更为恰当.</p>
<p>修复方法: 一旦对象引用已经过期, 只需清空这些引用即可.</p>
<p>清空对象引用应该是一种例外, 而不是一种规范行为. 消除过期引用最好的方法是让包含该引用的变量结束其生命周期. 如果你是在最紧凑的作用域范围内定义变量, 这种情形就会自然发生.</p>
<p><strong>一般而言, 只要类是自己管理内存</strong>, 程序员就应该警惕内存泄露问题. 一旦元素被释放掉, 则该元素中包含的任何对象引用都应该被清空.</p>
<p>内存泄露的<strong>另一个常见来源是缓存</strong>. 这个问题有这几种可能的解决方案: </p>
<ul>
<li>1.缓存项的生命周期由该键的外部引用决定 -&gt; <code>WeakHashMap</code>; </li>
<li>2.缓存项的生命周期是否有意义并不是很容易确定 -&gt; 随着时间的推移或者新增项的时候删除没用的项.</li>
</ul>
<p>内存泄露的<strong>第三个常见来源是监听器和其他回调</strong>.<br>如果你实现了一个API, 客户端注册了回调却没有注销, 就会积聚对象.<br>API端可以只保存对象的弱引用来确保回调对象生命周期结束后会被垃圾回收. </p>
<h2 id="第7条-避免使用终结方法"><a href="#第7条-避免使用终结方法" class="headerlink" title="第7条 避免使用终结方法"></a>第7条 避免使用终结方法</h2><p>终结方法(finalizer)通常是不可预测的, 也是很危险的, 一般情况下是不必要的.<br>使用终结方法会导致行为不稳定, 降低性能, 以及可移植性问题.</p>
<p>不要把finalizer当成是C++中的析构器(destructors)的对应物.<br>在Java中, 当一个对象变得不可到达的时候, 垃圾回收器会回收与该对象相关联的存储空间.</p>
<p>C++的析构器也可以用来回收其他的非内存资源, 而在Java中, 一般用try-finally块来完成类似的工作.</p>
<p>终结方法的缺点在于不能保证会被及时地执行. 从一个对象变得不可到达开始, 到它的终结方法被执行, 所花费的时间是任意长的. JVM会延迟执行终结方法. </p>
<p>及时地执行终结方法正是垃圾回收算法的一个主要功能. 这种算法在不同的JVM上不同. </p>
<p>Java语言规范不仅不保证终结方法会被及时地执行, 而且根本就不保证它们会被执行. 所以不应该依赖于终结方法来更新重要的持久状态. </p>
<p>不要被<code>System.gc()</code>和<code>System.runFinalization()</code>这两个方法所迷惑, 它们确实增加了终结方法被执行的机会, 但是它们并不保证终结方法一定会被执行. </p>
<p>如果未捕获的异常在终结过程中被抛出来, 那么这种异常可以被忽略, 而且该对象的终结过程也会终止. </p>
<p>使用终结方法有一个严重的性能损失. </p>
<p>如果类的对象中封装的资源(例如文件或线程)确实需要终止, 应该怎么做才能不用编写终结方法呢? 只需<strong>提供一个显式的终止方法</strong>. 并要求该类的客户端在每个实例不再有用的时候调用这个方法. 注意, 该实例必须记录下自己是否已经被终止了, 如果被终止之后再被调用, 要抛出异常.<br>例子: <code>InputStream</code>, <code>OutputStream</code>和<code>java.sql.Connection</code>上的<code>close()</code>方法; <code>java.util.Timer</code>的<code>cancel()</code>方法.<br><code>Image.flush()</code>会释放实例相关资源, 但该实例仍处于可用的状态, 如果有必要会重新分配资源. </p>
<p><strong>显式的终止方法通常与try-finally块结合使用, 以确保及时终止.</strong></p>
<p>终结方法的好处, 它有两种合法用途:</p>
<ul>
<li>当显式终止方法被忘记调用时, 终结方法可以充当安全网(safety net). <strong>但是如果终结方法发现资源还未被终止, 应该记录日志警告, 这表示客户端代码中的bug.</strong></li>
<li>对象的本地对等体(native peer), 垃圾回收器不会知道它, 当它的Java对等体被回收的时候, 它不会被回收. 如果本地对等体拥有必须被及时终止的资源, 那么该类就应该有一个显式的终止方法, 如前, 可以是本地方法或者它也可以调用本地方法; 如果本地对等体并不拥有关键资源, 终结方法是执行这项任务最合适的工具. </li>
</ul>
<p>注意, 终结方法链(finalizer chaining)并不会自动执行. 子类覆盖终结方法时, 必须手动调用超类的终结方法. try中终结子类, finally中终结超类. </p>
<p>为了避免忘记调用超类的终结方法, 还有一种写法, 是在子类中写一个匿名的类, 该匿名类的单个实例被称为<strong>终结方法守卫者(finalizer guardian)</strong>, 当守卫者被终结的时候, 它执行外围实例的终结行为. 这样外围类并没有覆盖超类的终结方法, 保证了超类的终结方法一定会被执行. </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Effective-Java笔记一-创建和销毁对象&quot;&gt;&lt;a href=&quot;#Effective-Java笔记一-创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;Effective Java笔记一 创建和销毁对象&quot;&gt;&lt;/a&gt;Effective Java笔记一 创建和销毁对象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第1条 考虑用静态工厂方法代替构造器&lt;/li&gt;
&lt;li&gt;第2条 遇到多个构造器参数时要考虑用构建器&lt;/li&gt;
&lt;li&gt;第3条 用私有构造器或者枚举类型强化Singleton属性&lt;/li&gt;
&lt;li&gt;第4条 通过私有构造器强化不可实例化的能力&lt;/li&gt;
&lt;li&gt;第5条 避免创建不必要的对象&lt;/li&gt;
&lt;li&gt;第6条 消除过期的对象引用&lt;/li&gt;
&lt;li&gt;第7条 避免使用终结方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mengdd.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://mengdd.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 232</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/11/25/android-weekly-notes-issue-232/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/11/25/android-weekly-notes-issue-232/</id>
    <published>2016-11-25T08:32:57.000Z</published>
    <updated>2016-11-28T06:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-232"><a href="#Android-Weekly-Issue-232" class="headerlink" title="Android Weekly Issue #232"></a>Android Weekly Issue #232</h1><p>November 20th, 2016<br><a href="http://androidweekly.net/issues/issue-232" target="_blank" rel="external">Android Weekly Issue #232</a><br>本期内容包括: Kotlin的优势讨论; MVVM模式结合RxJava和Retrofit的应用构架实现; Android中传感器使用; 如何给App写单元测试; Reductor的组合使用; Android应用进程被杀死的状态恢复和问题处理; Kotlin中的Anko; 后台任务处理库”Android Job”; VectorDrawable和PNG的使用问题等.</p>
<p>本期开源库: 给ImageView和RelativeLayout的底部加曲线; 长按弹框; Switch Button控件; 给View加深度/厚度的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="How-Kotlin-became-our-primary-language-for-Android"><a href="#How-Kotlin-became-our-primary-language-for-Android" class="headerlink" title="How Kotlin became our primary language for Android"></a><a href="https://medium.com/uptech-team/how-kotlin-became-our-primary-language-for-android-3af7fd6a994c#.a50t4ple8" target="_blank" rel="external">How Kotlin became our primary language for Android</a></h2><p>作者他们team想要完全用kotlin开发一个应用.<br>本文是他们的心得体会.</p>
<p>关于函数式编程的学习, 作者推荐: <a href="https://www.coursera.org/specializations/scala" target="_blank" rel="external">一个Scala的课程</a>.</p>
<p>Kotlin的优势: 和Java可以互相调用; 函数式语言; function purity; 高阶函数(函数可以作为参数或返回值); 不可变性(val); Null-safety; Anko;  Kotlin Android extensions(移除了ButterKnife); 还有对初学者很友好, 可以摆脱很多第三方的依赖, 函数扩展等等优势.</p>
<h2 id="RxJava-2-Android-MVVM-Lifecycle-App-Structure-with-Retrofit-2"><a href="#RxJava-2-Android-MVVM-Lifecycle-App-Structure-with-Retrofit-2" class="headerlink" title="RxJava 2: Android MVVM Lifecycle App Structure with Retrofit 2"></a><a href="https://medium.com/@manuelvicnt/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e#.jx3vg232m" target="_blank" rel="external">RxJava 2: Android MVVM Lifecycle App Structure with Retrofit 2</a></h2><p>作者一年多以前写过一个这个文章: <a href="https://medium.com/@manuelvicnt/rxjava-android-mvvm-app-structure-with-retrofit-a5605fa32c00#.44uq87s6w" target="_blank" rel="external">RxJava: Android MVVM App structure with Retrofit</a>, 介绍MVVM结合Retrofit和RxJava的App架构模式. 此篇文章是一年后作者对此的改进.</p>
<p>主要内容有:</p>
<ul>
<li>1.通过View和ViewModel之间的协议接口, 让ViewModel知道View的生命周期变化.</li>
<li>2.RxJava2的流式类型: Completable, Maybe, Flowable的使用.</li>
<li>3.用RxJava操作符组合网络请求: 让不同的网络请求一起发送, 并且都返回以后才得到通知 -&gt; 用<code>.zip()</code>. 顺序连接不同的网络请求 -&gt; <code>.flatMap()</code>, <code>.andThen()</code>.</li>
<li>4.后台网络请求和View更新的处理: 不取消网络请求, 等View再次resume的时候检查状态再更新. 这里提供了两种选择, 一种是用前面提到的协议接口中的生命周期方法, 另一种是用<code>AsyncProcessor</code>.</li>
<li>5.Mock Retrofit的网络请求.</li>
</ul>
<h2 id="Tech-Talks-You-Do-Have-Something-To-Say"><a href="#Tech-Talks-You-Do-Have-Something-To-Say" class="headerlink" title="Tech Talks - You Do Have Something To Say!"></a><a href="https://medium.com/upday-devs/tech-talks-you-do-have-something-to-say-a1a0ae23fa0#.61m7x6rj8" target="_blank" rel="external">Tech Talks - You Do Have Something To Say!</a></h2><p>这篇文章鼓励你分享你的知识, 经验, 问题及解决方法,  无论是通过演讲还是写出来的方式.</p>
<h2 id="Da-Real-Fragmentation-Sensors"><a href="#Da-Real-Fragmentation-Sensors" class="headerlink" title="Da Real Fragmentation - Sensors"></a><a href="http://pguardiola.com/blog/darealfragmentation-sensors/" target="_blank" rel="external">Da Real Fragmentation - Sensors</a></h2><p>介绍了Android中传感器的使用.</p>
<h2 id="Simple-unit-tests-for-Android"><a href="#Simple-unit-tests-for-Android" class="headerlink" title="Simple unit tests for Android"></a><a href="https://stfalcon.com/en/blog/post/simple-unit-tests-for-android" target="_blank" rel="external">Simple unit tests for Android</a></h2><p>如何给你的App写简单的单元测试.</p>
<h2 id="Reductor-Redux-for-Android-Part-2"><a href="#Reductor-Redux-for-Android-Part-2" class="headerlink" title="Reductor - Redux for Android. Part 2"></a><a href="https://yarikx.github.io/Reductor-composition/" target="_blank" rel="external">Reductor - Redux for Android. Part 2</a></h2><p>这是系列文章中的一篇, 继续讲<a href="https://github.com/Yarikx/reductor" target="_blank" rel="external">Reductor</a> library – Redux的Android版实现.</p>
<p>这篇文章结合例子将如何组合使用以及用@CombinedState来生成代码.</p>
<h2 id="Android-process-death-—-and-the-big-implications-for-your-app"><a href="#Android-process-death-—-and-the-big-implications-for-your-app" class="headerlink" title="Android process death — and the (big) implications for your app"></a><a href="https://medium.com/inloop/android-process-kill-and-the-big-implications-for-your-app-1ecbed4921cb#.iipoq2fne" target="_blank" rel="external">Android process death — and the (big) implications for your app</a></h2><p>本文探讨进程被杀死有可能导致的种种问题.</p>
<p>你的Android应用如果在paused或者stopped状态, 那么它任何时候都有可能会被系统杀死. 这时候你的Activity, Fragment和View状态将被保存, 当你回到应用的时候, 系统会重新启动进程, 重新创建Activity, 存储的状态会在bundle中返回.</p>
<p><strong>这个过程存在一个问题</strong>: 整个进程都被杀死了, 所有单例(或application scope的对象), 临时数据, 还有retained Fragment中的数据, 这些所有都会处于一种全新创建的状态, 但唯有一个不同, 一些在bundle中存储的状态被恢复出来了.</p>
<p>这样有可能会导致一些异常, 比如你的界面想要恢复一种状态, 但是数据已经被清空了.</p>
<p><strong>如何测试这种情况呢?</strong></p>
<ul>
<li>使用App, home键把它放进后台, 杀死app, 再恢复.</li>
<li>打开选项”Don’t Keep Activities”. 这种测试并不会杀死进程, 只会测试Activity的状态恢复.</li>
<li>设置Developer options中的Background Process Limit为”No background processes”. 这样把应用放在后台, 打开另一个应用, 再回来自己的应用, 将会重启进程.</li>
</ul>
<p><strong>相关问题信号</strong></p>
<ul>
<li>单例</li>
<li>保存可变数据的共享的实例</li>
<li>Application类中保存的数据和状态</li>
<li>可变的静态字段</li>
<li>Retained fragments(状态恢复了, 但是数据却丢失了)</li>
<li>基本上任何没有在<code>onSaveInstanceState()</code>中保存但是你却依赖的状态</li>
</ul>
<p>这些问题没有唯一的解决方案, 取决于你的应用.</p>
<h2 id="400-faster-layouts-with-Anko"><a href="#400-faster-layouts-with-Anko" class="headerlink" title="400% faster layouts with Anko"></a><a href="https://medium.com/@vergauwen.simon/400-faster-layouts-with-anko-da17f32c45dd#.bz6a3y8ql" target="_blank" rel="external">400% faster layouts with Anko</a></h2><p>作者把自己的一个布局改为用Kotlin的Anko, 然后测试性能.</p>
<p>好处是:</p>
<ul>
<li>1.性能提升了, 避免了XML的运行时解析所花费的时间.</li>
<li>2.可以动态地加入逻辑, 比如版本判断, 屏幕尺寸, 方向判断等.</li>
</ul>
<p>作者用的测试性能的工具是: <a href="https://github.com/frogermcs/AndroidDevMetrics" target="_blank" rel="external">AndroidDevMetrics</a></p>
<h2 id="Background-Work-with-Android-Job-and-Dagger"><a href="#Background-Work-with-Android-Job-and-Dagger" class="headerlink" title="Background Work with Android Job and Dagger"></a><a href="http://www.adavis.info/2016/11/background-work-with-android-job-and.html" target="_blank" rel="external">Background Work with Android Job and Dagger</a></h2><p>在Android上的后台工作, 你可以选择<code>Alarm Manager</code>, <code>Job Scheduler</code>或<code>GCM Network Manager</code>.</p>
<p>为了帮开发者从每种实现中抽象出来, Evernote开源了一个库: Android Job. 本文介绍了这个库如何使用.</p>
<h2 id="VectorDrawable-PNG"><a href="#VectorDrawable-PNG" class="headerlink" title="VectorDrawable PNG"></a><a href="https://blog.stylingandroid.com/vectordrawable-png/" target="_blank" rel="external">VectorDrawable PNG</a></h2><p>作者他们的应用中有VectorDrawable的版本兼容问题, 用support library中的Compat版本也不好使, 于是他们在旧版本决定使用自动生成的png.</p>
<p>然后发现了生成png的颜色设置问题, 在旧版本生成的图片用的是fillColor而不是tintColor. 把fillColor设置成想要的颜色即可.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Depth-Library-by-Daniel-Zeller"><a href="#Depth-Library-by-Daniel-Zeller" class="headerlink" title="Depth Library by Daniel Zeller"></a><a href="https://www.androidexperiments.com/experiment/depth-library" target="_blank" rel="external">Depth Library by Daniel Zeller</a></h2><p>一个应用, 展示了<a href="https://github.com/danielzeller/Depth-LIB-Android-" target="_blank" rel="external">Depth-LIB-Android-</a>的功能.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Crescento"><a href="#Crescento" class="headerlink" title="Crescento"></a><a href="https://github.com/developer-shivam/crescento/" target="_blank" rel="external">Crescento</a></h2><p>在<code>ImageView</code>和<code>RelativeLayout</code>底部加上曲线的库.</p>
<h2 id="LongPressPopup"><a href="#LongPressPopup" class="headerlink" title="LongPressPopup"></a><a href="https://github.com/RiccardoMoro/LongPressPopup" target="_blank" rel="external">LongPressPopup</a></h2><p>长按出现弹框的库.</p>
<h2 id="RMSwitch"><a href="#RMSwitch" class="headerlink" title="RMSwitch"></a><a href="https://github.com/RiccardoMoro/RMSwitch" target="_blank" rel="external">RMSwitch</a></h2><p>一个Switch Button的库, 带有更多自定义扩展功能.</p>
<h2 id="Depth-LIB-Android"><a href="#Depth-LIB-Android" class="headerlink" title="Depth-LIB-Android"></a><a href="https://github.com/danielzeller/Depth-LIB-Android-" target="_blank" rel="external">Depth-LIB-Android</a></h2><p>这个库给View加上深度/厚度.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-232&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-232&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #232&quot;&gt;&lt;/a&gt;Android Weekly Issue #232&lt;/h1&gt;&lt;p&gt;November 20th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-232&quot;&gt;Android Weekly Issue #232&lt;/a&gt;&lt;br&gt;本期内容包括: Kotlin的优势讨论; MVVM模式结合RxJava和Retrofit的应用构架实现; Android中传感器使用; 如何给App写单元测试; Reductor的组合使用; Android应用进程被杀死的状态恢复和问题处理; Kotlin中的Anko; 后台任务处理库”Android Job”; VectorDrawable和PNG的使用问题等.&lt;/p&gt;
&lt;p&gt;本期开源库: 给ImageView和RelativeLayout的底部加曲线; 长按弹框; Switch Button控件; 给View加深度/厚度的库.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Retrofit" scheme="http://mengdd.github.io/tags/Retrofit/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Redux" scheme="http://mengdd.github.io/tags/Redux/"/>
    
      <category term="Reductor" scheme="http://mengdd.github.io/tags/Reductor/"/>
    
      <category term="MVVM" scheme="http://mengdd.github.io/tags/MVVM/"/>
    
      <category term="Sensor" scheme="http://mengdd.github.io/tags/Sensor/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Unit Test" scheme="http://mengdd.github.io/tags/Unit-Test/"/>
    
      <category term="Process" scheme="http://mengdd.github.io/tags/Process/"/>
    
      <category term="State" scheme="http://mengdd.github.io/tags/State/"/>
    
      <category term="Anko" scheme="http://mengdd.github.io/tags/Anko/"/>
    
      <category term="VectorDrawable" scheme="http://mengdd.github.io/tags/VectorDrawable/"/>
    
      <category term="PNG" scheme="http://mengdd.github.io/tags/PNG/"/>
    
      <category term="Switch" scheme="http://mengdd.github.io/tags/Switch/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 231</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/11/17/android-weekly-notes-issue-231/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/11/17/android-weekly-notes-issue-231/</id>
    <published>2016-11-17T10:25:37.000Z</published>
    <updated>2016-11-17T10:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-231"><a href="#Android-Weekly-Issue-231" class="headerlink" title="Android Weekly Issue #231"></a>Android Weekly Issue #231</h1><p>November 13th, 2016<br><a href="http://androidweekly.net/issues/issue-231" target="_blank" rel="external">Android Weekly Issue #231</a></p>
<p>Android Weekly阅读笔记, Issue #231, 本期内容包括: MVP中的View做成passive响应式的, 返回Observable; Android Studio使用技巧; <code>BottomNavigationView</code>的使用; App tracking; Kotlin; 用Kotlin实现的Filter Animation效果; Dagger2的<code>Scope</code>和<code>Subcomponent</code>使用; Espresso测试中mock dagger注入; Android和Java中的Reference和内存泄露; MVVM + RxJava构架实际使用的经验分享; 还有TV以及Audio相关的内容等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Reactive-Views-retrying-errors"><a href="#Reactive-Views-retrying-errors" class="headerlink" title="Reactive Views: retrying errors"></a><a href="https://medium.com/xing-engineering/reactive-views-retrying-errors-a59fffbd827f#.m2n2c6v6i" target="_blank" rel="external">Reactive Views: retrying errors</a></h2><p>作者他们的app近来重构采用了RxJava和Clean Architecture, 进而想要使用<a href="http://martinfowler.com/eaaDev/PassiveScreen.html" target="_blank" rel="external">passive view</a>, 然后他们就发现了关于Reactive Views的一系列文章, 尤其是这一篇: <a href="https://artemzin.com/blog/rxui-talking-to-android-view-layer-in-a-reactive-way/" target="_blank" rel="external">RxUi: Talking to Android View layer in a Reactive way</a>.</p>
<p>他们的主要工作就是把View也改成响应式的, 即View返回Observable. 在Presenter初始化的时候和View的Observable绑定, 所以事件发生的时候会trigger到presenter.</p>
<p>这项工作主要需要依赖于<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>, 由于RxBinding没有提供长按RecyclerView item的bind, 所以他们自己写了<a href="https://gist.github.com/Shyish/92257b6348312b541aa4f6b205eb14e4" target="_blank" rel="external">一个</a>.<br>Snackbar也是: <a href="https://gist.github.com/Shyish/8af4cd774320c57ced0ec21f8840797e" target="_blank" rel="external">SnackbarActionOnSubscribe</a>.</p>
<p>作者采用这种方式重构了他们的代码, 使得view变成完全passive的.</p>
<p>并且其中还有一个<code>retryWhen()</code>使用的解释: <a href="http://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/" target="_blank" rel="external">RxJava’s repeatWhen and retryWhen, explained</a>.</p>
<h2 id="50-Android-Studio-Tips-Tricks-amp-Resources"><a href="#50-Android-Studio-Tips-Tricks-amp-Resources" class="headerlink" title="50 Android Studio Tips, Tricks &amp; Resources"></a><a href="https://medium.com/@mmbialas/50-android-studio-tips-tricks-resources-you-should-be-familiar-with-as-an-android-developer-af86e7cf56d2#.gzyghprf0" target="_blank" rel="external">50 Android Studio Tips, Tricks &amp; Resources</a></h2><p>设置Logcat的颜色; 使用<a href="https://medium.com/google-developers/writing-more-code-by-writing-less-code-with-android-studio-live-templates-244f648d17c7#.2p54ef8jr" target="_blank" rel="external">Live Templates</a>; 快捷键使用; Android Studio的插件; 还有一些资源分享.</p>
<h2 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a><a href="https://blog.stylingandroid.com/bottomnavigationview/" target="_blank" rel="external">BottomNavigationView</a></h2><p>Design support library 25.0.0推出了BottomNavigationView, 本文介绍其使用.</p>
<h2 id="The-key-concepts-of-app-tracking-for-developers"><a href="#The-key-concepts-of-app-tracking-for-developers" class="headerlink" title="The key concepts of app tracking for developers"></a><a href="https://medium.com/@sergii/the-key-concepts-of-app-tracking-for-developers-a11bebf1e65e#.mhdpwt9x9" target="_blank" rel="external">The key concepts of app tracking for developers</a></h2><p>这篇文章主要讲移动应用数据追踪和分析的几个原则:</p>
<ul>
<li>为什么你需要tracking;  </li>
<li>什么时候需要收集数据; </li>
<li>用什么Analytics tool; </li>
<li>用户隐私相关; </li>
<li>代码设计模式以及挑战; </li>
<li>如何debug和测试输出;</li>
<li>如何分析数据;</li>
</ul>
<h2 id="Why-You-Must-Try-Kotlin-For-Android-Development"><a href="#Why-You-Must-Try-Kotlin-For-Android-Development" class="headerlink" title="Why You Must Try Kotlin For Android Development?"></a><a href="https://medium.com/@amitshekhar/why-you-must-try-kotlin-for-android-development-e14d00c8084b#.z0xt70upu" target="_blank" rel="external">Why You Must Try Kotlin For Android Development?</a></h2><p>为什么要使用Kotlin来做Android开发? 简洁, 安全, 灵活, 和Java可互相操作.</p>
<p>文中介绍了Null Safety, Smart Casting, Default Arguments, Named Arguments, Functional Programming, Concise Code.</p>
<h2 id="Implementing-Filter-Animation-in-Kotlin"><a href="#Implementing-Filter-Animation-in-Kotlin" class="headerlink" title="Implementing Filter Animation in Kotlin"></a><a href="https://yalantis.com/blog/develop-filter-animation-kotlin-android/" target="_blank" rel="external">Implementing Filter Animation in Kotlin</a></h2><p>作者他们搞了一个应用FIT, 为女性IT工作者提供社区和交流平台, 想要成为Quora加上Linkedin.</p>
<p>为了让用户选择分类和过滤器tag进行搜索, 他们开发了一个组件: <a href="https://github.com/Yalantis/SearchFilter" target="_blank" rel="external">SearchFilter</a>. </p>
<p>文中讨论了这种设计的动画实现, 库是用Kotlin写的.</p>
<h2 id="DI-101-—-Part-3"><a href="#DI-101-—-Part-3" class="headerlink" title="DI 101 — Part 3"></a><a href="https://medium.com/di-101/di-101-part-3-f0136e67db8#.rdp4e4fwc" target="_blank" rel="external">DI 101 — Part 3</a></h2><p>本文讲什么是Scope, 如何定义Scope, 如何使用Scope和@Subcomponent.</p>
<p>Subcomponent会继承父类的所有bindings.</p>
<p>作者定义了一个Activity的Scope, 然后定义了一个Subcomponent专门给这个Activity用, 这个Subcomponent只在这个Activity的生命周期里存活. 代码例子比较简洁易懂.</p>
<h2 id="How-Dagger-2-Helps-In-Android-Espresso-Tests"><a href="#How-Dagger-2-Helps-In-Android-Espresso-Tests" class="headerlink" title="How Dagger 2 Helps In Android Espresso Tests"></a><a href="http://www.ottodroid.net/?p=514" target="_blank" rel="external">How Dagger 2 Helps In Android Espresso Tests</a></h2><p>这篇文章介绍了如何在写Espresso测试的时候, 使用一个测试用的Dagger Component.</p>
<h2 id="Finally-understanding-how-references-work-in-Android-and-Java"><a href="#Finally-understanding-how-references-work-in-Android-and-Java" class="headerlink" title="Finally understanding how references work in Android and Java"></a><a href="https://medium.com/google-developer-experts/finally-understanding-how-references-work-in-android-and-java-26a0d9c92f83#.95piwft68" target="_blank" rel="external">Finally understanding how references work in Android and Java</a></h2><p>这篇文章讲了Java中的引用类型和Android中的内存泄露.</p>
<p>Java中的引用类型:</p>
<ul>
<li>Strong reference</li>
<li>WeakReference</li>
<li>SoftReference</li>
<li>PhantomReference</li>
</ul>
<p>作者详细介绍了每一种引用并用例子说明了使用场景. </p>
<h2 id="MVVM-RxJava-Learnings"><a href="#MVVM-RxJava-Learnings" class="headerlink" title="MVVM + RxJava: Learnings"></a><a href="https://medium.com/upday-devs/mvvm-rxjava-learnings-1819423f9592#.3rat89dq5" target="_blank" rel="external">MVVM + RxJava: Learnings</a></h2><p>作者他们的新闻应用采用MVVM + RxJava架构, 本文总结了他们遇到的问题和学到的两点:</p>
<ol>
<li>暴露状态, 而不是事件;</li>
<li>所有的事情都应该通过ViewModel.</li>
</ol>
<h2 id="Adding-TV-Channels-to-Your-App-with-the-TIF-Companion-Library"><a href="#Adding-TV-Channels-to-Your-App-with-the-TIF-Companion-Library" class="headerlink" title="Adding TV Channels to Your App with the TIF Companion Library"></a><a href="http://android-developers.blogspot.com.au/2016/11/adding-tv-channels-to-your-app-with-the-tif-companion-library.html" target="_blank" rel="external">Adding TV Channels to Your App with the TIF Companion Library</a></h2><p>TV Input Framework(TIF)和Android TV让第三方应用开发者可以很容易地创建自己的电视频道. </p>
<h2 id="Background-Audio-in-Android-With-MediaSessionCompat"><a href="#Background-Audio-in-Android-With-MediaSessionCompat" class="headerlink" title="Background Audio in Android With MediaSessionCompat"></a><a href="https://code.tutsplus.com/tutorials/background-audio-in-android-with-mediasessioncompat--cms-27030" target="_blank" rel="external">Background Audio in Android With MediaSessionCompat</a></h2><p>Android support library中的<code>MediaSessionCompat</code>使用, 以及如何用它来做一个背景音乐.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FirebaseUI-Android"><a href="#FirebaseUI-Android" class="headerlink" title="FirebaseUI-Android"></a><a href="https://github.com/firebase/FirebaseUI-Android" target="_blank" rel="external">FirebaseUI-Android</a></h2><p>FirebaseUI for Android — UI Bindings for Firebase.</p>
<h2 id="ChipsLayoutManager"><a href="#ChipsLayoutManager" class="headerlink" title="ChipsLayoutManager"></a><a href="https://github.com/BelooS/ChipsLayoutManager" target="_blank" rel="external">ChipsLayoutManager</a></h2><p>一个自定义的RecyclerView的layout manager, 流式地显示很多小块的TextView.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-231&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-231&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #231&quot;&gt;&lt;/a&gt;Android Weekly Issue #231&lt;/h1&gt;&lt;p&gt;November 13th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-231&quot;&gt;Android Weekly Issue #231&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android Weekly阅读笔记, Issue #231, 本期内容包括: MVP中的View做成passive响应式的, 返回Observable; Android Studio使用技巧; &lt;code&gt;BottomNavigationView&lt;/code&gt;的使用; App tracking; Kotlin; 用Kotlin实现的Filter Animation效果; Dagger2的&lt;code&gt;Scope&lt;/code&gt;和&lt;code&gt;Subcomponent&lt;/code&gt;使用; Espresso测试中mock dagger注入; Android和Java中的Reference和内存泄露; MVVM + RxJava构架实际使用的经验分享; 还有TV以及Audio相关的内容等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Espresso" scheme="http://mengdd.github.io/tags/Espresso/"/>
    
      <category term="TV" scheme="http://mengdd.github.io/tags/TV/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="Tools" scheme="http://mengdd.github.io/tags/Tools/"/>
    
      <category term="Memory Leak" scheme="http://mengdd.github.io/tags/Memory-Leak/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="MVVM" scheme="http://mengdd.github.io/tags/MVVM/"/>
    
      <category term="BottomNavigationView" scheme="http://mengdd.github.io/tags/BottomNavigationView/"/>
    
      <category term="Audio" scheme="http://mengdd.github.io/tags/Audio/"/>
    
      <category term="Passive View" scheme="http://mengdd.github.io/tags/Passive-View/"/>
    
      <category term="RxBinding" scheme="http://mengdd.github.io/tags/RxBinding/"/>
    
      <category term="Tracking" scheme="http://mengdd.github.io/tags/Tracking/"/>
    
      <category term="Analytics" scheme="http://mengdd.github.io/tags/Analytics/"/>
    
      <category term="Scope" scheme="http://mengdd.github.io/tags/Scope/"/>
    
      <category term="Subcomponent" scheme="http://mengdd.github.io/tags/Subcomponent/"/>
    
      <category term="Reference" scheme="http://mengdd.github.io/tags/Reference/"/>
    
      <category term="Media" scheme="http://mengdd.github.io/tags/Media/"/>
    
  </entry>
  
</feed>
