<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng&#39;s pages</title>
  <subtitle>Android developer and maybe other intersting things.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mengdd.github.io/"/>
  <updated>2017-04-11T09:47:50.000Z</updated>
  <id>http://mengdd.github.io/</id>
  
  <author>
    <name>Dandan Meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络使用和电池消耗 原因和改进</title>
    <link href="http://mengdd.github.io/Android/2017/04/11/network-usage-and-battery-consumption/"/>
    <id>http://mengdd.github.io/Android/2017/04/11/network-usage-and-battery-consumption/</id>
    <published>2017-04-11T09:39:56.000Z</published>
    <updated>2017-04-11T09:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络使用和电池消耗-原因和改进"><a href="#网络使用和电池消耗-原因和改进" class="headerlink" title="网络使用和电池消耗 原因和改进"></a>网络使用和电池消耗 原因和改进</h1><p>你的app发送的网络请求是电量消耗的主要原因, 本文先教你如何使用IDE工具来分类分析应用中的网络请求, 之后按照三种不同的网络请求分类, 分别给出优化建议, 减少电量消耗.</p>
<p>本文是对Android官网<a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>系列文章的翻译, 略有删减, 可以作为摘要看看. (翻译不当的地方还请见谅).</p>
<a id="more"></a>
<h2 id="收集网络数据-Collecting-Network-Traffic-Data"><a href="#收集网络数据-Collecting-Network-Traffic-Data" class="headerlink" title="收集网络数据 Collecting Network Traffic Data"></a>收集网络数据 <a href="https://developer.android.com/topic/performance/power/network/gather-data.html" target="_blank" rel="external">Collecting Network Traffic Data</a></h2><p>使用<a href="https://developer.android.com/studio/profile/ddms.html#network" target="_blank" rel="external">Network Traffic tool</a>可以看到你的app如何以及何时通过网络发送数据.<br>本节教你如何通过在代码中加tag来测量和分类网络请求, 然后教你如何部署, 测试和可视化你的网络请求.</p>
<p>可以把网络请求分三类:</p>
<ul>
<li>用户发起的.</li>
<li>App发起的.</li>
<li>Server发起的. 比如notification.</li>
</ul>
<p>对这三个分类定义三个常量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_INITIATED = <span class="number">0x1000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_INITIATED = <span class="number">0x2000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_INITIATED =<span class="number">0x3000</span>;</div></pre></td></tr></table></figure></p>
<p>全文搜索:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extends GcmTaskService|extends JobService|extends AbstractThreadedSyncAdapter|HttpUrlConnection|Volley|Glide|HttpClient</div></pre></td></tr></table></figure></p>
<p>勾选Regular expression, File mask(s) 写 *.java.</p>
<p>找出所有的网络请求后, 加上下面的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (BuildConfig.NETWORK-TEST &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        TrafficStats.setThreadStatsTag(USER_INITIATED);</div><div class="line">        <span class="comment">// make network request using HttpClient.execute()</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        TrafficStats.clearThreadStatsTag();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中build type的配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    buildTypes &#123;</div><div class="line">        debug &#123;</div><div class="line">            // debuggable true is default for the debug buildType</div><div class="line">        &#125;</div><div class="line">        network-test &#123;</div><div class="line">            debuggable true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行测试:<br>Tools &gt; Android &gt; Android Device Monitor.<br>选择tab: Network Statistics.<br>选择你的应用, 然后按开始按钮.<br>你可以用下面的命令来清除应用的数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear package.name.of.app</div></pre></td></tr></table></figure></p>
<p>然后在你的应用中跑你想测试的应用场景即可.</p>
<p>使用了不同tag的网络请求会用不同的颜色显示出来.</p>
<h2 id="分析网络数据-Analyzing-Network-Traffic-Data"><a href="#分析网络数据-Analyzing-Network-Traffic-Data" class="headerlink" title="分析网络数据 Analyzing Network Traffic Data"></a>分析网络数据 <a href="https://developer.android.com/topic/performance/power/network/analyze-data.html" target="_blank" rel="external">Analyzing Network Traffic Data</a></h2><p>有效应用网络资源的特点: 应该有大段的时间网络硬件没有在使用中. 因为在移动设备上, 发送和接收数据, 长时间保持数据连接都会有巨大的花销. 如果你的应用访问网络很有效率, 那么网络通信看起来就应该是紧耦合的, 被无请求的休息时段合理地隔开.</p>
<h3 id="分析网络数据类型"><a href="#分析网络数据类型" class="headerlink" title="分析网络数据类型"></a>分析网络数据类型</h3><p>如果你的网络请求图看起来存在这方面的问题, 我们就需要根据上一节中加tag而分三种类型形成的网络图来进行分析, 提供一些优化意见.</p>
<h4 id="分析用户发起的网络请求"><a href="#分析用户发起的网络请求" class="headerlink" title="分析用户发起的网络请求"></a>分析用户发起的网络请求</h4><p>用户发起的网络请求: 当用户在执行一项特定的活动时, 可能可以有效地耦合在一起; 或者当用户不断请求附加信息时, 非均匀地展开. 当在分析用户发起的请求是, 你的目标是: 寻找频繁的网络使用模式, 还有试图创建或增加不使用网络的时段.</p>
<p>这种网络请求优化的挑战是用户请求的不确定性. 另外, 用户在使用app的时候总是期待快速的响应, 所以推迟请求会降低用户体验. 一般来说, 当用户和app直接交互时, 快速响应的优先级是高于有效的网络请求使用的.</p>
<p>这里是一些对于用户网络请求的优化手段:</p>
<ul>
<li>预取. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#pre-fetch-data" target="_blank" rel="external">Pre-fetch Network Data</a>. 当用户执行一项操作的时候, 应用预计一下它下一步可能需要的数据, 在单个连接中批量获取它们, 然后持有它们直到用户请求它们.</li>
<li>检测连接或监听变化. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#check-or-listen" target="_blank" rel="external">Check for Connectivity or Listen for Changes</a>. 在执行更新前, 检测网络连接, 或者监听网络连接变化.</li>
<li>减少连接数. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#reduce-connections" target="_blank" rel="external">Reduce the Number of Connections</a>. 使用允许数据按集合下载的server APIs</li>
</ul>
<h4 id="分析app发起的网络请求"><a href="#分析app发起的网络请求" class="headerlink" title="分析app发起的网络请求"></a>分析app发起的网络请求</h4><p>由你的应用发起的网络请求通常是一个对有效网络带宽有很大影响的方面. 在分析应用的网络活动的时候, 寻找空闲时段, 决定它们是否能被扩展. 如果你看到一致的网络请求的模式, 你应该寻找一些方法来改进, 以允许切换到低功耗模式.</p>
<p>一些优化app发起请求的手段:</p>
<ul>
<li>批处理和定时. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#batch-schedule" target="_blank" rel="external">Batch and Schedule Network Requests</a> 推迟你的网络请求以便它们可以一起处理, 并且在一个对电池来说有优势的时间.</li>
<li>允许系统检查连接. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#check-connect" target="_blank" rel="external">Allow System to Check for Connectivity</a>. 应该避免仅仅为了检查网络连接而引起的电池耗损, 在应用休眠的时候, 你可以让系统来帮你做检查.</li>
</ul>
<h4 id="分析server发起的网络请求"><a href="#分析server发起的网络请求" class="headerlink" title="分析server发起的网络请求"></a>分析server发起的网络请求</h4><p>由server对应用发起的网络请求通常也是一个对有效网络带宽有很大影响的方面. 在分析来自server的网络活动的时候, 寻找非活跃的时期, 看它们是否能被增加. </p>
<p>优化手段:</p>
<ul>
<li>使用GCM. <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html#gcm" target="_blank" rel="external">Use GCM for Server Updates</a>. 考虑使用Google Cloud Messaging service来做server端的更新, 而不是轮询.</li>
</ul>
<h2 id="优化用户网络请求-Optimizing-User-Initiated-Network-Use"><a href="#优化用户网络请求-Optimizing-User-Initiated-Network-Use" class="headerlink" title="优化用户网络请求 Optimizing User-Initiated Network Use"></a>优化用户网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html" target="_blank" rel="external">Optimizing User-Initiated Network Use</a></h2><p>快速处理用户的请求保证了良好的用户体验, 所以与此相比, 节约能量的优先级比较低.</p>
<h3 id="预取-Pre-fetch-Network-Data"><a href="#预取-Pre-fetch-Network-Data" class="headerlink" title="预取 Pre-fetch Network Data"></a>预取 Pre-fetch Network Data</h3><p>预取数据是一个减少数据传输的session数量很有效的方法. 使用预取, 在用户执行一个行为的时候, app预测下一步行为最有可能会用到的数据, 然后批量取出相关数据. 电池能量消耗因为两个原因被降低了:</p>
<ul>
<li>因为预取数据发生在mobile radio已经唤醒的状态, 所以不用再次唤醒. </li>
<li>应用预取了数据, 不然可能需要重新发另外的请求或者唤醒radio.</li>
</ul>
<p>Tip: 为了查看是否你的应用可以从预取中获利, 你可以检查你的网络traffic, 寻找永远导致多个网络请求的特定系列的用户行为. 比如那些当用户浏览时增量下载文章内容的应用, 可以在用户当前查看的分类下预取一个或多个文章.</p>
<p>更多可以查看: <a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#PrefetchData" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h3 id="检查连接-Check-for-Connectivity-or-Listen-for-Changes"><a href="#检查连接-Check-for-Connectivity-or-Listen-for-Changes" class="headerlink" title="检查连接 Check for Connectivity or Listen for Changes"></a>检查连接 Check for Connectivity or Listen for Changes</h3><p>在移动设备上来说, 搜寻信号是最费能量的操作之一. 你的应用应该总是在发出用户请求之前检查连接状态. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#choosing-scheduler" target="_blank" rel="external">Schedulers</a>可以帮你自动做这个.</p>
<ul>
<li>如果你的一些按钮依赖于网络连接, 用<a href="https://developer.android.com/reference/android/net/ConnectivityManager.html" target="_blank" rel="external">ConnectivityManager</a>来检查连接. 如果没有网络连接, app就可以节省下强制连接的电量. 具体做法见<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html#MonitorChanges" target="_blank" rel="external">Monitor for Changes in Connectivity</a>.</li>
<li>如果没有网络的情况下, 你的应用整个界面都处于不可用状态, 那么你可以根据需要使用Broadcast Receivers. 在你的Activity处于前台时监听网络连接变化, 当没有连接的时候, 就不再发请求. 如果你的app检测到网络连接丢失, 除了检测网路连接的那个receiver, 它关闭掉其他所有的receivers.</li>
</ul>
<p>对于用户发起的请求, 一个最佳实践就是在请求之前检查连接, 如果网络连接不存在, 可以调度请求在连接上以后再进行. 调度器可以用一些方式来节省电量, 比如每次检查的时候连接失败, 那么就加倍延迟时间下次再检查.</p>
<h3 id="减少连接数-Reduce-the-Number-of-Connections"><a href="#减少连接数-Reduce-the-Number-of-Connections" class="headerlink" title="减少连接数 Reduce the Number of Connections"></a>减少连接数 Reduce the Number of Connections</h3><p>一般来讲, 复用已存在的网络连接比启动新的更高效. 复用连接还允许网络更智能地对待拥堵和相关网络数据问题.<br>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#ReduceConnections" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h2 id="优化App发起的网络请求-Optimizing-App-Initiated-Network-Use"><a href="#优化App发起的网络请求-Optimizing-App-Initiated-Network-Use" class="headerlink" title="优化App发起的网络请求 Optimizing App-Initiated Network Use"></a>优化App发起的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html" target="_blank" rel="external">Optimizing App-Initiated Network Use</a></h2><p>你的应用发起的网络请求通常可以大幅度改善, 因为你可以对需要的资源做出计划并且设置访问它们的时间. 通过合理地调度时间, 可以创建出大段的设备radio空闲时间, 从而节约电量. 有一些Android的API可以用来调度网络访问, 并且其中的一些功能可以用来调节对其他应用的网络访问, 从而进一步优化电池性能.</p>
<h3 id="批处理和定时-Batch-and-Schedule-Network-Requests"><a href="#批处理和定时-Batch-and-Schedule-Network-Requests" class="headerlink" title="批处理和定时 Batch and Schedule Network Requests"></a>批处理和定时 Batch and Schedule Network Requests</h3><p>随机处理单个的请求会花掉很多的能量, 一个更高效的方法是把一系列的请求放入一个队列一起处理.</p>
<p>使用一个网络请求scheduler API用来管理和处理你的请求队列可以提高app的能量效率. Schedulers保存能量是通过把请求组合在一起, 让系统来处理. 它们还可以通过延迟一些请求, 等其他请求唤醒radio的时候, 或者等设备在充电的时候再做请求, 来进一步优化. Schedulers延迟和批处理请求是在系统范围的, 可以跨多个应用, 相比单个应用中的优化, 这给了它们更多优势.</p>
<h4 id="选择一个batch-and-scheduling-API"><a href="#选择一个batch-and-scheduling-API" class="headerlink" title="选择一个batch-and-scheduling API"></a>选择一个batch-and-scheduling API</h4><p>Android提供了三种API, 对于大多数操作功能相似, 按推荐性从高到低排列:</p>
<ul>
<li><a href="https://developers.google.com/cloud-messaging/network-manager" target="_blank" rel="external">GCM Network Manager</a>. 要求使用Google Play services.</li>
<li><a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">Job Scheduler</a>. Android 5.0 (API 21)及以上.</li>
<li><a href="https://developer.android.com/training/sync-adapters/index.html" target="_blank" rel="external">Sync Adapter for scheduled syncs</a>. 相比于前两种来说, 这种实现起来比较复杂.</li>
</ul>
<h3 id="允许系统检验连接-Allow-System-to-Check-for-Connectivity"><a href="#允许系统检验连接-Allow-System-to-Check-for-Connectivity" class="headerlink" title="允许系统检验连接 Allow System to Check for Connectivity"></a>允许系统检验连接 Allow System to Check for Connectivity</h3><p>一个最严重且意外的电池消耗原因是当用户超出信号塔或接入点范围时. 在这种情况下, 用户可能并没有使用手机, 但是他们注意到设备变热, 电池电量变少.</p>
<p>在这种情形下, 可能是app正在跑一个后台进程, 其中以固定时间间隔搜寻信号. 搜寻信号是一个很耗电的操作.</p>
<p>避免这个问题的方法是用一种更高效的方式来查询信号连接情况. 对于app发起的请求, 可以用一个scheduler, 在其中用<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html" target="_blank" rel="external">Connectivity Manager</a>来检查连接. 如果没有网络连接, Connectivity Manager节约了能量, 因为它是自己检查了连接, 而不是启动了app来做检查. 可以进一步使用<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="external">exponential backoff</a>来做优化, 如果没有连接, 那么扩大检查的时间间隔.</p>
<h2 id="优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use"><a href="#优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use" class="headerlink" title="优化来自server的网络请求 Optimizing Server-Initiated Network Use"></a>优化来自server的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html" target="_blank" rel="external">Optimizing Server-Initiated Network Use</a></h2><p>由server发往app的请求优化起来比较有难度. 一种解决方案是客户端轮询, 检查server是否有更新, 这种方式很浪费. 一种更有效率的方式是当有新数据的时候通知你的app.</p>
<p><a href="https://developers.google.com/cloud-messaging/gcm" target="_blank" rel="external">Google Cloud Messaging</a> GCM就是为了解决这个问题. 让你的server可以向app发送通知, 提高了网络效率, 降低了能量消耗.</p>
<h3 id="用GCM发送服务器更新-Send-Server-Updates-with-GCM"><a href="#用GCM发送服务器更新-Send-Server-Updates-with-GCM" class="headerlink" title="用GCM发送服务器更新 Send Server Updates with GCM"></a>用GCM发送服务器更新 Send Server Updates with GCM</h3><p>Google Cloud Messaging (GCM)是一个轻量级的机制, 用于server向app传输一些简短的信息. 使用了GCM之后, server就可以在有数据更新的时候通知app, 这个方法减少了app查询更新却没有数据的能量消耗, 也避免了周期性的轮询请求.</p>
<p>注意: 通常情况使用<a href="https://developers.google.com/cloud-messaging/concept-options#setting-the-priority-of-a-message" target="_blank" rel="external">Normal priority</a>即可, 这样不会在设备非活跃或者低电量的时候唤醒设备.</p>
<h2 id="优化一般的网络使用-Optimizing-General-Network-Use"><a href="#优化一般的网络使用-Optimizing-General-Network-Use" class="headerlink" title="优化一般的网络使用 Optimizing General Network Use"></a>优化一般的网络使用 <a href="https://developer.android.com/topic/performance/power/network/action-any-traffic.html" target="_blank" rel="external">Optimizing General Network Use</a></h2><p>一般情况下, 减少网络请求会对节约电量有帮助. 除了之前提到的改进方法, 你还应该知道一些一般性的方法. </p>
<h3 id="压缩数据-Compress-Data"><a href="#压缩数据-Compress-Data" class="headerlink" title="压缩数据 Compress Data"></a>压缩数据 Compress Data</h3><p>减少发送或接受的数据量会帮助减少连接时间, 从而节约电量.<br>你可以:</p>
<ul>
<li>压缩数据, 用一些压缩方法, 比如GZIP压缩.</li>
<li>使用简洁的数据协议. JSON和XML提供了可读性和语言灵活性, 但是它们都是很占带宽的模式, 并且在Android上有一些序列化花销.<br>二进制序列化格式, 比如<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">Protocol Buffers</a>或<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>, 提供了更小的数据包大小, 以及更快的编解码时间. 如果你的应用经常需要传输序列化数据, 这些格式会帮你获得解码时间和传输大小方面的优势.</li>
</ul>
<h3 id="本地缓存文件-Cache-Files-Locally"><a href="#本地缓存文件-Cache-Files-Locally" class="headerlink" title="本地缓存文件 Cache Files Locally"></a>本地缓存文件 Cache Files Locally</h3><p>应用可以通过缓存来避免下载重复的数据. 始终缓存静态资源, 包括要求下载的全尺寸图像, 并尽可能长时间缓存它们.</p>
<p>缓存实现见: <a href="https://developer.android.com/training/efficient-downloads/redundant_redundant.html#LocalCache" target="_blank" rel="external">Cache Files Locally</a>.</p>
<h3 id="优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size"><a href="#优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size" class="headerlink" title="优化预取缓存大小 Optimize Pre-Fetch Cache Size"></a>优化预取缓存大小 Optimize Pre-Fetch Cache Size</h3><p>根据本地文件系统的尺寸和当前的网络连接来优化预取缓存大小. 你可以使用connectivity manager来确定处于活动状态的网络类型(Wi-FI, LTE, HSPAP, EDGE, GPRS), 并修改你的预取程序来最小化电池负载.</p>
<p>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/connectivity_patterns.html#Bandwidth" target="_blank" rel="external">Use Modifying your Download Patterns Based on the Connectivity Type</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络使用和电池消耗-原因和改进&quot;&gt;&lt;a href=&quot;#网络使用和电池消耗-原因和改进&quot; class=&quot;headerlink&quot; title=&quot;网络使用和电池消耗 原因和改进&quot;&gt;&lt;/a&gt;网络使用和电池消耗 原因和改进&lt;/h1&gt;&lt;p&gt;你的app发送的网络请求是电量消耗的主要原因, 本文先教你如何使用IDE工具来分类分析应用中的网络请求, 之后按照三种不同的网络请求分类, 分别给出优化建议, 减少电量消耗.&lt;/p&gt;
&lt;p&gt;本文是对Android官网&lt;a href=&quot;https://developer.android.com/topic/performance/power/network/index.html&quot;&gt;Reducing Network Battery Drain&lt;/a&gt;系列文章的翻译, 略有删减, 可以作为摘要看看. (翻译不当的地方还请见谅).&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Network" scheme="http://mengdd.github.io/tags/Network/"/>
    
      <category term="Battery" scheme="http://mengdd.github.io/tags/Battery/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 251</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/04/06/android-weekly-notes-issue-251/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/04/06/android-weekly-notes-issue-251/</id>
    <published>2017-04-06T09:04:00.000Z</published>
    <updated>2017-04-06T09:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-251"><a href="#Android-Weekly-Issue-251" class="headerlink" title="Android Weekly Issue #251"></a>Android Weekly Issue #251</h1><p>April 2nd, 2017<br><a href="http://androidweekly.net/issues/issue-251" target="_blank" rel="external">Android Weekly Issue #251</a>.<br>本期内容: Android O新增的API: View的tooltips; Android中的字体设置; 该不该将Kotlin用于产品代码; 实现一个带自定义动画的搜索Toolbar; JUnit 5中用Lambda表达式; 用Mockito和Espresso写测试;<br>native的mobile开发应该扩展一下自己的知识; Kotlin中的依赖注入实现; Kotlin中lambda表达式的简化; 一个Intellij IDEA的插件, 帮助你改善Java代码的可读性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preliminary-look-at-View-tooltips"><a href="#Preliminary-look-at-View-tooltips" class="headerlink" title="Preliminary look at View tooltips"></a><a href="https://medium.com/@bherbst/preliminary-look-at-view-tooltips-b127583c5691" target="_blank" rel="external">Preliminary look at View tooltips</a></h2><p>Android O新推出了一个API, 是给View加tooltips.</p>
<p>如何使用:<br>可以在xml里面用属性<a href="https://developer.android.com/reference/android/view/View.html#attr_android:tooltipText" target="_blank" rel="external">android:tooltipText</a>, 或者使用Java方法<a href="https://developer.android.com/reference/android/view/View.html#setTooltipText%28java.lang.CharSequence%29" target="_blank" rel="external">View.setTooltipText()</a>来指定提示文字.</p>
<p>它们的外观看起来就像一个toast(半透明的灰色方框, 有圆角). 它支持多行, 有最大宽度, 超过98个字符结尾会以…省略.<br>目前还不能被定制.</p>
<p>它在什么时候出现呢? 长按和悬停.<br>当然你的长按如果已经被处理过了(<code>OnLongClickListener</code>返回了true), 它就不会出现了.</p>
<h2 id="Perfecting-Custom-Typography-in-Android"><a href="#Perfecting-Custom-Typography-in-Android" class="headerlink" title="Perfecting Custom Typography in Android"></a><a href="https://www.bignerdranch.com/blog/perfecting-custom-typography-in-android/" target="_blank" rel="external">Perfecting Custom Typography in Android</a></h2><p>关于字体设置的微调, 作者他们弄了一个小工具: <a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a>来提高设计师和开发者沟通字体时候的效率.</p>
<h3 id="字体尺寸"><a href="#字体尺寸" class="headerlink" title="字体尺寸"></a>字体尺寸</h3><p>对于字体, 通常我们建议用<code>sp</code>(scaleable pixel), 1pt=1sp. (pt是point).</p>
<p><code>sp</code>考虑到了用户设备上的字体设置, 所以通常是建议用sp来设置字体大小.</p>
<p>但是作者他们最近在应用中一些字很大的地方, 选择使用了<code>dp</code> (density-independent pixel), 这是因为这些字本来已经很大了, 所以他们不想让它们被调节以后变得更大.</p>
<h3 id="Leading"><a href="#Leading" class="headerlink" title="Leading"></a>Leading</h3><p>在字体排版中, Leading是指字体行之间的竖直间距. 和<code>line spacing</code>和<code>line height</code>是同义词, 同样也由<code>pt/sp</code>作为单位.</p>
<p>字体文件中会有一个基本的leading值, 根据字体不同可能会不同.</p>
<p>在Android中TextView的leading可以通过<code>lineSpacingExtra</code>和<code>lineSpacingMultiplier</code>属性来定义. 在代码中可以通过方法<a href="https://developer.android.com/reference/android/widget/TextView.html#setLineSpacing(float,%20float" target="_blank" rel="external">setLineSpacing()</a>)来定义. 注意用这个方法时, 单位是像素.</p>
<h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>Tracking指字间距(letterspacing).<br>在Android中可以通过属性<code>letterSpacing</code>来设置(API 21及以上), 以em为单位的分数测量.</p>
<h2 id="Kotlin-in-Production-Should-you-stay-or-should-you-go"><a href="#Kotlin-in-Production-Should-you-stay-or-should-you-go" class="headerlink" title="Kotlin in Production: Should you stay or should you go?"></a><a href="https://medium.com/@dpreussler/kotlin-in-production-should-you-stay-or-should-you-go-a3428b44b236" target="_blank" rel="external">Kotlin in Production: Should you stay or should you go?</a></h2><p>关于是否应该使用Kotlin, 作者发表了一些他的想法. 总体来说作者是支持Kotlin的, 对于各个可能存疑的点, 他都做出了解释.</p>
<h2 id="How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin"><a href="#How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin" class="headerlink" title="How We Made the ToolBar on Android Move Like Jelly (in Kotlin)"></a><a href="https://yalantis.com/blog/toolbar-jelly-animation-kotlin-android/" target="_blank" rel="external">How We Made the ToolBar on Android Move Like Jelly (in Kotlin)</a></h2><p>在Toolbar上点击搜索按钮, 展开关键词输入框的时候, 加一个动画, 让它有弹性地震动一下, 如何实现呢?<br>本文给出了详细代码.</p>
<h2 id="JUnit-5-Lambdas"><a href="#JUnit-5-Lambdas" class="headerlink" title="JUnit 5: Lambdas"></a><a href="https://blog.stylingandroid.com/junit-5-lambdas/" target="_blank" rel="external">JUnit 5: Lambdas</a></h2><p>如何在测试中使用lambda表达式, 这篇文章里作者讨论了如何在项目中使用lambda表达式的一些方法.</p>
<p>有两个比较好的方法:</p>
<ul>
<li>用<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">retrolambda</a>.</li>
<li>用Kotlin.</li>
</ul>
<h2 id="Testing-MVP-using-Espresso-and-Mockito"><a href="#Testing-MVP-using-Espresso-and-Mockito" class="headerlink" title="Testing MVP using Espresso and Mockito"></a><a href="https://josiassena.com/testing-mvp-using-espresso-and-mockito/" target="_blank" rel="external">Testing MVP using Espresso and Mockito</a></h2><p>如何用Mockito和Espresso给一个MVP架构的程序写单元测试和UI测试.</p>
<h2 id="The-rise-of-the-full-stack-native-mobile-app-developer"><a href="#The-rise-of-the-full-stack-native-mobile-app-developer" class="headerlink" title="The rise of the full-stack native mobile app developer"></a><a href="https://medium.com/@erikhellman/the-rise-of-the-full-stack-native-mobile-app-developer-a0757388bc1b" target="_blank" rel="external">The rise of the full-stack native mobile app developer</a></h2><p>这篇文章就说native的客户端开发应该扩展自己, 学一点后端知识, 来应对行业发展和以后的趋势.</p>
<h2 id="Kotlin-Dependency-Injection-with-the-Reader-Monad"><a href="#Kotlin-Dependency-Injection-with-the-Reader-Monad" class="headerlink" title="Kotlin Dependency Injection with the Reader Monad"></a><a href="https://medium.com/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e" target="_blank" rel="external">Kotlin Dependency Injection with the Reader Monad</a></h2><p>Dependency Injection (DI)依赖注入是一种概念, 和具体使用的工具无关, 所以有各种不同的方法可以实现它.<br>本文只是提供一种思路, 用Kotlin中函数式的一些特性来做依赖注入.</p>
<p>首先介绍了什么是<code>Functors</code>, <code>Applicatives</code>和<code>Monads</code>, 作者推荐看这系列文章: <a href="https://medium.com/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251" target="_blank" rel="external">Kotlin Functors, Applicatives, And Monads in Pictures. Part 1/3</a>.</p>
<p>后来作者举了实际的例子, 详情见原文.</p>
<h2 id="How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation"><a href="#How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation" class="headerlink" title="How lambdas work in Kotlin &amp; setOnClickListener transformation"></a><a href="https://antonioleiva.com/lambdas-kotlin-android/" target="_blank" rel="external">How lambdas work in Kotlin &amp; setOnClickListener transformation</a></h2><p>关于Kotlin中的lambda是如何简化的, 以<code>setOnClickListener()</code>为例:<br>它在Java中是这样定义的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Kotlin中是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun setOnClickListener(l: (View) -&gt; Unit)</div></pre></td></tr></table></figure></p>
<p>最原始的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(object : View.OnClickListener &#123;</div><div class="line">    override fun onClick(v: View?) &#123;</div><div class="line">        toast(&quot;Hello&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后IDE会提示你改为用lambda表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(&#123; v -&gt; toast(&quot;Hello&quot;) &#125;)</div></pre></td></tr></table></figure></p>
<p>然而这个还可以进一步被简化:</p>
<p>如果一个方法的<strong>最后一个参数</strong>是一个函数, 那么它可以写在括号外面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener() &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个方法只有一个参数, 并且是一个函数, 括号可以被删掉:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你并没有用到lambda表达式的参数, 你可以省略左边的部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你的表达式只有一个参数, 而你要用它, 你仍然可以不写左边的部分, 用<code>it</code>来代替它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; doSomething(it) &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Making-Java-Code-Easier-to-Read-Without-Changing-it"><a href="#Making-Java-Code-Easier-to-Read-Without-Changing-it" class="headerlink" title="Making Java Code Easier to Read (Without Changing it)"></a><a href="https://medium.com/@andrey_cheptsov/making-java-code-easier-to-read-without-changing-it-adeebd5c36de" target="_blank" rel="external">Making Java Code Easier to Read (Without Changing it)</a></h2><p>如何在不改变代码的情况下, 增加Java代码的可读性?</p>
<p>IntelliJ IDEA为Java 8以下的用户提供了代码折叠功能, 来模拟lambda的语法.</p>
<p>作者自己又开发了一个新的插件<a href="https://plugins.jetbrains.com/plugin/9320-advanced-java-folding" target="_blank" rel="external">Advanced Java Folding</a>, 进一步扩展了这个代码折叠的功能. 本文介绍其中一些features. 这些特性在插件中都是可选的, 可以根据需要和喜好配置.</p>
<p>(经过折叠以后的Java代码确实看起来很像Kotlin).</p>
<p>本期还有两篇Android Things的文章就不介绍啦.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="JellyToolbar"><a href="#JellyToolbar" class="headerlink" title="JellyToolbar"></a><a href="https://github.com/Yalantis/JellyToolbar" target="_blank" rel="external">JellyToolbar</a></h2><p>一个带弹性抖动动画的搜索Toolbar实现, 本期有一篇文章介绍.</p>
<h2 id="Android-Router"><a href="#Android-Router" class="headerlink" title="Android Router"></a><a href="https://github.com/TangXiaoLv/Android-Router" target="_blank" rel="external">Android Router</a></h2><p>一个轻量级的组件化协议框架, 用来解耦复杂项目.</p>
<h2 id="Typesetter"><a href="#Typesetter" class="headerlink" title="Typesetter"></a><a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a></h2><p>一个小工具, 用来调整和显示字体, 本期有相关文章.</p>
<h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a><a href="https://github.com/DrKLO/Telegram" target="_blank" rel="external">Telegram</a></h2><p>Telegram是一个通信应用, 关注速度和安全. 这是该应用的官方开源代码.</p>
<h2 id="Badger"><a href="#Badger" class="headerlink" title="Badger"></a><a href="https://github.com/volders/Badger" target="_blank" rel="external">Badger</a></h2><p>一个给图片加数字小标(badges)的库.</p>
<h2 id="classyshark-calculate-size"><a href="#classyshark-calculate-size" class="headerlink" title="classyshark-calculate-size"></a><a href="https://github.com/borisf/classyshark-calculate-size" target="_blank" rel="external">classyshark-calculate-size</a></h2><p>这个工具可以计算出你依赖的库在apk的classes.dex中到底占多少大小.</p>
<h2 id="SlidingRootNav"><a href="#SlidingRootNav" class="headerlink" title="SlidingRootNav"></a><a href="https://github.com/yarolegovich/SlidingRootNav" target="_blank" rel="external">SlidingRootNav</a></h2><p>一个类似于<code>DrawerLayout</code>的ViewGroup, 抽屉部分隐藏在内容的下面. 内容可以向右滑动缩小以露出抽屉.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-251&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-251&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #251&quot;&gt;&lt;/a&gt;Android Weekly Issue #251&lt;/h1&gt;&lt;p&gt;April 2nd, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-251&quot;&gt;Android Weekly Issue #251&lt;/a&gt;.&lt;br&gt;本期内容: Android O新增的API: View的tooltips; Android中的字体设置; 该不该将Kotlin用于产品代码; 实现一个带自定义动画的搜索Toolbar; JUnit 5中用Lambda表达式; 用Mockito和Espresso写测试;&lt;br&gt;native的mobile开发应该扩展一下自己的知识; Kotlin中的依赖注入实现; Kotlin中lambda表达式的简化; 一个Intellij IDEA的插件, 帮助你改善Java代码的可读性.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Toolbar" scheme="http://mengdd.github.io/tags/Toolbar/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Espresso" scheme="http://mengdd.github.io/tags/Espresso/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Lambda" scheme="http://mengdd.github.io/tags/Lambda/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="Topography" scheme="http://mengdd.github.io/tags/Topography/"/>
    
      <category term="Dependency Injection" scheme="http://mengdd.github.io/tags/Dependency-Injection/"/>
    
      <category term="Plugin" scheme="http://mengdd.github.io/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 250</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/31/android-weekly-notes-issue-250/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/31/android-weekly-notes-issue-250/</id>
    <published>2017-03-31T08:50:01.000Z</published>
    <updated>2017-03-31T09:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-250"><a href="#Android-Weekly-Issue-250" class="headerlink" title="Android Weekly Issue #250"></a>Android Weekly Issue #250</h1><p>March 26th, 2017<br><a href="http://androidweekly.net/issues/issue-250" target="_blank" rel="external">Android Weekly Issue #250</a>.<br>本期内容: 好几篇关于Android O预览版的文章; JUnit 5的动态测试; 作为团队里唯一的Android开发如何学习和工作; Support库新推出的基于物理的动画API: SpringAnimation; Uber Rider项目重构中关于依赖注入的scope层级的改动; Kotlin和RxJava的简洁性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="O-h-yeah-What-we-look-forward-to-in-Android-O"><a href="#O-h-yeah-What-we-look-forward-to-in-Android-O" class="headerlink" title="O-h yeah! What we look forward to in Android O"></a><a href="https://www.novoda.com/blog/o-h-yeah-what-we-look-forward-to-in-android-o/" target="_blank" rel="external">O-h yeah! What we look forward to in Android O</a></h2><p>Google宣布了最新Android O的预览程序. Novoda team查看了最新文档来看看什么新特性最让大家欣喜.</p>
<ul>
<li>更宽广的色域和多种颜色空间支持:<br>我们不再被限制在sRGB的颜色空间里, 文档见<a href="https://developer.android.com/reference/android/graphics/ColorSpace.html" target="_blank" rel="external">ColorSpace</a>.</li>
<li>字体支持.</li>
<li>Adaptive icons: Android N中提供了圆形的启动图标; 从Android O开始, 手机开发商和launcher开发者们可以指定一个mask到应用提供的背景图上.</li>
<li>ACCESSIBILITY按钮: Accessibility services(比如TalkBack)可以在有软导航键的设备上添加一个按钮.</li>
<li>指纹手势.</li>
<li>自动大小的TextView.</li>
<li>Autofill APIs. 自动填表.</li>
</ul>
<h2 id="JUnit-5-Dynamic-Tests"><a href="#JUnit-5-Dynamic-Tests" class="headerlink" title="JUnit 5: Dynamic Tests"></a><a href="https://blog.stylingandroid.com/junit-5-dynamic-tests/" target="_blank" rel="external">JUnit 5: Dynamic Tests</a></h2><p>本篇讲如何简化一个测试cases都很类似的test suite.</p>
<p>首先, 找出不同的部分, 抽取一个方法, 把不相同的部分作为参数传进去.</p>
<p>然后用JUnit 5的动态测试(Dynamic Tests)特性.<br>两个关键组件: <code>TextFactory</code>和<code>DynamicTest</code>.<br>文中代码详细说明了它们的用法.</p>
<h2 id="Flying-Solo-with-Android-Development"><a href="#Flying-Solo-with-Android-Development" class="headerlink" title="Flying Solo with Android Development"></a><a href="https://hackernoon.com/flying-solo-with-android-development-c52d911b62bf?gi=c13f45395440#.bdab0pxgy" target="_blank" rel="external">Flying Solo with Android Development</a></h2><p>作者几经周转, 从4人Android团队到2人团队, 现在又到了一个新团队, 作为团队里唯一Android开发. 在这篇文章中, 她分享了一些觉得不错的学习资源和她平时的工作习惯以及建议.</p>
<h2 id="Introduction-to-SpringAnimation-with-examples"><a href="#Introduction-to-SpringAnimation-with-examples" class="headerlink" title="Introduction to SpringAnimation with examples"></a><a href="https://www.thedroidsonroids.com/blog/android/springanimation-examples/" target="_blank" rel="external">Introduction to SpringAnimation with examples</a></h2><p>本文讲弹簧效果动画的实现.</p>
<p><a href="https://developer.android.com/reference/android/support/animation/package-summary.html" target="_blank" rel="external">Dynamic-animation</a>是Android Support Library 25.3.0最新引进的, 用于实现基于物理的动画.</p>
<p>作者这篇文章介绍了<a href="https://developer.android.com/reference/android/support/animation/SpringAnimation.html" target="_blank" rel="external">SpringAnimation</a>和<a href="https://developer.android.com/reference/android/support/animation/SpringForce.html" target="_blank" rel="external">SpringForce</a>的用法, 提供了几个例子, 动态改变View的位置, 旋转和大小属性: <a href="https://github.com/AlexKrupa/android-springanimation-examples" target="_blank" rel="external">android-springanimation-examples
</a>.</p>
<h2 id="Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies"><a href="#Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies" class="headerlink" title="Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies"></a><a href="https://eng.uber.com/deep-scope-hierarchies/" target="_blank" rel="external">Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies</a></h2><p>Android Uber rider app的重构.<br>主要讨论了由于存在很多共用组件, 所以依赖注入的设计需要改进.</p>
<p>首先介绍了旧的设计: 两级Scope层次.<br>后来他们的新设计采用了深层次的scope层级, 减少了耦合.</p>
<p>最后又介绍了几种他们曾经考虑过的架构模式.</p>
<h2 id="It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers"><a href="#It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers" class="headerlink" title="It’s time to kiss goodbye to your implicit BroadcastReceivers"></a><a href="https://medium.com/@iiro.krankka/its-time-to-kiss-goodbye-to-your-implicit-broadcastreceivers-eefafd9f4f8a#.67j4153n6" target="_blank" rel="external">It’s time to kiss goodbye to your implicit BroadcastReceivers</a></h2><p>Android O的preview已经出来了: <a href="https://developer.android.com/preview/index.html" target="_blank" rel="external">Android O Preview</a>. 这是它列出来的<a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="external">Behavior changes</a>.</p>
<p>如果你想要把app target到Android O, 而且你的manifest中注册了一些隐式的BroadcastReceiver. 那么这篇文章就是为你准备的.</p>
<p>Android做这一切的出发点都是为了节约电量.</p>
<p>Android 7.0的时候就<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html#bg-opt" target="_blank" rel="external">移除了三种隐式广播的支持</a>. 它们是<code>CONNECTIVITY_ACTION</code>,  <code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>.</p>
<p>现在Android O中, 除了<a href="https://developer.android.com/preview/features/background-broadcasts.html" target="_blank" rel="external">background-broadcasts</a>中提到的, 其他所有在manifest中注册的隐式广播都不再工作了. (注意这里的关键字: manifest中注册, 隐式广播.)</p>
<p>那么你的manifest中如果有receiver, 现在应该怎么办呢?</p>
<p>首先看看你的广播是否是隐式的. 根据<a href="https://developer.android.com/preview/features/background.html#broadcasts" target="_blank" rel="external">文档</a>, 所有跟你的应用没有直接关系的广播都是隐式的; 而直接相关的都是显式的.</p>
<p>然后检查你的应用是否真的受到了影响, 因为有一些隐式的广播是例外情况.</p>
<p>真的受到影响了怎么办呢? 使用<code>JobScheduler</code>来拯救. 但是它只在API 21以上有, 如果你的最低API小于21, 可以用官方推荐的<a href="https://github.com/firebase/firebase-jobdispatcher-android" target="_blank" rel="external">firebase-jobdispatcher-android</a>. 作者他们团队用的是Evernote的<a href="https://github.com/evernote/android-job" target="_blank" rel="external">android-job</a>.</p>
<p>如果上面的库仍然不能帮到你, 你可以考虑把广播换成动态注册的.<br>不管你的广播是隐式的还是显式的, <code>Context.registerReceiver()</code>是永远有效的. 但缺陷就是注销以后就不能再收到事件了.</p>
<h2 id="Random-Musings-on-the-O-Developer-Preview-1"><a href="#Random-Musings-on-the-O-Developer-Preview-1" class="headerlink" title="Random Musings on the O Developer Preview 1"></a><a href="https://commonsware.com/blog/2017/03/22/random-musings-o-developer-preview-1.html" target="_blank" rel="external">Random Musings on the O Developer Preview 1</a></h2><p>作者对Android O预览的一些看法.</p>
<h3 id="比较令人担心的几点"><a href="#比较令人担心的几点" class="headerlink" title="比较令人担心的几点"></a>比较令人担心的几点</h3><ul>
<li>后台工作的处理: 许多隐式的广播可能不再起作用, 可能会改变某些应用的行为.</li>
<li>多显示支持. 允许用户把一个activity投射到外部显示器上. 这个行为还需要进一步测试, 如果我们投射到一个不可触摸的显示器上会怎样?</li>
<li>关于磁盘空间, 缓存目录.</li>
<li>Support Libraries支持的最小API为14.</li>
</ul>
<h3 id="有启发性的几点"><a href="#有启发性的几点" class="headerlink" title="有启发性的几点"></a>有启发性的几点</h3><ul>
<li>可以给Notification设置timeout.</li>
<li>Picture-in-Picture (PIP)模式. 一种特殊的多窗口模式, 多数被用来播放视频, TV已经有了.</li>
<li>新字体.</li>
<li>Storage Access Framework (SAF) -&gt; Seekable streams.</li>
<li>WebView将支持allow-cleartext设置.</li>
<li>应用安装其他应用需要用户授权.</li>
<li>Content provider分页查询.</li>
<li><code>FragmentLifecycleCallbacks</code>.</li>
<li><code>SmsManager</code>可以创建tokens.</li>
<li><code>SharedPreferences</code>提供了接口, 可以更换底层存储实现.</li>
<li><code>findViewById()</code>不再需要强转.</li>
</ul>
<h3 id="其他你可能感兴趣的"><a href="#其他你可能感兴趣的" class="headerlink" title="其他你可能感兴趣的"></a>其他你可能感兴趣的</h3><ul>
<li><code>View.setTooltipText()</code>.</li>
<li><code>TextView.setJustify()</code>.</li>
<li>提供了padding和margin的Vertical和Horizontal属性, 这样一下就可以设置同一方向上的两个值.</li>
<li><code>ProgressBar.setMin()</code>.</li>
<li><code>ANDROID_ID</code>现在是对每个应用来说, 而不是用户或设备. 见<a href="https://developer.android.com/preview/behavior-changes.html#privacy-all" target="_blank" rel="external">Privacy</a>.</li>
</ul>
<h2 id="Writing-Concise-Code-with-Kotlin-and-RxJava"><a href="#Writing-Concise-Code-with-Kotlin-and-RxJava" class="headerlink" title="Writing Concise Code with Kotlin and RxJava"></a><a href="https://pspdfkit.com/blog/2017/writing-concise-code-with-kotlin-and-rxjava/" target="_blank" rel="external">Writing Concise Code with Kotlin and RxJava</a></h2><p>用Github API举例子, 用RxJava和Kotlin实现一个功能, 说明了它们的简洁性.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Fakeit"><a href="#Fakeit" class="headerlink" title="Fakeit"></a><a href="https://github.com/moove-it/fakeit" target="_blank" rel="external">Fakeit</a></h2><p>Kotlin版的假数据生成器.</p>
<h2 id="Cicerone"><a href="#Cicerone" class="headerlink" title="Cicerone"></a><a href="https://github.com/terrakok/Cicerone" target="_blank" rel="external">Cicerone</a></h2><p>一个轻量级的Android导航库.</p>
<h2 id="data-binding-validator"><a href="#data-binding-validator" class="headerlink" title="data-binding-validator"></a><a href="https://github.com/Ilhasoft/data-binding-validator" target="_blank" rel="external">data-binding-validator</a></h2><p>表单数据验证器, 使用data binding framework实现.</p>
<h2 id="LabCoat"><a href="#LabCoat" class="headerlink" title="LabCoat"></a><a href="https://github.com/Commit451/LabCoat" target="_blank" rel="external">LabCoat</a></h2><p>GitLab client for Android.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="O-MG-the-Developer-Preview-of-Android-O-is-here"><a href="#O-MG-the-Developer-Preview-of-Android-O-is-here" class="headerlink" title="O-MG, the Developer Preview of Android O is here!"></a><a href="https://android-developers.googleblog.com/2017/03/first-preview-of-android-o.html" target="_blank" rel="external">O-MG, the Developer Preview of Android O is here!</a></h2><p>Google发布了下一个系统版本Android O的开发者预览版.</p>
<h1 id="TOOLS"><a href="#TOOLS" class="headerlink" title="TOOLS"></a>TOOLS</h1><h2 id="Android-Studio-meets-Slack"><a href="#Android-Studio-meets-Slack" class="headerlink" title="Android Studio meets Slack"></a><a href="https://instapk.com/" target="_blank" rel="external">Android Studio meets Slack</a></h2><p>一个小工具, 可以直接把Android Studio打的包发到Slack去.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-250&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-250&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #250&quot;&gt;&lt;/a&gt;Android Weekly Issue #250&lt;/h1&gt;&lt;p&gt;March 26th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-250&quot;&gt;Android Weekly Issue #250&lt;/a&gt;.&lt;br&gt;本期内容: 好几篇关于Android O预览版的文章; JUnit 5的动态测试; 作为团队里唯一的Android开发如何学习和工作; Support库新推出的基于物理的动画API: SpringAnimation; Uber Rider项目重构中关于依赖注入的scope层级的改动; Kotlin和RxJava的简洁性.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Dagger" scheme="http://mengdd.github.io/tags/Dagger/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Android O" scheme="http://mengdd.github.io/tags/Android-O/"/>
    
      <category term="SpringAnimation" scheme="http://mengdd.github.io/tags/SpringAnimation/"/>
    
      <category term="Injection" scheme="http://mengdd.github.io/tags/Injection/"/>
    
      <category term="BroadcastReceiver" scheme="http://mengdd.github.io/tags/BroadcastReceiver/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 249</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/24/android-weekly-notes-issue-249/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/24/android-weekly-notes-issue-249/</id>
    <published>2017-03-24T09:13:37.000Z</published>
    <updated>2017-03-24T09:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-249"><a href="#Android-Weekly-Issue-249" class="headerlink" title="Android Weekly Issue #249"></a>Android Weekly Issue #249</h1><p>March 19th, 2017<br><a href="http://androidweekly.net/issues/issue-249" target="_blank" rel="external">Android Weekly Issue #249</a></p>
<p>本期内容包括: 一个设计的实现Demo讨论; Kotlin的Coroutines可能还是没有RxJava好用; 在构建SDK/Libraries时需要注意的事项; 如何用OpenGL和JBox2D实现一个好看的多气泡选择器效果;<br>网络请求中Etag, If-Modified-Since的工作原理和用OkHttp的客户端实现; 用ClassyShark导出类型分析; 指纹认证实现代码; MVI模式对调试带来的好处; 用TensorFlow做一个图像识别处理器.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="From-design-to-Android"><a href="#From-design-to-Android" class="headerlink" title="From design to Android"></a><a href="http://saulmm.github.io/from-design-to-android-part1" target="_blank" rel="external">From design to Android</a></h2><p>作者想建立一个项目, 把从<a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a>和<a href="https://material.uplabs.com/" target="_blank" rel="external">MaterialUp</a>上看到的一些设计实现出来, 再讲解一些实现细节和UI/UX的tips等.</p>
<p>本文是此系列文章的第一篇, 选择的设计是<a href="https://material.uplabs.com/posts/preferred-date-and-time" target="_blank" rel="external">preferred-date-and-time</a>, 实现的demo在这里:<a href="https://github.com/saulmm/from_design_to_android_part1" target="_blank" rel="external">from_design_to_android_part1</a>.</p>
<p>实现中涉及到的点: Bottom Sheets; <code>ConstraintLayout</code>和其中的链式约束<a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html#Chains" target="_blank" rel="external">Chains</a>; <a href="https://developer.android.com/reference/android/widget/ViewSwitcher.html" target="_blank" rel="external">ViewSwitcher</a>; Databinding; Scene和Transition.</p>
<h2 id="Why-Im-Skeptical-about-Kotlin-Coroutines"><a href="#Why-Im-Skeptical-about-Kotlin-Coroutines" class="headerlink" title="Why Im Skeptical about Kotlin Coroutines"></a><a href="https://www.philosophicalhacker.com/post/why-im-skeptical-about-kotlin-coroutines-for-android-development/" target="_blank" rel="external">Why Im Skeptical about Kotlin Coroutines</a></h2><p>Kotlin为了处理异步发布了Coroutines特性, 本文作者对Coroutines持怀疑态度, 认为RxJava的方式更好.</p>
<p>首先, Observables为我们要处理的问题建立了很好的模型, 但coroutines并没有起到这样的作用. (coroutines只是把异步的操作写成了看起来顺序的样子, 同时不阻塞主线程.)</p>
<p>其次, Observables让我们在同步和异步数据上都可以进行同等的抽象, 而coroutines的同步处理和异步处理明显不同.</p>
<p>最后, Observables让我们在更高的抽象层中工作, 比如对元素进行遍历处理的<code>.map()</code>.</p>
<p>当然, 本文并不是说Coroutines一无是处, 它肯定是有自己的用处的, 但是作者只是持怀疑态度, 觉得它的地位远不及RxJava.</p>
<h2 id="Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries"><a href="#Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries" class="headerlink" title="Things I wish I knew when I started building Android SDK/Libraries"></a><a href="https://android.jlelse.eu/things-i-wish-i-knew-when-i-started-building-android-sdk-libraries-dba1a524d619#.tc5qkaglp" target="_blank" rel="external">Things I wish I knew when I started building Android SDK/Libraries</a></h2><p>当你遇到一个问题并且解决了, 有时候你会把解决方案作为一个库发布出去.</p>
<p>作者发布了一些库<a href="https://github.com/nisrulz/android-tips-tricks#extra--android-libraries-built-by-me" target="_blank" rel="external">Android Libraries</a>, 他提出了一些基本的问题和几个应该注意的点.</p>
<h3 id="为什么要创建这个库呢"><a href="#为什么要创建这个库呢" class="headerlink" title="为什么要创建这个库呢?"></a>为什么要创建这个库呢?</h3><p>如果已经有现成的解决方案, 尝试使用已有的方案, 或者给已有的库提Pull Request. 如果没有解决方案, 好吧, 那创建自己的库吧.</p>
<h3 id="你的artifacts可选的类型是什么"><a href="#你的artifacts可选的类型是什么" class="headerlink" title="你的artifacts可选的类型是什么?"></a>你的artifacts可选的类型是什么?</h3><ul>
<li>Library Project: 直接项目引用.</li>
<li>JAR: 包含了Java class文件和metadata.</li>
<li>AAR: 除了Java class文件, 还包含了Android的资源和manifest.</li>
</ul>
<h3 id="你的库放在哪里"><a href="#你的库放在哪里" class="headerlink" title="你的库放在哪里?"></a>你的库放在哪里?</h3><ul>
<li>本地.</li>
<li>私有的代码库.</li>
<li>公有的代码库: Maven Central, Jcenter or JitPack.</li>
</ul>
<p>(每一种方式都有教程链接).</p>
<p>上面三个基本问题说完了, 在建立这个库的时候还有一些注意事项:</p>
<h3 id="避免多个参数"><a href="#避免多个参数" class="headerlink" title="避免多个参数"></a>避免多个参数</h3><p>参数最好不要多于三个, 可以用setter或者Builder模式来解决.</p>
<h3 id="容易使用"><a href="#容易使用" class="headerlink" title="容易使用"></a>容易使用</h3><ul>
<li>直观: 任何发生在库里的行为, 最好有一些反馈, 比如打印出logs或者显示在UI上.</li>
<li>一致性: 遵从<a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a>.</li>
<li>容易使用, 不容易滥用. 最好一眼能看出它的用途. public的方法应该有足够的验证, 确保用户不会滥用. 当不存在依赖关系时, 提供默认值并处理场景.</li>
</ul>
<h3 id="最小化权限"><a href="#最小化权限" class="headerlink" title="最小化权限"></a>最小化权限</h3><p>尽量少地要求权限, 可以发送Intent让更专业的应用帮你做一些处理然后返回结果. 根据权限的获取情况来使能你的feature, 不要仅因为没有权限就crash.</p>
<p>你也可以提供一些不需要权限的fallback的实现, 让库的使用者去获取权限.</p>
<h3 id="最小化要求"><a href="#最小化要求" class="headerlink" title="最小化要求"></a>最小化要求</h3><p>有时候我们需要设备具有某项功能, 比如蓝牙.<br>这时候就需要在manifest中写<code>uses-feature</code>.</p>
<p>如果我们在库中这样写, 它会被merge进应用的manifest, 在Play Store上, 整个应用对无蓝牙的设备都变为不显示. 这样只是引入了一个库, 却失去了一部分用户, 这肯定不是我们所希望看到的.</p>
<p>解决方案就是: 不要写在manifest里, 换为在代码中动态检查. 对于不支持的情况, 库可以关掉这个功能, 提供fallback的实现.</p>
<h3 id="支持不同的版本"><a href="#支持不同的版本" class="headerlink" title="支持不同的版本"></a>支持不同的版本</h3><p>如果你有一个特定版本才支持的功能, 应该做版本检查, 然后对于更低的版本关掉它.</p>
<h3 id="Production版本不要打log"><a href="#Production版本不要打log" class="headerlink" title="Production版本不要打log"></a>Production版本不要打log</h3><h3 id="不要悄悄crash-另外fail-fast"><a href="#不要悄悄crash-另外fail-fast" class="headerlink" title="不要悄悄crash, 另外fail fast"></a>不要悄悄crash, 另外fail fast</h3><p>遇到崩溃时应该总是输出错误信息.<br>如果你不想在production输出任何log, 你至少应该提供flag, 让初始化的时候可以使能它.</p>
<p>如果你的库遇到异常, 应该立即失败, 想开发者输出Exception, 而不是卡在那里. 要避免写出会阻塞主线程的代码.</p>
<h3 id="优雅地处理错误"><a href="#优雅地处理错误" class="headerlink" title="优雅地处理错误"></a>优雅地处理错误</h3><p>当你的库出错的时候, 尽量做检查, 使得代码不会让整个应用崩溃, 而是只有你的库提供的功能被关闭了.</p>
<h3 id="捕获特定的exceptions"><a href="#捕获特定的exceptions" class="headerlink" title="捕获特定的exceptions"></a>捕获特定的exceptions</h3><h3 id="处理不良的网络连接"><a href="#处理不良的网络连接" class="headerlink" title="处理不良的网络连接"></a>处理不良的网络连接</h3><p>如果你的库中有网络请求, 请处理网络连接不良的情况.</p>
<p>如果有可能, 批处理你的网络请求, 这会节约很多电量. 看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html" target="_blank" rel="external">这里</a>.</p>
<p>使用<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>而不是json或xml, 来减小网络请求的数据量.</p>
<p>更多的网络优化看这里: <a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>.</p>
<h3 id="尽量不要依赖很大的库"><a href="#尽量不要依赖很大的库" class="headerlink" title="尽量不要依赖很大的库"></a>尽量不要依赖很大的库</h3><p>主要是因为方法数的限制.</p>
<h3 id="不要依赖你不需要的库"><a href="#不要依赖你不需要的库" class="headerlink" title="不要依赖你不需要的库"></a>不要依赖你不需要的库</h3><p>除了不依赖没有用到的库, 还可以把添加依赖的选择权留给你的用户.</p>
<p>让用户来选择性地添加你依赖的库, 如果他选择不添加, 你的相关feature可以关闭.</p>
<p>可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOKHttpOnClasspath</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class.forName(<span class="string">"com.squareup.okhttp3.OkHttpClient"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">       ex.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而你添加的时候可以这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   // for gradle version 2.12 and below</div><div class="line">   provided &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">   // or for gradle version 2.12+</div><div class="line">   compileOnly &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种只能用于纯Java的依赖, 如果是aar就不行.</p>
<h3 id="不要拖慢启动时间"><a href="#不要拖慢启动时间" class="headerlink" title="不要拖慢启动时间"></a>不要拖慢启动时间</h3><p>在应用启动初始化你的库时, 不要花太多时间.</p>
<p>两种解决方案: 一种是新启一个线程来做初始化; 另一种是到使用之前才进行初始化.</p>
<h3 id="删除功能的时候要优雅"><a href="#删除功能的时候要优雅" class="headerlink" title="删除功能的时候要优雅"></a>删除功能的时候要优雅</h3><p>升级版本的时候, 不要删除public的方法.<br>可以把方法标记为<code>@Deprecated</code>, 然后在未来的版本中慢慢删除它.</p>
<h3 id="让你的代码可测试"><a href="#让你的代码可测试" class="headerlink" title="让你的代码可测试"></a>让你的代码可测试</h3><p>使用mock来测试你的代码, 在代码中国避免final的类和static的方法.</p>
<p>写代码的时候public的API用接口, 这样更容易更换实现, 更好测试.</p>
<h3 id="文档记录所有的事"><a href="#文档记录所有的事" class="headerlink" title="文档记录所有的事"></a>文档记录所有的事</h3><p>包括如何使用你的库, 库中每一个feature都是什么.</p>
<ul>
<li>Repo根目录有一个Readme.</li>
<li>所有的public方法应该有javadoc注释. 说明目的, 参数, 返回值.</li>
<li>有一个sample app, 展示如何使用你的库.</li>
<li>在你的release界面, 确保有一个详尽的change log.</li>
</ul>
<h3 id="提供一个最简单的sample"><a href="#提供一个最简单的sample" class="headerlink" title="提供一个最简单的sample"></a>提供一个最简单的sample</h3><p>越简单越容易让人明白.</p>
<h3 id="考虑加一个Licence"><a href="#考虑加一个Licence" class="headerlink" title="考虑加一个Licence"></a>考虑加一个Licence</h3><h3 id="收集反馈"><a href="#收集反馈" class="headerlink" title="收集反馈"></a>收集反馈</h3><h2 id="How-to-Create-a-Bubble-Selection-Animation-on-Android"><a href="#How-to-Create-a-Bubble-Selection-Animation-on-Android" class="headerlink" title="How to Create a Bubble Selection Animation on Android"></a><a href="https://medium.com/@igalata13/how-to-create-a-bubble-selection-animation-on-android-627044da4854#.1ncs9qy84" target="_blank" rel="external">How to Create a Bubble Selection Animation on Android</a></h2><p>作者他们想要在Android上实现Apple music中的选择气泡效果.</p>
<p>这种动画效果用于让用户在一系列的选择项中做出选择, 气泡自由浮动, 一旦被选中就会变大一点.</p>
<p>作者选择的是用Kotlin, OpenGL和JBox2D(物理引擎).</p>
<p>详细介绍的内容包括: 如何用GLSL写vertex shader和fragment shader; 如何贴图; 用JBox2D来实现气泡的动画(需要自己实现重力); 检测用户手势移动气泡; 发现用户点击的气泡.</p>
<p>项目在Github: <a href="https://github.com/igalata/Bubble-Picker" target="_blank" rel="external">Bubble-Picker</a>.</p>
<h2 id="Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since"><a href="#Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since" class="headerlink" title="Reducing networking footprint with OkHttp, Etags and If-Modified-Since"></a><a href="https://android.jlelse.eu/reducing-your-networking-footprint-with-okhttp-etags-and-if-modified-since-b598b8dd81a1#.260pws449" target="_blank" rel="external">Reducing networking footprint with OkHttp, Etags and If-Modified-Since</a></h2><h3 id="If-Modified-Since和Last-Modified"><a href="#If-Modified-Since和Last-Modified" class="headerlink" title="If-Modified-Since和Last-Modified"></a>If-Modified-Since和Last-Modified</h3><p>Header中使用了If-Modified-Since和Last-Modified, 如果两次请求之间内容并未改变, 第二次, server就会返回<code>304 NOT MODIFIED</code>, 并且响应不含body.</p>
<p><img src="/images/if-modified-since-and-last-modified.png" alt="if-modified-since and last-modified"></p>
<h3 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h3><p>Etag工作的原理类似, 它实现起来不容易出错, 但是需要server跑一个完整的查询, 并且每次都创建一个hash.</p>
<p><img src="/images/Etag-and-If-None-Match.png" alt="Etag and if-none-match"></p>
<p>server将会在返回response之前根据响应内容创建一个hash, 然后把它作为Etag header; 客户端在做下一次请求时, 把这个Etag作为If-None-Match header发给server. 客户端在准备下一个响应的时候, 比较新的hash和请求中发来的是否相同, 如果相同, 则返回无内容的<code>304 NOT MODIFIED</code>.</p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>如果你使用了Retrofit2, 或OkHttp3, 在客户端使能Last-Modified或Etags是很容易的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_SIZE_BYTES = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>;</div><div class="line">...</div><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient().newBuilder();</div><div class="line">builder.cache(<span class="keyword">new</span> Cache(context.getCacheDir(), CACHE_SIZE_BYTES));</div><div class="line">...</div></pre></td></tr></table></figure>
<p>根据server的响应, Last-Modified或Etags将会自动启用.</p>
<p>如果你还想减少处理的时间:</p>
<p><strong>减少处理</strong>:<br>在304状态下, Retrofit2和OkHttp3将会假装这个响应和上一次的相同, 所以被缓存的响应会被返回, 你可以检测响应返回值, 如果是304就不做处理.<br>但是有时候你可能需要每次都重新parse, 这就不用检查<code>HTTP_NOT_MODIFIED</code>了, 看你的需要.</p>
<p>注意在Retrofit2中要用raw()中的response来检查, 因为<code>response.networkResponse().code()</code>返回的是被缓存了的状态值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (response.isSuccessful() &amp;&amp;</div><div class="line">    response.raw().networkResponse() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">    response.raw().networkResponse().code() ==</div><div class="line">           HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</div><div class="line">    <span class="comment">// not modified, no need to do anything.</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// parse response here</span></div></pre></td></tr></table></figure>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>如果你的Etag或Last-Modified不工作.</p>
<p><strong>检查你的Headers.</strong></p>
<p>可以用<a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho</a>或<a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="external">OkHttp logging interceptor</a>来检查你的headers.</p>
<p>正确的输出是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cache-Control: private, must-revalidate</div></pre></td></tr></table></figure></p>
<p>所有请求和响应的Last-Modified和Etag headers都会被显示出来.</p>
<p><strong>同时使用Etags和Last-Modified.</strong></p>
<p>OkHttp3会按照严格的顺序检查cache headers:</p>
<ul>
<li>1.如果上一个响应包含Etag, 那么同样的Etag值将会被加在下一个请求的If-Not-Match中.</li>
<li>2.如果第一点不满足, 但上一个响应包含Last-Modified, 那么这个值将会被记载下一个请求的If-Modified-Since中.</li>
</ul>
<p>所以如果同时使用了两种, Etag会屏蔽Last-Modified.</p>
<h2 id="Exporting-types-from-Android-app-using-ClassyShark"><a href="#Exporting-types-from-Android-app-using-ClassyShark" class="headerlink" title="Exporting types from Android app using ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-types-from-android-app-using-classyshark-7cd2be18cdf7#.5q7p9qoya" target="_blank" rel="external">Exporting types from Android app using ClassyShark</a></h2><p>如何导出<code>ClassyShark</code>的类型分析.</p>
<h2 id="Fingerprint-authentication"><a href="#Fingerprint-authentication" class="headerlink" title="Fingerprint authentication"></a><a href="http://josiassena.com/android-fingerprint-authentication/" target="_blank" rel="external">Fingerprint authentication</a></h2><p>一个指纹认证的代码例子.</p>
<h2 id="Reactive-Apps-with-MVI-Part-5"><a href="#Reactive-Apps-with-MVI-Part-5" class="headerlink" title="Reactive Apps with MVI - Part 5"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-5" target="_blank" rel="external">Reactive Apps with MVI - Part 5</a></h2><p>MVI模式系列文章第五篇.</p>
<p>之前在第一篇讲过单向数据流的重要性, 应用状态应该由业务逻辑驱动. 本篇我们将看到这样做带来的好处: 调试程序变得简单了.</p>
<p>我们经常会遇到无法复现的bug, 这往往是因为你只知道崩溃栈, 却不知道用户在出现这个bug之前的实际状态.</p>
<p>当我们用MVI的时候, 我们可以把每次用户激发的intent和model(也即状态)都打出log(用Crashlytics或者其他工具).<br>这样做以后, 我们从收集到的log中不仅能看到崩溃前最近的状态, 还能看到用户的整个操作历史.</p>
<p>而且用户的应用状态截图都被当做json发送过来, 我们可以拿到任何状态当做我们的初始状态.</p>
<p>这样做以后, 不仅复现崩溃更加容易, 我们还可以利用这些序列化的状态来写一些回归测试.</p>
<p>这样做也是有缺点的: 状态的序列化需要额外花费一些毫秒; 崩溃时传递的数据量增大了; 对用户的敏感信息, 要么忽略, 会导致信息不完整; 要么加密, 那就会需要更多的处理时间.</p>
<h2 id="Add-some-machine-learning-to-your-apps-with-TensorFlow"><a href="#Add-some-machine-learning-to-your-apps-with-TensorFlow" class="headerlink" title="Add some machine learning to your apps, with TensorFlow"></a><a href="http://nilhcem.com/android/custom-tensorflow-classifier" target="_blank" rel="external">Add some machine learning to your apps, with TensorFlow</a></h2><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a>是一个开源的机器学习的库, 由Google开发.</p>
<p>一个简单快速的开始方法就是用TensorFlow来建立一个图像分类器. 相对于使用<a href="https://cloud.google.com/vision/" target="_blank" rel="external">Google’s Cloud Vision API</a>来说, 我们可以做一个离线和简化版本, 在Android设备上检测和识别图像中物体.</p>
<p>本篇文章中, 我们会创建一个app, 来识别游戏中的角色.</p>
<p>官方有一个<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="external">Demo</a>, 如果你要跑它, 你需要安装NDK和Bazel.</p>
<p>作者创建了这个<a href="https://github.com/Nilhcem/tensorflow-classifier-android" target="_blank" rel="external">Repo</a>, 可以直接clone下来build, 更快.</p>
<p>不管你选择哪种方式, 能够运行之后, 这个sample使用了Inception, 一个提前训练好的可以检测1000个物体的model.</p>
<p>之后作者重新下载了一些图片, 对Inception进行了重新训练, 优化, 最后导入新的model并运行, 文中详细记录了过程.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="AutoplayVideos"><a href="#AutoplayVideos" class="headerlink" title="AutoplayVideos"></a><a href="https://github.com/Krupen/AutoplayVideos" target="_blank" rel="external">AutoplayVideos</a></h2><p>在RecyclerView中显示url对应的Video, 当view出现时自动播放, view不见或部分可见时自动暂停.</p>
<h2 id="PreferenceHolder"><a href="#PreferenceHolder" class="headerlink" title="PreferenceHolder"></a><a href="https://github.com/MarcinMoskala/PreferenceHolder" target="_blank" rel="external">PreferenceHolder</a></h2><p>一个Kotlin的SharedPreferences的包装库.</p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><a href="https://github.com/MarcinMoskala/ActivityStarter" target="_blank" rel="external">ActivityStarter</a></h2><p>提供了一种简化的方式来启动多参数的Activity.<br>用注解简化了从Bundle拿参数的过程, 也有相应的存取状态的方法. 可以用于Activity, Fragment, Service和BroadcastReceiver.</p>
<h2 id="BlockCanaryEx"><a href="#BlockCanaryEx" class="headerlink" title="BlockCanaryEx"></a><a href="https://github.com/lqcandqq13/BlockCanaryEx" target="_blank" rel="external">BlockCanaryEx</a></h2><p>基于<a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">BlockCanary</a>的扩展, 用于检测UI阻塞, 打印出了更多的方法信息, 并显示出最耗时的方法.</p>
<h2 id="EasySP"><a href="#EasySP" class="headerlink" title="EasySP"></a><a href="https://github.com/WhiteDG/EasySP" target="_blank" rel="external">EasySP</a></h2><p>一个简单的SharedPreferences辅助类, 支持流式操作.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-249&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-249&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #249&quot;&gt;&lt;/a&gt;Android Weekly Issue #249&lt;/h1&gt;&lt;p&gt;March 19th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-249&quot;&gt;Android Weekly Issue #249&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本期内容包括: 一个设计的实现Demo讨论; Kotlin的Coroutines可能还是没有RxJava好用; 在构建SDK/Libraries时需要注意的事项; 如何用OpenGL和JBox2D实现一个好看的多气泡选择器效果;&lt;br&gt;网络请求中Etag, If-Modified-Since的工作原理和用OkHttp的客户端实现; 用ClassyShark导出类型分析; 指纹认证实现代码; MVI模式对调试带来的好处; 用TensorFlow做一个图像识别处理器.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Retrofit" scheme="http://mengdd.github.io/tags/Retrofit/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Fingerprint" scheme="http://mengdd.github.io/tags/Fingerprint/"/>
    
      <category term="TensorFlow" scheme="http://mengdd.github.io/tags/TensorFlow/"/>
    
      <category term="OkHttp" scheme="http://mengdd.github.io/tags/OkHttp/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="Network" scheme="http://mengdd.github.io/tags/Network/"/>
    
      <category term="ClassyShark" scheme="http://mengdd.github.io/tags/ClassyShark/"/>
    
      <category term="ViewSwitcher" scheme="http://mengdd.github.io/tags/ViewSwitcher/"/>
    
      <category term="Coroutines" scheme="http://mengdd.github.io/tags/Coroutines/"/>
    
      <category term="SDK" scheme="http://mengdd.github.io/tags/SDK/"/>
    
      <category term="Libraries" scheme="http://mengdd.github.io/tags/Libraries/"/>
    
      <category term="OpenGL" scheme="http://mengdd.github.io/tags/OpenGL/"/>
    
      <category term="JBox2D" scheme="http://mengdd.github.io/tags/JBox2D/"/>
    
      <category term="Etag" scheme="http://mengdd.github.io/tags/Etag/"/>
    
      <category term="If-Modified-Since" scheme="http://mengdd.github.io/tags/If-Modified-Since/"/>
    
      <category term="Machine Learning" scheme="http://mengdd.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 248</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/17/android-weekly-notes-issue-248/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/17/android-weekly-notes-issue-248/</id>
    <published>2017-03-17T02:51:51.000Z</published>
    <updated>2017-03-31T09:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-248"><a href="#Android-Weekly-Issue-248" class="headerlink" title="Android Weekly Issue #248"></a>Android Weekly Issue #248</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-248" target="_blank" rel="external">Android Weekly Issue #248</a>.<br>本期内容包括: 为什么有时候应该让你的应用崩溃(而不是一味保护); Trello离线模式实现中两个id的问题; 如何让Dagger的component按照scope保存, 在屏幕旋转时不重建; 用Dagger构建Realm的数据库迁移逻辑;<br>利用各种mock工具写单元测试; Map上markers的动画实现; JUnit5中@DisplayName的使用; RxJava中的Single和Completable使用; 举例说明如何给FindBugs写自定义的探测器; Android中静态代码分析工具的使用; Trello离线实现中sync失败情况的处理.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Why-your-app-should-crash"><a href="#Why-your-app-should-crash" class="headerlink" title="Why your app should crash"></a><a href="http://jeroenmols.com/blog/2017/03/08/appcrash/" target="_blank" rel="external">Why your app should crash</a></h2><p>作者认为有时候让应用崩溃反而是有好处的.</p>
<p>以NPE为例, 有时候我们会习惯性地加很多null判断, 有的是多余的, 有的防御型的代码反而会掩盖了真实问题所在. 比如当一个不合理的情况发生时, 让用户看到一个不可理解的页面, 比如空白, 然后我们开发者根本不知道这种情况的发生.</p>
<p>与其这样掩盖错误, 不如让应用崩溃, 让开发者立即知道问题的原因.</p>
<p>实用建议:</p>
<ul>
<li>永远让应用对外来输入(比如service的响应, UI的输入, 进来的intents)保持健壮性.</li>
<li>在程序的入口点保证数据的完整性. 这样不合理的数据就不会到处都是, 所以你不用到处检查.</li>
<li>如果你不确定某个错误是否会在某个地方发生, 先假装它不会发生, 在测试阶段再验证.</li>
<li>如果某个方法在产品环境不能被调用, 或者只能被调用一次等, 抛出<code>IllegalStateException</code>.</li>
<li>永远在发布之前进行完整测试, 这样你就会在用户之前, catch住可怕的崩溃.</li>
</ul>
<h2 id="The-Two-ID-Problem"><a href="#The-Two-ID-Problem" class="headerlink" title="The Two ID Problem"></a><a href="http://tech.trello.com/sync-two-id-problem/" target="_blank" rel="external">The Two ID Problem</a></h2><p>还是Trello开发离线模式的系列文章, 本篇讲他们遇到的一个很tricky的问题: id问题.</p>
<p>在他们的项目里, 所有的models都有一个id, 用以和server通信, 以及定义model之间的关系.</p>
<p>如果是在离线模式下, 就不能依靠server来提供这个id, 客户端需要自己生成. </p>
<p>所以离线模式下有两种id, 一种是本地生成的, 一种是用来和server通信的. </p>
<p>他们想过几个办法, 比如在sync的时候将local的id转化为server id; 或者干脆存储一个id的Pair类, 但是都有难以维护或者性能缺陷等种种问题.</p>
<p>最后他们提出了一个叫<code>local-server barrier</code>的解决方案. 基本的原则就是, 在app中, 只使用local的id, 同server通信时, 使用server id. 好处: 首先保证了客户端代码的简洁, 只有网络通信层需要考虑到server id; 重构代码量小.</p>
<h2 id="Retaining-Dagger-components"><a href="#Retaining-Dagger-components" class="headerlink" title="Retaining Dagger components"></a><a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a></h2><p>如果你用dagger创建了component,  scope是Activity或者Fragment, 那么你可能遇到过这个问题: 旋转屏幕之后, 所有的依赖都重建了, 因为你创建了一个新的component.</p>
<p>如果你想要在configuration变化的时候不重建, 你就需要把component存储在一个全局的地方, 但是这样的话, 当你真的结束你的Activity和Fragment的时候, 你如何释放这些component呢?</p>
<p>你需要分层地(hierarchical)存储, <a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a>就是用来做分层存储东西的一个工具. </p>
<p>文中基本思想是把Application的component作为根节点, 然后Activity和Fragment的component作为树形结构的叶子节点逐级存储. Activity和Fragment的节点什么时候移除, 有一些判断条件和时机选择, 详见原文代码.</p>
<h2 id="The-Burden-of-Knowledge"><a href="#The-Burden-of-Knowledge" class="headerlink" title="The Burden of Knowledge"></a><a href="https://medium.com/@trionkidnapper/the-burden-of-knowledge-52cc73508081#.1nyndcoo6" target="_blank" rel="external">The Burden of Knowledge</a></h2><p>鼓励在team里分享知识.</p>
<h2 id="Realm-Migrations-Supercharged-with-Dagger"><a href="#Realm-Migrations-Supercharged-with-Dagger" class="headerlink" title="Realm Migrations Supercharged with Dagger"></a><a href="http://www.adavis.info/2017/03/realm-migrations-supercharged-with.html" target="_blank" rel="external">Realm Migrations Supercharged with Dagger</a></h2><p>使用Dagger2可以大幅度改善Realm中的数据迁移处理. 具体的做法是把每一步的迁移处理都放在一个统一接口的实现类里, 然后注入它们.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MigrationsModule</span> </span>&#123;</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion1Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version1Migration();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">2</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion2Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version2Migration();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以最后的迁移类看起来就是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Reusable</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Migration</span> <span class="keyword">implements</span> <span class="title">RealmMigration</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Migration(Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations) &#123;</div><div class="line">        <span class="keyword">this</span>.versionMigrations = versionMigrations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="keyword">final</span> DynamicRealm realm, <span class="keyword">long</span> oldVersion, <span class="keyword">long</span> newVersion)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) oldVersion; i &lt; newVersion; i++) &#123;</div><div class="line">            <span class="keyword">final</span> Provider&lt;VersionMigration&gt; provider = versionMigrations.get(i);</div><div class="line">            <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</div><div class="line">                VersionMigration versionMigration = provider.get();</div><div class="line">                versionMigration.migrate(realm, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的好处:</p>
<ul>
<li>1.以后再有数据库升级也不需要再改这个类了.</li>
<li>2.不需要逐个check每个版本号, 自动只从需要的版本号开始做迁移.</li>
<li>3.每个迁移模块都变成了可测试的单元.</li>
</ul>
<p>我觉得作者的这种处理结构很好, 不仅仅限于Realm数据库的迁移, 其他的数据库迁移也可以用类似的结构来处理.</p>
<h2 id="How-to-be-a-Mock-Star…"><a href="#How-to-be-a-Mock-Star…" class="headerlink" title="How to be a Mock-Star…"></a><a href="https://medium.com/fueled-android/how-to-be-a-mock-star-fc00714d8c2f#.aff30qzf6" target="_blank" rel="external">How to be a Mock-Star…</a></h2><p>介绍如何用<a href="http://site.mockito.org/" target="_blank" rel="external">mockito</a>来测试一个MVP的程序.</p>
<p>首先测试Presenter的部分, 这里Mock了数据源和各种错误响应.</p>
<p>测试Repository, 需要用到<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">MockWebServer</a>, 来模拟测试环境下的响应.</p>
<h2 id="Animating-Markers-with-MapOverlayLayout"><a href="#Animating-Markers-with-MapOverlayLayout" class="headerlink" title="Animating Markers with MapOverlayLayout"></a><a href="https://www.thedroidsonroids.com/blog/workcation-app-part-2-animating-markers-with-mapoverlaylayout/" target="_blank" rel="external">Animating Markers with MapOverlayLayout</a></h2><p>作者App的动画实现讨论第二发, 如何让地图上的markers带缩放和渐变动画 -&gt; 用<code>MapOverlayLayout</code>.</p>
<p>文中有详细的实现代码, 基本思路就是在这个<code>MapOverlayLayout</code>中保存一个View的列表, 然后在自定义View中实现每个marker在相应动作时的动画.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2" class="headerlink" title="What Unit Tests are Trying to Tell us About Activities Pt 2"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt-2/" target="_blank" rel="external">What Unit Tests are Trying to Tell us About Activities Pt 2</a></h2><p>以Activity/Fragment作为基本构建单元, 让程序难以测试, 本文举例说明了这一点.</p>
<h2 id="JUnit-5-DisplayName"><a href="#JUnit-5-DisplayName" class="headerlink" title="JUnit 5: DisplayName"></a><a href="https://blog.stylingandroid.com/junit-5-displayname/" target="_blank" rel="external">JUnit 5: DisplayName</a></h2><p>JUnit 5提供了<code>@DisplayName</code>, 这样测试报告里case显示的名字将是<code>@DisplayName</code>定义的字符串. </p>
<p>相比原先的方法名来说, 这个字符串是可以带空格的, 所以比之前的可读性增强了.</p>
<h2 id="Clearer-RxJava-intentions-with-Single-and-Completable"><a href="#Clearer-RxJava-intentions-with-Single-and-Completable" class="headerlink" title="Clearer RxJava intentions with Single and Completable"></a><a href="https://medium.com/@ValCanBuild/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8#.kpyh1sal0" target="_blank" rel="external">Clearer RxJava intentions with Single and Completable</a></h2><p>RxJava中我们经常用到的类就是<code>Observable</code>, 然后处理三个事件: <code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>.</p>
<p>但是有些时候我们并不需要关心全部这三个事件, 这时候我们就可以用<code>Single&lt;T&gt;</code>和<code>Completable</code>.</p>
<p><code>Single&lt;T&gt;</code>返回一个值或者一个error.<br>它和<code>Observable</code>之间可以互相转换: 用<code>toObservable()</code>和<code>singleOrError()</code>方法.</p>
<p><code>Completable</code>, 只有<code>onCompleted()</code>和<code>onError()</code>. 它不发射任何值, 可以在它之后用<code>andThen()</code>来添加另一个Observable, 进行后续其他操作.</p>
<p><code>Observable</code>不能直接转换为<code>Completable</code>, 因为不知道<code>Observable</code>到底会不会停止. 可以把<code>Single</code>转换为<code>Completable</code>, 用<code>toCompletable()</code>方法.</p>
<h2 id="Custom-FindBugs-detectors-in-Android"><a href="#Custom-FindBugs-detectors-in-Android" class="headerlink" title="Custom FindBugs detectors in Android"></a><a href="https://rhye.org/post/custom-android-findbugs/" target="_blank" rel="external">Custom FindBugs detectors in Android</a></h2><p>Android中有两种工具可以做进一步的编译期检查: <a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">Android Lint</a>和<a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">FindBugs</a>. </p>
<p>FindBugs是一个静态的分析工具. 本文的主要任务是讲解如何实现一个自定义的检测器来检测一种特定的错误.</p>
<p>作者的例子是<code>try-with-resources</code>模式的代码.<br>这是Java 7新加的模式<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Cursor c = db.query(...)) &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>try语句中声明的资源将会在这个block结束的时候自动close.</p>
<p>但是这个特性最低需要API 19.<br>所以为了兼容旧版本, 我们不得不使用finally来自己close:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.query(...);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    c.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有时候我们会忘记close导致了泄露, 所以需要实现一个自定义的findbugs检测器来检查这种错误. 具体实现步骤和讨论见原文.</p>
<h2 id="Static-Code-Analysis-Tools"><a href="#Static-Code-Analysis-Tools" class="headerlink" title="Static Code Analysis Tools"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-static-code-analysis-tools-b6dd83282921#.e7sc5x1if" target="_blank" rel="external">Static Code Analysis Tools</a></h2><p>Android中流行的静态代码检测工具:</p>
<ul>
<li>Lint</li>
<li>PMD</li>
<li>FindBugs</li>
</ul>
<p>本文介绍它们如何配置和使用.</p>
<h2 id="Sync-Failure-Handling"><a href="#Sync-Failure-Handling" class="headerlink" title="Sync Failure Handling"></a><a href="http://tech.trello.com/sync-failure-handling/" target="_blank" rel="external">Sync Failure Handling</a></h2><p>Trello离线模式文章, sync失败的处理.</p>
<p>在发请求的时候可能会发生各种各样的错误, 分为暂时性的和永久性的两类.<br>对于永久性的错误, 我们可以直接放弃delta; 但是对于暂时性的错误, 我们需要重试. 这里就需要考虑重试的时间和重试的次数.</p>
<p>另外还有一种情况是客户端发了请求, server也收到了, 但是客户端在收响应的时候失败了, 所以客户端可能会找机会重新发请求, 为了保证幂等性, 我们的每一个请求都有一个唯一的id, 如果server发现同样的id, 只处理第一个.</p>
<p>对于多个用户编辑的冲突处理, 当前用的是简单的以后者为准的方式.</p>
<p>撤销本地不合理数据, 以server数据为准, 更新本地数据, 这就需要在sync开始的时候先讲本地改动上传. </p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="LottieFiles"><a href="#LottieFiles" class="headerlink" title="LottieFiles"></a><a href="http://www.lottiefiles.com/" target="_blank" rel="external">LottieFiles</a></h2><p>免费的Lottie动画.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="DiscreteScrollView"><a href="#DiscreteScrollView" class="headerlink" title="DiscreteScrollView"></a><a href="https://github.com/yarolegovich/DiscreteScrollView" target="_blank" rel="external">DiscreteScrollView</a></h2><p>可滚动的列表, 中间的项目放大. (基于RecyclerView, 长得有点像ViewPager.)</p>
<h2 id="SimpleRatingBar"><a href="#SimpleRatingBar" class="headerlink" title="SimpleRatingBar"></a><a href="https://github.com/borjabravo10/SimpleRatingBar" target="_blank" rel="external">SimpleRatingBar</a></h2><p>五星评价View, 用kotlin实现的.</p>
<h2 id="InstaCropper"><a href="#InstaCropper" class="headerlink" title="InstaCropper"></a><a href="https://github.com/yasharpm/InstaCropper" target="_blank" rel="external">InstaCropper</a></h2><p>剪切图像的View, 类似于Instagram的crop.</p>
<h2 id="GuildWars2-APIViewer"><a href="#GuildWars2-APIViewer" class="headerlink" title="GuildWars2_APIViewer"></a><a href="https://github.com/huhx0015/GuildWars2_APIViewer" target="_blank" rel="external">GuildWars2_APIViewer</a></h2><p>一个app, 用来查看Guild Wars 2的API响应.<br>用了Dagger2, Retrofit2, RxJava2, MVVM架构.</p>
<h2 id="here-be-dragons"><a href="#here-be-dragons" class="headerlink" title="here-be-dragons"></a><a href="https://github.com/anupcowkur/here-be-dragons" target="_blank" rel="external">here-be-dragons</a></h2><p>一个Intellij/Android Studio插件, 你可以在一个方法上标记<code>@SideEffect</code>, 之后你调用这个方法的代码行左边会显示出一个龙的图标.</p>
<h2 id="RoboGif"><a href="#RoboGif" class="headerlink" title="RoboGif"></a><a href="https://github.com/izacus/RoboGif" target="_blank" rel="external">RoboGif</a></h2><p>一个python的小工具, 可以把Android设备上的录屏生成一个GIF图.</p>
<h2 id="service-tree"><a href="#service-tree" class="headerlink" title="service-tree"></a><a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a></h2><p>一个存储service的树形结构. (本期文章<a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a>有讲.)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-248&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-248&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #248&quot;&gt;&lt;/a&gt;Android Weekly Issue #248&lt;/h1&gt;&lt;p&gt;March 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-248&quot;&gt;Android Weekly Issue #248&lt;/a&gt;.&lt;br&gt;本期内容包括: 为什么有时候应该让你的应用崩溃(而不是一味保护); Trello离线模式实现中两个id的问题; 如何让Dagger的component按照scope保存, 在屏幕旋转时不重建; 用Dagger构建Realm的数据库迁移逻辑;&lt;br&gt;利用各种mock工具写单元测试; Map上markers的动画实现; JUnit5中@DisplayName的使用; RxJava中的Single和Completable使用; 举例说明如何给FindBugs写自定义的探测器; Android中静态代码分析工具的使用; Trello离线实现中sync失败情况的处理.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Dagger" scheme="http://mengdd.github.io/tags/Dagger/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/tags/Realm/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
      <category term="Crash" scheme="http://mengdd.github.io/tags/Crash/"/>
    
      <category term="MockWebServer" scheme="http://mengdd.github.io/tags/MockWebServer/"/>
    
      <category term="Google Map" scheme="http://mengdd.github.io/tags/Google-Map/"/>
    
      <category term="FindBugs" scheme="http://mengdd.github.io/tags/FindBugs/"/>
    
      <category term="Lint" scheme="http://mengdd.github.io/tags/Lint/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 247</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/</id>
    <published>2017-03-08T06:49:43.000Z</published>
    <updated>2017-03-08T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-247"><a href="#Android-Weekly-Issue-247" class="headerlink" title="Android Weekly Issue #247"></a>Android Weekly Issue #247</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-247" target="_blank" rel="external">Android Weekly Issue #247</a>.</p>
<p>本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;<br>RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Offline-support-“Try-again-later”-no-more"><a href="#Offline-support-“Try-again-later”-no-more" class="headerlink" title="Offline support: “Try again, later”, no more"></a><a href="https://medium.com/@yonatanvlevin/offline-support-try-again-later-no-more-afc33eba79dc#.p90haop40" target="_blank" rel="external">Offline support: “Try again, later”, no more</a></h2><p>作者他们的应用很好地处理了离线模式, 他们的基本原则是, 应用中不需要显示任何的loading控件.</p>
<p>在离线装填下, 在用户看来仍是可以提交请求的, 只不过出现了一个sync的小图标, 一旦当用户再次连上网络, 他的请求就会被发送出去.</p>
<p>然后作者讲了他们的程序设计:<br>首先是MVP结构, 使用了Content Provider包装的SQLite数据库. (此处列举了使用Content Provider的若干优点).</p>
<p>后台的同步工作, 他们选择了<code>GCMNetworkManager</code>.</p>
<p>基本流程是这样: 但用户提交请求, 首先存储在数据库中, 状态为pending, 然后后台service发送请求, 如果成功, 则更新数据库中的状态为synced; 如果失败, 则用<code>GcmNetworkManager</code>schedule一个task, 在网络连接恢复时再做一次尝试, 成功和失败的处理同上一步.</p>
<h2 id="Story-Code"><a href="#Story-Code" class="headerlink" title="Story Code"></a><a href="https://publicobject.com/2017/02/06/story-code/" target="_blank" rel="external">Story Code</a></h2><p>作者讲了一种方法, 以一种叙事的方式来写一个测试故事, 然后把它分成很多个小的测试cases. 这样可以用来驱动API的设计和其实现等.</p>
<h2 id="Testing-RxJava2"><a href="#Testing-RxJava2" class="headerlink" title="Testing RxJava2"></a><a href="https://www.infoq.com/articles/Testing-RxJava2" target="_blank" rel="external">Testing RxJava2</a></h2><p>本文介绍RxJava2中内置的关于测试的支持.</p>
<p>测试一个<code>Observable</code>可以用<code>TestObserver</code>; 测试<code>Flowable</code>可以用<code>TestSubscriber</code>.</p>
<p>如何测试在不同线程上的工作?<br>有几种选择:</p>
<ul>
<li>把Observable变为blocking的. -&gt; <code>blockingIterable()</code>, 缺点: 测试慢.</li>
<li>强制测试等待, 直到某个条件达成. -&gt; <code>awaitTerminalEvent()</code>. 此处还推荐一个库: <a href="https://github.com/awaitility/awaitility" target="_blank" rel="external">awaitility</a>.</li>
<li>把schedular换为一个immediate的. <code>RxJavaPlugins.setComputationSchedulerHandler(scheduler -&gt; Schedulers.trampoline());</code>. 需要最后reset一下, 可以用JUnit的TestRule来进行简化.</li>
</ul>
<p>用<code>TestScheduler</code>可以操纵时间, 进行白盒测试.<br>利用它在测试中可以精确控制时间过去了多少, 我们可以测试在中间的时间点的状态.<br>值得注意的是它控制的并不是真实的时间, 真实的时间还是立即就度过了的, 所以不会降低测试的速度.</p>
<p>我们也可以利用<code>TestRule</code>和<code>RxJavaPlugins</code>来把这个scheduler设置为测试时候要切换成的scheduler.</p>
<h2 id="Syncing-Changes"><a href="#Syncing-Changes" class="headerlink" title="Syncing Changes"></a><a href="http://tech.trello.com/syncing-changes/" target="_blank" rel="external">Syncing Changes</a></h2><p>Trello的离线模式实现文章系列之二. 基本的原则是在离线的时候把改动(deltas)存在数据库里, 之后有机会再同步给server.</p>
<p>本文介绍了他们如何计算delta和将它们按时间上传到服务器.</p>
<h2 id="Reactive-Apps-With-MVI-Part-4"><a href="#Reactive-Apps-With-MVI-Part-4" class="headerlink" title="Reactive Apps With MVI - Part 4"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-4" target="_blank" rel="external">Reactive Apps With MVI - Part 4</a></h2><p>MVI系列文章的第四篇. 本篇讲如何构建独立的UI单元.</p>
<p>作者认为Presenter之间的Parent-Child关系是一种code smell, 因为这样引入了一种强耦合的关系, 不好读, 不好维护.</p>
<p>你也许要问那Presenter之间如何通信呢? 答案是, 它们根本就不需要通信, 它们只需要更新和观测同一个Model(可以说业务逻辑), 让底层来通知它们事件的发生就可以了.</p>
<h2 id="Resources-for-Learning-how-to-Test-Android-Apps"><a href="#Resources-for-Learning-how-to-Test-Android-Apps" class="headerlink" title="Resources for Learning how to Test Android Apps"></a><a href="https://www.philosophicalhacker.com/post/some-resources-for-learning-how-to-test-android-apps/" target="_blank" rel="external">Resources for Learning how to Test Android Apps</a></h2><p>关于Android测试的相关资源分享.</p>
<h2 id="Unboxing-the-FlexboxLayout"><a href="#Unboxing-the-FlexboxLayout" class="headerlink" title="Unboxing the FlexboxLayout"></a><a href="https://blog.devcenter.co/unboxing-the-flexboxlayout-a7cfd125f023#.ulop7q1jz" target="_blank" rel="external">Unboxing the FlexboxLayout</a></h2><p>作者想实现一个动态关键字的流式布局, 可以根据parent的宽度自动换行.</p>
<p>他想了几种方法, 都不太合适, 所以最后选择了<code>FlexboxLayout</code>.</p>
<p>作者尝试了单独使用<code>FlexboxLayout</code>和 将<code>FlexboxLayoutManager()</code>设置为<code>RecyclerView</code>的Layout Manager两种办法来实现他想要的效果.</p>
<h2 id="Configuring-Android-Project-Version-Name-amp-Code"><a href="#Configuring-Android-Project-Version-Name-amp-Code" class="headerlink" title="Configuring Android Project - Version Name &amp; Code"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-version-name-code-b168952f3323#.v20pogayh" target="_blank" rel="external">Configuring Android Project - Version Name &amp; Code</a></h2><p>首先介绍了<a href="https://git-scm.com/docs/git-describe" target="_blank" rel="external">git-describe</a>命令.</p>
<p><code>git describe -tags</code>可以输出当前最近的tag和它之后有几个提交, 还有最新提交的hash.</p>
<p>作者建议使用这个库: <a href="https://github.com/ajoberstar/grgit" target="_blank" rel="external">grgit</a>, 写一个script-git-version.gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;org.ajoberstar:grgit:1.5.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import org.ajoberstar.grgit.Grgit</div><div class="line"></div><div class="line">ext &#123;</div><div class="line">    git = Grgit.open(currentDir: projectDir)</div><div class="line">    gitVersionName = git.describe()</div><div class="line">    gitVersionCode = git.tag.list().size()</div><div class="line">    gitVersionCodeTime = git.head().time</div><div class="line">&#125;</div><div class="line"></div><div class="line">task printVersion() &#123;</div><div class="line">    println(&quot;Version Name: $gitVersionName&quot;)</div><div class="line">    println(&quot;Version Code: $gitVersionCode&quot;)</div><div class="line">    println(&quot;Version Code Time: $gitVersionCodeTime&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在主文件中apply这个文件.</p>
<p>执行printVersion task后会输出类似这样的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Version Name: 1.0-2-gdca226a</div><div class="line">Version Code: 2</div><div class="line">Version Code Time: 1484407970</div></pre></td></tr></table></figure>
<p>这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">    dev &#123;</div><div class="line">        versionCode gitVersionCodeTime</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    prod &#123;</div><div class="line">        versionCode gitVersionCode</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就自动生成了版本号和版本名.<br>你还可以进一步设计, 在版本名中包括分支名, 时间戳之类的.</p>
<h2 id="Workcation-App-Part-1-Fragment-custom-transition"><a href="#Workcation-App-Part-1-Fragment-custom-transition" class="headerlink" title="Workcation App - Part 1. Fragment custom transition"></a><a href="https://www.thedroidsonroids.com/blog/android/workcation-app-part-1-fragments-custom-transition/" target="_blank" rel="external">Workcation App - Part 1. Fragment custom transition</a></h2><p>作者的系列文章, 讨论他的项目中的动画的实现.<br>本文是第一篇, 介绍进入map的转场动画.</p>
<p>首先, 在map加载完毕后, 存一个截图放在缓存里, 然后用一个自定义的Transition来做缩放和渐变的动画, 最后把它设置为fragment的转场动画.</p>
<h2 id="Model-View-Presenter-Android-guidelines"><a href="#Model-View-Presenter-Android-guidelines" class="headerlink" title="Model-View-Presenter: Android guidelines"></a><a href="https://medium.com/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf#.s1d1l3dkt" target="_blank" rel="external">Model-View-Presenter: Android guidelines</a></h2><p>MVP实现的一些guidelines和最佳实践.</p>
<ul>
<li>1.View要无脑和被动.</li>
<li>2.Presenter要和framework无关, 不依赖任何Android的类.</li>
<li>3.写一个协议描述View和Presenter的交互.</li>
<li>4.定义命名规则来区分职责.</li>
<li>5.不要在Presenter里创建生命周期的回调方法.</li>
<li>6.Presenter和View是一对一的关系. 可以定义<code>attach()</code>和<code>detach()</code>或<code>start()</code>和<code>stop()</code>来关联和解除关联.</li>
<li>7.不要在Presenter里用Bundle保存状态. 因为不能包含Android的类.</li>
<li>8.不要保存Presenter. 因为Presenter并不是一个数据类.</li>
<li>9.在Model中提供cache来恢复View的状态.</li>
</ul>
<h2 id="5-Not-So-Obvious-Things-About-RxJava"><a href="#5-Not-So-Obvious-Things-About-RxJava" class="headerlink" title="5 Not So Obvious Things About RxJava"></a><a href="https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc#.dl9lo390z" target="_blank" rel="external">5 Not So Obvious Things About RxJava</a></h2><p>RxJava使用学习中的五点(RxJava1.2.6).</p>
<ul>
<li>什么时候用<code>map()</code>或者<code>flatMap()</code>.</li>
<li>不使用<code>Observable.create()</code>来创建observables. 使用其他更方便的方法, 比如<code>syncOnSubscribe</code>, <code>fromCallable</code>, <code>fromEmitter</code>.</li>
<li>如何处理Backpressure.</li>
<li>如和能让流不因为errors而停下来.</li>
<li>如何分享Observable到多个订阅者 -&gt; <code>share()</code>或<code>publish()</code>.</li>
</ul>
<h2 id="Simplify-Concurrency-with-Reactive-Modelling-on-Android"><a href="#Simplify-Concurrency-with-Reactive-Modelling-on-Android" class="headerlink" title="Simplify Concurrency with Reactive Modelling on Android"></a><a href="https://www.toptal.com/android/simplify-concurrency-reactive-modelling-android" target="_blank" rel="external">Simplify Concurrency with Reactive Modelling on Android</a></h2><p>用RxJava来处理Android上的并发和异步.<br>作者的文章中举了很详尽的各种例子.</p>
<h2 id="JUnit-5-Getting-Started"><a href="#JUnit-5-Getting-Started" class="headerlink" title="JUnit 5: Getting Started"></a><a href="https://blog.stylingandroid.com/junit-5-getting-started/" target="_blank" rel="external">JUnit 5: Getting Started</a></h2><p>使用JUnit 5做测试.<br>本文讲了一些在Android上setup可能会遇到的问题及怎么解决.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FastHub"><a href="#FastHub" class="headerlink" title="FastHub"></a><a href="https://github.com/k0shk0sh/FastHub" target="_blank" rel="external">FastHub</a></h2><p>一个Android的Github客户端.</p>
<h2 id="gradle-android-javafmt-plugin"><a href="#gradle-android-javafmt-plugin" class="headerlink" title="gradle-android-javafmt-plugin"></a><a href="https://github.com/f2prateek/gradle-android-javafmt-plugin" target="_blank" rel="external">gradle-android-javafmt-plugin</a></h2><p>一个gradle plugin, 自动format代码.</p>
<h2 id="HtmlCompat"><a href="#HtmlCompat" class="headerlink" title="HtmlCompat"></a><a href="https://github.com/Pixplicity/HtmlCompat" target="_blank" rel="external">HtmlCompat</a></h2><p>Android中Html类的兼容库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-247&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-247&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #247&quot;&gt;&lt;/a&gt;Android Weekly Issue #247&lt;/h1&gt;&lt;p&gt;March 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-247&quot;&gt;Android Weekly Issue #247&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;&lt;br&gt;RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="Offline" scheme="http://mengdd.github.io/tags/Offline/"/>
    
      <category term="Version Name" scheme="http://mengdd.github.io/tags/Version-Name/"/>
    
      <category term="Git" scheme="http://mengdd.github.io/tags/Git/"/>
    
      <category term="Transition" scheme="http://mengdd.github.io/tags/Transition/"/>
    
      <category term="JUnit 5" scheme="http://mengdd.github.io/tags/JUnit-5/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 246</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/</id>
    <published>2017-03-01T09:45:13.000Z</published>
    <updated>2017-03-01T09:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-246"><a href="#Android-Weekly-Issue-246" class="headerlink" title="Android Weekly Issue #246"></a>Android Weekly Issue #246</h1><p>February 26th, 2017<br><a href="http://androidweekly.net/issues/issue-246" target="_blank" rel="external">Android Weekly Issue #246</a><br>本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;<br>In-App Billing的实现; 如何用组合而非继承的方式来组织应用.</p>
<p>代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Shared-Element-Transitions-with-RecyclerView"><a href="#Shared-Element-Transitions-with-RecyclerView" class="headerlink" title="Shared Element Transitions with RecyclerView"></a><a href="http://mikescamell.com/shared-element-transitions-part-4-recyclerview/" target="_blank" rel="external">Shared Element Transitions with RecyclerView</a></h2><p>作者介绍了如何在RecyclerView中实现shared element动画.</p>
<h2 id="Sharing-files-through-Intents-part-2"><a href="#Sharing-files-through-Intents-part-2" class="headerlink" title="Sharing files through Intents (part 2)"></a><a href="https://medium.com/@quiro91/sharing-files-through-intents-part-2-fixing-the-permissions-before-lollipop-ceb9bb0eec3a#.ci4hqoauq" target="_blank" rel="external">Sharing files through Intents (part 2)</a></h2><p>之前介绍过因为Android 7 Nougat对文件权限的限制, 不能再依靠Intent来发送<code>file://uri</code>数据了, 应该用<code>FileProvider</code>. 但是你采用了这些新方法之后, 在一些Android的旧版本上有可能会遇到问题.</p>
<p>你可能遇到这种异常: <code>java.lang.SecurityException: Permission Denial</code>.</p>
<p>在API 16及以上, 系统有一个方法<code>migrateExtraStreamToClipData()</code>会根据你的Intent的action帮你迁移数据到ClipData, 并自动帮你加上权限. 见代码: <a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/content/Intent.java#9037" target="_blank" rel="external">Intent</a>. 但是之前的版本却没有.</p>
<p>所以解决办法是在原本的代码中加上这两句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">    takePictureIntent.setClipData(ClipData.newRawUri(<span class="string">""</span>, photoURI));</div><div class="line">    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION|Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以要包括LOLLIPOP是因为<code>migrateExtraStreamToClipData()</code>这个方法是在preview版本之后才加上的, 所以不能保证所有的LOLLIPOP的设备都有这个方法.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1" class="headerlink" title="What Unit Tests are Trying to Tell us about Activities: Pt. 1"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt1/" target="_blank" rel="external">What Unit Tests are Trying to Tell us about Activities: Pt. 1</a></h2><p>“android-centric”的构架是指用Activity/Fragment作为屏幕基本构架单元的程序架构. 作者的系列文章要讨论为什么这种架构是对测试不友好的.</p>
<h2 id="Build-flexible-layouts-with-FlexboxLayout"><a href="#Build-flexible-layouts-with-FlexboxLayout" class="headerlink" title="Build flexible layouts with FlexboxLayout"></a><a href="https://android-developers.googleblog.com/2017/02/build-flexible-layouts-with.html" target="_blank" rel="external">Build flexible layouts with FlexboxLayout</a></h2><p>Google去年开源了<a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a>, 目的是将CSS中的<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">Flexible Layout module</a>引入到Android中来. 本文介绍了FlexboxLayout十分有用的几种情况, 附有demos.</p>
<h2 id="Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally"><a href="#Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally" class="headerlink" title="Making RxJava code tidier with doOnSubscribe and doFinally"></a><a href="https://medium.com/@ValCanBuild/making-rxjava-code-tidier-with-doonsubscribe-and-dofinally-3748f223d32d#.58wup7kxn" target="_blank" rel="external">Making RxJava code tidier with doOnSubscribe and doFinally</a></h2><p>使用<code>doOnSubscribe()</code>和<code>doFinally()</code>(RxJava 2)可以让RxJava的代码更加简洁.</p>
<ul>
<li><p><code>doOnSubscribe()</code>中的代码在subscribe的时候被调用.</p>
</li>
<li><p><code>doFinally()</code>在<code>Observable</code>调用<code>onError()</code>或<code>onCompleted()</code>之后, 或者流被下游放弃的时候调用.</p>
</li>
</ul>
<p>作者举的例子是用它们来show loading和hide loading, 这样它们也作为流的一部分, 而且subscriber可以只处理其他相关逻辑.</p>
<h2 id="Implementing-In-App-Billing-in-Android"><a href="#Implementing-In-App-Billing-in-Android" class="headerlink" title="Implementing In-App Billing in Android"></a><a href="https://hackernoon.com/implementing-in-app-billing-in-android-4896232c7d6b?gi=575af60d0286#.scggjiasz" target="_blank" rel="external">Implementing In-App Billing in Android</a></h2><p>关于Android In-App Billing的实现.</p>
<p>首先你会搜到<a href="https://developer.android.com/google/play/billing/index.html" target="_blank" rel="external">官方文档</a>.</p>
<p>作者在本文中介绍了其他的一些可选方案.</p>
<h2 id="Composite-Views-in-Android-Composition-over-Inheritance"><a href="#Composite-Views-in-Android-Composition-over-Inheritance" class="headerlink" title="Composite Views in Android: Composition over Inheritance"></a><a href="https://medium.com/@manuelvicnt/composite-views-in-android-composition-over-inheritance-4a7114609560#.n55x4611x" target="_blank" rel="external">Composite Views in Android: Composition over Inheritance</a></h2><p>作者介绍了这个库: <a href="https://github.com/passsy/CompositeAndroid" target="_blank" rel="external">CompositeAndroid</a>, 它解决了一个什么问题呢? </p>
<p>在App中, 如果多个Activity或者多个Fragment有一些共同的功能, 那么我们很可能就会创建一个基类Activity或者基类Fragment, 然后继承它. 当一些功能只被一些类共享时, 我们可能会继续不断创建基类, 产生一个无法维护的继承树.</p>
<p>解决的办法就是使用这个库, Activity只需要继承<code>CompositeActivity</code>, 所有共有的功能都会被当做插件加进来.<br>这样我们遵守了一个原则: <code>组合优于继承</code>.</p>
<p>但是这个库也有一些缺点: 它还在alpha阶段; 如果你使用了一些不常用的生命周期, 可能会有问题; 它是基于support library的, 所以如果这个库不更新support库的版本, 你也无法更新.</p>
<p>所以作者提出了一个简单的解决方案, 不使用CompositeAndroid. 文中举例展示了他的实现.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ShapeShifter"><a href="#ShapeShifter" class="headerlink" title="ShapeShifter"></a><a href="https://github.com/alexjlockwood/ShapeShifter" target="_blank" rel="external">ShapeShifter</a></h2><p>创建路径变形动画的一个web-app, 支持导出到<code>AnimatedVectorDrawable</code>.</p>
<h2 id="Shuttle"><a href="#Shuttle" class="headerlink" title="Shuttle"></a><a href="https://github.com/timusus/Shuttle" target="_blank" rel="external">Shuttle</a></h2><p>一个开源的本地音乐播放器.</p>
<h2 id="cortado"><a href="#cortado" class="headerlink" title="cortado"></a><a href="https://github.com/blipinsk/cortado" target="_blank" rel="external">cortado</a></h2><p>在Espresso上提供了一个抽象层, 使用更流畅.</p>
<h2 id="fragment-navigation-2-0"><a href="#fragment-navigation-2-0" class="headerlink" title="fragment-navigation-2.0"></a><a href="https://github.com/gyorgygabor/fragment-navigation-2.0" target="_blank" rel="external">fragment-navigation-2.0</a></h2><p>Fragment导航库.</p>
<h2 id="flexbox-layout"><a href="#flexbox-layout" class="headerlink" title="flexbox-layout"></a><a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a></h2><p>Flexbox for Android.</p>
<h2 id="kotlin-coroutines-retrofit"><a href="#kotlin-coroutines-retrofit" class="headerlink" title="kotlin-coroutines-retrofit"></a><a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="external">kotlin-coroutines-retrofit</a></h2><p>This is small library that provides Kotlin Coroutines suspending extension Call.await() for Retrofit 2.</p>
<h2 id="StatefulLayout"><a href="#StatefulLayout" class="headerlink" title="StatefulLayout"></a><a href="https://github.com/gturedi/StatefulLayout" target="_blank" rel="external">StatefulLayout</a></h2><p>一个内置包含loading, 错误, 空状态的布局.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-246&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-246&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #246&quot;&gt;&lt;/a&gt;Android Weekly Issue #246&lt;/h1&gt;&lt;p&gt;February 26th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-246&quot;&gt;Android Weekly Issue #246&lt;/a&gt;&lt;br&gt;本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;&lt;br&gt;In-App Billing的实现; 如何用组合而非继承的方式来组织应用.&lt;/p&gt;
&lt;p&gt;代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="Shared Element" scheme="http://mengdd.github.io/tags/Shared-Element/"/>
    
      <category term="FlexboxLayout" scheme="http://mengdd.github.io/tags/FlexboxLayout/"/>
    
      <category term="In-App Billing" scheme="http://mengdd.github.io/tags/In-App-Billing/"/>
    
      <category term="Music Player" scheme="http://mengdd.github.io/tags/Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Realm数据库使用指南</title>
    <link href="http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/"/>
    <id>http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/</id>
    <published>2017-02-27T09:32:23.000Z</published>
    <updated>2017-02-28T01:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Realm数据库使用指南"><a href="#Android-Realm数据库使用指南" class="headerlink" title="Android Realm数据库使用指南"></a>Android Realm数据库使用指南</h1><p>Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. </p>
<p>本文面向Android开发, 所以只讨论Java实现.<br>目前Realm Java的最新版本是2.3.1.</p>
<p>官方文档在此: <a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">realm java doc</a>, 花一个下午就可以基本过一遍, 之后随时查用. </p>
<p>我写了一个小程序<a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a>, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.</p>
<p>本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.</p>
<a id="more"></a>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>在项目的根build.gradle的文件中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;io.realm:realm-gradle-plugin:2.3.0&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在app的build.gradle文件中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;realm-android&apos;</div></pre></td></tr></table></figure></p>
<p>Done.</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Model类只要继承<code>RealmObject</code>即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">RealmObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String          name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             age;</div><div class="line"></div><div class="line">    <span class="meta">@Ignore</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             sessionId;</div><div class="line"></div><div class="line">    <span class="comment">// Standard getters &amp; setters generated by your IDE…</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getSessionId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sessionId; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setSessionId</span><span class="params">(<span class="keyword">int</span> sessionId)</span> </span>&#123; <span class="keyword">this</span>.sessionId = sessionId; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>Model类中可以包含的字段类型包括基本数据类型(及它们的装箱类型)和Date类, 另外也可以包含<code>RealmObject</code>的子类或者是<code>RealmList&lt;? extends RealmObject&gt;</code>.</p>
<h3 id="字段性质"><a href="#字段性质" class="headerlink" title="字段性质"></a>字段性质</h3><p>在字段上加注解可以定义字段的性质:</p>
<p><code>@Required</code>表明字段非null.<br>原生类型和<code>RealmList</code>类型默认是非null的.<br><code>RealmObject</code>字段永远是可以为null的.</p>
<p><code>@Ignore</code>表示字段不会被存储.</p>
<p><code>@Index</code>加索引.</p>
<p><code>@PrimaryKey</code>加主键, 主键只能有一个, 主键默认加索引.</p>
<p>但是注意主键默认没有加<code>@Required</code>, 如果主键要求非null, 需要显式添加<code>@Required</code>.</p>
<h3 id="主键使用"><a href="#主键使用" class="headerlink" title="主键使用"></a>主键使用</h3><p>有主键才能使用<code>copyToRealmOrUpdate()</code>这个方法.<br>主键类型必须是String或者整型(byte, short, int, long)或者它们的装箱类型(Byte, Short, Integer, Long).</p>
<p>有主键的对象创建的时候不能使用<code>createObject(Class&lt;E&gt; clazz)</code>方法, 而应该使用<code>createObject(Class&lt;E&gt; clazz, Object primaryKeyValue)</code>附上主键.</p>
<p>或者用<br><code>copyToRealm(obj)</code>或<code>copyToRealmOrUpdate(obj)</code>, 前者遇到主键冲突时会崩溃, 后者遇到主键冲突会更新已有对象.</p>
<h3 id="自动更新的对象"><a href="#自动更新的对象" class="headerlink" title="自动更新的对象"></a>自动更新的对象</h3><p>Realm中的数据对象是自动更新(Auto-Updating)的, 对象一旦被查询出来, 后续发生的任何数据改变也会立即反映在结果中, 不需要刷新对象.</p>
<p>这是一个非常有用的特性, 结合数据变化的通知可以很方便地刷新UI.</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Realm model对象间可以很方便地建立关系.<br>你可以在Model中存储另一个对象的引用, 建立多对一的关系; 也可以存储一组对象<code>RealmList&lt;T&gt;</code>, 建立一对多或多对多的关系.</p>
<p><code>RealmList&lt;T&gt;</code>的getter永远也不会返回null, 它只会返回一个为空的list.<br>把这个字段设置为null可以清空这个list.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Realm在使用之前需要调用初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Realm.init(context);</div></pre></td></tr></table></figure></p>
<p>建议把它放在Application的<code>onCreate()</code>里.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类: <code>RealmConfiguration</code>定义了Realm的创建配置.<br>最基本的配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div></pre></td></tr></table></figure></p>
<p>它会创建一个叫<code>default.realm</code>的文件, 放在<code>Context.getFilesDir()</code>的目录下.</p>
<p>如果我们想自定义一个配置, 可以这样写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The RealmConfiguration is created using the builder pattern.</span></div><div class="line"><span class="comment">// The Realm file will be located in Context.getFilesDir() with name "myrealm.realm"</span></div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">  .name(<span class="string">"myrealm.realm"</span>)</div><div class="line">  .encryptionKey(getKey())</div><div class="line">  .schemaVersion(<span class="number">42</span>)</div><div class="line">  .modules(<span class="keyword">new</span> MySchemaModule())</div><div class="line">  .migration(<span class="keyword">new</span> MyMigration())</div><div class="line">  .build();</div><div class="line"><span class="comment">// Use the config</span></div><div class="line">Realm realm = Realm.getInstance(config);</div></pre></td></tr></table></figure></p>
<p>所以我们是可以有多个配置, 访问多个Realm实例的.</p>
<p>我们可以把配置设置为默认配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Realm.init(<span class="keyword">this</span>);</div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div><div class="line">Realm.setDefaultConfiguration(config);</div></pre></td></tr></table></figure></p>
<p>之后用<code>Realm.getDefaultInstance()</code>取到的就是这个默认配置对应的实例.</p>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>迁移的策略是通过config指定的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">    .schemaVersion(<span class="number">2</span>) <span class="comment">// Must be bumped when the schema changes</span></div><div class="line">    .migration(<span class="keyword">new</span> MyMigration()) <span class="comment">// Migration to run instead of throwing an exception</span></div><div class="line">    .build()</div></pre></td></tr></table></figure></p>
<p>其中<code>MyMigration</code>实现了<code>RealmMigration</code>接口, 在<code>migrate()</code>方法中根据新旧版本号进行一步一步地升级.</p>
<p>具体例子见<a href="https://github.com/realm/realm-java/blob/master/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java" target="_blank" rel="external">Migration</a>.</p>
<p>开发的时候为了方便我用的是<code>.deleteRealmIfMigrationNeeded()</code>, 这样在需要数据库迁移的时候直接就删了数据重新开始了.</p>
<h2 id="关于Realm的close"><a href="#关于Realm的close" class="headerlink" title="关于Realm的close()"></a>关于Realm的close()</h2><p>一个打开的Realm实例会持有一些资源, 有一些是Java不能自动管理的, 所以就需要打开实例的代码负责在不需要的时候将其关闭.</p>
<p>Realm的instance是引用计数的(reference counted cache), 在同一个线程中获取后续实例是免费的, 但是底层的资源只有当所有实例被释放了之后才能释放. 也即你调用了多少次<code>getInstance()</code>, 就需要调用相应次数的<code>close()</code>方法.</p>
<p>比较建议的方法是在Activity或Fragment的生命周期中处理Realm实例的开启和释放:</p>
<ul>
<li>在Activity的<code>onCreate()</code>中<code>getInstance()</code>, <code>onDestroy()</code>中<code>close()</code>.</li>
<li>在Fragment的<code>onCreateView()</code>中<code>getInstance()</code>, <code>onDestroyView()</code>中<code>close()</code>.</li>
</ul>
<p>如果多个Fragment相关的都是同一个数据库实例, 那么在Activity中处理更好一些.</p>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>写操作一般的流程是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Obtain a Realm instance</span></div><div class="line">Realm realm = Realm.getDefaultInstance();</div><div class="line"></div><div class="line">realm.beginTransaction();</div><div class="line"></div><div class="line"><span class="comment">//... add or update objects here ...</span></div><div class="line"></div><div class="line">realm.commitTransaction();</div></pre></td></tr></table></figure></p>
<p>这里创建对象可以用<code>createObject()</code>方法或者<code>copyToRealm()</code>方法.<br>前者是先创建再set值, 后者是先new对象再更新数据库.</p>
<p>如果不想自己处理<code>beginTransaction()</code>, <code>cancelTransaction()</code>和<code>commitTransaction()</code>, 可以直接调用<code>realm.executeTransaction()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">realm.executeTransaction(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">        User user = realm.createObject(User.class);</div><div class="line">        user.setName(<span class="string">"John"</span>);</div><div class="line">        user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>因为transactions之间是互相阻塞的.<br>异步执行可以用这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">realm.executeTransactionAsync(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm bgRealm)</span> </span>&#123;</div><div class="line">                User user = bgRealm.createObject(User.class);</div><div class="line">                user.setName(<span class="string">"John"</span>);</div><div class="line">                user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnSuccess() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction was a success.</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnError() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction failed and was automatically canceled.</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这两个回调是Optional的, 它们只能在有Looper的线程调用.</p>
<p>注意: 这个方法的返回值对象可以用于在Activity/Fragment生命周期结束的时候取消未完的操作.</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>所有的写操作都要放在transaction中进行, 如上, 不同的操作只是其中具体方法不同.</p>
<p>删除操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> RealmResults&lt;User&gt; users = getUsers();</div><div class="line"><span class="comment">// method 1:</span></div><div class="line">users.get(<span class="number">0</span>).deleteFromRealm();</div><div class="line"><span class="comment">// method 2:</span></div><div class="line">users.deleteFromRealm(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// delete all</span></div><div class="line">users.deleteAllFromRealm();</div></pre></td></tr></table></figure></p>
<p>更新操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.copyToRealmOrUpdate(obj);</div></pre></td></tr></table></figure></p>
<p>注意: 这个方法需要Model有主键, 会更新obj的主键对应的对象, 如果不存在则新建对象.</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询可以流式地写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Or alternatively do the same all at once (the "Fluent interface"):</span></div><div class="line">RealmResults&lt;User&gt; result2 = realm.where(User.class)</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"John"</span>)</div><div class="line">                                  .or()</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"Peter"</span>)</div><div class="line">                                  .findAll();</div></pre></td></tr></table></figure></p>
<p>查询条件默认是and的关系, or则需要显式指定.</p>
<p>这个<code>RealmResults</code>是继承Java的<code>AbstractList</code>的, 是有序的集合, 可以通过索引访问.<br><code>RealmResults</code>永远不会为null, 当查不到结果时, 它的<code>size()</code>返回0.</p>
<h3 id="查询的线程"><a href="#查询的线程" class="headerlink" title="查询的线程"></a>查询的线程</h3><p>基本上所有的查询都是很快进行的, 足够在UI线程上同步进行.<br>所以绝大多数情况在UI线程上使用<code>findAll()</code>是没有问题的.</p>
<p>如果你要进行非常复杂的查询, 或者你的查询是在非常大的数据集上进行的, 你可以选择异步查询, 使用<code>findAllAsync()</code>.</p>
<h3 id="查询条件是一个集合-gt-in"><a href="#查询条件是一个集合-gt-in" class="headerlink" title="查询条件是一个集合 -&gt; in()"></a>查询条件是一个集合 -&gt; <code>in()</code></h3><p>如果想要查询的某一个字段的值是在一个集合中, 比如我有一个id的集合, 我现在想把id在这个集合中的项目全都查出来, 这就可以使用in操作符:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;TodoList&gt; toDeleteLists = realm.where(TodoList.class).in(<span class="string">"id"</span>, ids).findAll();</div></pre></td></tr></table></figure></p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>查询的时候可以利用link或关系来查询, 比如一个Person类中含有一个<code>RealmList&lt;Dog&gt; dogs</code>的字段.<br>查询的时候可以这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;Person&gt; persons = realm.where(Person.class)</div><div class="line">                                .equalTo(<span class="string">"dogs.color"</span>, <span class="string">"Brown"</span>)</div><div class="line">                                .findAll();</div></pre></td></tr></table></figure></p>
<p>利用字段名<code>dogs.</code>来查询一个dog的属性, 再查出拥有这种特定属性dog的人.</p>
<p>但是反向地, 我们能不能查询主人是满足特定属性的人的所有dogs呢? 目前(2017.2.17)这种查询仍是不支持的. 这里有讨论:  <a href="https://github.com/realm/realm-java/issues/607" target="_blank" rel="external">realm-java-issue-607</a>.</p>
<p> 所以两种解决办法: 一是做两次查询; 二是在Dog类的model里加入对Person的引用.</p>
<h2 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h2><p>可以添加一个listener, 在数据改变的时候收到更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Realm realm;</div><div class="line">    <span class="keyword">private</span> RealmChangeListener realmListener;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">      realm = Realm.getDefaultInstance();</div><div class="line">      realmListener = <span class="keyword">new</span> RealmChangeListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">            <span class="comment">// ... do something with the updates (UI, etc.) ...</span></div><div class="line">        &#125;&#125;;</div><div class="line">      realm.addChangeListener(realmListener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">// Remove the listener.</span></div><div class="line">        realm.removeChangeListener(realmListener);</div><div class="line">        <span class="comment">// Close the Realm instance.</span></div><div class="line">        realm.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意listener需要在不用的时候删除掉. </p>
<p>可以用这样删除所有的listeners:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.removeAllChangeListeners();</div></pre></td></tr></table></figure></p>
<p>Listener不一定要和Realm绑定, 也可以和具体的<code>RealmObject</code>或者<code>RealmResults</code>绑定.<br>当Listener被调用的时候, 它绑定的对象是自动更新的, 不需要手动刷新.</p>
<h2 id="查看数据库的工具"><a href="#查看数据库的工具" class="headerlink" title="查看数据库的工具"></a>查看数据库的工具</h2><p>用Stetho不能直接查看Realm的数据库, 看不到.<br>需要用这个工具配置一下: <a href="https://github.com/uPhyca/stetho-realm" target="_blank" rel="external">stetho-realm</a>.<br>之后就可以在浏览器中查看Realm的数据库了.</p>
<p>(但是感觉这个工具不是很好用, 有时候不显示数据, 有时候显示的是旧数据.)</p>
<p>也可以用官方提供的Realm Browser来查看, 但是只有Mac版.<br>如何查看看这里: <a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803" target="_blank" rel="external">StackOverflow answer</a>.</p>
<h2 id="实际使用的感想和遇到的问题"><a href="#实际使用的感想和遇到的问题" class="headerlink" title="实际使用的感想和遇到的问题"></a>实际使用的感想和遇到的问题</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>建立Model之间的关系很方便也很直接, 查询的时候自动关联了其中的关系.</li>
<li>自动更新(Auto-Updating)的特性很有用, 不用再关心数据的刷新, 只用关心UI的刷新. </li>
</ul>
<p>比如一旦给Adapter绑定了数据, 之后的数据更新只需要在onChange()里面通知Adapter调用<code>notifyDataSetChanged()</code>即可.</p>
<p>当然我并没有用<code>RealmBaseAdapter</code>和<code>RealmRecyclerViewAdapter</code>, 估计这两个更好用, 官方有例子, 这里不再赘述.</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这里有的也不能说是缺点, 只是使用起来觉得不方便的地方. </p>
<ul>
<li>限制了创建对象和操作对象必须在同一个线程.<br>违反了这条会报错: <code>java.lang.IllegalStateException: Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.</code> 比如我们在UI线程查询出来的对象, 想要异步地删除或者更新, 我们必须在新的线程重新查询.</li>
<li>没有主键自增的功能, 见<a href="https://github.com/realm/realm-java/issues/469" target="_blank" rel="external">Issue #469</a>, 需要自己控制主键自增.</li>
<li>从List中删除了一项之后, 最后的一项会移动过来补到被删除的那一项原来的位置. 这是因为人家就是这么设计的<a href="http://stackoverflow.com/questions/37480785/realm-order-of-records-was-changed" target="_blank" rel="external">stackoverflow</a>. 默认情况下是没有排序的, 数据按照添加的顺序返回, 但是这并不是一种保证, 所以当删除了中间的元素, 后面的会补上这个位置, 以保证底层的数据是放在一起的. 解决办法就是指定一个排序规则.</li>
<li>查询出来的对象不可以临时改变其数据, 否则会报错: <code>java.lang.IllegalStateException: Changing Realm data can only be done from inside a transaction.</code></li>
<li>不支持反向link的查询. (见前面链式查询部分的介绍).</li>
<li>不支持级联删除. 即从数据库中删除一个对象的时候, 不会删除其中<code>RealmObject</code>子类或<code>RealmList</code>类型的字段在数据库中对应的数据. <a href="https://github.com/realm/realm-java/issues/1104" target="_blank" rel="external">Issue #1104</a>, <a href="https://github.com/realm/realm-java/issues/2717" target="_blank" rel="external">Issue #2717</a>. 这点也可以理解, 因为model之间的关系可能是多对多的. 所以需要实现级联删除的地方需要手动处理.</li>
<li>测试不方便: <code>RealmResults</code>对象即不能被mock也不能被new; 所有的Model对象也不能被mock. 因为<code>Mockito can only mock non-private &amp; non-final classes.</code></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/realm/realm-java" target="_blank" rel="external">Github repo realm-java</a></li>
<li><a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">Realm Java Doc</a></li>
</ul>
<p>我的练习Demo:</p>
<ul>
<li><a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Realm数据库使用指南&quot;&gt;&lt;a href=&quot;#Android-Realm数据库使用指南&quot; class=&quot;headerlink&quot; title=&quot;Android Realm数据库使用指南&quot;&gt;&lt;/a&gt;Android Realm数据库使用指南&lt;/h1&gt;&lt;p&gt;Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. &lt;/p&gt;
&lt;p&gt;本文面向Android开发, 所以只讨论Java实现.&lt;br&gt;目前Realm Java的最新版本是2.3.1.&lt;/p&gt;
&lt;p&gt;官方文档在此: &lt;a href=&quot;https://realm.io/docs/java/latest/&quot;&gt;realm java doc&lt;/a&gt;, 花一个下午就可以基本过一遍, 之后随时查用. &lt;/p&gt;
&lt;p&gt;我写了一个小程序&lt;a href=&quot;https://github.com/mengdd/TodoRealm&quot;&gt;TodoRealm&lt;/a&gt;, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.&lt;/p&gt;
&lt;p&gt;本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/categories/Android/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/categories/Android/Database/Realm/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Database" scheme="http://mengdd.github.io/tags/Database/"/>
    
      <category term="Realm" scheme="http://mengdd.github.io/tags/Realm/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 245</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/</id>
    <published>2017-02-22T07:35:47.000Z</published>
    <updated>2017-03-09T05:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-245"><a href="#Android-Weekly-Issue-245" class="headerlink" title="Android Weekly Issue #245"></a>Android Weekly Issue #245</h1><p>February 19th, 2017<br><a href="http://androidweekly.net/issues/issue-245" target="_blank" rel="external">Android Weekly Issue #245</a><br>本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);<br>用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中<code>Subscription</code>注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.</p>
<p>本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Write-awesome-unit-tests"><a href="#Write-awesome-unit-tests" class="headerlink" title="Write awesome unit tests"></a><a href="http://jeroenmols.com/blog/2017/02/16/unittests/" target="_blank" rel="external">Write awesome unit tests</a></h2><p>作者关于写好单元测试提供了三条简单的规则以及每条规则对应的一些建议.</p>
<h3 id="1-尽快尽早地跑测试"><a href="#1-尽快尽早地跑测试" class="headerlink" title="1. 尽快尽早地跑测试."></a>1. 尽快尽早地跑测试.</h3><p>尽量在每次改动之后都跑跑测试, 及早发现问题. 你的测试跑得越快你就越有可能经常跑它们.</p>
<p>为了让测试跑得很快:</p>
<ul>
<li>让测试跑在JVM上而不是设备上.</li>
<li>仅测试独立的逻辑模块.</li>
<li>不要包含UI, 数据库, 或者网络测试在你的主测试套件中.</li>
<li>测试中不要使用wait/sleep.</li>
</ul>
<h3 id="2-小并且关注点集中的测试"><a href="#2-小并且关注点集中的测试" class="headerlink" title="2. 小并且关注点集中的测试"></a>2. 小并且关注点集中的测试</h3><p>对每一个bug来说, 应该有且只有一个测试挂掉, 并且测试失败的原因应该能从测试方法名上看出来.</p>
<p>这样就迫使你每一个测试只检查一件事情, 导致你的测试小并且简单易懂, 也好维护. </p>
<p>实现tips:</p>
<ul>
<li>测试中只有一条assert/verify语句.</li>
<li>有更多的小测试, 而不是几个大测试.</li>
<li>测试的名字能清楚地描述失败的原因.</li>
</ul>
<h3 id="3-100-的可靠性"><a href="#3-100-的可靠性" class="headerlink" title="3. 100%的可靠性"></a>3. 100%的可靠性</h3><p>你的测试应该是完全值得信赖的, 不应该随机失败, 否则你将会对测试失去信任, 也不再会认真对待测试的失败.</p>
<p>所以你的测试应该是100%可靠的, 只在真的有问题的时候才失败.</p>
<p>建议是:</p>
<ul>
<li>在JVM上跑测试, 因为到设备的连接可能会中断.</li>
<li>在测试的时候mock网络通信.</li>
<li>把UI/集成测试移出你的单元测试套件.</li>
</ul>
<h2 id="Helping-to-Mock-Tests-in-Kotlin"><a href="#Helping-to-Mock-Tests-in-Kotlin" class="headerlink" title="Helping to Mock Tests in Kotlin"></a><a href="https://medium.com/@orogersilva/helping-androiddev-to-mock-tests-in-kotlin-ab3be5204559#.wetcvdvbt" target="_blank" rel="external">Helping to Mock Tests in Kotlin</a></h2><p>因为Kotlin中的类默认是<code>final</code>的, 要继承的话需要显示地声明<code>open</code>.</p>
<p>如果只是为了在单元测试中mock就要加个open吗? 不.</p>
<p>本篇文章就介绍如何如何mock Kotlin的对象, 而不用该它的声明.</p>
<p>首先, <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="external">Set up</a>; 然后, 使用这个库<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>.</p>
<p>文中详细介绍了使用细节, 以及对<code>any()</code>方法的讨论.</p>
<h2 id="How-and-Why-I-Kill-God-Objects"><a href="#How-and-Why-I-Kill-God-Objects" class="headerlink" title="How and Why I Kill God Objects"></a><a href="https://www.philosophicalhacker.com/post/towards-godless-android-development-how-and-why-i-kill-god-objects/" target="_blank" rel="external">How and Why I Kill God Objects</a></h2><p>在面向对象编程中, God Objects是应该被避免的.</p>
<p>在Android开发中, 最常见的一种God对象是Context. 本文介绍如何清除这个God对象, 同样的方法也可以用来处理其他对象.</p>
<p>首先说为什么要干掉Context?<br>在做TDD的过程中, 我们希望是面向接口的, 而且我们不应该mock非我们拥有的类型.<br>所以我们不应该直接mock外部的API, 而是应该创建一个自己的接口层.</p>
<p>作者发现很多类其实并不真正需要一个Context, 它们只是需要得到string或者存储的键值对.</p>
<p>之后文中举例介绍了如何通过定义接口摆脱Context.</p>
<h2 id="How-to-Make-Calls-and-Use-SMS-in-Android-Apps"><a href="#How-to-Make-Calls-and-Use-SMS-in-Android-Apps" class="headerlink" title="How to Make Calls and Use SMS in Android Apps"></a><a href="https://code.tutsplus.com/tutorials/how-to-make-calls-and-use-sms-in-android-apps--cms-28168" target="_blank" rel="external">How to Make Calls and Use SMS in Android Apps</a></h2><p><strong>如何拨打电话</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String dial = <span class="string">"tel:"</span> + phoneNo;</div><div class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(dial)));</div></pre></td></tr></table></figure></p>
<p>(不需要权限).</p>
<p>如果想在app里直接拨出去电话, 需要权限<code>android.permission.CALL_PHON</code>, 并且改用<code>ACTION_CALL</code>.</p>
<p><strong>监控电话事件</strong>:</p>
<p>需要权限<code>android.permission.READ_PHONE_STATE</code>.来监控来电, 打出去的电话需要这个权限: <code>android.permission.PROCESS_OUTGOING_CALLS</code>.</p>
<p>具体实现就是在<code>TelephonyManager</code>注册监听器<code>PhoneStateListener</code>. 如果是在Activity中需要在对应的生命周期注销监听器.</p>
<p>如果需要后台监控, 则需要用到<code>BroadcastReceiver</code>, 过滤actions为<code>android.intent.action.PHONE_STATE</code>和<code>android.intent.action.NEW_OUTGOING_CALL</code>.<br>除了获取相应的电话号码, 还可以进一步阻止电话的拨出.</p>
<p><strong>发送短信</strong>:</p>
<p>发短信也是两种方法, 启动一个短信客户端程序, 或者直接从程序里发.</p>
<p>启动其他程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent smsIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, Uri.parse(<span class="string">"smsto:"</span> + phoneNo));</div><div class="line">smsIntent.putExtra(<span class="string">"sms_body"</span>, message);</div><div class="line">startActivity(smsIntent);</div></pre></td></tr></table></figure></p>
<p>自己发: 需要权限<code>android.permission.SEND_SMS</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SmsManager smsManager = SmsManager.getDefault();</div><div class="line">smsManager.sendTextMessage(phoneNo, <span class="keyword">null</span>, message, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>注意Android 6.0以上的设备, 本文提到的这些危险权限都是需要动态请求的.</p>
<p><strong>收短信</strong>:<br>通过<code>BroadcastReceiver</code>, 需要权限<code>android.permission.RECEIVE_SMS</code>.</p>
<h2 id="Android-Things-Electricity-Monitoring-App"><a href="#Android-Things-Electricity-Monitoring-App" class="headerlink" title="Android Things - Electricity Monitoring App"></a><a href="https://riggaroo.co.za/android-things-electricity-monitoring-app/" target="_blank" rel="external">Android Things - Electricity Monitoring App</a></h2><p>作者分享了一个她的Android Things的应用(和Github repo), 可以监控她家的用电情况.</p>
<h2 id="Using-Keystore-system-to-store-and-retrieve-sensitive-information"><a href="#Using-Keystore-system-to-store-and-retrieve-sensitive-information" class="headerlink" title="Using Keystore system to store and retrieve sensitive information"></a><a href="https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454b#.nu3gw39qp" target="_blank" rel="external">Using Keystore system to store and retrieve sensitive information</a></h2><p>利用Android的Keystore来存储一些敏感信息.</p>
<h2 id="The-lost-droid-and-the-magic-Dagger"><a href="#The-lost-droid-and-the-magic-Dagger" class="headerlink" title="The lost droid and the magic Dagger"></a><a href="https://medium.com/rocknnull/the-lost-droid-and-the-magic-dagger-an-intro-to-dependency-injection-for-android-c686f4399117#.k5vgmxsjh" target="_blank" rel="external">The lost droid and the magic Dagger</a></h2><p>一篇依赖注入的介绍文章.<br>先介绍依赖注入是什么, 有什么优点, 接着介绍Dagger 2的使用.</p>
<h2 id="Wear-2-0-Match-Timer-–-Part-1"><a href="#Wear-2-0-Match-Timer-–-Part-1" class="headerlink" title="Wear 2.0: Match Timer – Part 1"></a><a href="https://blog.stylingandroid.com/wear-2-0-match-timer-part-1/" target="_blank" rel="external">Wear 2.0: Match Timer – Part 1</a></h2><p>作者把他的Wear应用升级到了Wear 2.0.</p>
<h2 id="ViewPager-without-Fragments"><a href="#ViewPager-without-Fragments" class="headerlink" title="ViewPager without Fragments"></a><a href="http://www.ottodroid.net/?p=523" target="_blank" rel="external">ViewPager without Fragments</a></h2><p>一些开发者可能不想选择Fragment, 这篇文章里有相关讨论: <a href="https://medium.com/square-corner-blog/advocating-against-android-fragments-81fd0b462c97#.e4k145h1b" target="_blank" rel="external">Advocating Against Android Fragments</a>.</p>
<p>作者推荐了一些在不用Fragment的情况下构建App的库: <a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">Conductor</a>, <a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>, <a href="https://github.com/square/flow" target="_blank" rel="external">flow</a>, <a href="https://github.com/square/mortar" target="_blank" rel="external">mortar</a>.</p>
<p>而本篇文章想要展示另一种方法, 既不用Fragment, 也不用上述的第三方库来构建一个App -&gt; 用ViewPager.</p>
<p>在PagerAdapter里管理了一个Presenter的List, 每一个Presenter管理一个View. 具体实现见原文.</p>
<h2 id="Stress-testing-Android-apps"><a href="#Stress-testing-Android-apps" class="headerlink" title="Stress-testing Android apps"></a><a href="https://android.jlelse.eu/stress-testing-android-apps-601311ebf590#.8kqor9m39" target="_blank" rel="external">Stress-testing Android apps</a></h2><p>之前大神JakeWharton有一个Sample App: <a href="https://github.com/JakeWharton/u2020" target="_blank" rel="external">JakeWharton/u2020</a>, 里面有一个debug drawer, 可以用来模拟不同的测试情形, 比如网络连接不好, 延迟, 或者网络错误等等.</p>
<p>作者他们的App也有一个类似的debug drawer, 他们讨论出了一个需要测试的情形的checklist:</p>
<ul>
<li>网络延迟</li>
<li>错误率</li>
<li>离线模式</li>
<li>屏幕旋转</li>
<li>应用在后台被杀死</li>
<li>应用升级</li>
<li>Key Bashing</li>
<li>多窗口模式 (Android N)</li>
<li>TransactionTooLargeException (Android N)</li>
</ul>
<p>作者甚至发现其中的一些项目组合起来测试非常有趣.</p>
<ul>
<li>网络延迟: 可结合方向改变/app后台被杀死测试.</li>
<li>错误率: 可以检查错误是否被正确处理并被报告.</li>
<li>离线模式: 关掉网络或者打开飞行模式, 检测正在执行的网络请求是否会引起崩溃; 是否正确通知了用户连接丢失了; 所有应该被cach的内容是否被正确cach了.</li>
<li>方向改变: 检查:  正在进行的请求会怎么办? app的状态是否被正确恢复了? 是否加载了当前方向对应的正确资源?</li>
<li>App在后台被杀死: 可以通过命令: <code>adb shell am kill YOUR_PACKAGNE_NAME</code>或者”Do not keep activities”来模拟这种情形. 相关阅读: <a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">Optimizing for Doze and App Standby</a>.</li>
<li>App更新: 升级后之前的数据是否被保存了?</li>
<li>Key Bashing: 剧烈的滑动和敲击可能产生一些奇怪的错误. 可以跑Monkey来测试一下你的应用: <code>adb shell monkey -p YOUR_PACKAGNE_NAME</code>.</li>
<li>多窗口模式(Android N): 列出了一些多窗口的测试项目, 详情见原文.</li>
<li>TransactionTooLargeException (Android N): Bundle中的数据不能太大, 超过限制, 在Android N以上会直接抛异常.</li>
</ul>
<h2 id="How-to-leak-memory-with-Subscriptions-in-RxJava"><a href="#How-to-leak-memory-with-Subscriptions-in-RxJava" class="headerlink" title="How to leak memory with Subscriptions in RxJava"></a><a href="https://medium.com/@scanarch/how-to-leak-memory-with-subscriptions-in-rxjava-ae0ef01ad361#.20w4lbkxq" target="_blank" rel="external">How to leak memory with Subscriptions in RxJava</a></h2><p>文中举了一个例子, 用RxJava结合MVP, 做网络请求, 更新UI, 很常见的使用情形. </p>
<p>在生命周期结束的时候调用RxJava的<code>Subscription.unsubscribe()</code>来注销, 以结束还在进行的网络请求.</p>
<p>看上去没有什么问题, 但是程序实际运行, 反复旋转屏幕进行测试, <code>StrictMode</code>报告出了Activity的<code>InstanceCountViolation</code>, dump memory的确看到了多个Activity的实例. 这是为什么呢? </p>
<p>作者深究原因, 发现<code>Subscriber</code>的子类存储的都是final的字段, 比如这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext;</div><div class="line">    <span class="keyword">final</span> Action1&lt;Throwable&gt; onError;</div><div class="line">    <span class="keyword">final</span> Action0 onCompleted;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionSubscriber</span><span class="params">(Action1&lt;? <span class="keyword">super</span> T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.onNext = onNext;</div><div class="line">        <span class="keyword">this</span>.onError = onError;</div><div class="line">        <span class="keyword">this</span>.onCompleted = onCompleted;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它们都是final的, 所以最后即便执行了注销操作, 也是没有办法把它们置为null的.</p>
<p>在生命周期结束的时候注销的操作是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    subscription.unsubscribe();</div><div class="line">    view = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>subscription</code>是<code>subscribe()</code>方法的返回值, 被保存在Presenter的一个字段里, 它实际就是<code>Subscriber</code>对象.</p>
<p>这里的问题就是, 在<code>destroy()</code>之后, 该引用并没有被置为null, 导致了下面的引用链:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Presenter -&gt; subscription字段, 也即匿名的`Subscriber`对象 -&gt; final字段 -&gt; 对view的引用 -&gt; 对Activity的引用.</div></pre></td></tr></table></figure>
<p>从而造成了内存泄露.</p>
<p>解决的办法有两个:</p>
<ul>
<li>在<code>subscription.unsubscribe();</code>之后把<code>subscription</code>字段置为null.</li>
<li>使用<code>CompositeSubscription</code>, 它可以管理多个<code>Subscription</code>对象, 用它的<code>clear()</code>方法, 它会unsubscribe所有项目并且清除所有的引用.</li>
</ul>
<p>文后还列了相关的资料, 作者发现问题并寻找原因的思路很值得学习.</p>
<h2 id="Your-Unit-tests-might-not-be-as-reliable-as-you-thought"><a href="#Your-Unit-tests-might-not-be-as-reliable-as-you-thought" class="headerlink" title="Your Unit tests might not be as reliable as you thought"></a><a href="https://afterecho.uk/blog/your-unit-tests-might-not-be-as-reliable-as-you-thought.html" target="_blank" rel="external">Your Unit tests might not be as reliable as you thought</a></h2><p>作者举了个例子, 说明即便你的单元测试过了, 也不保证你的产品代码一定没问题.</p>
<p>他的例子是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SimpleDateFormat fmt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>);</div></pre></td></tr></table></figure></p>
<p>失败的原因是因为<code>XXX</code>格式是在Android 4.3以上才支持的, 它是在<code>java.text</code>包下的. 所以实际在高版本的设备还运行正常, 换个低版本的设备就崩溃了.</p>
<p>所以单元测试并不一定可靠, 因为跑单元测试的JVM和Android设备上的JVM有可能不一样.</p>
<h2 id="Airplane-Mode-Enabling-Trello-Mobile-Offline"><a href="#Airplane-Mode-Enabling-Trello-Mobile-Offline" class="headerlink" title="Airplane Mode: Enabling Trello Mobile Offline"></a><a href="http://tech.trello.com/sync-architecture/" target="_blank" rel="external">Airplane Mode: Enabling Trello Mobile Offline</a></h2><p>Trello移动移动现在有离线模式了. 作者介绍了他们的心路历程和架构变化. (比较简单和笼统的介绍).</p>
<h2 id="Self-guided-resources-to-Android-development"><a href="#Self-guided-resources-to-Android-development" class="headerlink" title="Self-guided resources to Android development"></a><a href="https://twitter.com/corey_latislaw/status/831624360175603713?s=03" target="_blank" rel="external">Self-guided resources to Android development</a></h2><p>这是一条Twitter, 作者分享了Android的学习资源. (可惜我打不开里面说的链接, 不知为何.)</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Alerter"><a href="#Alerter" class="headerlink" title="Alerter"></a><a href="https://github.com/Tapadoo/Alerter" target="_blank" rel="external">Alerter</a></h2><p>一个加在Window的Decor View上面的顶部提示栏, 类似于Snackbar和Toast一类的东东. 可定制外观, icon, 加多行字, 可添加click事件.</p>
<h2 id="sensey"><a href="#sensey" class="headerlink" title="sensey"></a><a href="https://github.com/nisrulz/sensey" target="_blank" rel="external">sensey</a></h2><p>一个好用的手势检测库.</p>
<h2 id="mkloader"><a href="#mkloader" class="headerlink" title="mkloader"></a><a href="https://github.com/nntuyen/mkloader" target="_blank" rel="external">mkloader</a></h2><p>好看并且平滑的自定义loading view. 目前支持好几种图案.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-245&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-245&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #245&quot;&gt;&lt;/a&gt;Android Weekly Issue #245&lt;/h1&gt;&lt;p&gt;February 19th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-245&quot;&gt;Android Weekly Issue #245&lt;/a&gt;&lt;br&gt;本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&amp;gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);&lt;br&gt;用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中&lt;code&gt;Subscription&lt;/code&gt;注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.&lt;/p&gt;
&lt;p&gt;本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Memory Leak" scheme="http://mengdd.github.io/tags/Memory-Leak/"/>
    
      <category term="Mockito" scheme="http://mengdd.github.io/tags/Mockito/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Unit Test" scheme="http://mengdd.github.io/tags/Unit-Test/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="God Objects" scheme="http://mengdd.github.io/tags/God-Objects/"/>
    
      <category term="Call" scheme="http://mengdd.github.io/tags/Call/"/>
    
      <category term="SMS" scheme="http://mengdd.github.io/tags/SMS/"/>
    
      <category term="Keystore" scheme="http://mengdd.github.io/tags/Keystore/"/>
    
      <category term="Wear 2.0" scheme="http://mengdd.github.io/tags/Wear-2-0/"/>
    
      <category term="ViewPager" scheme="http://mengdd.github.io/tags/ViewPager/"/>
    
      <category term="Alert" scheme="http://mengdd.github.io/tags/Alert/"/>
    
      <category term="Gesture" scheme="http://mengdd.github.io/tags/Gesture/"/>
    
      <category term="Loading" scheme="http://mengdd.github.io/tags/Loading/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 244</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/</id>
    <published>2017-02-13T06:53:29.000Z</published>
    <updated>2017-02-13T07:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-244"><a href="#Android-Weekly-Issue-244" class="headerlink" title="Android Weekly Issue #244"></a>Android Weekly Issue #244</h1><p>February 12th, 2017<br><a href="http://androidweekly.net/issues/issue-244" target="_blank" rel="external">Android Weekly Issue #244</a><br>本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送<code>file:// URI</code>, 应用需要改用<code>FileProvider</code>实现原有功能.<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-Fragments-Tutorial-An-Introduction"><a href="#Android-Fragments-Tutorial-An-Introduction" class="headerlink" title="Android Fragments Tutorial: An Introduction"></a><a href="https://www.raywenderlich.com/149112/android-fragments-tutorial-introduction" target="_blank" rel="external">Android Fragments Tutorial: An Introduction</a></h2><p>一篇如何使用Fragments的讲解.</p>
<h2 id="Exporting-data-from-ClassyShark"><a href="#Exporting-data-from-ClassyShark" class="headerlink" title="Exporting data from ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-data-from-classyshark-e3cf3fe3fab8#.e2r76detr" target="_blank" rel="external">Exporting data from ClassyShark</a></h2><p>用<a href="https://github.com/google/android-classyshark" target="_blank" rel="external">ClassyShark</a>的APK dashboardA检查apk的问题(重复依赖, 过期依赖等).<br>本文介绍如何一次性导出全部的数据.</p>
<h2 id="Post-mortem-Firebase-vs-permissions"><a href="#Post-mortem-Firebase-vs-permissions" class="headerlink" title="Post-mortem : Firebase vs permissions"></a><a href="http://jeremie-martinez.com/2017/02/08/firebase-permissions/" target="_blank" rel="external">Post-mortem : Firebase vs permissions</a></h2><p>两周前Firebase发布了一个新功能: <a href="https://firebase.google.com/docs/app-indexing/android/personal-content" target="_blank" rel="external">Personal App Indexing</a>. 之后遇到了一些权限相关的问题, 本文讨论遇到的具体问题和解决方法, 然后他们发布了一个hotfix版本.</p>
<h2 id="Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails"><a href="#Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails" class="headerlink" title="Did you get one of these Google Play Developer Policy Violation Emails?"></a><a href="https://medium.com/@ali.muzaffar/did-you-get-one-of-these-google-play-developer-policy-violation-emails-6c529ceb082d#.glctt861o" target="_blank" rel="external">Did you get one of these Google Play Developer Policy Violation Emails?</a></h2><p>如果你的应用使用了一些”dangerous permissions”, 你需要在应用或者Google Play上附有privacy policy, 否则你就会收到Google Play的邮件.</p>
<p>作者他的Demo app也收到了这种邮件, 所以他提供了他的解决方法.</p>
<p>他找到了这个<a href="https://privacypolicytemplate.net/" target="_blank" rel="external">网站</a>, 这是他最后写成的<a href="https://gist.github.com/alphamu/c42f6c3fce530ca5e804e672fed70d78" target="_blank" rel="external">Gist</a>. 利用<a href="https://rawgit.com/" target="_blank" rel="external">RawGit</a>可以将github上的文件url转成用HTML显示的url. 之后在app中设置一个链接, 点击打开这个url就可以了.</p>
<h2 id="Pushing-the-limits-of-Kotlin-annotation-processing"><a href="#Pushing-the-limits-of-Kotlin-annotation-processing" class="headerlink" title="Pushing the limits of Kotlin annotation processing"></a><a href="https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711#.7crkk5m68" target="_blank" rel="external">Pushing the limits of Kotlin annotation processing</a></h2><p>关于Kotlin的annotation processor支持, 是一个很复杂的问题, 作者讨论了关于这个问题的历史进展和当前的局限性.</p>
<h2 id="Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming"><a href="#Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming" class="headerlink" title="Pull vs Push &amp; Imperative vs Reactive - Reactive Programming"></a><a href="http://www.uwanttolearn.com/android/pull-vs-push-imperative-vs-reactive-reactive-programming-android-rxjava2-hell-part2/" target="_blank" rel="external">Pull vs Push &amp; Imperative vs Reactive - Reactive Programming</a></h2><p>作者用浅显的代码例子解释了Pull和Push模式的区别, 一个是自己不停地查询读取, 另一个是等改变发生的时候收到通知. </p>
<h2 id="Why-Android-Testing-is-so-Hard-Historical-Edition"><a href="#Why-Android-Testing-is-so-Hard-Historical-Edition" class="headerlink" title="Why Android Testing is so Hard: Historical Edition"></a><a href="https://www.philosophicalhacker.com/post/why-android-testing-is-so-hard-historical-edition/" target="_blank" rel="external">Why Android Testing is so Hard: Historical Edition</a></h2><p>为什么Android项目这么难测试呢? 作者认为主要有三方面的历史原因: </p>
<ul>
<li>Performance方面的考虑. </li>
<li>对Android组件的误解.</li>
<li>Android和Unit Testing出现的时机.</li>
</ul>
<h2 id="Sharing-files-though-Intents-are-you-ready-for-Nougat"><a href="#Sharing-files-though-Intents-are-you-ready-for-Nougat" class="headerlink" title="Sharing files though Intents: are you ready for Nougat?"></a><a href="https://medium.com/@quiro91/sharing-files-though-intents-are-you-ready-for-nougat-70f7e9294a0b#.h3f06hxg7A" target="_blank" rel="external">Sharing files though Intents: are you ready for Nougat?</a></h2><p>Android 7 Nougat引入了一些文件系统的权限变化, 来增强安全性.</p>
<p>如果你已经把<code>targetSdkVersion</code>升到了24+, 并且你用Intent发送一个<code>file:// URI</code>, 你将会得到一个<code>FileUriExposedException</code>.</p>
<p>解决办法是使用<code>FileProvider</code>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="SlidingSquaresLoader"><a href="#SlidingSquaresLoader" class="headerlink" title="SlidingSquaresLoader"></a><a href="https://github.com/biodunalfet/SlidingSquaresLoader" target="_blank" rel="external">SlidingSquaresLoader</a></h2><p>一个有趣的动画方块的loading图案.</p>
<h2 id="ason"><a href="#ason" class="headerlink" title="ason"></a><a href="https://github.com/afollestad/ason" target="_blank" rel="external">ason</a></h2><p>一个JSON库, 简化了序列化, 更易使用.</p>
<h2 id="Intro-To-RxJava"><a href="#Intro-To-RxJava" class="headerlink" title="Intro-To-RxJava"></a><a href="https://github.com/PareshMayani/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a></h2><p>上一期有一篇文章提过的RxJava练习项目.</p>
<h2 id="chuck"><a href="#chuck" class="headerlink" title="chuck"></a><a href="https://github.com/jgilfelt/chuck" target="_blank" rel="external">chuck</a></h2><p>An in-app HTTP inspector for Android OkHttp clients.<br>截取请求和响应, 点击通知可以查看UI显示.</p>
<h2 id="android-parcelable-intellij-plugin-kotlin"><a href="#android-parcelable-intellij-plugin-kotlin" class="headerlink" title="android-parcelable-intellij-plugin-kotlin"></a><a href="https://github.com/nekocode/android-parcelable-intellij-plugin-kotlin" target="_blank" rel="external">android-parcelable-intellij-plugin-kotlin</a></h2><p>为kotlin的类生成Parcelable代码的插件.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-244&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-244&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #244&quot;&gt;&lt;/a&gt;Android Weekly Issue #244&lt;/h1&gt;&lt;p&gt;February 12th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-244&quot;&gt;Android Weekly Issue #244&lt;/a&gt;&lt;br&gt;本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送&lt;code&gt;file:// URI&lt;/code&gt;, 应用需要改用&lt;code&gt;FileProvider&lt;/code&gt;实现原有功能.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://mengdd.github.io/tags/Fragment/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="ClassyShark" scheme="http://mengdd.github.io/tags/ClassyShark/"/>
    
      <category term="Permission" scheme="http://mengdd.github.io/tags/Permission/"/>
    
      <category term="Privacy Policy" scheme="http://mengdd.github.io/tags/Privacy-Policy/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 243</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/</id>
    <published>2017-02-07T04:52:37.000Z</published>
    <updated>2017-02-07T04:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-243"><a href="#Android-Weekly-Issue-243" class="headerlink" title="Android Weekly Issue #243"></a>Android Weekly Issue #243</h1><p>February 5th, 2017<br><a href="http://androidweekly.net/issues/issue-243" target="_blank" rel="external">Android Weekly Issue #243</a><br>本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;<br>Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Constraint-Layout-Animations"><a href="#Constraint-Layout-Animations" class="headerlink" title="Constraint Layout Animations"></a><a href="http://www.uwanttolearn.com/android/constraint-layout-animations-dynamic-constraints-ui-java-hell/" target="_blank" rel="external">Constraint Layout Animations</a></h2><p>作者举例说明了如何在Java代码中动态地改变约束条件, 从而使<code>ConstraintLayout</code>中的View动起来.</p>
<h2 id="Android-Testing-with-Kotlin"><a href="#Android-Testing-with-Kotlin" class="headerlink" title="Android Testing with Kotlin"></a><a href="http://fernandocejas.com/2017/02/03/android-testing-with-kotlin/" target="_blank" rel="external">Android Testing with Kotlin</a></h2><p>如果你想逐渐地迁移代码到Kotlin, 你可以从测试开始, 这样你也不用更改产品环境的代码, 就先熟悉了Kotlin.</p>
<p>本篇文章详细讲了如何setup, 然后写各种测试:</p>
<h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>需要JUnit, <a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>和<a href="https://github.com/MarkusAmshove/Kluent" target="_blank" rel="external">Kluent</a>.</p>
<p>对于在<code>setUp()</code>方法中初始化的变量, 需要标记为<code>lateinit</code>.</p>
<h3 id="Robolectric测试"><a href="#Robolectric测试" class="headerlink" title="Robolectric测试"></a>Robolectric测试</h3><p>作者封装了一个基类, 把所有Mockito相关的东东包装在里面. 这样在Mockito升级的时候不用更改每一个测试文件.</p>
<h3 id="Espresso测试"><a href="#Espresso测试" class="headerlink" title="Espresso测试"></a>Espresso测试</h3><p>同样, 这里作者也创建了几个基类, 将所有Espresso相关的东东包装起来.</p>
<h2 id="Practical-challenges-for-RxJava-learners"><a href="#Practical-challenges-for-RxJava-learners" class="headerlink" title="Practical challenges for RxJava learners"></a><a href="https://medium.com/@sergii/practical-challenges-for-rxjava-learners-1821c454de9#.9icb22hrr" target="_blank" rel="external">Practical challenges for RxJava learners</a></h2><p>作者建议通过实践来检验和学习RxJava技能, 之前他用过这个Repo: <a href="https://github.com/Froussios/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a>, 现在他又新推出了这个<a href="https://github.com/sergiiz/RxBasicsKata" target="_blank" rel="external">Repo</a>, 针对RxJava2的.</p>
<h2 id="Coordinators-solving-a-problem-you-didn’t-even-know-you-had"><a href="#Coordinators-solving-a-problem-you-didn’t-even-know-you-had" class="headerlink" title="Coordinators: solving a problem you didn’t even know you had"></a><a href="https://hackernoon.com/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf#.mcx15cssl" target="_blank" rel="external">Coordinators: solving a problem you didn’t even know you had</a></h2><p>Square发布了一个库叫<a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a>, 这个库是用来分离View中的一些控制逻辑.</p>
<h2 id="Review-Reporter-Part-1"><a href="#Review-Reporter-Part-1" class="headerlink" title="Review-Reporter: Part 1 "></a><a href="https://medium.com/azimolabs/review-reporter-part-1-connecting-to-google-play-8abd37edc49f#.a0s5gx66j" target="_blank" rel="external">Review-Reporter: Part 1 </a></h2><p>作者他们做了一个小项目: <a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a>, 可以自动把Google Play上新的用户回复发到slack, firebase, Jira上. 本篇文章讲了他们是怎么做的.</p>
<h2 id="How-to-test-a-Service"><a href="#How-to-test-a-Service" class="headerlink" title="How to test a Service"></a><a href="https://medium.com/@josiassena/android-how-to-unit-test-a-service-67e5340544a5#.qg3751nxg" target="_blank" rel="external">How to test a Service</a></h2><p>Android官方文档介绍了如何测试Service: <a href="https://developer.android.com/training/testing/integration-testing/service-testing.html" target="_blank" rel="external">Testing your Service</a>. 本文作者介绍他是如何做的.</p>
<h2 id="Introducing-Lottie"><a href="#Introducing-Lottie" class="headerlink" title="Introducing Lottie"></a><a href="https://medium.com/airbnb-engineering/introducing-lottie-4ff4a0afac0e#.e7wojthmp" target="_blank" rel="external">Introducing Lottie</a></h2><p><a href="http://airbnb.design/lottie/" target="_blank" rel="external">Lottie</a>是一个iOS, Android和React Native的库, 可以实时渲染After Effects的动画, 让native的应用像使用静态文件一样简单地使用复杂的动画.</p>
<h2 id="Learning-to-use-and-abuse-Mutability"><a href="#Learning-to-use-and-abuse-Mutability" class="headerlink" title="Learning to use and abuse Mutability"></a><a href="https://medium.com/google-developer-experts/learning-to-use-and-abuse-mutability-b4c71576299#.diungnuw6" target="_blank" rel="external">Learning to use and abuse Mutability</a></h2><blockquote>
<p>An immutable class is a class whose state cannot be changed once it has been created.</p>
</blockquote>
<p>这篇文章分享了作者关于Java中的mutability &amp; immutability的一些想法.</p>
<h2 id="A-Curious-Case-of-Multiple-Locales"><a href="#A-Curious-Case-of-Multiple-Locales" class="headerlink" title="A Curious Case of Multiple Locales"></a><a href="https://blog.egorand.me/a-curious-case-of-multiple-locales/" target="_blank" rel="external">A Curious Case of Multiple Locales</a></h2><p>Android N的一个新feature就是可以在设置中选择多种语言.</p>
<p>比如一个用户, 她会说意大利语和德语, 她使用的是一个低于Android 7的手机, 她把手机语言设置为意大利语.</p>
<p>有一个app, 支持两种语言, 默认是英语, 然后还支持德语.</p>
<p>但是这个应用在这个用户的手机上打开时, 发现自己并不支持意大利语, 于是会显示英语(默认)而不是德语, 因为应用又不知道这个用户还会德语.</p>
<p>后来用户把手机升级了, 用了Android 7的系统, 她发现可以设置支持多种语言, 于是, 于是她设置了两种语言, 意大利语和德语. 在新手机上装之前那个app的时候发现现在显示的是德语.</p>
<p>因为应用现在知道了用户还会讲德语.</p>
<p>现在, 假设我们需要进行向下兼容以前的旧版本设备, 我们加入了<code>appcompat-v7</code>, 用户更新后, 英语又出现了. </p>
<p>这是因为<code>appcompat-v7</code>中含有一些意大利语的资源, 因为所有的资源在build的时候都会merge到一起, 所以现在app也包含了这些资源. 系统认为现在app能够支持用户的第一语言了, 然后就查找对应的资源, 当然没查找到, 于是就使用了默认资源, 也就是英语.</p>
<p>我们有什么办法可以解决这个问题呢? 答案是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;  </div><div class="line">  ...</div><div class="line"></div><div class="line">  resConfigs &quot;en&quot;, &quot;de&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就告诉了Gradle我们只支持这两种语言, 所有其他的资源都不会被打包进来.</p>
<p>验证的方法是使用Android Studio的<code>Analyze APK</code>来查看string有多少种configurations.</p>
<h2 id="Use-StrictMode-To-Find-Things-You-Did-By-Accident"><a href="#Use-StrictMode-To-Find-Things-You-Did-By-Accident" class="headerlink" title="Use StrictMode To Find Things You Did By Accident"></a><a href="https://blog.mindorks.com/use-strictmode-to-find-things-you-did-by-accident-in-android-development-4cf0e7c8d997#.l5tbilx16" target="_blank" rel="external">Use StrictMode To Find Things You Did By Accident</a></h2><p><code>StrictMode</code>是一个开发工具, 用于发现一些问题, 好让你来修复它们. </p>
<p>一个常用的情景是用来捕捉主线程的IO操作, 避免ANR弹框.</p>
<p>如何使用呢? 很简单, 只需要在应用启动时初始化一下, 可以是你的Application, Activity或其他组件的<code>onCreate()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</div><div class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</div><div class="line">                .detectDiskReads()</div><div class="line">                .detectDiskWrites()</div><div class="line">                .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></div><div class="line">                .penaltyLog()</div><div class="line">                .build());</div><div class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</div><div class="line">                .detectLeakedSqlLiteObjects()</div><div class="line">                .detectLeakedClosableObjects()</div><div class="line">                .penaltyLog()</div><div class="line">                .penaltyDeath()</div><div class="line">                .build());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以决定检测到问题时要发生什么, 比如:</p>
<ul>
<li><code>penaltyDeath()</code>: 整个进程崩溃.</li>
<li><code>penaltyDialog()</code>: 显示Dialog.</li>
<li><code>penaltyLog()</code>: 显示log.</li>
</ul>
<p>更多的处理见: <a href="https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html" target="_blank" rel="external">StrictMode.ThreadPolicy.Builder</a>.</p>
<p>StrictMode文档: <a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">StrictMode</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-material-stepper"><a href="#android-material-stepper" class="headerlink" title="android-material-stepper"></a><a href="https://github.com/stepstone-tech/android-material-stepper" target="_blank" rel="external">android-material-stepper</a></h2><p>一个Material steppers的库, 类似于配合ViewPager使用的indicators.</p>
<h2 id="AOSP-Support-Library-Contribution-Guide"><a href="#AOSP-Support-Library-Contribution-Guide" class="headerlink" title="AOSP Support Library Contribution Guide"></a><a href="https://android.googlesource.com/platform/frameworks/support/" target="_blank" rel="external">AOSP Support Library Contribution Guide</a></h2><p>Google开放了对support library的bug修改和文档更新.</p>
<h2 id="sqlite-android"><a href="#sqlite-android" class="headerlink" title="sqlite-android"></a><a href="https://github.com/requery/sqlite-android" target="_blank" rel="external">sqlite-android</a></h2><p>一个Android的SQLite库, 包含了最新的SQLite版本.</p>
<h2 id="Review-Reporter"><a href="#Review-Reporter" class="headerlink" title="Review-Reporter"></a><a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a></h2><p>Google Play反馈的自动提示, 支持提示到Slack和Jira.</p>
<h2 id="SimpleRecyclerView"><a href="#SimpleRecyclerView" class="headerlink" title="SimpleRecyclerView"></a><a href="https://github.com/jaychang0917/SimpleRecyclerView" target="_blank" rel="external">SimpleRecyclerView</a></h2><p>更简单好用的RecyclerView.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-243&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-243&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #243&quot;&gt;&lt;/a&gt;Android Weekly Issue #243&lt;/h1&gt;&lt;p&gt;February 5th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-243&quot;&gt;Android Weekly Issue #243&lt;/a&gt;&lt;br&gt;本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;&lt;br&gt;Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Service" scheme="http://mengdd.github.io/tags/Service/"/>
    
      <category term="Lottie" scheme="http://mengdd.github.io/tags/Lottie/"/>
    
      <category term="Mutability" scheme="http://mengdd.github.io/tags/Mutability/"/>
    
      <category term="Locales" scheme="http://mengdd.github.io/tags/Locales/"/>
    
      <category term="StrictMode" scheme="http://mengdd.github.io/tags/StrictMode/"/>
    
  </entry>
  
  <entry>
    <title>Say Hello to ConstraintLayout</title>
    <link href="http://mengdd.github.io/Android/2017/02/06/hello-constraint-layout/"/>
    <id>http://mengdd.github.io/Android/2017/02/06/hello-constraint-layout/</id>
    <published>2017-02-06T07:49:03.000Z</published>
    <updated>2017-02-06T07:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConstraintLayout介绍"><a href="#ConstraintLayout介绍" class="headerlink" title="ConstraintLayout介绍"></a>ConstraintLayout介绍</h2><p><code>ConstraintLayout</code>让你可以在很平的view结构(没有多层布局嵌套)中构建一个复杂的布局结构. 有点像<code>RelativeLayout</code>, 所有的view都是根据它和兄弟View和父layout的关系布局的, 但是它比<code>RelativeLayout</code>要更加灵活, 在Layout Editor中也更加好用.</p>
<a id="more"></a>
<p>在Layout Editor中你可以直接靠拖拽来构建<code>ConstraintLayout</code>.</p>
<p>为了在<code>ConstraintLayout</code>中定义一个view的位置, 你必须给view加上两条或多条约束(constraints). 每一条约束代表了一种和其他View(或parent, 或不可见的guideline)之间的联系或者对齐关系.</p>
<p>每一条约束都规定了这个view沿着水平或竖直轴的一个位置, 所以每个View在每个轴上都必须至少有一条约束(但是通常需要更多).</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>首先确认下载support库, 在<code>Tools &gt; Android &gt; SDK Manager</code>的<code>SDK Tools</code>tab下:<br>展开<code>Support Repository</code>, check <code>ConstraintLayout for Android</code>和<code>Solver for ConstraintLayout</code>.<br>Check <code>Show Package Details</code>, 显示版本信息.</p>
<p>比如当前我最新的版本信息是1.0.0-beta4, 我在module的build.gradle中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后点击Sync即可.</p>
<h2 id="转换已有布局"><a href="#转换已有布局" class="headerlink" title="转换已有布局"></a>转换已有布局</h2><p>我们可以新建布局, 然后让它的根节点是<code>android.support.constraint.ConstraintLayout</code>.</p>
<p>除此之外, 我们还可以直接转换已有布局.<br>打开Layout, 切换到<code>Design</code>tab, 然后在<code>Component Tree</code>窗口, 右击布局然后选择最底部的<code>Convert XXXLayout(这里是你布局节点的类型) to ConstraintLayout</code>.</p>
<h2 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h2><p>在Design模式下, 从Palette窗口中拖一个View到editor中去. 当你把一个View加入到ConstraintLayout中之后, 它会展示出一个bounding box, 四角的四个小方块用来拖拽调节大小, 每一个边上都有一个小圆点用来建立约束.<br>这些小方块和小圆点都被称为<code>handles</code>.</p>
<p>点击View, 然后点击并拖住一个约束handle, 把它拖拽到一个可用的anchor point(另一个View的边缘, layout的边缘, 或者一个guideline).当你松手的时候, 约束就生效了. (有一个默认的<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-margins" target="_blank" rel="external">margin</a>)</p>
<p>有几个规则:</p>
<ul>
<li>每个View都至少有两条约束: 一个水平的一个竖直的.</li>
<li>你只能在共享平面的handle和anchor point之间建立约束. 比如一个View的竖直平面只能和另一个竖直平面建立约束, baseline也只能和其他baseline建立约束.</li>
<li>每一个handle只能被用来建立一个约束, 但是你可以对一个anchor point建立(来自多个View的)多个约束.</li>
</ul>
<p>要删掉一个约束, 只需要选择这个view, 点击那个对应的handle.</p>
<p>如果你给同一个View加了两个相反的约束, 约束的线条就会变成弹簧状, 来显示两个相反方向的约束.  当View内容的尺寸固定或者是wrap的时候, 在这种情况下View就会在两个约束下居中显示, 如果你想让它展开, 那么就应该修改它的尺寸为<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-size" target="_blank" rel="external">Any Size</a>; 如果你想要保持当前的尺寸, 你可以<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-constraint-bias" target="_blank" rel="external">调节约束的权重</a>.</p>
<p>通常情况下可以加的有这几种约束:</p>
<ul>
<li>Parent constraint: View的边和Parent的边的关系.</li>
<li>Position constraint: View之间水平和竖直的位置关系, 拖动可改变相对的margin距离.</li>
<li>Alignment constraint: View边之间的对齐关系, 对齐后可以调节偏移量.</li>
<li>Baseline alignment constraint: 对齐View的text baseline, 要创建baseline约束, 首先选中View, 然后把鼠标放在baseline上方两秒钟, 等它变白就可以拖到另一个baseline去建立约束了.</li>
<li>Constrain to a guideline: 可以创建竖直或水平的guideline, 然后往上绑定约束, guideline对于用户来说是不可见的. 放置guideline的时候可以根据相对于layout边缘dp单位的距离, 也可以根据百分比.<br>Toolbar上有Guideline的按钮, 点击可选择水平或竖直.<br>点击Guideline尾部的小圆圈可以切换它到底是根据距离还是百分比放置的, 然后拖动它放到一个想要的位置.</li>
</ul>
<h2 id="使用Autoconnect和Infer-Constraints"><a href="#使用Autoconnect和Infer-Constraints" class="headerlink" title="使用Autoconnect和Infer Constraints"></a>使用Autoconnect和Infer Constraints</h2><p>当打开<code>Autoconnect</code>模式之后, 每一个<strong>新加的View</strong>都会自动创建约束. Autoconnect模式默认是关闭的.</p>
<p>点击<code>Infer Constraints</code>会给layout中当前所有的View创建约束, 这是一个一次性的action. 它会选择建立最有效的约束, 所以它可能会建立离得很远的两个view之间的约束. 不像Autoconnect模式开启下, 只给新加的View建立约束, 并且只选择最近的元素.</p>
<h2 id="调整View大小"><a href="#调整View大小" class="headerlink" title="调整View大小"></a>调整View大小</h2><p>可以通过拖拽View四个角的handles来改变View的大小, 但是这样生成的是hard-coded的尺寸, 对于适配来讲这样是不好的.</p>
<p>你可以点击View然后在Properties窗口编辑尺寸.<br><img src="/images/constraint-layout-properties-window.png" alt="ConstraintLayout Properties Window"></p>
<p>有三种尺寸模式:</p>
<ul>
<li>Wrap Content:  用<code>&gt;&gt;&gt;</code>图形表示.</li>
<li>Any Size: 用弹簧图形表示. 说明View会一直展开到满足所有约束, 实际的值是0dp. 可以把它想象成”match constraints”. 如果此时只有单边的约束, 那么它只展开到能放下自己的内容为止. </li>
<li>Fixed: 用图形<code>|-|</code>表示, 固定尺寸.</li>
</ul>
<p>可以通过点击图形符号来切换这些模式.</p>
<p>注意: 在<code>ConstraintLayout</code>中的View中不应该使用<code>match_parent</code>, 而是用”Any Size”(0dp).</p>
<h2 id="调整约束偏差"><a href="#调整约束偏差" class="headerlink" title="调整约束偏差"></a>调整约束偏差</h2><p>当你给一个View的对立两边都添加了约束, 而View的尺寸是fixed或者wrap_content, 那么默认情况下View就会居中显示在两个anchor point之间(bias=50%).<br>你可以通过拖拽View或者在Properties窗口中拖拽bias slider来改变它的偏移权重.</p>
<h2 id="调节View边距"><a href="#调节View边距" class="headerlink" title="调节View边距"></a>调节View边距</h2><p>可以在toolbar上点击默认边距(8)来修改.</p>
<p>注意这个修改只对修改后新添加的View生效.</p>
<p>每一个View的边距都可以通过Properties窗口修改: 点击约束线条上的margin数字.</p>
<p>注意提供的值都是8的倍数, 以确保你遵循了Material Design的建议.</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="https://developer.android.com/training/constraint-layout/index.html" target="_blank" rel="external">Build a Responsive UI with ConstraintLayout</a></li>
<li>Demo: <a href="https://github.com/mengdd/HelloConstraintLayout" target="_blank" rel="external">HelloConstraintLayout</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ConstraintLayout介绍&quot;&gt;&lt;a href=&quot;#ConstraintLayout介绍&quot; class=&quot;headerlink&quot; title=&quot;ConstraintLayout介绍&quot;&gt;&lt;/a&gt;ConstraintLayout介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConstraintLayout&lt;/code&gt;让你可以在很平的view结构(没有多层布局嵌套)中构建一个复杂的布局结构. 有点像&lt;code&gt;RelativeLayout&lt;/code&gt;, 所有的view都是根据它和兄弟View和父layout的关系布局的, 但是它比&lt;code&gt;RelativeLayout&lt;/code&gt;要更加灵活, 在Layout Editor中也更加好用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 242</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/02/03/android-weekly-notes-issue-242/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/02/03/android-weekly-notes-issue-242/</id>
    <published>2017-02-03T09:27:49.000Z</published>
    <updated>2017-02-03T09:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-242"><a href="#Android-Weekly-Issue-242" class="headerlink" title="Android Weekly Issue #242"></a>Android Weekly Issue #242</h1><p>January 29th, 2017<br><a href="http://androidweekly.net/issues/issue-242" target="_blank" rel="external">Android Weekly Issue #242</a><br>本期内容包括: Android中常用的设计模式; 基于NoSQL的移动对象数据库–ObjectBox; MVC, MVP和MVVM模式的讨论; 一个Google Actions的Java SDK; 一个带黏性动画的FAB的实现; Kotlin 1.1的新功能; Firebase的实时数据库讨论; Model-View-Intent模式应用的实现; 关于实现gradient时透明颜色的使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Common-Design-Patterns-for-Android"><a href="#Common-Design-Patterns-for-Android" class="headerlink" title="Common Design Patterns for Android"></a><a href="https://www.raywenderlich.com/109843/common-design-patterns-for-android" target="_blank" rel="external">Common Design Patterns for Android</a></h2><h3 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h3><ul>
<li>Builder</li>
<li>依赖注入: 举例: Dagger </li>
<li>Singleton</li>
</ul>
<h3 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h3><ul>
<li>Adapter</li>
<li>Facade: 举例: Retrofit</li>
</ul>
<h3 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h3><ul>
<li>Command: 举例: EventBus</li>
<li>Observer: 举例: RxAndroid</li>
<li>Model View Controller</li>
<li>Model View ViewModel</li>
</ul>
<h2 id="ObjectBox-The-new-Mobile-Database"><a href="#ObjectBox-The-new-Mobile-Database" class="headerlink" title="ObjectBox - The new Mobile Database"></a><a href="http://greenrobot.org/announcement/introducing-objectbox-beta/" target="_blank" rel="external">ObjectBox - The new Mobile Database</a></h2><p><a href="http://greenrobot.org/objectbox/" target="_blank" rel="external">ObjectBox</a>是greenrobot发布的一个新的mobile对象数据库, 主要关注于性能, 据说superfast.</p>
<p>在ObjectBox中, 主要是把NoSQL技术迁移到mobile端使用. 之前他们创建的greenDAO, 据说是最快的Object/Relational Mapper (ORM) for Android and SQLite.</p>
<p>ObjectBox的5大特性:</p>
<ul>
<li>Superfast.</li>
<li>Object API.</li>
<li>Instant unit testing.</li>
<li>Simple threading.</li>
<li>No manual schema migrations.</li>
</ul>
<p><a href="http://greenrobot.org/objectbox/documentation/" target="_blank" rel="external">文档</a><br><a href="https://github.com/greenrobot/ObjectBoxExamples" target="_blank" rel="external">Demo</a></p>
<h2 id="MVC-vs-MVP-vs-MVVM-on-Android"><a href="#MVC-vs-MVP-vs-MVVM-on-Android" class="headerlink" title="MVC vs. MVP vs. MVVM on Android"></a><a href="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/" target="_blank" rel="external">MVC vs. MVP vs. MVVM on Android</a></h2><p>MVC, MVP, MVVM模式的介绍.</p>
<h2 id="Building-Google-Actions-with-Java"><a href="#Building-Google-Actions-with-Java" class="headerlink" title="Building Google Actions with Java"></a><a href="https://medium.com/@froger_mcs/building-google-actions-with-java-696cffedbd01#.d6uuck1ho" target="_blank" rel="external">Building Google Actions with Java</a></h2><p>非官方的<a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google Actions Java SDK</a>, 本文为开发者介绍其如何使用.</p>
<h2 id="Android-Gooey-FAB-is-EASY"><a href="#Android-Gooey-FAB-is-EASY" class="headerlink" title="Android Gooey FAB is EASY"></a><a href="http://myhexaville.com/2017/01/18/android-gooey-fab-easy/" target="_blank" rel="external">Android Gooey FAB is EASY</a></h2><p>实现一个胶黏的FAB.<br>首先作者展示了效果, 点击FAB, 从中逐渐分离中一个新的小按钮. 作者讨论了这种效果可能的实现方法:</p>
<ul>
<li>用bitmap的mesh transformation, 这是能高度自定义的.</li>
<li>创建自定义View, 自己绘制Path.</li>
<li>最简单的办法: 用Animated Vector Drawable, 即本文所介绍的方法.</li>
</ul>
<p>源码在这里: <a href="https://github.com/IhorKlimov/Android-Animations" target="_blank" rel="external">Android-Animations</a></p>
<h2 id="What-Comes-in-Kotlin-1-1-for-Android-Developers"><a href="#What-Comes-in-Kotlin-1-1-for-Android-Developers" class="headerlink" title="What Comes in Kotlin 1.1 for Android Developers?"></a><a href="https://blog.elpassion.com/what-comes-in-kotlin-1-1-for-android-developers-831d559f780f#.wlmujxwi3" target="_blank" rel="external">What Comes in Kotlin 1.1 for Android Developers?</a></h2><p>Kotlin 1.1的新features.</p>
<ul>
<li>Coroutines. 改善Kotlin中的异步编程.</li>
<li>Type Aliases. 可以为类型起别名.</li>
<li>Inlining Property Accessors.</li>
<li>Less Restrictive Inheritance. sealed类的子类不用再放在同一个类中; 非final的类现在也可以继承data类了.</li>
<li>Destructuring and Underscores.</li>
<li>Methods Count. 作者对比了一个sample程序, 用kotlin的不同版本, 发现用最新版kotlin确实会增加一些方法数, 但它仍然算是一个很轻量的库.</li>
</ul>
<h2 id="Understanding-the-Power-of-Firebase-Security-Rules"><a href="#Understanding-the-Power-of-Firebase-Security-Rules" class="headerlink" title="Understanding the Power of Firebase Security Rules"></a><a href="https://medium.com/@dftaiwo/understanding-the-power-of-firebase-security-rules-part-1-f46aae773a24#.cw34j1v2z" target="_blank" rel="external">Understanding the Power of Firebase Security Rules</a></h2><p>作者要写关于Firebase的一系列文章: 第一和第二篇主要介绍实时数据库的规则, 第三篇介绍Storage的规则.</p>
<p>关于实时数据库规则的主要内容包括:</p>
<ul>
<li>识别你的用户.</li>
<li>控制数据访问权限.</li>
<li>验证创建, 更新和删除操作.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-3"><a href="#Reactive-apps-with-Model-View-Intent-Part-3" class="headerlink" title="Reactive apps with Model-View-Intent - Part 3"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-3" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 3</a></h2><p>上一篇中介绍了用Model-View-Intent模式来构建一个单相数据流的简单屏. 这篇文章接着讲如何用MVI和state reducer来构建一个复杂屏.</p>
<p>(感觉太复杂了我没仔细看).</p>
<h2 id="Android-Dev-Tip-3-A-gotcha-with-color-transparent"><a href="#Android-Dev-Tip-3-A-gotcha-with-color-transparent" class="headerlink" title="Android Dev Tip #3: A gotcha with color/transparent"></a><a href="https://android.jlelse.eu/android-dev-tip-3-99da754151ad#.rarx8jafm" target="_blank" rel="external">Android Dev Tip #3: A gotcha with color/transparent</a></h2><p>如果你要在xml中用gradient写一个渐变色, 对于透明色<code>@android:color/transparent.</code>的使用一定要注意.</p>
<p>透明色<code>@android:color/transparent.</code>的色值是<code>#00000000</code>, 所以它实际上代表的是一个透明的黑色.</p>
<p>在gradient进行插值的时候, 会对ARGB每一个通道的色值都分别进行插值然后叠加.</p>
<p>所以如果你想要保持颜色不变, 只改变透明度, 也即Alpha通道的值, 你就应该把透明色中RGB颜色设置为和原来的颜色一样. </p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PreviewSeekBar"><a href="#PreviewSeekBar" class="headerlink" title="PreviewSeekBar"></a><a href="https://github.com/rubensousa/PreviewSeekBar" target="_blank" rel="external">PreviewSeekBar</a></h2><p>一个带Preview的SeekBar.</p>
<h2 id="AndroidTestingBox"><a href="#AndroidTestingBox" class="headerlink" title="AndroidTestingBox"></a><a href="https://roroche.github.io/AndroidTestingBox/" target="_blank" rel="external">AndroidTestingBox</a></h2><p>一个Android项目, 用于实验各种测试工具.</p>
<h2 id="FunctionalRx2"><a href="#FunctionalRx2" class="headerlink" title="FunctionalRx2"></a><a href="https://github.com/pakoito/FunctionalRx2" target="_blank" rel="external">FunctionalRx2</a></h2><p>a collection of constructs to simplify a functional programming approach to Java and Android.</p>
<h2 id="gradle-completion"><a href="#gradle-completion" class="headerlink" title="gradle-completion"></a><a href="https://github.com/eriwen/gradle-completion" target="_blank" rel="external">gradle-completion</a></h2><p>gradle的tab补全, for bash and zsh.</p>
<h2 id="ObjectBox"><a href="#ObjectBox" class="headerlink" title="ObjectBox"></a><a href="https://github.com/greenrobot/ObjectBox" target="_blank" rel="external">ObjectBox</a></h2><p>超快的移动平台对象数据库.</p>
<h2 id="superlightstack"><a href="#superlightstack" class="headerlink" title="superlightstack"></a><a href="https://github.com/nextdimension/superlightstack" target="_blank" rel="external">superlightstack</a></h2><p>一个轻量级的库, 用于创建View的stack, 并处理转换和状态维持.</p>
<h2 id="PicassoFaceDetectionTransformation"><a href="#PicassoFaceDetectionTransformation" class="headerlink" title="PicassoFaceDetectionTransformation"></a><a href="https://github.com/aryarohit07/PicassoFaceDetectionTransformation" target="_blank" rel="external">PicassoFaceDetectionTransformation</a></h2><p>一个配合picasso使用的图像转换库, 可以根据人脸检测自动确定范围而切图.</p>
<p>(Readme中附有配合Glide和Fresco使用的版本.)</p>
<h2 id="cwac-netsecurity"><a href="#cwac-netsecurity" class="headerlink" title="cwac-netsecurity"></a><a href="https://github.com/commonsguy/cwac-netsecurity" target="_blank" rel="external">cwac-netsecurity</a></h2><p>This library contains a backport of the Android 7.0 network security configuration subsystem.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-242&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-242&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #242&quot;&gt;&lt;/a&gt;Android Weekly Issue #242&lt;/h1&gt;&lt;p&gt;January 29th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-242&quot;&gt;Android Weekly Issue #242&lt;/a&gt;&lt;br&gt;本期内容包括: Android中常用的设计模式; 基于NoSQL的移动对象数据库–ObjectBox; MVC, MVP和MVVM模式的讨论; 一个Google Actions的Java SDK; 一个带黏性动画的FAB的实现; Kotlin 1.1的新功能; Firebase的实时数据库讨论; Model-View-Intent模式应用的实现; 关于实现gradient时透明颜色的使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="MVP" scheme="http://mengdd.github.io/tags/MVP/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="MVVM" scheme="http://mengdd.github.io/tags/MVVM/"/>
    
      <category term="MVC" scheme="http://mengdd.github.io/tags/MVC/"/>
    
      <category term="Color" scheme="http://mengdd.github.io/tags/Color/"/>
    
      <category term="Design Patterns" scheme="http://mengdd.github.io/tags/Design-Patterns/"/>
    
      <category term="ObjectBox" scheme="http://mengdd.github.io/tags/ObjectBox/"/>
    
      <category term="Google Actions" scheme="http://mengdd.github.io/tags/Google-Actions/"/>
    
      <category term="FAB" scheme="http://mengdd.github.io/tags/FAB/"/>
    
      <category term="Model-View-Intent" scheme="http://mengdd.github.io/tags/Model-View-Intent/"/>
    
      <category term="Gradient" scheme="http://mengdd.github.io/tags/Gradient/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 241</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/25/android-weekly-notes-issue-241/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/25/android-weekly-notes-issue-241/</id>
    <published>2017-01-25T01:40:01.000Z</published>
    <updated>2017-01-25T01:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-241"><a href="#Android-Weekly-Issue-241" class="headerlink" title="Android Weekly Issue #241"></a>Android Weekly Issue #241</h1><p>January 22nd, 2017<br><a href="http://androidweekly.net/issues/issue-241" target="_blank" rel="external">Android Weekly Issue #241</a><br>本期内容包括: 经典导航模式Master/Detail的设计和实现; APK的大小讨论和增量下载大小的预估工具; Model-View-Intent模式的讨论和实现; 分多个modules对build时间的影响; 测试中能够利用的一些Android特有的接缝设计(manifest, build config, resource).</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Case-Study-Master-Detail-Pattern-Revisited"><a href="#Case-Study-Master-Detail-Pattern-Revisited" class="headerlink" title="Case Study. Master/Detail Pattern Revisited"></a><a href="http://goneremote.io/master-detail-pattern/" target="_blank" rel="external">Case Study. Master/Detail Pattern Revisited</a></h2><p>Master/Detail是一种经典的导航流, master屏包含一个list, detail显示某一项的详细信息. <a href="https://developer.android.com/training/implementing-navigation/descendant.html" target="_blank" rel="external">Android Doc</a>.</p>
<p>作者讲了他适配多种屏幕(包括平板)的设计, 以及简单的实现.</p>
<h2 id="Tracking-app-update-sizes"><a href="#Tracking-app-update-sizes" class="headerlink" title="Tracking app update sizes"></a><a href="https://medium.com/google-developers/tracking-app-update-sizes-1a1f57634f7b#.v2ecs8u4t" target="_blank" rel="external">Tracking app update sizes</a></h2><p>以前作者有一系列的<a href="https://medium.com/google-developers/smallerapk-part-1-anatomy-of-an-apk-da83c25e7003#.dv2tfqdyq" target="_blank" rel="external">文章</a>讲过apk的组成以及如何减少apk的大小.</p>
<p>事实上app的大小可以分下面四种:</p>
<ul>
<li>提交到Google Play的APK文件大小.</li>
<li>初始的下载大小.</li>
<li>在设备上的安装大小.</li>
<li>更新下载大小.</li>
</ul>
<p>之前的一些文章可能都在讨论如何减少初始的大小, 但是大多数情况用户可能只安装你的应用一次, 之后就只是从Play Store更新, 所以应用的更新大小也是很重要的.</p>
<p>事实上Android Studio(2.2+)改善了打包apk的机制, (<a href="https://android-developers.googleblog.com/2016/11/understanding-apk-packaging-in-android-studio-2-2.html" target="_blank" rel="external">apk packaging</a>), 使得每一个build都尽可能地相似, 这样Play Store就能计算出一个较小的delta更新. 另外, Play Store也引入了新的算法, 比如最近的<a href="https://android-developers.googleblog.com/2016/12/saving-data-reducing-the-size-of-app-updates-by-65-percent.html" target="_blank" rel="external">File-By-File patching</a>, 同样也有效减小了更新的大小.</p>
<p>所以我们要注意的就是不要介入和干扰当前Android Studio和Play Store的这些优化, 比如不要用自定义的ZIP加密设置来自己压缩APK. 也不要用Zopfli来再次压缩APK.</p>
<p>Play Store上会显示应用的下载大小, 如果用户已经安装了, 则显示的是更新大小.</p>
<p>对于开发者来说, 如果能在发布前知道这些信息就更好了, 所以作者他们开源了这个库: <a href="https://github.com/googlesamples/apk-patch-size-estimator" target="_blank" rel="external">apk-patch-size-estimator</a></p>
<p>这是一个命令行的工具, 可以集成到CI里, 也可以手动比较两个apk文件.</p>
<p>这个工具实现了当前Play Store的算法, 可以帮你估计出初始的apk下载大小和更新下载大小.</p>
<p>(注意下载大小和apk文件大小不同因为Play Store可能会做进一步压缩.)</p>
<p>同样, Android Studio中也有一个图形化的 APK Analyzer工具, 可以做apk的比较, 让你看到到底是哪一部分的尺寸增长了.</p>
<h2 id="Reactive-Apps-with-Model-View-Intent-Part-2"><a href="#Reactive-Apps-with-Model-View-Intent-Part-2" class="headerlink" title="Reactive Apps with Model-View-Intent - Part 2"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-2" target="_blank" rel="external">Reactive Apps with Model-View-Intent - Part 2</a></h2><p>上一篇文章讨论了一个好的Model层可以解决很多问题. 这篇来介绍<code>Model-View-Intent</code>模式.</p>
<h3 id="Model-View-Intent模式"><a href="#Model-View-Intent模式" class="headerlink" title="Model-View-Intent模式"></a>Model-View-Intent模式</h3><p>Model-View-Intent模式是在一个JavaScript的framework <code>cycle.js</code>中提出的.</p>
<p><img src="/images/view-model-intent.png" alt="view-model-intent"></p>
<ul>
<li><code>intent()</code>: 这个方法接收用户输入, 然后输出将会作为参数传给<code>model()</code>.</li>
<li><code>model()</code>: 接收<code>intent()</code>的输出作为自己的输入, 来操纵Model, 这个方法的输出是一个新的Model(状态变化). 所以它不应该更新一个已经存在的Model. 因为我们想要不可变性. 注意这里是唯一一个允许创建新Model的地方.</li>
<li><code>view()</code>: 接收<code>model()</code>方法返回的model作为输入, 然后将其展示出来.</li>
</ul>
<h3 id="用RxJava连接"><a href="#用RxJava连接" class="headerlink" title="用RxJava连接"></a>用RxJava连接</h3><p>我们希望数据流是单向的, 于是我们用了RxJava, 它很适合这种基于事件的编程, 在这里主要是UI事件.</p>
<p>作者之后举了一个实现的例子, 在这个例子中他们的Model层用了ViewState后缀. <code>SearchInteractor</code>用来执行搜索, 返回的结果是<code>Observable&lt;SearchViewState&gt;</code>.</p>
<p>这个模式中定义的View接口里包含了<code>render()</code>方法, 根据传入的状态model显示UI; 这个View接口其实还包含了<code>intent()</code>的方法, 返回的是一个<code>Observable</code>, UI中用了<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>.</p>
<p>最后一步就是, 如何将View的intent和业务逻辑联系起来呢? 这里用到了一个额外的组件: <code>Presenter</code>.</p>
<p>这个Presenter看起来像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchPresenter</span> <span class="keyword">extends</span> <span class="title">MviBasePresenter</span>&lt;<span class="title">SearchView</span>, <span class="title">SearchViewState</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SearchInteractor searchInteractor;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindIntents</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;SearchViewState&gt; search =</div><div class="line">        intent(SearchView::searchIntent)</div><div class="line">            .switchMap(searchInteractor::search) <span class="comment">// I have used flatMap() in the video above, but switchMap() makes more sense here</span></div><div class="line">            .observeOn(AndroidSchedulers.mainThread());</div><div class="line"></div><div class="line">    subscribeViewState(search, SearchView::render);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>MviBasePresenter</code>是<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>中的一个类.<br>这个类做的事情就是当View第一次attach到Prensenter上时, 调用<code>bindIntent()</code>方法将来自view的intent绑定到业务逻辑上, 只有第一次会绑定, 当View再次attach时不会发生.</p>
<p>而<code>subscribeViewState()</code>方法则处理了定于管理, 避免内存泄露(具体原因见原文).</p>
<h2 id="How-modularization-affects-build-time-of-an-Android-application"><a href="#How-modularization-affects-build-time-of-an-Android-application" class="headerlink" title="How modularization affects build time of an Android application"></a><a href="https://medium.com/@nikita.kozlov/how-modularisation-affects-build-time-of-an-android-application-43a984ce9968#.hzgv3h6cm" target="_blank" rel="external">How modularization affects build time of an Android application</a></h2><p>一个Android应用至少有一个application module, build这个module之后得到一个.apk文件.</p>
<p>application module之间不能相互依赖, 它只能依赖于library, build library module的结果是得到一个.aar(Android Archive Library)文件.</p>
<p>build的过程可以粗略分为5个阶段:</p>
<ul>
<li>1.准备依赖.</li>
<li>2.Merge资源和manifest.</li>
<li>3.编译. 从annotation processors开始, 把源码编译成字节码.</li>
<li>4.后处理. 所有以<code>transform</code>开头的gradle tasks都属于这个阶段. 其中最重要的是<code>transformClassesWithMultidexlist</code>和<code>transformClassesWithDex</code>, 它们生成了.dex文件.</li>
<li>5.打包发布. 对library来说是生成.aar, 对application来说是生成.apk.</li>
</ul>
<p>我们都知道gradle只有在输入变化了的情况下才会重跑task. 而且如果一个module没有变化, 也不会被重新build, 那么就出现了一种假设: 多个module应用的增量build要比单个module的快, 因为只有被改变了的module才会重新编译.</p>
<p>作者想验证这种假设是否正确.<br>他用的工具就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradle assembleDebug --profile</div></pre></td></tr></table></figure></p>
<p>做了一系列实验之后证明这个假设还是有道理的.</p>
<p>实验过程中的一些发现:</p>
<p>1.当应用被拆分为多个modules之后, 改变application module中的代码, build时间会减少; 但是library中的代码, build时间反而会增加. 这是因为library build的时候debug和release的tasks都执行了(并不知道为什么).</p>
<p>当library module被这样添加的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile project(path: &apos;:app2&apos;)</div><div class="line">    compile project(path: &apos;:app3&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管app当前的build type是什么, app永远依赖的是library的release版本.</p>
<p>这是一个Gradle当前的限制. 参见<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Library-Publication" target="_blank" rel="external">Library-Publication</a>.</p>
<p>幸运的是, 我们可以改变这一行为:<br>首先在library中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        defaultPublishConfig &apos;release&apos;</div><div class="line">        publishNonDefault true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>让它也可以发布debug版.<br>在app中依赖的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    debugCompile project(path: &apos;:app2&apos;, configuration: &quot;debug&quot;)</div><div class="line">    releaseCompile project(path: &apos;:app2&apos;, configuration: &quot;release&quot;)</div><div class="line"></div><div class="line">    debugCompile project(path: &apos;:app3&apos;, configuration: &quot;debug&quot;)</div><div class="line">    releaseCompile project(path: &apos;:app3&apos;, configuration: &quot;release&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样debug和release都只依赖各自对应版本的library了.</p>
<p>2.不管我们改动的是library中的代码还是application中的代码, application module永远都会被重新编译, 所以减小app module的尺寸很有意义.</p>
<p>3.上面这些都是library之间互相独立的情况, 如果library之间还有相互依赖, 那么build时间也会变长.</p>
<p>4.如果应用超出了DEX的方法数限制, 用了multidex, 也会增加build时间, Android 5.0开始使用了一个叫做ART的runtime, 在这方面有一些优化, 可以减少build时间, 所以我们可以在开发的时候设置最小API是21: <a href="https://developer.android.com/studio/build/multidex.html#dev-build" target="_blank" rel="external">Optimize multidex in development builds</a>.</p>
<h2 id="Exploiting-Android-Seams-for-Testing-and-Flexibility"><a href="#Exploiting-Android-Seams-for-Testing-and-Flexibility" class="headerlink" title="Exploiting Android Seams for Testing and Flexibility"></a><a href="https://www.philosophicalhacker.com/post/exploiting-android-specific-seams-for-testing-and-flexibility/" target="_blank" rel="external">Exploiting Android Seams for Testing and Flexibility</a></h2><p>如何让Android应用代码可测试? 答案是创建一些接缝. 这篇文章中, 作者将一些Android特有的接缝, 来让我们的应用更加灵活和易测.</p>
<h3 id="Manifest接缝"><a href="#Manifest接缝" class="headerlink" title="Manifest接缝"></a>Manifest接缝</h3><p>使用<a href="https://developer.android.com/studio/build/manifest-merge.html#merge_rule_markers" target="_blank" rel="external">Merge rule markers</a>可以方便地更改manifest.</p>
<p>比如在build variant是mock的时候, 由于我们在src/mock/AndroidManifest.xml里这样写:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- src/mock/AndroidManifest.xml --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">  <span class="attr">android:name</span>=<span class="string">".StubConfigActivity"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">  <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">tools:node</span>=<span class="string">"remove"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以在build mock的时候, 启动Activity会被替换成上面这个<code>StubConfigActivity</code>.</p>
<p>还有更多的可能值得探索, 比如你可以替换filter的内容, 从而改变默认intent启动的Activity.</p>
<h3 id="BuildConfig接缝"><a href="#BuildConfig接缝" class="headerlink" title="BuildConfig接缝"></a>BuildConfig接缝</h3><p>在gradle中可以根据不同的build variant来定义<code>BuildConfig</code>中的变量值. </p>
<p>默认情况下<code>BuildConfig</code>中会包含一些有用的变量比如<code>DEBUG</code>和<code>FLAVOR</code>.</p>
<p>我们可以创建更多额外的变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">  mock &#123;</div><div class="line">    buildConfigField(&apos;Boolean&apos;, &apos;MOCK&apos;, &quot;true&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个简单的应用case是我们可以定义不同的base url:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">  buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;api.awesomecompany.com\&quot;&apos;)</div><div class="line">&#125;</div><div class="line">productFlavors &#123;</div><div class="line">  sandbox &#123;</div><div class="line">    buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;localhost:8080\&quot;&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Resource接缝"><a href="#Resource接缝" class="headerlink" title="Resource接缝"></a>Resource接缝</h3><p>不同build variants的资源就像manifest一样, 最后会被merged. 但是对于资源我们没有markers可以控制它们如何merge. </p>
<p>我们可以利用默认的merge行为: <a href="https://developer.android.com/studio/write/add-resources.html#resource_merging" target="_blank" rel="external">Resource merging</a>.</p>
<p>优先级是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</div></pre></td></tr></table></figure></p>
<p>所以我们可以把默认的资源放在main里, 然后在特定的build variant再创建一份覆盖它们.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Reptar"><a href="#Reptar" class="headerlink" title="Reptar"></a><a href="https://github.com/Commit451/Reptar" target="_blank" rel="external">Reptar</a></h2><p>RxJava2.x的有用的类的集合.</p>
<h2 id="Toasty"><a href="#Toasty" class="headerlink" title="Toasty"></a><a href="https://github.com/GrenderG/Toasty" target="_blank" rel="external">Toasty</a></h2><p>前面加了一个icon的Toast, 带背景颜色, 除了内置的error, info, success, warning等几种形式, 还可以自定义.</p>
<h2 id="Google-Actions-Java-SDK"><a href="#Google-Actions-Java-SDK" class="headerlink" title="Google-Actions-Java-SDK"></a><a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google-Actions-Java-SDK</a></h2><p>非官方的Google Actions Java SDK.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-241&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-241&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #241&quot;&gt;&lt;/a&gt;Android Weekly Issue #241&lt;/h1&gt;&lt;p&gt;January 22nd, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-241&quot;&gt;Android Weekly Issue #241&lt;/a&gt;&lt;br&gt;本期内容包括: 经典导航模式Master/Detail的设计和实现; APK的大小讨论和增量下载大小的预估工具; Model-View-Intent模式的讨论和实现; 分多个modules对build时间的影响; 测试中能够利用的一些Android特有的接缝设计(manifest, build config, resource).&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="APK" scheme="http://mengdd.github.io/tags/APK/"/>
    
      <category term="Master/Detail" scheme="http://mengdd.github.io/tags/Master-Detail/"/>
    
      <category term="MVI" scheme="http://mengdd.github.io/tags/MVI/"/>
    
      <category term="Build Time" scheme="http://mengdd.github.io/tags/Build-Time/"/>
    
      <category term="Toast" scheme="http://mengdd.github.io/tags/Toast/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 240</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/24/android-weekly-notes-issue-240/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/24/android-weekly-notes-issue-240/</id>
    <published>2017-01-24T02:50:19.000Z</published>
    <updated>2017-01-24T02:58:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-240"><a href="#Android-Weekly-Issue-240" class="headerlink" title="Android Weekly Issue #240"></a>Android Weekly Issue #240</h1><p>January 15th, 2017<br><a href="http://androidweekly.net/issues/issue-240" target="_blank" rel="external">Android Weekly Issue #240</a><br>Hello, 各位亲, 从本篇笔记开始, 以后并不包含Android Weekly的每一篇文章了, 只是选一些我感兴趣的做笔记. 想要看全部文章的还请点击上面的链接.</p>
<p>本期内容包括: 一个Android的RxJava教程; 关于测试中的注释讨论; Dagger2的实现细节讨论; Kotlin语言设计中和Effective Java相关的点和优化; Reactive app的构建模式, 一个好的model层的重要性; 怎样写数据库测试.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="RxAndroid-Tutorial"><a href="#RxAndroid-Tutorial" class="headerlink" title="RxAndroid Tutorial"></a><a href="https://www.raywenderlich.com/141980/rxandroid-tutorial" target="_blank" rel="external">RxAndroid Tutorial</a></h2><p>一个RxAndroid的Tutorial, 内容包括:</p>
<ul>
<li>Reactive Programming是什么. -&gt; 把reactive programming比喻成excel里面的表达式.</li>
<li>observable是什么.</li>
<li>如何把按钮点击和输入文字改变事件事件变为observables.</li>
<li>转换.</li>
<li>过滤.</li>
<li>指定线程.</li>
<li>把多个observables联合成一个.</li>
</ul>
<h2 id="Clean-tests-Part-2-Comments"><a href="#Clean-tests-Part-2-Comments" class="headerlink" title="Clean tests, Part 2: Comments"></a><a href="https://android.jlelse.eu/clean-tests-part-2-comments-4016ee82f186#.15u9kq7jz" target="_blank" rel="external">Clean tests, Part 2: Comments</a></h2><p>上一篇文章里作者讨论了测试代码的命名, 这篇讨论注释.<br>在测试里我们经常会见到这样的注释:</p>
<ul>
<li>// GIVEN</li>
<li>// WHEN</li>
<li>// THEN</li>
</ul>
<p>注意每一次添加注释的时候都应该想清楚自己的代码是不是能够自解释, 而不是依赖于注释. 这条原则同样适用于产品代码和测试代码.</p>
<p>为每一个测试重复这三行其实没有什么意义, 因为这个顺序是显而易见的.</p>
<p>理想情况下, 简单的测试并不需要这些注释就显得很好看了, 如果是复杂的测试, 一般执行应该是一行, 验证也应该是一行, 如果需要太多验证我们应该考虑把它们抽取成多个测试方法. 而关于准备阶段, 如果我们真的需要很多准备的代码, 这是一种code smell, 可能说明我们要测试的这个方法做了太多事情, 可能我们应该先重构一下再进行测试.</p>
<p>我们也应该好好利用<code>setUp()</code>方法, 让我们的测试看起来更干净.</p>
<p>最后建议用一些比较好的assert库让最后的断言语句看起来更易懂.</p>
<h2 id="Android-Dagger2-Critical-things-to-know-before-you-implement"><a href="#Android-Dagger2-Critical-things-to-know-before-you-implement" class="headerlink" title="Android Dagger2: Critical things to know before you implement"></a><a href="https://blog.mindorks.com/android-dagger2-critical-things-to-know-before-you-implement-275663aecc3e#.nxpqzmohn" target="_blank" rel="external">Android Dagger2: Critical things to know before you implement</a></h2><p>关于Dagger2的实现, 你应该搞清楚的几个关键点.</p>
<ul>
<li>实现单例的时候, 如果提供了@Provides方法, 那么@Singleton也要在这个provides方法上声明, 声明在类上是没有用的. (类的单例声明只和构造@Inject配合使用).</li>
<li>在component中提供了get方法后, 如果这个get方法没有被调用, 则对象不会被实例化.</li>
<li>Scope可以定义在该scope下的单例.</li>
</ul>
<h2 id="How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin"><a href="#How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin" class="headerlink" title="How “Effective Java” may have influenced the design of Kotlin"></a><a href="https://medium.com/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974#.nqwl31wn6" target="_blank" rel="external">How “Effective Java” may have influenced the design of Kotlin</a></h2><p>Kotlin的设计中考虑到的和Effective Java相关的几个点:</p>
<ul>
<li>Kotlin的构造默认参数值进一步简化了Builder模式.</li>
<li>更容易创建单例: 用object声明.</li>
<li>用了data声明后, 再也不用自己写<code>equals()</code>和<code>hashCode()</code>了.</li>
<li>properties自带了默认的get/set, 使用更加简洁, 也支持后续扩展.</li>
<li>Kotlin中的override关键字是强制的而不是可选的.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-1"><a href="#Reactive-apps-with-Model-View-Intent-Part-1" class="headerlink" title="Reactive apps with Model-View-Intent - Part 1"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-1" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 1</a></h2><p>作者用RxJava + Model-View-Intent (MVI)构建的Reactive App, 也即UI响应状态变化的App.</p>
<p>首先作者列举了Android流行的模式MVC, MVP, MVVM, 这里面都会有一个Model. 但是作者发现大多数时候程序并没有Model这一层.</p>
<p>构建一个好的Model层可以解决很多问题:</p>
<ul>
<li>状态.</li>
<li>屏幕方向旋转.</li>
<li>后退导航.</li>
<li>进程死亡.</li>
<li>不可变和单向的数据流.</li>
<li>可调试和重复的状态.</li>
<li>可测试性.</li>
</ul>
<p>最基本的理念就是把这个Model层作为唯一的真实状态来源.</p>
<h2 id="Testing-SQLite-on-Android-–-Medium"><a href="#Testing-SQLite-on-Android-–-Medium" class="headerlink" title="Testing SQLite on Android – Medium"></a><a href="https://medium.com/@MAFI8919/testing-sqlite-on-android-bfa0733e11e7#.a4hufzbc7" target="_blank" rel="external">Testing SQLite on Android – Medium</a></h2><p>如何写SQLite数据库测试.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Desertplaceholder"><a href="#Desertplaceholder" class="headerlink" title="Desertplaceholder"></a><a href="https://github.com/JetradarMobile/desertplaceholder" target="_blank" rel="external">Desertplaceholder</a></h2><p>一个沙漠空白页面.</p>
<h2 id="Android-SwitchIcon"><a href="#Android-SwitchIcon" class="headerlink" title="Android-SwitchIcon"></a><a href="https://github.com/zagum/Android-SwitchIcon" target="_blank" rel="external">Android-SwitchIcon</a></h2><p>Google launcher风格的Switch icon, enable时点亮, disable时灰去.</p>
<h2 id="SlidesCodeHighlighter"><a href="#SlidesCodeHighlighter" class="headerlink" title="SlidesCodeHighlighter"></a><a href="https://github.com/romannurik/SlidesCodeHighlighter" target="_blank" rel="external">SlidesCodeHighlighter</a></h2><p>一个web应用, 让你可以把带有高亮的代码拷贝进slides.</p>
<h2 id="GithubWidget"><a href="#GithubWidget" class="headerlink" title="GithubWidget"></a><a href="https://github.com/Nightonke/GithubWidget" target="_blank" rel="external">GithubWidget</a></h2><p>一个Github Widget, 显示Contributions, stars, followers, trending etc.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-240&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-240&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #240&quot;&gt;&lt;/a&gt;Android Weekly Issue #240&lt;/h1&gt;&lt;p&gt;January 15th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-240&quot;&gt;Android Weekly Issue #240&lt;/a&gt;&lt;br&gt;Hello, 各位亲, 从本篇笔记开始, 以后并不包含Android Weekly的每一篇文章了, 只是选一些我感兴趣的做笔记. 想要看全部文章的还请点击上面的链接.&lt;/p&gt;
&lt;p&gt;本期内容包括: 一个Android的RxJava教程; 关于测试中的注释讨论; Dagger2的实现细节讨论; Kotlin语言设计中和Effective Java相关的点和优化; Reactive app的构建模式, 一个好的model层的重要性; 怎样写数据库测试.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://mengdd.github.io/tags/Dagger2/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="SQLite" scheme="http://mengdd.github.io/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 239</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/10/android-weekly-notes-issue-239/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/10/android-weekly-notes-issue-239/</id>
    <published>2017-01-10T06:10:31.000Z</published>
    <updated>2017-03-09T05:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-239"><a href="#Android-Weekly-Issue-239" class="headerlink" title="Android Weekly Issue #239"></a>Android Weekly Issue #239</h1><p>January 8th, 2017<br><a href="http://androidweekly.net/issues/issue-239" target="_blank" rel="external">Android Weekly Issue #239</a><br>本期内容包括: Android Things开发; Android中有用却不常见的一些API介绍(拼写检查, 文字识别, 时间log, 截图, 创建PDF); Gradle依赖管理冲突和解决办法; Looper, Handler和HandlerThread; 兼顾Wear1.0和2.0的部署方式; 打开PDF的实现方法; 单元测试的命名; Robolectric的弊病; 迁移到RxJava2的好处和面临的挑战. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preparing-your-computer-for-Android-dev"><a href="#Preparing-your-computer-for-Android-dev" class="headerlink" title="Preparing your computer for Android dev"></a><a href="https://medium.com/@rafael_toledo/preparing-your-android-environment-for-development-android-tutorials-pt-1-5f76ca2b8a32#.yxa0bvkp5" target="_blank" rel="external">Preparing your computer for Android dev</a></h2><p>在Windows, OSX和Linux上设置开发环境.</p>
<h2 id="Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things"><a href="#Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things" class="headerlink" title="Beginner’s guide to Raspberry Pi 3 B and Android Things"></a><a href="http://www.andtuts.com/a-beginners-guide-to-raspberry-pi-3-b-and-android-things/" target="_blank" rel="external">Beginner’s guide to Raspberry Pi 3 B and Android Things</a></h2><p>如何Set up with Android Things.</p>
<h2 id="Creating-new-project-and-emulator-on-Android-Studio"><a href="#Creating-new-project-and-emulator-on-Android-Studio" class="headerlink" title="Creating new project and emulator on Android Studio"></a><a href="https://medium.com/@rafael_toledo/creating-a-new-project-and-an-emulator-on-android-studio-android-tutorials-2-35bd965ac42b#.lwlhy72wf" target="_blank" rel="external">Creating new project and emulator on Android Studio</a></h2><p>如何创建新项目和模拟器.</p>
<h2 id="Discovering-Android-API"><a href="#Discovering-Android-API" class="headerlink" title="Discovering Android API"></a><a href="https://blog.autsoft.hu/discovering-the-android-api-part-1/" target="_blank" rel="external">Discovering Android API</a></h2><p>Android是基于Java的, Java本身已经有四千多个类, Android API也有很多个类, 有一些不太常见但是却很有用的API我们应该了解一下.</p>
<p>这篇文章就旨在发现那些不常见却很有用的API, 并且附有一个<a href="https://github.com/peekler/GDG" target="_blank" rel="external">Demo</a>.</p>
<h3 id="No-1-Spell-Checker"><a href="#No-1-Spell-Checker" class="headerlink" title="No.1 - Spell Checker"></a>No.1 - Spell Checker</h3><p><a href="https://developer.android.com/reference/android/view/textservice/TextServicesManager.html" target="_blank" rel="external">TextServicesManager</a>从API 14开始支持, 可以发现拼写错误, 并返回正确的单词拼写.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextServicesManager tsm = (TextServicesManager) getSystemService(Context.TEXT_SERVICES_MANAGER_SERVICE);  </div><div class="line">SpellCheckerSession spellCheckerSession = tsm.newSpellCheckerSession(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">this</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<h3 id="No-2-Text-Recognizer"><a href="#No-2-Text-Recognizer" class="headerlink" title="No.2 - Text Recognizer"></a>No.2 - Text Recognizer</h3><p>Google Play Services Vision API中的文字识别.</p>
<p>Version API中包括了人脸识别, 二维码扫描和文字识别.</p>
<p>这个例子中可以从图像中扫描出文字信息.</p>
<h3 id="No-3-TimingLogger"><a href="#No-3-TimingLogger" class="headerlink" title="No.3 - TimingLogger"></a>No.3 - TimingLogger</h3><p><a href="https://developer.android.com/reference/android/util/TimingLogger.html" target="_blank" rel="external">TimingLogger</a>是用来测量流逝时间的一个好工具.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TimingLogger timings = <span class="keyword">new</span> TimingLogger(TAG, <span class="string">"methodA"</span>);</div><div class="line"><span class="comment">// ... do some work A ...</span></div><div class="line">timings.addSplit(<span class="string">"work A"</span>);</div><div class="line"><span class="comment">// ... do some work B ...</span></div><div class="line">timings.addSplit(<span class="string">"work B"</span>);</div><div class="line"><span class="comment">// ... do some work C ...</span></div><div class="line">timings.addSplit(<span class="string">"work C"</span>);</div><div class="line">timings.dumpToLog();</div></pre></td></tr></table></figure></p>
<p>最后一句执行后, 会在log中一次性输出下面的log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D/TAG     ( 3459): methodA: begin</div><div class="line">D/TAG     ( 3459): methodA:      9 ms, work A</div><div class="line">D/TAG     ( 3459): methodA:      1 ms, work B</div><div class="line">D/TAG     ( 3459): methodA:      6 ms, work C</div><div class="line">D/TAG     ( 3459): methodA: end, 16 ms</div></pre></td></tr></table></figure></p>
<p>注意需要在adb中使能TAG:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setprop log.tag.TAG_MYJOB VERBOSE</div></pre></td></tr></table></figure></p>
<p>假设本例子中TAG = “TAG_MYJOB”.</p>
<h3 id="No-4-Taking-screenshots"><a href="#No-4-Taking-screenshots" class="headerlink" title="No.4 - Taking screenshots"></a>No.4 - Taking screenshots</h3><p>有一些库可以提供截屏, 比如<a href="https://github.com/jraska/Falcon" target="_blank" rel="external">Falcon</a>. </p>
<p>在Android 21之上用<a href="https://developer.android.com/reference/android/media/projection/MediaProjection.html" target="_blank" rel="external">MediaProjection</a>甚至可以录屏.</p>
<p>但是得到屏幕图像更简单的一种方法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">View viewRoot = getWindow().getDecorView().getRootView();  </div><div class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">true</span>);  </div><div class="line">Bitmap screenShotAsBitmap = Bitmap.createBitmap(viewRoot.getDrawingCache());  </div><div class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">false</span>);  </div><div class="line"><span class="comment">// use screenShotAsBitmap as you need</span></div></pre></td></tr></table></figure></p>
<h3 id="No-5-PDF-Creation-API"><a href="#No-5-PDF-Creation-API" class="headerlink" title="No.5 - PDF Creation API"></a>No.5 - PDF Creation API</h3><p>从API 19开始Android就提供了API可以创建PDF文档.<br>文中的例子是创建了一个PDF文档, 然后把当前屏幕内容放进去.</p>
<h2 id="Avoiding-Conflicts-in-android-gradle-dependencies"><a href="#Avoiding-Conflicts-in-android-gradle-dependencies" class="headerlink" title="Avoiding Conflicts in android gradle dependencies"></a><a href="https://blog.mindorks.com/avoiding-conflicts-in-android-gradle-dependencies-28e4200ca235#.x66q6p4v4" target="_blank" rel="external">Avoiding Conflicts in android gradle dependencies</a></h2><p>如果两个依赖又都依赖了同一个库, 但是是不同的版本, 那会发生什么呢?</p>
<p>比如下面这个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">androidTestCompile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</div><div class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</div></pre></td></tr></table></figure></p>
<p>这两个库都依赖于”org.hamcrest:hamcrest-core”, 但是版本却不同.</p>
<p>这种情况下, 最终被包含进build的是最高版本的库.</p>
<p>在依赖被声明的module里运行下面这个命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew dependencies.</div></pre></td></tr></table></figure></p>
<p>会显式地看到gradle自动把第二个依赖中的hamcrest库从1.1升级到了1.3.</p>
<p>前面, 两个依赖都是test依赖, 所以gradle自动解决了冲突.  如果两个依赖属于不同的配置, 如, 把第一个<code>androidTestCompile</code>改为<code>compile</code>, gradle将会报错.</p>
<p>原因是:</p>
<blockquote>
<p>When instrumentation tests are run, both the main APK and test APK share the same classpath. Gradle build will fail if the main APK and the test APK use the same library (e.g. Guava) but in different versions. If gradle didn’t catch that, your app could behave differently during tests and during normal run (including crashing in one of the cases).</p>
</blockquote>
<p><strong>解决依赖冲突</strong><br>一旦有了依赖冲突, 就需要开发者决定最后到底用什么版本的库, 有几种解决方法:</p>
<ul>
<li>方法1: 从依赖中排除这个库.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Now junit will not include hamcrest library. Therefore there will be no </div><div class="line">//dependency conflict. </div><div class="line"> compile (&apos;junit:junit:4.12&apos;)&#123;</div><div class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">androidTestCompile (&apos;org.mockito:mockito-core:1.10.19&apos;)&#123;</div><div class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>真实的项目中可能有多个依赖依赖于同一个库, 那么我们就需要写多个排除语句.</p>
<ul>
<li>方法2: 显式地声明冲突库的版本.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</div><div class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</div><div class="line">androidTestCompile &apos;org.hamcrest:hamcrest-core:1.3&apos; //(We explictly mention </div><div class="line">//that include version 1.3)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方法不用写exclude, 但是当升级直接依赖库的时候需要注意更新这种间接依赖库的版本.</p>
<ul>
<li>方法3: 强制解析.</li>
</ul>
<p>强制设置所有configuration的依赖版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    configurations.all &#123;</div><div class="line">        resolutionStrategy.force &apos;org.hamcrest:hamcrest-core:1.1&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这种方法的时候需要小心, 因为与方法2不同, 它是把所有configuration中的版本都强制设置了. 当直接依赖更新的时候, 要注意更新间接依赖的版本.</p>
<h2 id="Looper-Handler-and-HandlerThread"><a href="#Looper-Handler-and-HandlerThread" class="headerlink" title="Looper, Handler, and HandlerThread"></a><a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a#.zf2nhog1x" target="_blank" rel="external">Looper, Handler, and HandlerThread</a></h2><p>这篇文章讨论Looper, Handler和HandlerThread.</p>
<p>首先, 读者应该了解Java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" target="_blank" rel="external">Thread</a>和<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" target="_blank" rel="external">Runnable</a>.</p>
<p>然后让我们带着问题来探索和复习:</p>
<h3 id="Java的Thread存在什么问题"><a href="#Java的Thread存在什么问题" class="headerlink" title="Java的Thread存在什么问题?"></a>Java的Thread存在什么问题?</h3><p>Java的Thread是一次性的, 当它执行完<code>run()</code>方法之后, 它就死了.</p>
<h3 id="我们可以改善这个问题吗"><a href="#我们可以改善这个问题吗" class="headerlink" title="我们可以改善这个问题吗?"></a>我们可以改善这个问题吗?</h3><p>线程本身是个双刃剑, 我们可以把任务分发到多个线程来加速, 但同时线程过多又会降低速度. 线程创建也会花费时间, 所以最好我们能有一个固定优化数量的线程, 然后用它们来执行任务.</p>
<p><strong>线程复用模型</strong>:</p>
<ul>
<li>1.一个线程保持活跃, 通过它的<code>run()</code>方法不断循环.</li>
<li>2.任务由该线程连续执行, 并保持在一个队列中(MessageQueue).</li>
<li>3.当完成之后结束这个线程.</li>
</ul>
<h3 id="Android是以什么方式来做这件事的呢"><a href="#Android是以什么方式来做这件事的呢" class="headerlink" title="Android是以什么方式来做这件事的呢?"></a>Android是以什么方式来做这件事的呢?</h3><p>Android用<code>Looper</code>, <code>Handler</code>和<code>HandlerThread</code>实现了上述模型.<br>系统可以用这样的图表示:<br><img src="/images/Android-Looper-Handler.jpeg" alt="Android Looper Handler"></p>
<ul>
<li>1.<code>MessageQueue</code>是一个队列, 里面含有需要被处理的任务(消息).</li>
<li>2.<code>Handler</code>利用<code>Looper</code>往队列中加任务, 同时也在任务出队列的时候进行处理.</li>
<li>3.<code>Looper</code>是一个工人, 保持一个线程的活跃, 循环消息队列, 把消息发给对应的handler去处理.(一个线程只能对应一个唯一的<code>Looper</code>, 但是可以有多个关联的<code>Handler</code>).</li>
<li>4.最后<code>Looper.quit()</code>会让线程终止.</li>
</ul>
<p>为一个线程创建<code>Looper</code>和<code>MessageQueue</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Handler mHandler; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        Looper.prepare();</div><div class="line"></div><div class="line">        mHandler = <span class="keyword">new</span> Handler() &#123; </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; </div><div class="line">               <span class="comment">// process incoming messages here</span></div><div class="line">               <span class="comment">// this will run in non-ui/background thread</span></div><div class="line">            &#125; </div><div class="line">        &#125;; </div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建<code>Handler</code>的时候自动和当前线程的Looper关联, 但是也可以通过构造传入Looper来使Handler关联到特定的线程.</p>
<p>用<code>Handler</code>发消息有两种方式: <code>Message</code>和<code>Runnable</code>.</p>
<p>自己创建一个线程并提供Looper和消息队列的方式是不好的, 所以Android提供了<code>HandlerThread</code>来简化这个过程, 它内部的实现和我们之前做的差不多, 但是是以一种更加稳健的方式. 所以我们应该使用<code>HandlerThread</code>而不是自己实现.</p>
<p>大多数时候你只需要继承<code>HandlerThread</code>来创建它的子类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</div><div class="line"></div><div class="line">    Handler handler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</div><div class="line">        handler = <span class="keyword">new</span> Handler(getLooper()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                <span class="comment">// process incoming messages here</span></div><div class="line">                <span class="comment">// this will run in non-ui/background thread</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li><code>Looper</code>只有在<code>HandlerThread</code>的<code>start()</code>方法被调用(线程开始跑)后才会进入prepared状态.</li>
<li>只有在<code>HandlerThread</code>的<code>Looper</code>处于parepared状态以后, <code>Handler</code>才可以关联.</li>
</ul>
<p>另一种创建<code>HandlerThread</code>的方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"MyHandlerThread"</span>);</div><div class="line">handlerThread.start();</div><div class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</div></pre></td></tr></table></figure></p>
<p>注意: <code>HandlerThread</code>需要调用<code>quit()</code>方法来停止线程执行和释放资源.</p>
<p>作者文后还附有一个练习的demo.</p>
<h2 id="Android-Wear-packaging"><a href="#Android-Wear-packaging" class="headerlink" title="Android Wear packaging"></a><a href="https://www.novoda.com/blog/android-wear-packaging/" target="_blank" rel="external">Android Wear packaging</a></h2><p>Android Wear 2.0将在2017年发布, 本文讨论了如何同时支持1.0和2.0的应用部署.</p>
<h2 id="Simple-Things-–-Part-1"><a href="#Simple-Things-–-Part-1" class="headerlink" title="Simple Things – Part 1"></a><a href="https://blog.stylingandroid.com/simple-things-part-1/" target="_blank" rel="external">Simple Things – Part 1</a></h2><p>Android Things应用.</p>
<h2 id="Options-for-Viewing-PDFs"><a href="#Options-for-Viewing-PDFs" class="headerlink" title="Options for Viewing PDFs"></a><a href="https://commonsware.com/blog/2017/01/04/options-viewing-pdfs.html" target="_blank" rel="external">Options for Viewing PDFs</a></h2><p>显示PDF传统的方法是通过ACTION_VIEW发出去, 用一个第三方应用打开.</p>
<p>但是有一些开发者不愿意这样做.</p>
<p>还有一种方法是把文件上传, 然后用Google Docs URL用WebView打开它. </p>
<p>除了这些传统的方法, 还有一些选项, 虽然它们各自都有一些问题.</p>
<p>比如用<code>PdfRenderer</code>, 它是Android 5.0加入的.</p>
<p>Mozilka在Firefox上用的是<a href="https://mozilla.github.io/pdf.js/" target="_blank" rel="external">PDF.js</a>, 在Android 4.4+的WebView上可用, 它会给apk带来2MB左右的增加.</p>
<p>Google在Chrominum上用的是<a href="https://pdfium.googlesource.com/pdfium/" target="_blank" rel="external">pdfium</a>, 这是C++. <a href="https://github.com/barteksc/AndroidPdfViewer" target="_blank" rel="external">barteksc/AndroidPdfViewer</a>封装了Pdfium, 处理了渲染和基本的手势, 在一些较老的Android版本上也使用, 但是大约每个CPU架构会给APK增加5MB, 默认情况下你会增加30MB.</p>
<h2 id="Clean-tests-Part-1-Naming"><a href="#Clean-tests-Part-1-Naming" class="headerlink" title="Clean tests, Part 1: Naming"></a><a href="https://android.jlelse.eu/clean-tests-part-1-naming-cce94edf0522#.5nmmqx81y" target="_blank" rel="external">Clean tests, Part 1: Naming</a></h2><p>关于怎么写干净的单元测试, 本文作者提出了几点他对于命名的看法.</p>
<ul>
<li>不要用”test”开头写测试名.</li>
<li>不要把被测试的方法名字写在测试名里.</li>
<li>测试是一种规范.</li>
</ul>
<h2 id="Why-I-Don’t-use-Robolectric"><a href="#Why-I-Don’t-use-Robolectric" class="headerlink" title="Why I Don’t use Robolectric"></a><a href="http://www.philosophicalhacker.com/post/why-i-dont-use-roboletric/" target="_blank" rel="external">Why I Don’t use Robolectric</a></h2><p>作者觉得Robolectric不好的几点:</p>
<ul>
<li>Robolectric mock了一些我们并不拥有的type.</li>
<li>Robolectric turns TDD on its head.</li>
</ul>
<p>所以最好的做法是我们在写Android代码的时候将逻辑代码抽象出来, 与framework分离, 这样在测试的时候不依赖于Android SDK的类, 也不需要robolectric来模拟一个中间层.</p>
<h2 id="The-Next-Step-for-Reactive-Android-Programming"><a href="#The-Next-Step-for-Reactive-Android-Programming" class="headerlink" title="The Next Step for Reactive Android Programming"></a><a href="http://futurice.com/blog/the-next-step-for-reactive-android-programming" target="_blank" rel="external">The Next Step for Reactive Android Programming</a></h2><p>RxJava 2已经推出了, 本篇文章讨论从RxJava 1迁移到RxJava 2会带来的好处和挑战.</p>
<p>好处:</p>
<ul>
<li>兼容了<a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="external">Reactive Streams</a>.</li>
<li>Backpressure的处理.</li>
<li>Performance.</li>
</ul>
<p>挑战:</p>
<ul>
<li>流中不能再使用null.</li>
<li>方法数限制. RxJava 1(5500), RxJava 2(9200).</li>
<li>自定义操作符变得很难写.</li>
</ul>
<p>Note: 可以对比简单的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java" target="_blank" rel="external">map</a>和复杂的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java" target="_blank" rel="external">flatMap</a>.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introducing-Auto-Layout-for-Sketch"><a href="#Introducing-Auto-Layout-for-Sketch" class="headerlink" title="Introducing Auto-Layout for Sketch"></a><a href="https://medium.com/sketch-app-sources/introducing-auto-layout-for-sketch-24e7b5d068f9#.tusju2z7k" target="_blank" rel="external">Introducing Auto-Layout for Sketch</a></h2><p>一个Sketch插件, 让你查看不同屏幕上的效果.</p>
<h2 id="Designing-for-Both-Android-and-iOS"><a href="#Designing-for-Both-Android-and-iOS" class="headerlink" title="Designing for Both Android and iOS"></a><a href="https://webdesign.tutsplus.com/articles/a-tale-of-two-platforms-designing-for-both-android-and-ios--cms-23616" target="_blank" rel="external">Designing for Both Android and iOS</a></h2><p>Android和iOS的设计, 很详细的介绍, 最后附有一些resources.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="flowless"><a href="#flowless" class="headerlink" title="flowless"></a><a href="https://github.com/Zhuinden/flowless" target="_blank" rel="external">flowless</a></h2><p>一个框架, 给你Activity的UI状态命名, 管理并记录状态转换.</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a><a href="https://github.com/NYTimes/Store" target="_blank" rel="external">Store</a></h2><p>异步数据加载和缓存的库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-239&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-239&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #239&quot;&gt;&lt;/a&gt;Android Weekly Issue #239&lt;/h1&gt;&lt;p&gt;January 8th, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-239&quot;&gt;Android Weekly Issue #239&lt;/a&gt;&lt;br&gt;本期内容包括: Android Things开发; Android中有用却不常见的一些API介绍(拼写检查, 文字识别, 时间log, 截图, 创建PDF); Gradle依赖管理冲突和解决办法; Looper, Handler和HandlerThread; 兼顾Wear1.0和2.0的部署方式; 打开PDF的实现方法; 单元测试的命名; Robolectric的弊病; 迁移到RxJava2的好处和面临的挑战. &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Wear" scheme="http://mengdd.github.io/tags/Wear/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="RxJava" scheme="http://mengdd.github.io/tags/RxJava/"/>
    
      <category term="Test" scheme="http://mengdd.github.io/tags/Test/"/>
    
      <category term="RxJava2" scheme="http://mengdd.github.io/tags/RxJava2/"/>
    
      <category term="Handler" scheme="http://mengdd.github.io/tags/Handler/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="Looper" scheme="http://mengdd.github.io/tags/Looper/"/>
    
      <category term="HandlerThread" scheme="http://mengdd.github.io/tags/HandlerThread/"/>
    
      <category term="PDF" scheme="http://mengdd.github.io/tags/PDF/"/>
    
      <category term="Robolectric" scheme="http://mengdd.github.io/tags/Robolectric/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 238</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2017/01/03/android-weekly-notes-issue-238/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2017/01/03/android-weekly-notes-issue-238/</id>
    <published>2017-01-03T10:02:01.000Z</published>
    <updated>2017-03-09T05:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-238"><a href="#Android-Weekly-Issue-238" class="headerlink" title="Android Weekly Issue #238"></a>Android Weekly Issue #238</h1><p>January 1st, 2017<br><a href="http://androidweekly.net/issues/issue-238" target="_blank" rel="external">Android Weekly Issue #238</a><br>本期内容包括: Firebase发送Notification; RecyclerView的预取; 后台工作的实现方式讨论; RecyclerView分组数据; 跨平台应用工具Flutter介绍; Gradle依赖管理;<br>写测试的一些注意事项; Android Things应用搭建及一些思考; 如何搭建CI等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Mastering-Firebase-Notifications"><a href="#Mastering-Firebase-Notifications" class="headerlink" title="Mastering Firebase Notifications"></a><a href="https://medium.com/@Miqubel/mastering-firebase-notifications-36a3ffe57c41#.ykkpzrs4l" target="_blank" rel="external">Mastering Firebase Notifications</a></h2><p>用Firebase发通知:</p>
<ul>
<li>Console Notifications.</li>
<li>使用命令行, 发送curl命令.</li>
<li><code>FirebaseMessagingService</code>在应用前台的时候处理通知.</li>
<li>如果应用前后台的时候都需要处理, 则发送data而不是notification.<br>官方文档<a href="https://firebase.google.com/docs/cloud-messaging/android/receive" target="_blank" rel="external">Firebase cloud-messaging</a>.</li>
</ul>
<h2 id="RecyclerView-Prefetch"><a href="#RecyclerView-Prefetch" class="headerlink" title="RecyclerView Prefetch"></a><a href="https://medium.com/google-developers/recyclerview-prefetch-c2f269075710#.21takened" target="_blank" rel="external">RecyclerView Prefetch</a></h2><p>作者研究了RecyclerView的渲染时间, 发现在滚动的时候很多的时间会花在新item的创建和bind上, 这样会推迟UI线程的其他工作, 还有RenderThread的后续工作, 如果超出了frame boundary, 就有可能会造成明显的卡顿.</p>
<p>而同时前一帧, UI线程可能处于空闲状态.</p>
<p>那么我们有没有可能以一种预取的方式, 把即将出现的View在提前的空闲阶段准备好呢?</p>
<p>pre-fetch的优化已经在<a href="https://developer.android.com/topic/libraries/support-library/revisions.html#rev25-0-0" target="_blank" rel="external">Support Library v25</a>加入, <a href="https://developer.android.com/topic/libraries/support-library/revisions.html#25-1-0" target="_blank" rel="external">v25.1.0</a>有进一步的加强. 如果你没有自定义LayoutManager, 也没有嵌套<code>RecyclerView</code>, 那么你升级support library之后就自动获得了这项优化. 其他两种情况你还需要调用一些方法.</p>
<p>你可以设置<code>LayoutManager.setItemPrefetchEnabled()</code>来对比开启和关闭预取功能前后的不同. 性能测量用<a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="external">Systrace</a>和<a href="https://developer.android.com/studio/profile/dev-options-rendering.html" target="_blank" rel="external">GPU profiling</a>.</p>
<h2 id="Things-to-consider-before-running-background-tasks"><a href="#Things-to-consider-before-running-background-tasks" class="headerlink" title="Things to consider before running background tasks"></a><a href="https://blog.yipl.com.np/things-to-consider-before-running-background-tasks-e71f00d2ad3a#.baugcaodi" target="_blank" rel="external">Things to consider before running background tasks</a></h2><p>完成后台任务的几种方式和各自的优缺点分析.</p>
<ul>
<li>Thread.</li>
<li>AsyncTask.</li>
<li>Service.</li>
<li>IntentService.</li>
<li>Loader.</li>
<li>JobService and JobScheduler. GCM Network Manager.</li>
<li>RxJava.</li>
</ul>
<h2 id="Android-RecyclerView-Grouping-Data"><a href="#Android-RecyclerView-Grouping-Data" class="headerlink" title="Android RecyclerView - Grouping Data"></a><a href="https://krtkush.github.io/2016/07/08/android-recyclerview-grouping-data.html" target="_blank" rel="external">Android RecyclerView - Grouping Data</a></h2><p>作者展示了如何将RecyclerView中的数据分组展示, 在他的例子中是按照时间分组, 每一组开始是该组的时间占据一行.</p>
<p>其实主要是前期的数据处理, 首先创建一个HashMap, 分组依据作为key, 符合该依据的数据作为值存在对应key的value list里; 然后给日期和数据创建一个共同的基类, 把HashMap再重新展开成一个List, 里面穿插好数据. 最后用RecyclerView按照数据类型不同显示两种布局.</p>
<h2 id="Flutter-Intro"><a href="#Flutter-Intro" class="headerlink" title="Flutter Intro"></a><a href="https://medium.com/@develodroid/flutter-i-intro-and-install-a8bf6dfcc7c8#.f9ktsu3r8" target="_blank" rel="external">Flutter Intro</a></h2><p><a href="https://flutter.io/" target="_blank" rel="external">Flutter</a>是一个Google推出的新工具, 用来构建跨平台的应用.</p>
<p>本文介绍了如何setup和创建一个Hello World.</p>
<h2 id="How-to-add-Gradle-dependencies-using-‘foreach’"><a href="#How-to-add-Gradle-dependencies-using-‘foreach’" class="headerlink" title="How to add Gradle dependencies using ‘foreach’"></a><a href="https://hackernoon.com/android-how-to-add-gradle-dependencies-using-foreach-c4cbcc070458#.aplxhrmn3" target="_blank" rel="external">How to add Gradle dependencies using ‘foreach’</a></h2><p>一种管理依赖的方式, 把所有的依赖定义在同一个文件的不同分组里, 然后在每个module各自添加自己的分组即可.</p>
<h2 id="Best-practices-to-improve-app-engagement"><a href="#Best-practices-to-improve-app-engagement" class="headerlink" title="Best practices to improve app engagement"></a><a href="https://android-developers.googleblog.com/2016/12/important-best-practices-to-improve-app-engagement.html" target="_blank" rel="external">Best practices to improve app engagement</a></h2><p>如何提高app的用户参与度.</p>
<h2 id="The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android"><a href="#The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android" class="headerlink" title="The Do’s and Don’ts of Writing Test cases in Android"></a><a href="https://blog.mindorks.com/the-dos-and-don-ts-of-writing-test-cases-in-android-70f1b5dab3e1#.7ol81s1wo" target="_blank" rel="external">The Do’s and Don’ts of Writing Test cases in Android</a></h2><p>作者分享了在写测试的时候需要注意的几点:</p>
<ul>
<li>首先明确我们要测试的是什么, 预先条件是否满足, 如果是因为前置条件不满足, 那么并不是我们的测试本身失败了.</li>
<li>每个测试都是独立完成的, 测试的执行顺序不应该影响结果.</li>
<li>在测试中不要写条件语句. 条件语句是在实际代码中的, 每一个条件都应该对应一个单独的测试case.</li>
<li>测试应该不受外部因素影响, 比如server和网络. 因为如果因为这类原因测试失败了, 并不代表我们的代码有bug.</li>
</ul>
<h2 id="Making-Rainbow-HAT-Work-with-the-Android-Things"><a href="#Making-Rainbow-HAT-Work-with-the-Android-Things" class="headerlink" title="Making Rainbow HAT Work with the Android Things"></a><a href="https://blog.egorand.me/making-rainbow-hat-work-with-the-android-things-2/" target="_blank" rel="external">Making Rainbow HAT Work with the Android Things</a></h2><p>一个Android Things应用.</p>
<h2 id="Christmas-Voice-–-Part-2"><a href="#Christmas-Voice-–-Part-2" class="headerlink" title="Christmas Voice – Part 2"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-2/" target="_blank" rel="external">Christmas Voice – Part 2</a></h2><p>一个小应用, 录音, 做转换并播放.</p>
<h2 id="Will-Android-do-for-the-IoT-what-it-did-for-mobile"><a href="#Will-Android-do-for-the-IoT-what-it-did-for-mobile" class="headerlink" title="Will Android do for the IoT what it did for mobile?"></a><a href="https://medium.com/@carl.whalley/will-android-do-for-iot-what-it-did-for-mobile-c9ac79d06c#.41phc9zbb" target="_blank" rel="external">Will Android do for the IoT what it did for mobile?</a></h2><p>关于Android Things的一些看法.</p>
<h2 id="Set-up-a-CI-server-for-Android-dev"><a href="#Set-up-a-CI-server-for-Android-dev" class="headerlink" title="Set up a CI server for Android dev"></a><a href="https://medium.com/@pamartineza/how-to-set-up-a-continuous-integration-server-for-android-development-ubuntu-jenkins-sonarqube-43c1ed6b08d3#.lzs2m4zg8" target="_blank" rel="external">Set up a CI server for Android dev</a></h2><p>如何搭建Android项目的CI, (Ubuntu + Jenkins + SonarQube).</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Material-Growth-amp-communications"><a href="#Material-Growth-amp-communications" class="headerlink" title="Material: Growth &amp; communications"></a><a href="https://material.io/guidelines/growth-communications/introduction.html#" target="_blank" rel="external">Material: Growth &amp; communications</a></h2><p>如何进行用户引导, feature发现和手势教育.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PanoramaImageView"><a href="#PanoramaImageView" class="headerlink" title="PanoramaImageView"></a><a href="https://github.com/gjiazhe/PanoramaImageView" target="_blank" rel="external">PanoramaImageView</a></h2><p>一个ImageView, 在设备转动的时候可以自动滚动内容.</p>
<h2 id="TextDecorator"><a href="#TextDecorator" class="headerlink" title="TextDecorator"></a><a href="https://github.com/nntuyen/text-decorator" target="_blank" rel="external">TextDecorator</a></h2><p>可以给文字分段加上各种装饰, 下划线, 点击事件等.</p>
<h2 id="Delightful-SQLBrite"><a href="#Delightful-SQLBrite" class="headerlink" title="Delightful-SQLBrite"></a><a href="https://github.com/geralt-encore/Delightful-SQLBrite" target="_blank" rel="external">Delightful-SQLBrite</a></h2><p>一个示例应用, 展示<a href="https://github.com/square/sqldelight" target="_blank" rel="external">SQLDelight</a>和<a href="https://github.com/square/sqlbrite" target="_blank" rel="external">SQLBrite</a>结合使用.</p>
<h2 id="mainframer"><a href="#mainframer" class="headerlink" title="mainframer"></a><a href="https://github.com/gojuno/mainframer" target="_blank" rel="external">mainframer</a></h2><p>一个远程build的脚本.</p>
<h2 id="material-about-library"><a href="#material-about-library" class="headerlink" title="material-about-library"></a><a href="https://github.com/daniel-stoneuk/material-about-library" target="_blank" rel="external">material-about-library</a></h2><p>创建一个Material风格about页面的库.</p>
<h2 id="android-snowfall"><a href="#android-snowfall" class="headerlink" title="android-snowfall"></a><a href="https://github.com/JetradarMobile/android-snowfall" target="_blank" rel="external">android-snowfall</a></h2><p>下雪View.</p>
<h2 id="Android-ExpandIcon"><a href="#Android-ExpandIcon" class="headerlink" title="Android-ExpandIcon"></a><a href="https://github.com/zagum/Android-ExpandIcon" target="_blank" rel="external">Android-ExpandIcon</a></h2><p>展开/合上的上下箭头icon, 支持点击和手势滑动切换.</p>
<h2 id="RxAnimations"><a href="#RxAnimations" class="headerlink" title="RxAnimations"></a><a href="https://github.com/0ximDigital/RxAnimations" target="_blank" rel="external">RxAnimations</a></h2><p>Rx形式的动画库.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-238&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-238&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #238&quot;&gt;&lt;/a&gt;Android Weekly Issue #238&lt;/h1&gt;&lt;p&gt;January 1st, 2017&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-238&quot;&gt;Android Weekly Issue #238&lt;/a&gt;&lt;br&gt;本期内容包括: Firebase发送Notification; RecyclerView的预取; 后台工作的实现方式讨论; RecyclerView分组数据; 跨平台应用工具Flutter介绍; Gradle依赖管理;&lt;br&gt;写测试的一些注意事项; Android Things应用搭建及一些思考; 如何搭建CI等.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="Gradle" scheme="http://mengdd.github.io/tags/Gradle/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="Notification" scheme="http://mengdd.github.io/tags/Notification/"/>
    
      <category term="Testing" scheme="http://mengdd.github.io/tags/Testing/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="Background work" scheme="http://mengdd.github.io/tags/Background-work/"/>
    
      <category term="Flutter" scheme="http://mengdd.github.io/tags/Flutter/"/>
    
      <category term="CI" scheme="http://mengdd.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 237</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/12/30/android-weekly-notes-issue-237/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/12/30/android-weekly-notes-issue-237/</id>
    <published>2016-12-30T07:30:25.000Z</published>
    <updated>2016-12-30T07:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-237"><a href="#Android-Weekly-Issue-237" class="headerlink" title="Android Weekly Issue #237"></a>Android Weekly Issue #237</h1><p>December 25th, 2016<br><a href="http://androidweekly.net/issues/issue-237" target="_blank" rel="external">Android Weekly Issue #237</a><br>这是本年的最后一篇issue, 感谢大家.<br>本期内容包括: ConstraintLayout的使用; Android Things的应用; 如何利用第三方库使得Java具有Kotlin的一些新特性; Firebase是如何利用<code>ContentProvider</code>进行初始化的; Kotlin上的并发处理; 其他还有一些关于程序架构, 代码优化相关的讨论.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Building-interfaces-with-ConstraintLayout"><a href="#Building-interfaces-with-ConstraintLayout" class="headerlink" title="Building interfaces with ConstraintLayout"></a><a href="https://medium.com/google-developers/building-interfaces-with-constraintlayout-3958fa38a9f7#.al6p1anu7" target="_blank" rel="external">Building interfaces with ConstraintLayout</a></h2><p>本文介绍<code>ConstraintLayout</code>的chains和ratios. 另外还提到很多使用<code>ConstraintLayout</code>的实现细节.</p>
<p>所谓chains就是几个View之间建立的双向约束.</p>
<p>ratios是帮助你设置View的宽高比, 它所做的事情和<a href="https://developer.android.com/reference/android/support/percent/PercentFrameLayout.html" target="_blank" rel="external">PercentFrameLayout</a>差不多, 但是不用添加额外的ViewGroup.</p>
<h2 id="Electronic-Candle-using-Android-Things"><a href="#Electronic-Candle-using-Android-Things" class="headerlink" title="Electronic Candle using Android Things"></a><a href="https://plus.google.com/+DaveSmithDev/posts/4JN7ZaSKxaM" target="_blank" rel="external">Electronic Candle using Android Things</a></h2><p>用ObjectAnimator和Android Things搭建的一个电子蜡烛.</p>
<h2 id="ExoPlayer-2-1-What’s-new"><a href="#ExoPlayer-2-1-What’s-new" class="headerlink" title="ExoPlayer 2.1 - What’s new"></a><a href="https://medium.com/google-exoplayer/exoplayer-2-1-whats-new-2832c09fedab#.po64o4uha" target="_blank" rel="external">ExoPlayer 2.1 - What’s new</a></h2><p>ExoPlayer 2.1有什么新功能.<br>这是他们的<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="external">release notes</a>.</p>
<h2 id="Living-Android-without-Kotlin"><a href="#Living-Android-without-Kotlin" class="headerlink" title="Living (Android) without Kotlin"></a><a href="https://hackernoon.com/living-android-without-kotlin-db7391a2b170#.7fm956ryk" target="_blank" rel="external">Living (Android) without Kotlin</a></h2><p>如果你因为种种原因不能在项目中使用kotlin, 这篇文章告诉你如何借助于一些工具和库用Java实现Kotlin的一些features.</p>
<h2 id="Christmas-Voice-–-Part-1"><a href="#Christmas-Voice-–-Part-1" class="headerlink" title="Christmas Voice – Part 1"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-1/" target="_blank" rel="external">Christmas Voice – Part 1</a></h2><p>作者发布了一个改变声音的应用, 并且将其开源了: <a href="https://github.com/StylingAndroid/ChristmasVoice" target="_blank" rel="external">ChristmasVoice</a>.</p>
<h2 id="How-does-Firebase-initialize-on-Android"><a href="#How-does-Firebase-initialize-on-Android" class="headerlink" title="How does Firebase initialize on Android?"></a><a href="https://firebase.googleblog.com/2016/12/how-does-firebase-initialize-on-android.html" target="_blank" rel="external">How does Firebase initialize on Android?</a></h2><p>Firebase在Android上是如何初始化的?</p>
<p>很多SDK在初始化的时候会要求应用传入<code>Context</code>. Firebase简化了这一步骤. 解决方案就是用了<code>ContentProvider</code>, 既解决了时间问题, 也得到了sdk需要的<code>Context</code>. 并且不需要应用的开发者添加任何额外的初始化代码.</p>
<p>选择<code>ContentProvider</code>主要有两点原因:</p>
<ul>
<li><code>ContentProvider</code>初始化早.<br>当一个Android进程启动的时候, 首先会初始化每一个ContentProvider, 然后是Application, 最后是被Intent启动的组件. </li>
</ul>
<p>在ContentProvider初始化的时候, 就可以拿到Context了.</p>
<ul>
<li><code>ContentProvider</code>可以merge到最终的manifest里.<br><a href="https://developer.android.com/studio/build/manifest-merge.html" target="_blank" rel="external">Manifest merge</a>是在build的时候来定义你的应用最终的manifest. 最终的manifest会包含所有依赖的库的manifest中声明的组件.</li>
</ul>
<p>如果你也想选择用<code>ContentProvider</code>来做应用或库的初始化, 请注意authority的唯一性问题和<code>ContentProvider</code>只在主进程运行的问题.</p>
<h2 id="Seductive-Code"><a href="#Seductive-Code" class="headerlink" title="Seductive Code"></a><a href="https://publicobject.com/2016/12/19/seductive-code/" target="_blank" rel="external">Seductive Code</a></h2><p>当我们在改善代码可读性的时候, 很有可能会影响到性能和可维护性. </p>
<p>作者举例说明了他在实际编程中遇到的几个问题.</p>
<h2 id="Testing-Android-Things-–-Unit-amp-Vendor-tests"><a href="#Testing-Android-Things-–-Unit-amp-Vendor-tests" class="headerlink" title="Testing Android Things – Unit &amp; Vendor tests"></a><a href="http://blog.blundellapps.co.uk/testing-android-things-iot-meets-java/" target="_blank" rel="external">Testing Android Things – Unit &amp; Vendor tests</a></h2><p>如何开发Android Things应用, 才能让测试更加容易. 本文以一个很小的LED灯闪烁程序为例.</p>
<h2 id="Engineering-the-Architecture-Behind-Uber’s-New-Rider-App"><a href="#Engineering-the-Architecture-Behind-Uber’s-New-Rider-App" class="headerlink" title="Engineering the Architecture Behind Uber’s New Rider App"></a><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">Engineering the Architecture Behind Uber’s New Rider App</a></h2><p>Uber团队重新打造了他们的ride app, 提出了一个新的构架模式: Riblets.</p>
<p>关于架构的选型, 已有的类型可以查看这个<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tmcojtwgg" target="_blank" rel="external">iOS Architecture Patterns</a>.</p>
<h2 id="Rebuilding-the-Buffer-Android-Composer"><a href="#Rebuilding-the-Buffer-Android-Composer" class="headerlink" title="Rebuilding the Buffer Android Composer"></a><a href="https://overflow.buffer.com/2016/12/22/rebuild-android-composer/" target="_blank" rel="external">Rebuilding the Buffer Android Composer</a></h2><p>作者重构了自己应用的代码, 应用了clean architecture, 本文讲述了其过程.</p>
<h2 id="Papercut"><a href="#Papercut" class="headerlink" title="Papercut"></a><a href="http://stu.ie/?page_id=3133" target="_blank" rel="external">Papercut</a></h2><p><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a>是一个库, 用来标记那些我们觉得需要删除或者需要重构的代码.</p>
<h2 id="Concurrency-Primitives-in-Kotlin"><a href="#Concurrency-Primitives-in-Kotlin" class="headerlink" title="Concurrency Primitives in Kotlin"></a><a href="https://blog.egorand.me/concurrency-primitives-in-kotlin/" target="_blank" rel="external">Concurrency Primitives in Kotlin</a></h2><p>作者最近看了一本书, 讲Android的并发, 觉得很好, 想要用Kotlin来重写书中的例子, 结果发现:</p>
<ul>
<li>Kotlin中没有<code>synchronized</code>关键字.</li>
<li>Kotlin中没有<code>volatile</code>关键字.</li>
<li>Kotlin中的<code>Any</code>, 类比于Java中的<code>Object</code>, 但是却没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法.</li>
</ul>
<p>所以Kotlin中的并发是怎么处理呢? 这里有个问题: <a href="https://discuss.kotlinlang.org/t/concurrency-in-kotlin/858" target="_blank" rel="external">Kotlin forum</a>, Kotlin语言的开发人员表示这些应该由库来处理, 而不是语言本身.</p>
<p>尽管Kotlin不支持, 但是它还是提供了一些底层的并发工具.</p>
<ul>
<li>创建线程. 因为Kotlin可以调用Java代码, 所以仍然可以通过两种方法来创建线程.</li>
<li><code>@Synchronized</code>注解和<code>synchronized()</code>方法.</li>
<li><code>@Volatile</code>注解.</li>
<li>没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法, 但是可以把<code>Object</code>对象作为锁, 然后调用锁的这些方法.</li>
</ul>
<p><a href="http://stackoverflow.com/questions/35520583/why-there-are-no-concurrency-keywords-in-kotlin" target="_blank" rel="external">stackoverflow</a>上有一个相关问题, 答案很不错, 列了处理并发的一些有用的库.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KataScreenshotAndroid"><a href="#KataScreenshotAndroid" class="headerlink" title="KataScreenshotAndroid"></a><a href="https://github.com/Karumi/KataScreenshotAndroid" target="_blank" rel="external">KataScreenshotAndroid</a></h2><p>一个Screen Kata应用, 用来练习做UI测试的.</p>
<h2 id="Papercut-1"><a href="#Papercut-1" class="headerlink" title="Papercut"></a><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a></h2><p>一个用来标记需要重构或者移除代码的工具库.</p>
<h2 id="Squint"><a href="#Squint" class="headerlink" title="Squint"></a><a href="https://github.com/IntruderShanky/Squint" target="_blank" rel="external">Squint</a></h2><p>一个可以自定义的对角线切割View.</p>
<h2 id="Colorful"><a href="#Colorful" class="headerlink" title="Colorful"></a><a href="https://github.com/garretyoder/Colorful" target="_blank" rel="external">Colorful</a></h2><p>一个动态的主题库, 让你可以方便地修改应用的颜色.</p>
<h2 id="scytale"><a href="#scytale" class="headerlink" title="scytale"></a><a href="https://github.com/yakivmospan/scytale" target="_blank" rel="external">scytale</a></h2><p>包装了JCA API和AndroidKeyStore API, 让创建, 加密和管理任何Android API的keys变得更容易.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-237&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-237&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #237&quot;&gt;&lt;/a&gt;Android Weekly Issue #237&lt;/h1&gt;&lt;p&gt;December 25th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-237&quot;&gt;Android Weekly Issue #237&lt;/a&gt;&lt;br&gt;这是本年的最后一篇issue, 感谢大家.&lt;br&gt;本期内容包括: ConstraintLayout的使用; Android Things的应用; 如何利用第三方库使得Java具有Kotlin的一些新特性; Firebase是如何利用&lt;code&gt;ContentProvider&lt;/code&gt;进行初始化的; Kotlin上的并发处理; 其他还有一些关于程序架构, 代码优化相关的讨论.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://mengdd.github.io/tags/Kotlin/"/>
    
      <category term="Firebase" scheme="http://mengdd.github.io/tags/Firebase/"/>
    
      <category term="ExoPlayer" scheme="http://mengdd.github.io/tags/ExoPlayer/"/>
    
      <category term="ConstraintLayout" scheme="http://mengdd.github.io/tags/ConstraintLayout/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="Java" scheme="http://mengdd.github.io/tags/Java/"/>
    
      <category term="ContentProvider" scheme="http://mengdd.github.io/tags/ContentProvider/"/>
    
      <category term="Architecture" scheme="http://mengdd.github.io/tags/Architecture/"/>
    
      <category term="Concurrency" scheme="http://mengdd.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 236</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/Design/2016/12/21/android-weekly-notes-issue-236/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/Design/2016/12/21/android-weekly-notes-issue-236/</id>
    <published>2016-12-21T02:27:39.000Z</published>
    <updated>2016-12-21T02:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-236"><a href="#Android-Weekly-Issue-236" class="headerlink" title="Android Weekly Issue #236"></a>Android Weekly Issue #236</h1><p>December 18th, 2016<br><a href="http://androidweekly.net/issues/issue-236" target="_blank" rel="external">Android Weekly Issue #236</a></p>
<p>本期内容包括: Google的物联网平台Android Things; FileProvider; Android Studio的Layout Preview使用; Retrofit2使用; Google Sign-In和SmartLock; 把敏感信息放入NDK的解决方式.</p>
<p>设计部分讨论了调色板的灵感来源和几个开发app的时候应该注意的问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Getting-started-with-Android-Things"><a href="#Getting-started-with-Android-Things" class="headerlink" title="Getting started with Android Things"></a><a href="https://medium.com/@alexsimo/getting-started-with-android-things-b73be3295b42#.c1arra4ps" target="_blank" rel="external">Getting started with Android Things</a></h2><p>Internet of Things (物联网, IoT), 是互联网, 传统电信网等咨询承载体, 让所有能行使独立功能的物品之间实现互联互通的网络.</p>
<p>2016年12月, Google发布了Android Things的开发者预览版, 这是一个专门为IoT设备定制的Android系统.</p>
<p>本篇文章一步一步地教你如何写一个IoT的基本程序, 跑在Raspberry Pi 3 Model B上.</p>
<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><a href="https://blog.stylingandroid.com/fileprovider/" target="_blank" rel="external">FileProvider</a></h2><p>上次我们提到了用<code>DownloadManager</code>下载的东西可以和其他应用分享, 那么如果我们下载的时候没有用<code>DownloadManager</code>呢? </p>
<p>比较常见的情况是我们的应用需要分享内容到其他应用, 或者是文件的类型是我们应用不能自己处理的, 需要找一个支持这种文件类型的其他应用来帮我们打开它.</p>
<p>怎么解决呢? 答案是用<code>FileProvider</code>.</p>
<p>上一期有一篇文章也说过Android 7开始废弃了”file://“, 解决方案就是用<code>FileProvider</code>, 所以实现是一样的, 这里就不重复了.</p>
<h2 id="Working-with-the-Layout-Preview"><a href="#Working-with-the-Layout-Preview" class="headerlink" title="Working with the Layout Preview"></a><a href="https://www.novoda.com/blog/layout-preview-101/" target="_blank" rel="external">Working with the Layout Preview</a></h2><p>Layout Preview向你展示了你的xml将如何在设备上显示. 你可以用它查看布局在不同的配置下如何显示, 比如可以切换横竖屏, 语言等等.</p>
<p>但是它同样也有一些问题:</p>
<p><strong>Issue #1: Preview显示空白</strong><br>当你的布局是由动态获取的数据来填充的, preview不知道如何填充, 所以你看到的是空白的. </p>
<p>一个好的practice是使用<code>tools</code>命名空间, 指定一些只在preview阶段使用的属性. 这样你就可以指定一些text或src用来预览.</p>
<p><strong>Tip #2: 使得动态内容在Preview可见</strong><br>如果你的图片是动态资源, 你也可以设置一些最大宽高给parent view, 以防真实的图片比期待的大太多或者是比例不对. 你可以设置<code>tools:layout_height</code> 和<code>tools:layout_width</code>, 还有<code>tools:background</code>在preview中查看view占多大.</p>
<p>本文还推荐了另一个阅读资料: <a href="https://tips.seebrock3r.me/tools-of-the-trade-part-1-f3c1c73de898#.e038jlqyy" target="_blank" rel="external">Tools of the trade — Part 1</a></p>
<p><strong>Tip #3: 修复坏掉的Previews</strong><br>当你创建一个自定义View的时候, 你需要确保你的View不需要任何外部依赖即可被实例化, 否则Preview可能看不到你的View. 因为Preview不是运行在你的app上的, 它只是运行在IDE的JVM上, 所以View framework之外的东西它是访问不到的.</p>
<p>解决办法是在你的自定义View中做一些特殊处理, 比如把依赖注入放在<code>!isInEditMode()</code>里, 或者用<code>tools:</code>命名空间加一些默认值.</p>
<p><strong>Tip #4: <merge> 布局没有被渲染</merge></strong></p>
<p><merge>里面的控件在preview里会被重叠在一起.<br>解决的办法是使用<code>tools:showIn=&quot;layout&quot;</code>, 指定<merge>具体是显示在哪个布局里. 如果你有多个布局都用到这个<merge>, 你可以选一个.</merge></merge></merge></p>
<p>从Android Studio 2.2开始, 你可以使用<code>tools:parentTag</code>来指定parent的类型, 比如<code>tools:parentTag=&quot;LinearLayout&quot;</code>.</p>
<p><strong>Tip #5: 在Preview中显示隐藏的View</strong><br>如果你在layout中把view的visibility设置为gone, 那么它是不会在Preview中显示的. </p>
<p>解决办法: 使用<code>tools:visibility=&quot;visible&quot;</code>.</p>
<h2 id="Android-Things-Tutorials"><a href="#Android-Things-Tutorials" class="headerlink" title="Android Things Tutorials"></a><a href="https://blog.mindorks.com/android-things-tutorials-getting-started-8464c11009ff#.dhacx13kq" target="_blank" rel="external">Android Things Tutorials</a></h2><p>Android Things教程.</p>
<h2 id="Get-Started-With-Retrofit-2-HTTP-Client"><a href="#Get-Started-With-Retrofit-2-HTTP-Client" class="headerlink" title="Get Started With Retrofit 2 HTTP Client"></a><a href="https://code.tutsplus.com/tutorials/getting-started-with-retrofit-2--cms-27792" target="_blank" rel="external">Get Started With Retrofit 2 HTTP Client</a></h2><p>本篇文章以实例讲述如何使用Retrofit, 虽然都是基础内容, 但讲解很详细.</p>
<h2 id="Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock"><a href="#Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock" class="headerlink" title="Improving sign-in experience with Google Sign-In and SmartLock"></a><a href="https://medium.com/@p.tournaris/android-improving-sign-in-experience-with-google-sign-in-and-smartlock-f0bfd789602a#.dqh1aptm4" target="_blank" rel="external">Improving sign-in experience with Google Sign-In and SmartLock</a></h2><p>Google提供了两种方式来帮助我们改善用户的登录体验:<br>Google Sign-In(之前被称为Google+ Sign-In)和SmartLock.</p>
<p>这篇文章举例解释了Google Sign-In和SmartLock的实现.</p>
<p>Google Sign-In的部分比较简单.</p>
<p>SmartLock让我们可以:</p>
<ul>
<li>让用户保存credentials.</li>
<li>在打开应用的时候请求credentials.</li>
<li>使用存在Chrome上的credentials, 这样我们的网站和app就可以共享credentials.</li>
<li>显示Email提示, 让用户选择email地址.</li>
<li>所有的这些信息都保存在Google的server里, 用户可以保存或删除.</li>
</ul>
<p>Demo app: <a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">charbgr/AuthManager</a></p>
<h2 id="Storing-your-secure-information-in-the-NDK"><a href="#Storing-your-secure-information-in-the-NDK" class="headerlink" title="Storing your secure information in the NDK"></a><a href="https://www.androidsecurity.info/2016/12/15/storing-your-secure-information-in-the-ndk/" target="_blank" rel="external">Storing your secure information in the NDK</a></h2><p>这篇文章说敏感信息放在Java代码里不安全, 很容易被人反编译查看出来, 如果放在NDK里面就好一些, 你打开查看的只能是二进制文件, 很难找到.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introduction-to-Natural-palettes"><a href="#Introduction-to-Natural-palettes" class="headerlink" title="Introduction to Natural palettes"></a><a href="https://stories.uplabs.com/introduction-to-natural-palettes-9503bfeee3d5#.z9y0xf7zc" target="_blank" rel="external">Introduction to Natural palettes</a></h2><p>作者从大自然的图像中得到颜色组合的灵感.<br>文章中举了几个例子, 如何用相关的照片找到相关主题的调色板.</p>
<p>另推荐一个网站: <a href="http://color.romanuke.com/" target="_blank" rel="external">IN COLOR<br> BALANCE</a></p>
<h2 id="Make-your-Android-app-look-better"><a href="#Make-your-Android-app-look-better" class="headerlink" title="Make your Android app look better"></a><a href="https://hackernoon.com/make-your-android-app-look-less-shitty-5dd63c4938f1#.4q5ro3ty8" target="_blank" rel="external">Make your Android app look better</a></h2><p>让你的App看起来更好的几点建议:</p>
<ul>
<li>使用同一个图标集的图标.<br>(这里推荐了一些图片工具和网站.)</li>
<li>使用Material Design设计的keylines, 使用固定的格子大小.</li>
<li>使用颜色的时候小心一些. (这里推荐了一些调色板网站)</li>
<li>选择字体要明智一些.</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Material-Components"><a href="#Material-Components" class="headerlink" title="Material Components"></a><a href="https://github.com/material-components" target="_blank" rel="external">Material Components</a></h2><p>模块化和可定制的Material Design UI组件. Android, iOS, Web.</p>
<h2 id="Android-oss-from-Kickstarter"><a href="#Android-oss-from-Kickstarter" class="headerlink" title="Android-oss from Kickstarter"></a><a href="https://github.com/kickstarter/android-oss" target="_blank" rel="external">Android-oss from Kickstarter</a></h2><p>Kickstarter开源了他们的Android应用.</p>
<h2 id="stencil"><a href="#stencil" class="headerlink" title="stencil"></a><a href="https://github.com/thoughtbot/stencil" target="_blank" rel="external">stencil</a></h2><p>一个kotlin写的Android库, 实现一种文字路径的动画.</p>
<h2 id="AuthManager"><a href="#AuthManager" class="headerlink" title="AuthManager"></a><a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">AuthManager</a></h2><p>包装了Google Sign-In和SmartLock的Manager.</p>
<h2 id="FolioReader-Android"><a href="#FolioReader-Android" class="headerlink" title="FolioReader-Android"></a><a href="https://github.com/FolioReader/FolioReader-Android" target="_blank" rel="external">FolioReader-Android</a></h2><p>一个ePub阅读器和解析框架.</p>
<h2 id="BufferTextInputLayout"><a href="#BufferTextInputLayout" class="headerlink" title="BufferTextInputLayout"></a><a href="https://github.com/bufferapp/BufferTextInputLayout" target="_blank" rel="external">BufferTextInputLayout</a></h2><p>对Support Library中的<code>TextInputLayout</code>的扩展, 增加了字数统计.</p>
<h2 id="TextLayoutBuilder"><a href="#TextLayoutBuilder" class="headerlink" title="TextLayoutBuilder"></a><a href="https://facebookincubator.github.io/TextLayoutBuilder/" target="_blank" rel="external">TextLayoutBuilder</a></h2><p>使用Builder模式来配置创建一个Layout的属性.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-236&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-236&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #236&quot;&gt;&lt;/a&gt;Android Weekly Issue #236&lt;/h1&gt;&lt;p&gt;December 18th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-236&quot;&gt;Android Weekly Issue #236&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本期内容包括: Google的物联网平台Android Things; FileProvider; Android Studio的Layout Preview使用; Retrofit2使用; Google Sign-In和SmartLock; 把敏感信息放入NDK的解决方式.&lt;/p&gt;
&lt;p&gt;设计部分讨论了调色板的灵感来源和几个开发app的时候应该注意的问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
      <category term="Design" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/Design/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="Security" scheme="http://mengdd.github.io/tags/Security/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="Design" scheme="http://mengdd.github.io/tags/Design/"/>
    
      <category term="IoT" scheme="http://mengdd.github.io/tags/IoT/"/>
    
      <category term="Android Things" scheme="http://mengdd.github.io/tags/Android-Things/"/>
    
      <category term="FileProvider" scheme="http://mengdd.github.io/tags/FileProvider/"/>
    
      <category term="IDE" scheme="http://mengdd.github.io/tags/IDE/"/>
    
      <category term="Retrofit2" scheme="http://mengdd.github.io/tags/Retrofit2/"/>
    
      <category term="Sign In" scheme="http://mengdd.github.io/tags/Sign-In/"/>
    
      <category term="SmartLock" scheme="http://mengdd.github.io/tags/SmartLock/"/>
    
      <category term="NDK" scheme="http://mengdd.github.io/tags/NDK/"/>
    
      <category term="Color" scheme="http://mengdd.github.io/tags/Color/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Notes Issue 235</title>
    <link href="http://mengdd.github.io/Android/Android-Weekly/2016/12/16/android-weekly-notes-issue-235/"/>
    <id>http://mengdd.github.io/Android/Android-Weekly/2016/12/16/android-weekly-notes-issue-235/</id>
    <published>2016-12-16T06:14:34.000Z</published>
    <updated>2016-12-16T06:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-235"><a href="#Android-Weekly-Issue-235" class="headerlink" title="Android Weekly Issue #235"></a>Android Weekly Issue #235</h1><p>December 11th, 2016<br><a href="http://androidweekly.net/issues/issue-235" target="_blank" rel="external">Android Weekly Issue #235</a><br>本期内容包括: 开发一个自定义View并发布为开源库的完整流程介绍; 用<code>AnimatedVectorDrawable</code>实现的动画; 什么样的程序是可测试的; <code>DownloadManager</code>介绍; Okhttp的重试; Android 7取消了<code>file://</code>; Android Studio即将推出的build cache功能; 支持离线模式的app构架; 如何写自定义的lint规则; Epoxy, 一个处理复杂RecyclerView屏的库; <code>FragmentPagerAdapter</code>和<code>FragmentStatePagerAdapter</code>的比较等. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Make-an-android-custom-view-publish-and-open-source"><a href="#Make-an-android-custom-view-publish-and-open-source" class="headerlink" title="Make an android custom view, publish and open source "></a><a href="https://medium.com/dualcores-studio/make-an-android-custom-view-publish-and-open-source-99a3d86df228#.zc8s14lek" target="_blank" rel="external">Make an android custom view, publish and open source </a></h2><p>作者开发了一个环形的SeekBar, 并把它作为一个库发布到了JCenter.</p>
<p><strong>作者首先讲了自定义View的实现</strong>:<br>首先是关于View生命周期的介绍, 在写自定义View的时候有几个关键的生命周期回调需要处理:<br><img src="/images/view-lifecycle-diagram-lite-version.png" alt="view-lifecycle-diagram-lite-version"></p>
<p>作者实现的几个关键步骤讲解:</p>
<ul>
<li>自定义属性并获取.</li>
<li>在<code>onMeasure()</code>中控制尺寸.</li>
<li>在<code>onDraw()</code>中绘制: 避免在<code>onDraw()</code>中分配内存; 用<code>invalidate()</code>方法来激发重绘.</li>
<li>在<code>onTouchEvent()</code>处理用户手势. 在他的环形SeekBar的实现里, 这里涉及到了点击坐标到角度的转换. </li>
</ul>
<p><strong>将自定义View库开源到Github</strong>:<br>开源到Github有个好的README很重要, 这里有几个tips:</p>
<ul>
<li>提供截图, Gif或者Video.</li>
<li>提供安装/使用说明.<br>作者自己的库: <a href="https://github.com/enginebai/SwagPoints" target="_blank" rel="external">SwagPoints</a></li>
</ul>
<p><strong>发布库</strong>:</p>
<ul>
<li>去<a href="https://bintray.com/" target="_blank" rel="external">JFrog Bintray</a>注册.</li>
<li>创建repository, package, 和版本号.</li>
<li>生成并上传, 用了<a href="https://github.com/blundell/release-android-library" target="_blank" rel="external">这个library</a>.</li>
<li>添加到Jcenter.</li>
<li>被接受之后收到邮件, 就可以使用了.</li>
</ul>
<h2 id="Animation-Jump-through"><a href="#Animation-Jump-through" class="headerlink" title="Animation: Jump-through"></a><a href="https://medium.com/google-developers/animation-jump-through-861f4f5b3de4#.k238d5tw2" target="_blank" rel="external">Animation: Jump-through</a></h2><p>用<code>AnimatedVectorDrawable</code>实现的一个很fancy的位置标志动画.</p>
<h2 id="What-makes-Android-Apps-Testable"><a href="#What-makes-Android-Apps-Testable" class="headerlink" title="What makes Android Apps Testable"></a><a href="http://www.philosophicalhacker.com/post/what-makes-android-apps-testable/" target="_blank" rel="external">What makes Android Apps Testable</a></h2><p>如果程序的架构不适合测试, 那么硬要写一些测试很可能就会面临这样的局面: 要么就是发现没法写测试, 要么就是为了写测试而破坏了代码, 做了一些奇怪的事情.</p>
<p>那么到底是什么样的程序才是适合写测试, 或者是可测试的呢?</p>
<p>有一个有趣的定义是seam(接缝), 在接缝处你可以改变程序的行为, 而不用编辑当前程序. 如果程序没有接缝, 你将无法设置测试的初始条件和验证测试结果.</p>
<p>本文中举了一个实际的例子, 开始的时候程序没有seam, 所以导致无法测试, 后来把静态方法改为实例的方法之后, 我们就可以通过Mockito来模拟行为, 设置条件, 最后通过验证某一方法的调用与否来进行验证.</p>
<h2 id="DownloadManager-–-Part-3"><a href="#DownloadManager-–-Part-3" class="headerlink" title="DownloadManager – Part 3"></a><a href="https://blog.stylingandroid.com/downloadmanager-part-3/" target="_blank" rel="external">DownloadManager – Part 3</a></h2><p>用<code>DownloadManager</code>来处理下载.<br>首先它在设备上有自己的UI, 还有notification, 还有Downloads app能让用户管理下载文件.</p>
<p> 我们可以查询到文件的一些信息, 比如MIME type, 文件尺寸, 下载状态等.</p>
<p> 我们还可以用<code>getUriForDownloadedFile()</code>方法来获取一个URI, 配合MIME type, 发送Intent, 来打开一个相关的查看程序.</p>
<p> 关于储存文件的合适地点:</p>
<ul>
<li>文件小, 仅app自己使用 -&gt; 私有数据区域(默认行为).</li>
<li>文件大, 仅app自己使用 -&gt; 外部存储的私有数据区域(不需要权限). <code>setDestinationInExternalFilesDir()</code>.</li>
<li>文件需要被别的应用访问 -&gt; 外部存储的共有区域, 需要<code>WRITE_EXTERNAL_STORAGE</code>权限. <code>setDestinationInExternalPublicDir()</code>.</li>
</ul>
<h2 id="OkHttp-is-quietly-retrying-requests-Is-your-API-ready"><a href="#OkHttp-is-quietly-retrying-requests-Is-your-API-ready" class="headerlink" title="OkHttp is quietly retrying requests. Is your API ready?"></a><a href="https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace#.ldxyyly7t" target="_blank" rel="external">OkHttp is quietly retrying requests. Is your API ready?</a></h2><p>在网路较慢或不稳定的时候, OkHttp有可能会重复发送请求, 直到成功. </p>
<p>这个重试的逻辑是通过<a href="https://github.com/square/okhttp/blob/07309c1c7d9e296014268ebd155ebf7ef8679f6c/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java" target="_blank" rel="external">RetryAndFollowUpInterceptor.java</a>实现的.</p>
<p>那么, 我们可以关掉这个重试行为吗? 有一些issues就在讨论这个问题: <a href="https://github.com/square/okhttp/issues/1043" target="_blank" rel="external">Issue # 1043</a>. 后来有两个pull requests:  <a href="https://github.com/square/okhttp/pull/1259" target="_blank" rel="external">PR #1259</a>和<a href="https://github.com/square/okhttp/pull/2479" target="_blank" rel="external">PR #2479</a>改进了这个问题, 减少(但并没有消除)了不必要的retry请求.</p>
<p>全局关闭重试行为: <code>OkHttpClient.Builder .retryOnConnectionFailure()</code>设置为false. 但是注意这样是很粗暴并具有破坏性的, 消除了retry逻辑带来的好处:</p>
<ul>
<li>如果Url有多个IP, 失败了一个还可以试另一个.</li>
<li>连接池中的连接偶尔会time out, 减少这种意外导致的后果.</li>
<li>可以顺次查找多个代理, 如果都失败了再转向直接连接.</li>
</ul>
<p><strong>解决真正的问题</strong>: 关闭静默重试在某些情形下有帮助, 但是其实它隐藏了真正的问题, 就是你的API是否是幂等的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">idempotent</a>. server端可以根据客户端的GUID来检测重复, 这样server就不会多次执行操作, 会通知发送者.</p>
<h2 id="File-scheme-is-now-not-allowed-with-Intent-on-N"><a href="#File-scheme-is-now-not-allowed-with-Intent-on-N" class="headerlink" title="File scheme is now not allowed with Intent on N"></a><a href="https://inthecheesefactory.com/blog/how-to-share-access-to-file-with-fileprovider-on-android-nougat/en" target="_blank" rel="external">File scheme is now not allowed with Intent on N</a></h2><p>Android N (Nougat, API 24)开始, 不再允许发送<code>file://</code>的Intent, 将会直接抛出<code>FileUriExposedException</code>异常.</p>
<p>所以当你把<code>targetSdkVersion</code>改为24之后, 你必须要确保你修复了这些问题再发布.</p>
<p>解决方案是什么呢? 用<code>content://</code>, 结合<code>FileProvider</code>:<br>首先在manifest里面声明:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></div><div class="line">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.provider"</span></div><div class="line">    <span class="attr">android:exported</span>=<span class="string">"false"</span></div><div class="line">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></div><div class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>res\xml\provider_paths.xml</code>文件里指明路径:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external_files"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最后, 把<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uri photoURI = Uri.fromFile(createImageFile());</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri photoURI = FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,</div><div class="line">        BuildConfig.APPLICATION_ID + <span class="string">".provider"</span>,</div><div class="line">        createImageFile());</div></pre></td></tr></table></figure></p>
<p>然后放在Intent里发送就好了.</p>
<p>注意, 如果你的<code>targetSdkVersion</code>还没有更新到24, 那么即便是在Nougat的手机上<code>file://</code>也仍然是能正常使用的.</p>
<h2 id="Use-Android-Studio-Gradle-Build-Cache-for-faster-builds"><a href="#Use-Android-Studio-Gradle-Build-Cache-for-faster-builds" class="headerlink" title="Use Android Studio Gradle Build Cache for faster builds"></a><a href="http://zeroturnaround.com/rebellabs/using-build-cache-in-android-studio-makes-gradle-build-faster/" target="_blank" rel="external">Use Android Studio Gradle Build Cache for faster builds</a></h2><p>Android Studio当前的最新版是2.3 Canary 2. 有一些新的改进, 但是其中最吸引人的是这个<a href="http://tools.android.com/tech-docs/build-cache" target="_blank" rel="external">build cache</a>. 它会使你的clean build更快.</p>
<p>本文后面解析了build cache的工作原理.</p>
<h2 id="Offline-App-Architecture-build-for-the-Next-Billion"><a href="#Offline-App-Architecture-build-for-the-Next-Billion" class="headerlink" title="Offline App Architecture, build for the Next Billion"></a><a href="https://hackernoon.com/so-you-want-to-develop-for-the-next-billion-9eb072c26bc8#.1zklimr3o" target="_blank" rel="external">Offline App Architecture, build for the Next Billion</a></h2><p>一个好的应用应该在网络不好甚至离线的时候仍然可以使用, 我们应该做些什么呢?</p>
<ul>
<li>确定连接状况. 可以使用这个<a href="https://github.com/facebook/network-connection-class" target="_blank" rel="external">network-connection-class
</a>. 如果你使用的是Okhttp, 可以加一个Intercepter来进行采样.</li>
<li>有效地缓存. 从网络取数据很慢并且昂贵, 所以有效地利用之前取到的数据是很关键的优化. (Cache-Control, Etag).</li>
<li>在本地操作, 在全局同步. 等网络请求的时候可以先显示本地数据, 而不是loading.</li>
<li>有效地处理线程.</li>
<li>优化图片. 网络不好的时候先用RGB_565, 等网络变好了再取高质量图片.</li>
<li>使用大Cookie. 尽量一次传输更多的数据(big cookie), 而不是频繁发送一些小请求(small cookies).</li>
</ul>
<h2 id="Writing-custom-lint-rules-and-integrating-them"><a href="#Writing-custom-lint-rules-and-integrating-them" class="headerlink" title="Writing custom lint rules and integrating them"></a><a href="https://medium.com/@mosesJay/writing-custom-lint-rules-and-integrating-them-with-android-studio-inspections-or-carefulnow-c54d72f00d30#.5y0o98bor" target="_blank" rel="external">Writing custom lint rules and integrating them</a></h2><p>如何创建自定义的lint规则.<br>事情的由来是作者发现了一个死循环调用, 然后他想做一个什么标记以防以后其他人会犯同样的错误.</p>
<p>然后他想到的是<a href="https://developer.android.com/studio/write/annotations.html#adding-nullness" target="_blank" rel="external">@Nullable注解</a>, 的检查, 实质是依靠<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">lint</a>来实现的.</p>
<p>于是他自己写了一个自定义的lint规则, 来提示使用用他的注解<code>@CarefulNow</code>标记的方法时应当注意.<br>详细的实现方式请看原文.</p>
<h2 id="Epoxy-Airbnb’s-View-Architecture-on-Android"><a href="#Epoxy-Airbnb’s-View-Architecture-on-Android" class="headerlink" title="Epoxy: Airbnb’s View Architecture on Android"></a><a href="https://medium.com/airbnb-engineering/epoxy-airbnbs-view-architecture-on-android-c3e1af150394#.uyvuayspc" target="_blank" rel="external">Epoxy: Airbnb’s View Architecture on Android</a></h2><p><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a>是一个Android库, 用来处理复杂的RecyclerView屏. 本文介绍了它在项目中实际的使用.</p>
<h2 id="Adventures-with-FragmentStatePagerAdapter"><a href="#Adventures-with-FragmentStatePagerAdapter" class="headerlink" title="Adventures with FragmentStatePagerAdapter"></a><a href="https://medium.com/inloop/adventures-with-fragmentstatepageradapter-4f56a643f8e0#.qk6aygake" target="_blank" rel="external">Adventures with FragmentStatePagerAdapter</a></h2><p>可能有很多Android开发者对于<br><a href="https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html" target="_blank" rel="external">FragmentPagerAdapter</a>和<a href="https://developer.android.com/reference/android/support/v4/app/FragmentStatePagerAdapter.html" target="_blank" rel="external">FragmentStatePagerAdapter</a>的区别不是太清楚或根本不知道, 本文作者就具体介绍了二者的不同.</p>
<p><strong>基本不同</strong></p>
<p><code>FragmentPagerAdapter</code><br>适用于项目个数确定的情形.<br>为什么呢? 因为一旦fragment的实例被创建, 它永远也不会从<code>FragmentManager</code>中移除, 直到Activity被销毁.</p>
<p>当Fragment不见的时候, 仅仅是<code>onDestroyView()</code>被调用, 当fragment再次回来时, 再调用<code>onCreateView()</code>.</p>
<p><code>FragmentStatePagerAdapter</code><br>当fragment的实例不可达的时候, 实例就会立即从<code>FragmentManager</code>移除. 被移除的fragment实例的状态由<code>FragmentStatePagerAdapter</code>保存, 当你再次回到该项的时候, fragment会重建新实例, 并且状态被恢复. 所以这种adapter适用于项目个数不确定或的情况.</p>
<p>所以使用<code>FragmentPagerAdapter</code>的时候需要注意内存问题.</p>
<p><strong>notifyDatasetChanged()的问题</strong>.</p>
<p><code>notifyDataSetChanged()</code>是用来处理数据集变化的情况, 比如一些项目增删的情况. 这个方法不是用来刷新当前显示的Fragment或其中的Views的.</p>
<p>文章中还有一些关于数据改变实现以及现有issue的讨论. 为了解决issue作者还发布了一个库<a href="https://github.com/inloop/UpdatableFragmentStatePagerAdapter" target="_blank" rel="external">UpdatableFragmentStatePagerAdapter</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KeepActivitiesTile"><a href="#KeepActivitiesTile" class="headerlink" title="KeepActivitiesTile"></a><a href="https://github.com/Stocard/KeepActivitiesTile" target="_blank" rel="external">KeepActivitiesTile</a></h2><p>一个quick settings tile来开启”Don’t keep activities”.</p>
<h2 id="WaveLoading"><a href="#WaveLoading" class="headerlink" title="WaveLoading"></a><a href="https://github.com/race604/WaveLoading" target="_blank" rel="external">WaveLoading</a></h2><p>一个波形的loading图, 水面上涨代表loading程度.</p>
<h2 id="coordinators"><a href="#coordinators" class="headerlink" title="coordinators"></a><a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a></h2><p>Simple MVWhatever for Android.</p>
<h2 id="epoxy"><a href="#epoxy" class="headerlink" title="epoxy"></a><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a></h2><p>一个处理复杂的RecyclerView屏的库.</p>
<h2 id="Screen-Record-for-Android"><a href="#Screen-Record-for-Android" class="headerlink" title="Screen Record for Android"></a><a href="https://gist.github.com/tasomaniac/93cefd97af13e2ea2b2f248affb373bd" target="_blank" rel="external">Screen Record for Android</a></h2><p>录屏脚本.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Weekly-Issue-235&quot;&gt;&lt;a href=&quot;#Android-Weekly-Issue-235&quot; class=&quot;headerlink&quot; title=&quot;Android Weekly Issue #235&quot;&gt;&lt;/a&gt;Android Weekly Issue #235&lt;/h1&gt;&lt;p&gt;December 11th, 2016&lt;br&gt;&lt;a href=&quot;http://androidweekly.net/issues/issue-235&quot;&gt;Android Weekly Issue #235&lt;/a&gt;&lt;br&gt;本期内容包括: 开发一个自定义View并发布为开源库的完整流程介绍; 用&lt;code&gt;AnimatedVectorDrawable&lt;/code&gt;实现的动画; 什么样的程序是可测试的; &lt;code&gt;DownloadManager&lt;/code&gt;介绍; Okhttp的重试; Android 7取消了&lt;code&gt;file://&lt;/code&gt;; Android Studio即将推出的build cache功能; 支持离线模式的app构架; 如何写自定义的lint规则; Epoxy, 一个处理复杂RecyclerView屏的库; &lt;code&gt;FragmentPagerAdapter&lt;/code&gt;和&lt;code&gt;FragmentStatePagerAdapter&lt;/code&gt;的比较等. &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://mengdd.github.io/categories/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/categories/Android/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://mengdd.github.io/tags/Android/"/>
    
      <category term="Android Weekly" scheme="http://mengdd.github.io/tags/Android-Weekly/"/>
    
      <category term="AnimatedVectorDrawable" scheme="http://mengdd.github.io/tags/AnimatedVectorDrawable/"/>
    
      <category term="Animation" scheme="http://mengdd.github.io/tags/Animation/"/>
    
      <category term="RecyclerView" scheme="http://mengdd.github.io/tags/RecyclerView/"/>
    
      <category term="Android Studio" scheme="http://mengdd.github.io/tags/Android-Studio/"/>
    
      <category term="Nougat" scheme="http://mengdd.github.io/tags/Nougat/"/>
    
      <category term="Android 7" scheme="http://mengdd.github.io/tags/Android-7/"/>
    
      <category term="Test" scheme="http://mengdd.github.io/tags/Test/"/>
    
      <category term="Custom View" scheme="http://mengdd.github.io/tags/Custom-View/"/>
    
      <category term="JCenter" scheme="http://mengdd.github.io/tags/JCenter/"/>
    
      <category term="DownloadManager" scheme="http://mengdd.github.io/tags/DownloadManager/"/>
    
      <category term="OkHttp" scheme="http://mengdd.github.io/tags/OkHttp/"/>
    
      <category term="Offline Architecture" scheme="http://mengdd.github.io/tags/Offline-Architecture/"/>
    
      <category term="lint" scheme="http://mengdd.github.io/tags/lint/"/>
    
      <category term="FragmentPagerAdapter" scheme="http://mengdd.github.io/tags/FragmentPagerAdapter/"/>
    
      <category term="FragmentStatePagerAdapter" scheme="http://mengdd.github.io/tags/FragmentStatePagerAdapter/"/>
    
  </entry>
  
</feed>
