<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[网络使用和电池消耗 原因和改进]]></title>
      <url>http://mengdd.github.io/Android/2017/04/11/network-usage-and-battery-consumption/</url>
      <content type="html"><![CDATA[<h1 id="网络使用和电池消耗-原因和改进"><a href="#网络使用和电池消耗-原因和改进" class="headerlink" title="网络使用和电池消耗 原因和改进"></a>网络使用和电池消耗 原因和改进</h1><p>你的app发送的网络请求是电量消耗的主要原因, 本文先教你如何使用IDE工具来分类分析应用中的网络请求, 之后按照三种不同的网络请求分类, 分别给出优化建议, 减少电量消耗.</p>
<p>本文是对Android官网<a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>系列文章的翻译, 略有删减, 可以作为摘要看看. (翻译不当的地方还请见谅).</p>
<a id="more"></a>
<h2 id="收集网络数据-Collecting-Network-Traffic-Data"><a href="#收集网络数据-Collecting-Network-Traffic-Data" class="headerlink" title="收集网络数据 Collecting Network Traffic Data"></a>收集网络数据 <a href="https://developer.android.com/topic/performance/power/network/gather-data.html" target="_blank" rel="external">Collecting Network Traffic Data</a></h2><p>使用<a href="https://developer.android.com/studio/profile/ddms.html#network" target="_blank" rel="external">Network Traffic tool</a>可以看到你的app如何以及何时通过网络发送数据.<br>本节教你如何通过在代码中加tag来测量和分类网络请求, 然后教你如何部署, 测试和可视化你的网络请求.</p>
<p>可以把网络请求分三类:</p>
<ul>
<li>用户发起的.</li>
<li>App发起的.</li>
<li>Server发起的. 比如notification.</li>
</ul>
<p>对这三个分类定义三个常量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_INITIATED = <span class="number">0x1000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_INITIATED = <span class="number">0x2000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_INITIATED =<span class="number">0x3000</span>;</div></pre></td></tr></table></figure></p>
<p>全文搜索:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extends GcmTaskService|extends JobService|extends AbstractThreadedSyncAdapter|HttpUrlConnection|Volley|Glide|HttpClient</div></pre></td></tr></table></figure></p>
<p>勾选Regular expression, File mask(s) 写 *.java.</p>
<p>找出所有的网络请求后, 加上下面的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (BuildConfig.NETWORK-TEST &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        TrafficStats.setThreadStatsTag(USER_INITIATED);</div><div class="line">        <span class="comment">// make network request using HttpClient.execute()</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        TrafficStats.clearThreadStatsTag();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中build type的配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    buildTypes &#123;</div><div class="line">        debug &#123;</div><div class="line">            // debuggable true is default for the debug buildType</div><div class="line">        &#125;</div><div class="line">        network-test &#123;</div><div class="line">            debuggable true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行测试:<br>Tools &gt; Android &gt; Android Device Monitor.<br>选择tab: Network Statistics.<br>选择你的应用, 然后按开始按钮.<br>你可以用下面的命令来清除应用的数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear package.name.of.app</div></pre></td></tr></table></figure></p>
<p>然后在你的应用中跑你想测试的应用场景即可.</p>
<p>使用了不同tag的网络请求会用不同的颜色显示出来.</p>
<h2 id="分析网络数据-Analyzing-Network-Traffic-Data"><a href="#分析网络数据-Analyzing-Network-Traffic-Data" class="headerlink" title="分析网络数据 Analyzing Network Traffic Data"></a>分析网络数据 <a href="https://developer.android.com/topic/performance/power/network/analyze-data.html" target="_blank" rel="external">Analyzing Network Traffic Data</a></h2><p>有效应用网络资源的特点: 应该有大段的时间网络硬件没有在使用中. 因为在移动设备上, 发送和接收数据, 长时间保持数据连接都会有巨大的花销. 如果你的应用访问网络很有效率, 那么网络通信看起来就应该是紧耦合的, 被无请求的休息时段合理地隔开.</p>
<h3 id="分析网络数据类型"><a href="#分析网络数据类型" class="headerlink" title="分析网络数据类型"></a>分析网络数据类型</h3><p>如果你的网络请求图看起来存在这方面的问题, 我们就需要根据上一节中加tag而分三种类型形成的网络图来进行分析, 提供一些优化意见.</p>
<h4 id="分析用户发起的网络请求"><a href="#分析用户发起的网络请求" class="headerlink" title="分析用户发起的网络请求"></a>分析用户发起的网络请求</h4><p>用户发起的网络请求: 当用户在执行一项特定的活动时, 可能可以有效地耦合在一起; 或者当用户不断请求附加信息时, 非均匀地展开. 当在分析用户发起的请求是, 你的目标是: 寻找频繁的网络使用模式, 还有试图创建或增加不使用网络的时段.</p>
<p>这种网络请求优化的挑战是用户请求的不确定性. 另外, 用户在使用app的时候总是期待快速的响应, 所以推迟请求会降低用户体验. 一般来说, 当用户和app直接交互时, 快速响应的优先级是高于有效的网络请求使用的.</p>
<p>这里是一些对于用户网络请求的优化手段:</p>
<ul>
<li>预取. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#pre-fetch-data" target="_blank" rel="external">Pre-fetch Network Data</a>. 当用户执行一项操作的时候, 应用预计一下它下一步可能需要的数据, 在单个连接中批量获取它们, 然后持有它们直到用户请求它们.</li>
<li>检测连接或监听变化. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#check-or-listen" target="_blank" rel="external">Check for Connectivity or Listen for Changes</a>. 在执行更新前, 检测网络连接, 或者监听网络连接变化.</li>
<li>减少连接数. <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html#reduce-connections" target="_blank" rel="external">Reduce the Number of Connections</a>. 使用允许数据按集合下载的server APIs</li>
</ul>
<h4 id="分析app发起的网络请求"><a href="#分析app发起的网络请求" class="headerlink" title="分析app发起的网络请求"></a>分析app发起的网络请求</h4><p>由你的应用发起的网络请求通常是一个对有效网络带宽有很大影响的方面. 在分析应用的网络活动的时候, 寻找空闲时段, 决定它们是否能被扩展. 如果你看到一致的网络请求的模式, 你应该寻找一些方法来改进, 以允许切换到低功耗模式.</p>
<p>一些优化app发起请求的手段:</p>
<ul>
<li>批处理和定时. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#batch-schedule" target="_blank" rel="external">Batch and Schedule Network Requests</a> 推迟你的网络请求以便它们可以一起处理, 并且在一个对电池来说有优势的时间.</li>
<li>允许系统检查连接. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#check-connect" target="_blank" rel="external">Allow System to Check for Connectivity</a>. 应该避免仅仅为了检查网络连接而引起的电池耗损, 在应用休眠的时候, 你可以让系统来帮你做检查.</li>
</ul>
<h4 id="分析server发起的网络请求"><a href="#分析server发起的网络请求" class="headerlink" title="分析server发起的网络请求"></a>分析server发起的网络请求</h4><p>由server对应用发起的网络请求通常也是一个对有效网络带宽有很大影响的方面. 在分析来自server的网络活动的时候, 寻找非活跃的时期, 看它们是否能被增加. </p>
<p>优化手段:</p>
<ul>
<li>使用GCM. <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html#gcm" target="_blank" rel="external">Use GCM for Server Updates</a>. 考虑使用Google Cloud Messaging service来做server端的更新, 而不是轮询.</li>
</ul>
<h2 id="优化用户网络请求-Optimizing-User-Initiated-Network-Use"><a href="#优化用户网络请求-Optimizing-User-Initiated-Network-Use" class="headerlink" title="优化用户网络请求 Optimizing User-Initiated Network Use"></a>优化用户网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-user-traffic.html" target="_blank" rel="external">Optimizing User-Initiated Network Use</a></h2><p>快速处理用户的请求保证了良好的用户体验, 所以与此相比, 节约能量的优先级比较低.</p>
<h3 id="预取-Pre-fetch-Network-Data"><a href="#预取-Pre-fetch-Network-Data" class="headerlink" title="预取 Pre-fetch Network Data"></a>预取 Pre-fetch Network Data</h3><p>预取数据是一个减少数据传输的session数量很有效的方法. 使用预取, 在用户执行一个行为的时候, app预测下一步行为最有可能会用到的数据, 然后批量取出相关数据. 电池能量消耗因为两个原因被降低了:</p>
<ul>
<li>因为预取数据发生在mobile radio已经唤醒的状态, 所以不用再次唤醒. </li>
<li>应用预取了数据, 不然可能需要重新发另外的请求或者唤醒radio.</li>
</ul>
<p>Tip: 为了查看是否你的应用可以从预取中获利, 你可以检查你的网络traffic, 寻找永远导致多个网络请求的特定系列的用户行为. 比如那些当用户浏览时增量下载文章内容的应用, 可以在用户当前查看的分类下预取一个或多个文章.</p>
<p>更多可以查看: <a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#PrefetchData" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h3 id="检查连接-Check-for-Connectivity-or-Listen-for-Changes"><a href="#检查连接-Check-for-Connectivity-or-Listen-for-Changes" class="headerlink" title="检查连接 Check for Connectivity or Listen for Changes"></a>检查连接 Check for Connectivity or Listen for Changes</h3><p>在移动设备上来说, 搜寻信号是最费能量的操作之一. 你的应用应该总是在发出用户请求之前检查连接状态. <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html#choosing-scheduler" target="_blank" rel="external">Schedulers</a>可以帮你自动做这个.</p>
<ul>
<li>如果你的一些按钮依赖于网络连接, 用<a href="https://developer.android.com/reference/android/net/ConnectivityManager.html" target="_blank" rel="external">ConnectivityManager</a>来检查连接. 如果没有网络连接, app就可以节省下强制连接的电量. 具体做法见<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html#MonitorChanges" target="_blank" rel="external">Monitor for Changes in Connectivity</a>.</li>
<li>如果没有网络的情况下, 你的应用整个界面都处于不可用状态, 那么你可以根据需要使用Broadcast Receivers. 在你的Activity处于前台时监听网络连接变化, 当没有连接的时候, 就不再发请求. 如果你的app检测到网络连接丢失, 除了检测网路连接的那个receiver, 它关闭掉其他所有的receivers.</li>
</ul>
<p>对于用户发起的请求, 一个最佳实践就是在请求之前检查连接, 如果网络连接不存在, 可以调度请求在连接上以后再进行. 调度器可以用一些方式来节省电量, 比如每次检查的时候连接失败, 那么就加倍延迟时间下次再检查.</p>
<h3 id="减少连接数-Reduce-the-Number-of-Connections"><a href="#减少连接数-Reduce-the-Number-of-Connections" class="headerlink" title="减少连接数 Reduce the Number of Connections"></a>减少连接数 Reduce the Number of Connections</h3><p>一般来讲, 复用已存在的网络连接比启动新的更高效. 复用连接还允许网络更智能地对待拥堵和相关网络数据问题.<br>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html#ReduceConnections" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a>.</p>
<h2 id="优化App发起的网络请求-Optimizing-App-Initiated-Network-Use"><a href="#优化App发起的网络请求-Optimizing-App-Initiated-Network-Use" class="headerlink" title="优化App发起的网络请求 Optimizing App-Initiated Network Use"></a>优化App发起的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-app-traffic.html" target="_blank" rel="external">Optimizing App-Initiated Network Use</a></h2><p>你的应用发起的网络请求通常可以大幅度改善, 因为你可以对需要的资源做出计划并且设置访问它们的时间. 通过合理地调度时间, 可以创建出大段的设备radio空闲时间, 从而节约电量. 有一些Android的API可以用来调度网络访问, 并且其中的一些功能可以用来调节对其他应用的网络访问, 从而进一步优化电池性能.</p>
<h3 id="批处理和定时-Batch-and-Schedule-Network-Requests"><a href="#批处理和定时-Batch-and-Schedule-Network-Requests" class="headerlink" title="批处理和定时 Batch and Schedule Network Requests"></a>批处理和定时 Batch and Schedule Network Requests</h3><p>随机处理单个的请求会花掉很多的能量, 一个更高效的方法是把一系列的请求放入一个队列一起处理.</p>
<p>使用一个网络请求scheduler API用来管理和处理你的请求队列可以提高app的能量效率. Schedulers保存能量是通过把请求组合在一起, 让系统来处理. 它们还可以通过延迟一些请求, 等其他请求唤醒radio的时候, 或者等设备在充电的时候再做请求, 来进一步优化. Schedulers延迟和批处理请求是在系统范围的, 可以跨多个应用, 相比单个应用中的优化, 这给了它们更多优势.</p>
<h4 id="选择一个batch-and-scheduling-API"><a href="#选择一个batch-and-scheduling-API" class="headerlink" title="选择一个batch-and-scheduling API"></a>选择一个batch-and-scheduling API</h4><p>Android提供了三种API, 对于大多数操作功能相似, 按推荐性从高到低排列:</p>
<ul>
<li><a href="https://developers.google.com/cloud-messaging/network-manager" target="_blank" rel="external">GCM Network Manager</a>. 要求使用Google Play services.</li>
<li><a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">Job Scheduler</a>. Android 5.0 (API 21)及以上.</li>
<li><a href="https://developer.android.com/training/sync-adapters/index.html" target="_blank" rel="external">Sync Adapter for scheduled syncs</a>. 相比于前两种来说, 这种实现起来比较复杂.</li>
</ul>
<h3 id="允许系统检验连接-Allow-System-to-Check-for-Connectivity"><a href="#允许系统检验连接-Allow-System-to-Check-for-Connectivity" class="headerlink" title="允许系统检验连接 Allow System to Check for Connectivity"></a>允许系统检验连接 Allow System to Check for Connectivity</h3><p>一个最严重且意外的电池消耗原因是当用户超出信号塔或接入点范围时. 在这种情况下, 用户可能并没有使用手机, 但是他们注意到设备变热, 电池电量变少.</p>
<p>在这种情形下, 可能是app正在跑一个后台进程, 其中以固定时间间隔搜寻信号. 搜寻信号是一个很耗电的操作.</p>
<p>避免这个问题的方法是用一种更高效的方式来查询信号连接情况. 对于app发起的请求, 可以用一个scheduler, 在其中用<a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring.html" target="_blank" rel="external">Connectivity Manager</a>来检查连接. 如果没有网络连接, Connectivity Manager节约了能量, 因为它是自己检查了连接, 而不是启动了app来做检查. 可以进一步使用<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="external">exponential backoff</a>来做优化, 如果没有连接, 那么扩大检查的时间间隔.</p>
<h2 id="优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use"><a href="#优化来自server的网络请求-Optimizing-Server-Initiated-Network-Use" class="headerlink" title="优化来自server的网络请求 Optimizing Server-Initiated Network Use"></a>优化来自server的网络请求 <a href="https://developer.android.com/topic/performance/power/network/action-server-traffic.html" target="_blank" rel="external">Optimizing Server-Initiated Network Use</a></h2><p>由server发往app的请求优化起来比较有难度. 一种解决方案是客户端轮询, 检查server是否有更新, 这种方式很浪费. 一种更有效率的方式是当有新数据的时候通知你的app.</p>
<p><a href="https://developers.google.com/cloud-messaging/gcm" target="_blank" rel="external">Google Cloud Messaging</a> GCM就是为了解决这个问题. 让你的server可以向app发送通知, 提高了网络效率, 降低了能量消耗.</p>
<h3 id="用GCM发送服务器更新-Send-Server-Updates-with-GCM"><a href="#用GCM发送服务器更新-Send-Server-Updates-with-GCM" class="headerlink" title="用GCM发送服务器更新 Send Server Updates with GCM"></a>用GCM发送服务器更新 Send Server Updates with GCM</h3><p>Google Cloud Messaging (GCM)是一个轻量级的机制, 用于server向app传输一些简短的信息. 使用了GCM之后, server就可以在有数据更新的时候通知app, 这个方法减少了app查询更新却没有数据的能量消耗, 也避免了周期性的轮询请求.</p>
<p>注意: 通常情况使用<a href="https://developers.google.com/cloud-messaging/concept-options#setting-the-priority-of-a-message" target="_blank" rel="external">Normal priority</a>即可, 这样不会在设备非活跃或者低电量的时候唤醒设备.</p>
<h2 id="优化一般的网络使用-Optimizing-General-Network-Use"><a href="#优化一般的网络使用-Optimizing-General-Network-Use" class="headerlink" title="优化一般的网络使用 Optimizing General Network Use"></a>优化一般的网络使用 <a href="https://developer.android.com/topic/performance/power/network/action-any-traffic.html" target="_blank" rel="external">Optimizing General Network Use</a></h2><p>一般情况下, 减少网络请求会对节约电量有帮助. 除了之前提到的改进方法, 你还应该知道一些一般性的方法. </p>
<h3 id="压缩数据-Compress-Data"><a href="#压缩数据-Compress-Data" class="headerlink" title="压缩数据 Compress Data"></a>压缩数据 Compress Data</h3><p>减少发送或接受的数据量会帮助减少连接时间, 从而节约电量.<br>你可以:</p>
<ul>
<li>压缩数据, 用一些压缩方法, 比如GZIP压缩.</li>
<li>使用简洁的数据协议. JSON和XML提供了可读性和语言灵活性, 但是它们都是很占带宽的模式, 并且在Android上有一些序列化花销.<br>二进制序列化格式, 比如<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">Protocol Buffers</a>或<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>, 提供了更小的数据包大小, 以及更快的编解码时间. 如果你的应用经常需要传输序列化数据, 这些格式会帮你获得解码时间和传输大小方面的优势.</li>
</ul>
<h3 id="本地缓存文件-Cache-Files-Locally"><a href="#本地缓存文件-Cache-Files-Locally" class="headerlink" title="本地缓存文件 Cache Files Locally"></a>本地缓存文件 Cache Files Locally</h3><p>应用可以通过缓存来避免下载重复的数据. 始终缓存静态资源, 包括要求下载的全尺寸图像, 并尽可能长时间缓存它们.</p>
<p>缓存实现见: <a href="https://developer.android.com/training/efficient-downloads/redundant_redundant.html#LocalCache" target="_blank" rel="external">Cache Files Locally</a>.</p>
<h3 id="优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size"><a href="#优化预取缓存大小-Optimize-Pre-Fetch-Cache-Size" class="headerlink" title="优化预取缓存大小 Optimize Pre-Fetch Cache Size"></a>优化预取缓存大小 Optimize Pre-Fetch Cache Size</h3><p>根据本地文件系统的尺寸和当前的网络连接来优化预取缓存大小. 你可以使用connectivity manager来确定处于活动状态的网络类型(Wi-FI, LTE, HSPAP, EDGE, GPRS), 并修改你的预取程序来最小化电池负载.</p>
<p>更多信息请看<a href="https://developer.android.com/training/efficient-downloads/connectivity_patterns.html#Bandwidth" target="_blank" rel="external">Use Modifying your Download Patterns Based on the Connectivity Type</a>.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Network </tag>
            
            <tag> Battery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 251]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/04/06/android-weekly-notes-issue-251/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-251"><a href="#Android-Weekly-Issue-251" class="headerlink" title="Android Weekly Issue #251"></a>Android Weekly Issue #251</h1><p>April 2nd, 2017<br><a href="http://androidweekly.net/issues/issue-251" target="_blank" rel="external">Android Weekly Issue #251</a>.<br>本期内容: Android O新增的API: View的tooltips; Android中的字体设置; 该不该将Kotlin用于产品代码; 实现一个带自定义动画的搜索Toolbar; JUnit 5中用Lambda表达式; 用Mockito和Espresso写测试;<br>native的mobile开发应该扩展一下自己的知识; Kotlin中的依赖注入实现; Kotlin中lambda表达式的简化; 一个Intellij IDEA的插件, 帮助你改善Java代码的可读性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preliminary-look-at-View-tooltips"><a href="#Preliminary-look-at-View-tooltips" class="headerlink" title="Preliminary look at View tooltips"></a><a href="https://medium.com/@bherbst/preliminary-look-at-view-tooltips-b127583c5691" target="_blank" rel="external">Preliminary look at View tooltips</a></h2><p>Android O新推出了一个API, 是给View加tooltips.</p>
<p>如何使用:<br>可以在xml里面用属性<a href="https://developer.android.com/reference/android/view/View.html#attr_android:tooltipText" target="_blank" rel="external">android:tooltipText</a>, 或者使用Java方法<a href="https://developer.android.com/reference/android/view/View.html#setTooltipText%28java.lang.CharSequence%29" target="_blank" rel="external">View.setTooltipText()</a>来指定提示文字.</p>
<p>它们的外观看起来就像一个toast(半透明的灰色方框, 有圆角). 它支持多行, 有最大宽度, 超过98个字符结尾会以…省略.<br>目前还不能被定制.</p>
<p>它在什么时候出现呢? 长按和悬停.<br>当然你的长按如果已经被处理过了(<code>OnLongClickListener</code>返回了true), 它就不会出现了.</p>
<h2 id="Perfecting-Custom-Typography-in-Android"><a href="#Perfecting-Custom-Typography-in-Android" class="headerlink" title="Perfecting Custom Typography in Android"></a><a href="https://www.bignerdranch.com/blog/perfecting-custom-typography-in-android/" target="_blank" rel="external">Perfecting Custom Typography in Android</a></h2><p>关于字体设置的微调, 作者他们弄了一个小工具: <a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a>来提高设计师和开发者沟通字体时候的效率.</p>
<h3 id="字体尺寸"><a href="#字体尺寸" class="headerlink" title="字体尺寸"></a>字体尺寸</h3><p>对于字体, 通常我们建议用<code>sp</code>(scaleable pixel), 1pt=1sp. (pt是point).</p>
<p><code>sp</code>考虑到了用户设备上的字体设置, 所以通常是建议用sp来设置字体大小.</p>
<p>但是作者他们最近在应用中一些字很大的地方, 选择使用了<code>dp</code> (density-independent pixel), 这是因为这些字本来已经很大了, 所以他们不想让它们被调节以后变得更大.</p>
<h3 id="Leading"><a href="#Leading" class="headerlink" title="Leading"></a>Leading</h3><p>在字体排版中, Leading是指字体行之间的竖直间距. 和<code>line spacing</code>和<code>line height</code>是同义词, 同样也由<code>pt/sp</code>作为单位.</p>
<p>字体文件中会有一个基本的leading值, 根据字体不同可能会不同.</p>
<p>在Android中TextView的leading可以通过<code>lineSpacingExtra</code>和<code>lineSpacingMultiplier</code>属性来定义. 在代码中可以通过方法<a href="https://developer.android.com/reference/android/widget/TextView.html#setLineSpacing(float,%20float" target="_blank" rel="external">setLineSpacing()</a>)来定义. 注意用这个方法时, 单位是像素.</p>
<h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>Tracking指字间距(letterspacing).<br>在Android中可以通过属性<code>letterSpacing</code>来设置(API 21及以上), 以em为单位的分数测量.</p>
<h2 id="Kotlin-in-Production-Should-you-stay-or-should-you-go"><a href="#Kotlin-in-Production-Should-you-stay-or-should-you-go" class="headerlink" title="Kotlin in Production: Should you stay or should you go?"></a><a href="https://medium.com/@dpreussler/kotlin-in-production-should-you-stay-or-should-you-go-a3428b44b236" target="_blank" rel="external">Kotlin in Production: Should you stay or should you go?</a></h2><p>关于是否应该使用Kotlin, 作者发表了一些他的想法. 总体来说作者是支持Kotlin的, 对于各个可能存疑的点, 他都做出了解释.</p>
<h2 id="How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin"><a href="#How-We-Made-the-ToolBar-on-Android-Move-Like-Jelly-in-Kotlin" class="headerlink" title="How We Made the ToolBar on Android Move Like Jelly (in Kotlin)"></a><a href="https://yalantis.com/blog/toolbar-jelly-animation-kotlin-android/" target="_blank" rel="external">How We Made the ToolBar on Android Move Like Jelly (in Kotlin)</a></h2><p>在Toolbar上点击搜索按钮, 展开关键词输入框的时候, 加一个动画, 让它有弹性地震动一下, 如何实现呢?<br>本文给出了详细代码.</p>
<h2 id="JUnit-5-Lambdas"><a href="#JUnit-5-Lambdas" class="headerlink" title="JUnit 5: Lambdas"></a><a href="https://blog.stylingandroid.com/junit-5-lambdas/" target="_blank" rel="external">JUnit 5: Lambdas</a></h2><p>如何在测试中使用lambda表达式, 这篇文章里作者讨论了如何在项目中使用lambda表达式的一些方法.</p>
<p>有两个比较好的方法:</p>
<ul>
<li>用<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">retrolambda</a>.</li>
<li>用Kotlin.</li>
</ul>
<h2 id="Testing-MVP-using-Espresso-and-Mockito"><a href="#Testing-MVP-using-Espresso-and-Mockito" class="headerlink" title="Testing MVP using Espresso and Mockito"></a><a href="https://josiassena.com/testing-mvp-using-espresso-and-mockito/" target="_blank" rel="external">Testing MVP using Espresso and Mockito</a></h2><p>如何用Mockito和Espresso给一个MVP架构的程序写单元测试和UI测试.</p>
<h2 id="The-rise-of-the-full-stack-native-mobile-app-developer"><a href="#The-rise-of-the-full-stack-native-mobile-app-developer" class="headerlink" title="The rise of the full-stack native mobile app developer"></a><a href="https://medium.com/@erikhellman/the-rise-of-the-full-stack-native-mobile-app-developer-a0757388bc1b" target="_blank" rel="external">The rise of the full-stack native mobile app developer</a></h2><p>这篇文章就说native的客户端开发应该扩展自己, 学一点后端知识, 来应对行业发展和以后的趋势.</p>
<h2 id="Kotlin-Dependency-Injection-with-the-Reader-Monad"><a href="#Kotlin-Dependency-Injection-with-the-Reader-Monad" class="headerlink" title="Kotlin Dependency Injection with the Reader Monad"></a><a href="https://medium.com/@JorgeCastilloPr/kotlin-dependency-injection-with-the-reader-monad-7d52f94a482e" target="_blank" rel="external">Kotlin Dependency Injection with the Reader Monad</a></h2><p>Dependency Injection (DI)依赖注入是一种概念, 和具体使用的工具无关, 所以有各种不同的方法可以实现它.<br>本文只是提供一种思路, 用Kotlin中函数式的一些特性来做依赖注入.</p>
<p>首先介绍了什么是<code>Functors</code>, <code>Applicatives</code>和<code>Monads</code>, 作者推荐看这系列文章: <a href="https://medium.com/@aballano/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251" target="_blank" rel="external">Kotlin Functors, Applicatives, And Monads in Pictures. Part 1/3</a>.</p>
<p>后来作者举了实际的例子, 详情见原文.</p>
<h2 id="How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation"><a href="#How-lambdas-work-in-Kotlin-amp-setOnClickListener-transformation" class="headerlink" title="How lambdas work in Kotlin &amp; setOnClickListener transformation"></a><a href="https://antonioleiva.com/lambdas-kotlin-android/" target="_blank" rel="external">How lambdas work in Kotlin &amp; setOnClickListener transformation</a></h2><p>关于Kotlin中的lambda是如何简化的, 以<code>setOnClickListener()</code>为例:<br>它在Java中是这样定义的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Kotlin中是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun setOnClickListener(l: (View) -&gt; Unit)</div></pre></td></tr></table></figure></p>
<p>最原始的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(object : View.OnClickListener &#123;</div><div class="line">    override fun onClick(v: View?) &#123;</div><div class="line">        toast(&quot;Hello&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后IDE会提示你改为用lambda表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(&#123; v -&gt; toast(&quot;Hello&quot;) &#125;)</div></pre></td></tr></table></figure></p>
<p>然而这个还可以进一步被简化:</p>
<p>如果一个方法的<strong>最后一个参数</strong>是一个函数, 那么它可以写在括号外面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener() &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果一个方法只有一个参数, 并且是一个函数, 括号可以被删掉:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; v -&gt; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你并没有用到lambda表达式的参数, 你可以省略左边的部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; toast(&quot;Hello&quot;) &#125;</div></pre></td></tr></table></figure></p>
<p>如果你的表达式只有一个参数, 而你要用它, 你仍然可以不写左边的部分, 用<code>it</code>来代替它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener &#123; doSomething(it) &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Making-Java-Code-Easier-to-Read-Without-Changing-it"><a href="#Making-Java-Code-Easier-to-Read-Without-Changing-it" class="headerlink" title="Making Java Code Easier to Read (Without Changing it)"></a><a href="https://medium.com/@andrey_cheptsov/making-java-code-easier-to-read-without-changing-it-adeebd5c36de" target="_blank" rel="external">Making Java Code Easier to Read (Without Changing it)</a></h2><p>如何在不改变代码的情况下, 增加Java代码的可读性?</p>
<p>IntelliJ IDEA为Java 8以下的用户提供了代码折叠功能, 来模拟lambda的语法.</p>
<p>作者自己又开发了一个新的插件<a href="https://plugins.jetbrains.com/plugin/9320-advanced-java-folding" target="_blank" rel="external">Advanced Java Folding</a>, 进一步扩展了这个代码折叠的功能. 本文介绍其中一些features. 这些特性在插件中都是可选的, 可以根据需要和喜好配置.</p>
<p>(经过折叠以后的Java代码确实看起来很像Kotlin).</p>
<p>本期还有两篇Android Things的文章就不介绍啦.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="JellyToolbar"><a href="#JellyToolbar" class="headerlink" title="JellyToolbar"></a><a href="https://github.com/Yalantis/JellyToolbar" target="_blank" rel="external">JellyToolbar</a></h2><p>一个带弹性抖动动画的搜索Toolbar实现, 本期有一篇文章介绍.</p>
<h2 id="Android-Router"><a href="#Android-Router" class="headerlink" title="Android Router"></a><a href="https://github.com/TangXiaoLv/Android-Router" target="_blank" rel="external">Android Router</a></h2><p>一个轻量级的组件化协议框架, 用来解耦复杂项目.</p>
<h2 id="Typesetter"><a href="#Typesetter" class="headerlink" title="Typesetter"></a><a href="https://github.com/bignerdranch/Typesetter" target="_blank" rel="external">Typesetter</a></h2><p>一个小工具, 用来调整和显示字体, 本期有相关文章.</p>
<h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a><a href="https://github.com/DrKLO/Telegram" target="_blank" rel="external">Telegram</a></h2><p>Telegram是一个通信应用, 关注速度和安全. 这是该应用的官方开源代码.</p>
<h2 id="Badger"><a href="#Badger" class="headerlink" title="Badger"></a><a href="https://github.com/volders/Badger" target="_blank" rel="external">Badger</a></h2><p>一个给图片加数字小标(badges)的库.</p>
<h2 id="classyshark-calculate-size"><a href="#classyshark-calculate-size" class="headerlink" title="classyshark-calculate-size"></a><a href="https://github.com/borisf/classyshark-calculate-size" target="_blank" rel="external">classyshark-calculate-size</a></h2><p>这个工具可以计算出你依赖的库在apk的classes.dex中到底占多少大小.</p>
<h2 id="SlidingRootNav"><a href="#SlidingRootNav" class="headerlink" title="SlidingRootNav"></a><a href="https://github.com/yarolegovich/SlidingRootNav" target="_blank" rel="external">SlidingRootNav</a></h2><p>一个类似于<code>DrawerLayout</code>的ViewGroup, 抽屉部分隐藏在内容的下面. 内容可以向右滑动缩小以露出抽屉.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Toolbar </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Lambda </tag>
            
            <tag> Mockito </tag>
            
            <tag> Testing </tag>
            
            <tag> JUnit 5 </tag>
            
            <tag> Android O </tag>
            
            <tag> Topography </tag>
            
            <tag> Dependency Injection </tag>
            
            <tag> Plugin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 250]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/03/31/android-weekly-notes-issue-250/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-250"><a href="#Android-Weekly-Issue-250" class="headerlink" title="Android Weekly Issue #250"></a>Android Weekly Issue #250</h1><p>March 26th, 2017<br><a href="http://androidweekly.net/issues/issue-250" target="_blank" rel="external">Android Weekly Issue #250</a>.<br>本期内容: 好几篇关于Android O预览版的文章; JUnit 5的动态测试; 作为团队里唯一的Android开发如何学习和工作; Support库新推出的基于物理的动画API: SpringAnimation; Uber Rider项目重构中关于依赖注入的scope层级的改动; Kotlin和RxJava的简洁性.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="O-h-yeah-What-we-look-forward-to-in-Android-O"><a href="#O-h-yeah-What-we-look-forward-to-in-Android-O" class="headerlink" title="O-h yeah! What we look forward to in Android O"></a><a href="https://www.novoda.com/blog/o-h-yeah-what-we-look-forward-to-in-android-o/" target="_blank" rel="external">O-h yeah! What we look forward to in Android O</a></h2><p>Google宣布了最新Android O的预览程序. Novoda team查看了最新文档来看看什么新特性最让大家欣喜.</p>
<ul>
<li>更宽广的色域和多种颜色空间支持:<br>我们不再被限制在sRGB的颜色空间里, 文档见<a href="https://developer.android.com/reference/android/graphics/ColorSpace.html" target="_blank" rel="external">ColorSpace</a>.</li>
<li>字体支持.</li>
<li>Adaptive icons: Android N中提供了圆形的启动图标; 从Android O开始, 手机开发商和launcher开发者们可以指定一个mask到应用提供的背景图上.</li>
<li>ACCESSIBILITY按钮: Accessibility services(比如TalkBack)可以在有软导航键的设备上添加一个按钮.</li>
<li>指纹手势.</li>
<li>自动大小的TextView.</li>
<li>Autofill APIs. 自动填表.</li>
</ul>
<h2 id="JUnit-5-Dynamic-Tests"><a href="#JUnit-5-Dynamic-Tests" class="headerlink" title="JUnit 5: Dynamic Tests"></a><a href="https://blog.stylingandroid.com/junit-5-dynamic-tests/" target="_blank" rel="external">JUnit 5: Dynamic Tests</a></h2><p>本篇讲如何简化一个测试cases都很类似的test suite.</p>
<p>首先, 找出不同的部分, 抽取一个方法, 把不相同的部分作为参数传进去.</p>
<p>然后用JUnit 5的动态测试(Dynamic Tests)特性.<br>两个关键组件: <code>TextFactory</code>和<code>DynamicTest</code>.<br>文中代码详细说明了它们的用法.</p>
<h2 id="Flying-Solo-with-Android-Development"><a href="#Flying-Solo-with-Android-Development" class="headerlink" title="Flying Solo with Android Development"></a><a href="https://hackernoon.com/flying-solo-with-android-development-c52d911b62bf?gi=c13f45395440#.bdab0pxgy" target="_blank" rel="external">Flying Solo with Android Development</a></h2><p>作者几经周转, 从4人Android团队到2人团队, 现在又到了一个新团队, 作为团队里唯一Android开发. 在这篇文章中, 她分享了一些觉得不错的学习资源和她平时的工作习惯以及建议.</p>
<h2 id="Introduction-to-SpringAnimation-with-examples"><a href="#Introduction-to-SpringAnimation-with-examples" class="headerlink" title="Introduction to SpringAnimation with examples"></a><a href="https://www.thedroidsonroids.com/blog/android/springanimation-examples/" target="_blank" rel="external">Introduction to SpringAnimation with examples</a></h2><p>本文讲弹簧效果动画的实现.</p>
<p><a href="https://developer.android.com/reference/android/support/animation/package-summary.html" target="_blank" rel="external">Dynamic-animation</a>是Android Support Library 25.3.0最新引进的, 用于实现基于物理的动画.</p>
<p>作者这篇文章介绍了<a href="https://developer.android.com/reference/android/support/animation/SpringAnimation.html" target="_blank" rel="external">SpringAnimation</a>和<a href="https://developer.android.com/reference/android/support/animation/SpringForce.html" target="_blank" rel="external">SpringForce</a>的用法, 提供了几个例子, 动态改变View的位置, 旋转和大小属性: <a href="https://github.com/AlexKrupa/android-springanimation-examples" target="_blank" rel="external">android-springanimation-examples
</a>.</p>
<h2 id="Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies"><a href="#Rewriting-Uber-Engineering’s-Rider-App-with-Deep-Scope-Hierarchies" class="headerlink" title="Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies"></a><a href="https://eng.uber.com/deep-scope-hierarchies/" target="_blank" rel="external">Rewriting Uber Engineering’s Rider App with Deep Scope Hierarchies</a></h2><p>Android Uber rider app的重构.<br>主要讨论了由于存在很多共用组件, 所以依赖注入的设计需要改进.</p>
<p>首先介绍了旧的设计: 两级Scope层次.<br>后来他们的新设计采用了深层次的scope层级, 减少了耦合.</p>
<p>最后又介绍了几种他们曾经考虑过的架构模式.</p>
<h2 id="It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers"><a href="#It’s-time-to-kiss-goodbye-to-your-implicit-BroadcastReceivers" class="headerlink" title="It’s time to kiss goodbye to your implicit BroadcastReceivers"></a><a href="https://medium.com/@iiro.krankka/its-time-to-kiss-goodbye-to-your-implicit-broadcastreceivers-eefafd9f4f8a#.67j4153n6" target="_blank" rel="external">It’s time to kiss goodbye to your implicit BroadcastReceivers</a></h2><p>Android O的preview已经出来了: <a href="https://developer.android.com/preview/index.html" target="_blank" rel="external">Android O Preview</a>. 这是它列出来的<a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="external">Behavior changes</a>.</p>
<p>如果你想要把app target到Android O, 而且你的manifest中注册了一些隐式的BroadcastReceiver. 那么这篇文章就是为你准备的.</p>
<p>Android做这一切的出发点都是为了节约电量.</p>
<p>Android 7.0的时候就<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html#bg-opt" target="_blank" rel="external">移除了三种隐式广播的支持</a>. 它们是<code>CONNECTIVITY_ACTION</code>,  <code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>.</p>
<p>现在Android O中, 除了<a href="https://developer.android.com/preview/features/background-broadcasts.html" target="_blank" rel="external">background-broadcasts</a>中提到的, 其他所有在manifest中注册的隐式广播都不再工作了. (注意这里的关键字: manifest中注册, 隐式广播.)</p>
<p>那么你的manifest中如果有receiver, 现在应该怎么办呢?</p>
<p>首先看看你的广播是否是隐式的. 根据<a href="https://developer.android.com/preview/features/background.html#broadcasts" target="_blank" rel="external">文档</a>, 所有跟你的应用没有直接关系的广播都是隐式的; 而直接相关的都是显式的.</p>
<p>然后检查你的应用是否真的受到了影响, 因为有一些隐式的广播是例外情况.</p>
<p>真的受到影响了怎么办呢? 使用<code>JobScheduler</code>来拯救. 但是它只在API 21以上有, 如果你的最低API小于21, 可以用官方推荐的<a href="https://github.com/firebase/firebase-jobdispatcher-android" target="_blank" rel="external">firebase-jobdispatcher-android</a>. 作者他们团队用的是Evernote的<a href="https://github.com/evernote/android-job" target="_blank" rel="external">android-job</a>.</p>
<p>如果上面的库仍然不能帮到你, 你可以考虑把广播换成动态注册的.<br>不管你的广播是隐式的还是显式的, <code>Context.registerReceiver()</code>是永远有效的. 但缺陷就是注销以后就不能再收到事件了.</p>
<h2 id="Random-Musings-on-the-O-Developer-Preview-1"><a href="#Random-Musings-on-the-O-Developer-Preview-1" class="headerlink" title="Random Musings on the O Developer Preview 1"></a><a href="https://commonsware.com/blog/2017/03/22/random-musings-o-developer-preview-1.html" target="_blank" rel="external">Random Musings on the O Developer Preview 1</a></h2><p>作者对Android O预览的一些看法.</p>
<h3 id="比较令人担心的几点"><a href="#比较令人担心的几点" class="headerlink" title="比较令人担心的几点"></a>比较令人担心的几点</h3><ul>
<li>后台工作的处理: 许多隐式的广播可能不再起作用, 可能会改变某些应用的行为.</li>
<li>多显示支持. 允许用户把一个activity投射到外部显示器上. 这个行为还需要进一步测试, 如果我们投射到一个不可触摸的显示器上会怎样?</li>
<li>关于磁盘空间, 缓存目录.</li>
<li>Support Libraries支持的最小API为14.</li>
</ul>
<h3 id="有启发性的几点"><a href="#有启发性的几点" class="headerlink" title="有启发性的几点"></a>有启发性的几点</h3><ul>
<li>可以给Notification设置timeout.</li>
<li>Picture-in-Picture (PIP)模式. 一种特殊的多窗口模式, 多数被用来播放视频, TV已经有了.</li>
<li>新字体.</li>
<li>Storage Access Framework (SAF) -&gt; Seekable streams.</li>
<li>WebView将支持allow-cleartext设置.</li>
<li>应用安装其他应用需要用户授权.</li>
<li>Content provider分页查询.</li>
<li><code>FragmentLifecycleCallbacks</code>.</li>
<li><code>SmsManager</code>可以创建tokens.</li>
<li><code>SharedPreferences</code>提供了接口, 可以更换底层存储实现.</li>
<li><code>findViewById()</code>不再需要强转.</li>
</ul>
<h3 id="其他你可能感兴趣的"><a href="#其他你可能感兴趣的" class="headerlink" title="其他你可能感兴趣的"></a>其他你可能感兴趣的</h3><ul>
<li><code>View.setTooltipText()</code>.</li>
<li><code>TextView.setJustify()</code>.</li>
<li>提供了padding和margin的Vertical和Horizontal属性, 这样一下就可以设置同一方向上的两个值.</li>
<li><code>ProgressBar.setMin()</code>.</li>
<li><code>ANDROID_ID</code>现在是对每个应用来说, 而不是用户或设备. 见<a href="https://developer.android.com/preview/behavior-changes.html#privacy-all" target="_blank" rel="external">Privacy</a>.</li>
</ul>
<h2 id="Writing-Concise-Code-with-Kotlin-and-RxJava"><a href="#Writing-Concise-Code-with-Kotlin-and-RxJava" class="headerlink" title="Writing Concise Code with Kotlin and RxJava"></a><a href="https://pspdfkit.com/blog/2017/writing-concise-code-with-kotlin-and-rxjava/" target="_blank" rel="external">Writing Concise Code with Kotlin and RxJava</a></h2><p>用Github API举例子, 用RxJava和Kotlin实现一个功能, 说明了它们的简洁性.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Fakeit"><a href="#Fakeit" class="headerlink" title="Fakeit"></a><a href="https://github.com/moove-it/fakeit" target="_blank" rel="external">Fakeit</a></h2><p>Kotlin版的假数据生成器.</p>
<h2 id="Cicerone"><a href="#Cicerone" class="headerlink" title="Cicerone"></a><a href="https://github.com/terrakok/Cicerone" target="_blank" rel="external">Cicerone</a></h2><p>一个轻量级的Android导航库.</p>
<h2 id="data-binding-validator"><a href="#data-binding-validator" class="headerlink" title="data-binding-validator"></a><a href="https://github.com/Ilhasoft/data-binding-validator" target="_blank" rel="external">data-binding-validator</a></h2><p>表单数据验证器, 使用data binding framework实现.</p>
<h2 id="LabCoat"><a href="#LabCoat" class="headerlink" title="LabCoat"></a><a href="https://github.com/Commit451/LabCoat" target="_blank" rel="external">LabCoat</a></h2><p>GitLab client for Android.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="O-MG-the-Developer-Preview-of-Android-O-is-here"><a href="#O-MG-the-Developer-Preview-of-Android-O-is-here" class="headerlink" title="O-MG, the Developer Preview of Android O is here!"></a><a href="https://android-developers.googleblog.com/2017/03/first-preview-of-android-o.html" target="_blank" rel="external">O-MG, the Developer Preview of Android O is here!</a></h2><p>Google发布了下一个系统版本Android O的开发者预览版.</p>
<h1 id="TOOLS"><a href="#TOOLS" class="headerlink" title="TOOLS"></a>TOOLS</h1><h2 id="Android-Studio-meets-Slack"><a href="#Android-Studio-meets-Slack" class="headerlink" title="Android Studio meets Slack"></a><a href="https://instapk.com/" target="_blank" rel="external">Android Studio meets Slack</a></h2><p>一个小工具, 可以直接把Android Studio打的包发到Slack去.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> Dagger </tag>
            
            <tag> JUnit 5 </tag>
            
            <tag> Android O </tag>
            
            <tag> SpringAnimation </tag>
            
            <tag> Injection </tag>
            
            <tag> BroadcastReceiver </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 249]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/03/24/android-weekly-notes-issue-249/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-249"><a href="#Android-Weekly-Issue-249" class="headerlink" title="Android Weekly Issue #249"></a>Android Weekly Issue #249</h1><p>March 19th, 2017<br><a href="http://androidweekly.net/issues/issue-249" target="_blank" rel="external">Android Weekly Issue #249</a></p>
<p>本期内容包括: 一个设计的实现Demo讨论; Kotlin的Coroutines可能还是没有RxJava好用; 在构建SDK/Libraries时需要注意的事项; 如何用OpenGL和JBox2D实现一个好看的多气泡选择器效果;<br>网络请求中Etag, If-Modified-Since的工作原理和用OkHttp的客户端实现; 用ClassyShark导出类型分析; 指纹认证实现代码; MVI模式对调试带来的好处; 用TensorFlow做一个图像识别处理器.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="From-design-to-Android"><a href="#From-design-to-Android" class="headerlink" title="From design to Android"></a><a href="http://saulmm.github.io/from-design-to-android-part1" target="_blank" rel="external">From design to Android</a></h2><p>作者想建立一个项目, 把从<a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a>和<a href="https://material.uplabs.com/" target="_blank" rel="external">MaterialUp</a>上看到的一些设计实现出来, 再讲解一些实现细节和UI/UX的tips等.</p>
<p>本文是此系列文章的第一篇, 选择的设计是<a href="https://material.uplabs.com/posts/preferred-date-and-time" target="_blank" rel="external">preferred-date-and-time</a>, 实现的demo在这里:<a href="https://github.com/saulmm/from_design_to_android_part1" target="_blank" rel="external">from_design_to_android_part1</a>.</p>
<p>实现中涉及到的点: Bottom Sheets; <code>ConstraintLayout</code>和其中的链式约束<a href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html#Chains" target="_blank" rel="external">Chains</a>; <a href="https://developer.android.com/reference/android/widget/ViewSwitcher.html" target="_blank" rel="external">ViewSwitcher</a>; Databinding; Scene和Transition.</p>
<h2 id="Why-Im-Skeptical-about-Kotlin-Coroutines"><a href="#Why-Im-Skeptical-about-Kotlin-Coroutines" class="headerlink" title="Why Im Skeptical about Kotlin Coroutines"></a><a href="https://www.philosophicalhacker.com/post/why-im-skeptical-about-kotlin-coroutines-for-android-development/" target="_blank" rel="external">Why Im Skeptical about Kotlin Coroutines</a></h2><p>Kotlin为了处理异步发布了Coroutines特性, 本文作者对Coroutines持怀疑态度, 认为RxJava的方式更好.</p>
<p>首先, Observables为我们要处理的问题建立了很好的模型, 但coroutines并没有起到这样的作用. (coroutines只是把异步的操作写成了看起来顺序的样子, 同时不阻塞主线程.)</p>
<p>其次, Observables让我们在同步和异步数据上都可以进行同等的抽象, 而coroutines的同步处理和异步处理明显不同.</p>
<p>最后, Observables让我们在更高的抽象层中工作, 比如对元素进行遍历处理的<code>.map()</code>.</p>
<p>当然, 本文并不是说Coroutines一无是处, 它肯定是有自己的用处的, 但是作者只是持怀疑态度, 觉得它的地位远不及RxJava.</p>
<h2 id="Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries"><a href="#Things-I-wish-I-knew-when-I-started-building-Android-SDK-Libraries" class="headerlink" title="Things I wish I knew when I started building Android SDK/Libraries"></a><a href="https://android.jlelse.eu/things-i-wish-i-knew-when-i-started-building-android-sdk-libraries-dba1a524d619#.tc5qkaglp" target="_blank" rel="external">Things I wish I knew when I started building Android SDK/Libraries</a></h2><p>当你遇到一个问题并且解决了, 有时候你会把解决方案作为一个库发布出去.</p>
<p>作者发布了一些库<a href="https://github.com/nisrulz/android-tips-tricks#extra--android-libraries-built-by-me" target="_blank" rel="external">Android Libraries</a>, 他提出了一些基本的问题和几个应该注意的点.</p>
<h3 id="为什么要创建这个库呢"><a href="#为什么要创建这个库呢" class="headerlink" title="为什么要创建这个库呢?"></a>为什么要创建这个库呢?</h3><p>如果已经有现成的解决方案, 尝试使用已有的方案, 或者给已有的库提Pull Request. 如果没有解决方案, 好吧, 那创建自己的库吧.</p>
<h3 id="你的artifacts可选的类型是什么"><a href="#你的artifacts可选的类型是什么" class="headerlink" title="你的artifacts可选的类型是什么?"></a>你的artifacts可选的类型是什么?</h3><ul>
<li>Library Project: 直接项目引用.</li>
<li>JAR: 包含了Java class文件和metadata.</li>
<li>AAR: 除了Java class文件, 还包含了Android的资源和manifest.</li>
</ul>
<h3 id="你的库放在哪里"><a href="#你的库放在哪里" class="headerlink" title="你的库放在哪里?"></a>你的库放在哪里?</h3><ul>
<li>本地.</li>
<li>私有的代码库.</li>
<li>公有的代码库: Maven Central, Jcenter or JitPack.</li>
</ul>
<p>(每一种方式都有教程链接).</p>
<p>上面三个基本问题说完了, 在建立这个库的时候还有一些注意事项:</p>
<h3 id="避免多个参数"><a href="#避免多个参数" class="headerlink" title="避免多个参数"></a>避免多个参数</h3><p>参数最好不要多于三个, 可以用setter或者Builder模式来解决.</p>
<h3 id="容易使用"><a href="#容易使用" class="headerlink" title="容易使用"></a>容易使用</h3><ul>
<li>直观: 任何发生在库里的行为, 最好有一些反馈, 比如打印出logs或者显示在UI上.</li>
<li>一致性: 遵从<a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a>.</li>
<li>容易使用, 不容易滥用. 最好一眼能看出它的用途. public的方法应该有足够的验证, 确保用户不会滥用. 当不存在依赖关系时, 提供默认值并处理场景.</li>
</ul>
<h3 id="最小化权限"><a href="#最小化权限" class="headerlink" title="最小化权限"></a>最小化权限</h3><p>尽量少地要求权限, 可以发送Intent让更专业的应用帮你做一些处理然后返回结果. 根据权限的获取情况来使能你的feature, 不要仅因为没有权限就crash.</p>
<p>你也可以提供一些不需要权限的fallback的实现, 让库的使用者去获取权限.</p>
<h3 id="最小化要求"><a href="#最小化要求" class="headerlink" title="最小化要求"></a>最小化要求</h3><p>有时候我们需要设备具有某项功能, 比如蓝牙.<br>这时候就需要在manifest中写<code>uses-feature</code>.</p>
<p>如果我们在库中这样写, 它会被merge进应用的manifest, 在Play Store上, 整个应用对无蓝牙的设备都变为不显示. 这样只是引入了一个库, 却失去了一部分用户, 这肯定不是我们所希望看到的.</p>
<p>解决方案就是: 不要写在manifest里, 换为在代码中动态检查. 对于不支持的情况, 库可以关掉这个功能, 提供fallback的实现.</p>
<h3 id="支持不同的版本"><a href="#支持不同的版本" class="headerlink" title="支持不同的版本"></a>支持不同的版本</h3><p>如果你有一个特定版本才支持的功能, 应该做版本检查, 然后对于更低的版本关掉它.</p>
<h3 id="Production版本不要打log"><a href="#Production版本不要打log" class="headerlink" title="Production版本不要打log"></a>Production版本不要打log</h3><h3 id="不要悄悄crash-另外fail-fast"><a href="#不要悄悄crash-另外fail-fast" class="headerlink" title="不要悄悄crash, 另外fail fast"></a>不要悄悄crash, 另外fail fast</h3><p>遇到崩溃时应该总是输出错误信息.<br>如果你不想在production输出任何log, 你至少应该提供flag, 让初始化的时候可以使能它.</p>
<p>如果你的库遇到异常, 应该立即失败, 想开发者输出Exception, 而不是卡在那里. 要避免写出会阻塞主线程的代码.</p>
<h3 id="优雅地处理错误"><a href="#优雅地处理错误" class="headerlink" title="优雅地处理错误"></a>优雅地处理错误</h3><p>当你的库出错的时候, 尽量做检查, 使得代码不会让整个应用崩溃, 而是只有你的库提供的功能被关闭了.</p>
<h3 id="捕获特定的exceptions"><a href="#捕获特定的exceptions" class="headerlink" title="捕获特定的exceptions"></a>捕获特定的exceptions</h3><h3 id="处理不良的网络连接"><a href="#处理不良的网络连接" class="headerlink" title="处理不良的网络连接"></a>处理不良的网络连接</h3><p>如果你的库中有网络请求, 请处理网络连接不良的情况.</p>
<p>如果有可能, 批处理你的网络请求, 这会节约很多电量. 看<a href="https://developer.android.com/training/efficient-downloads/efficient-network-access.html" target="_blank" rel="external">这里</a>.</p>
<p>使用<a href="https://google.github.io/flatbuffers/" target="_blank" rel="external">FlatBuffers</a>而不是json或xml, 来减小网络请求的数据量.</p>
<p>更多的网络优化看这里: <a href="https://developer.android.com/topic/performance/power/network/index.html" target="_blank" rel="external">Reducing Network Battery Drain</a>.</p>
<h3 id="尽量不要依赖很大的库"><a href="#尽量不要依赖很大的库" class="headerlink" title="尽量不要依赖很大的库"></a>尽量不要依赖很大的库</h3><p>主要是因为方法数的限制.</p>
<h3 id="不要依赖你不需要的库"><a href="#不要依赖你不需要的库" class="headerlink" title="不要依赖你不需要的库"></a>不要依赖你不需要的库</h3><p>除了不依赖没有用到的库, 还可以把添加依赖的选择权留给你的用户.</p>
<p>让用户来选择性地添加你依赖的库, 如果他选择不添加, 你的相关feature可以关闭.</p>
<p>可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOKHttpOnClasspath</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class.forName(<span class="string">"com.squareup.okhttp3.OkHttpClient"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">       ex.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而你添加的时候可以这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   // for gradle version 2.12 and below</div><div class="line">   provided &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">   // or for gradle version 2.12+</div><div class="line">   compileOnly &apos;com.squareup.okhttp3:okhttp:3.6.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种只能用于纯Java的依赖, 如果是aar就不行.</p>
<h3 id="不要拖慢启动时间"><a href="#不要拖慢启动时间" class="headerlink" title="不要拖慢启动时间"></a>不要拖慢启动时间</h3><p>在应用启动初始化你的库时, 不要花太多时间.</p>
<p>两种解决方案: 一种是新启一个线程来做初始化; 另一种是到使用之前才进行初始化.</p>
<h3 id="删除功能的时候要优雅"><a href="#删除功能的时候要优雅" class="headerlink" title="删除功能的时候要优雅"></a>删除功能的时候要优雅</h3><p>升级版本的时候, 不要删除public的方法.<br>可以把方法标记为<code>@Deprecated</code>, 然后在未来的版本中慢慢删除它.</p>
<h3 id="让你的代码可测试"><a href="#让你的代码可测试" class="headerlink" title="让你的代码可测试"></a>让你的代码可测试</h3><p>使用mock来测试你的代码, 在代码中国避免final的类和static的方法.</p>
<p>写代码的时候public的API用接口, 这样更容易更换实现, 更好测试.</p>
<h3 id="文档记录所有的事"><a href="#文档记录所有的事" class="headerlink" title="文档记录所有的事"></a>文档记录所有的事</h3><p>包括如何使用你的库, 库中每一个feature都是什么.</p>
<ul>
<li>Repo根目录有一个Readme.</li>
<li>所有的public方法应该有javadoc注释. 说明目的, 参数, 返回值.</li>
<li>有一个sample app, 展示如何使用你的库.</li>
<li>在你的release界面, 确保有一个详尽的change log.</li>
</ul>
<h3 id="提供一个最简单的sample"><a href="#提供一个最简单的sample" class="headerlink" title="提供一个最简单的sample"></a>提供一个最简单的sample</h3><p>越简单越容易让人明白.</p>
<h3 id="考虑加一个Licence"><a href="#考虑加一个Licence" class="headerlink" title="考虑加一个Licence"></a>考虑加一个Licence</h3><h3 id="收集反馈"><a href="#收集反馈" class="headerlink" title="收集反馈"></a>收集反馈</h3><h2 id="How-to-Create-a-Bubble-Selection-Animation-on-Android"><a href="#How-to-Create-a-Bubble-Selection-Animation-on-Android" class="headerlink" title="How to Create a Bubble Selection Animation on Android"></a><a href="https://medium.com/@igalata13/how-to-create-a-bubble-selection-animation-on-android-627044da4854#.1ncs9qy84" target="_blank" rel="external">How to Create a Bubble Selection Animation on Android</a></h2><p>作者他们想要在Android上实现Apple music中的选择气泡效果.</p>
<p>这种动画效果用于让用户在一系列的选择项中做出选择, 气泡自由浮动, 一旦被选中就会变大一点.</p>
<p>作者选择的是用Kotlin, OpenGL和JBox2D(物理引擎).</p>
<p>详细介绍的内容包括: 如何用GLSL写vertex shader和fragment shader; 如何贴图; 用JBox2D来实现气泡的动画(需要自己实现重力); 检测用户手势移动气泡; 发现用户点击的气泡.</p>
<p>项目在Github: <a href="https://github.com/igalata/Bubble-Picker" target="_blank" rel="external">Bubble-Picker</a>.</p>
<h2 id="Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since"><a href="#Reducing-networking-footprint-with-OkHttp-Etags-and-If-Modified-Since" class="headerlink" title="Reducing networking footprint with OkHttp, Etags and If-Modified-Since"></a><a href="https://android.jlelse.eu/reducing-your-networking-footprint-with-okhttp-etags-and-if-modified-since-b598b8dd81a1#.260pws449" target="_blank" rel="external">Reducing networking footprint with OkHttp, Etags and If-Modified-Since</a></h2><h3 id="If-Modified-Since和Last-Modified"><a href="#If-Modified-Since和Last-Modified" class="headerlink" title="If-Modified-Since和Last-Modified"></a>If-Modified-Since和Last-Modified</h3><p>Header中使用了If-Modified-Since和Last-Modified, 如果两次请求之间内容并未改变, 第二次, server就会返回<code>304 NOT MODIFIED</code>, 并且响应不含body.</p>
<p><img src="/images/if-modified-since-and-last-modified.png" alt="if-modified-since and last-modified"></p>
<h3 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h3><p>Etag工作的原理类似, 它实现起来不容易出错, 但是需要server跑一个完整的查询, 并且每次都创建一个hash.</p>
<p><img src="/images/Etag-and-If-None-Match.png" alt="Etag and if-none-match"></p>
<p>server将会在返回response之前根据响应内容创建一个hash, 然后把它作为Etag header; 客户端在做下一次请求时, 把这个Etag作为If-None-Match header发给server. 客户端在准备下一个响应的时候, 比较新的hash和请求中发来的是否相同, 如果相同, 则返回无内容的<code>304 NOT MODIFIED</code>.</p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>如果你使用了Retrofit2, 或OkHttp3, 在客户端使能Last-Modified或Etags是很容易的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_SIZE_BYTES = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>;</div><div class="line">...</div><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient().newBuilder();</div><div class="line">builder.cache(<span class="keyword">new</span> Cache(context.getCacheDir(), CACHE_SIZE_BYTES));</div><div class="line">...</div></pre></td></tr></table></figure>
<p>根据server的响应, Last-Modified或Etags将会自动启用.</p>
<p>如果你还想减少处理的时间:</p>
<p><strong>减少处理</strong>:<br>在304状态下, Retrofit2和OkHttp3将会假装这个响应和上一次的相同, 所以被缓存的响应会被返回, 你可以检测响应返回值, 如果是304就不做处理.<br>但是有时候你可能需要每次都重新parse, 这就不用检查<code>HTTP_NOT_MODIFIED</code>了, 看你的需要.</p>
<p>注意在Retrofit2中要用raw()中的response来检查, 因为<code>response.networkResponse().code()</code>返回的是被缓存了的状态值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (response.isSuccessful() &amp;&amp;</div><div class="line">    response.raw().networkResponse() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">    response.raw().networkResponse().code() ==</div><div class="line">           HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</div><div class="line">    <span class="comment">// not modified, no need to do anything.</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// parse response here</span></div></pre></td></tr></table></figure>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>如果你的Etag或Last-Modified不工作.</p>
<p><strong>检查你的Headers.</strong></p>
<p>可以用<a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho</a>或<a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="external">OkHttp logging interceptor</a>来检查你的headers.</p>
<p>正确的输出是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cache-Control: private, must-revalidate</div></pre></td></tr></table></figure></p>
<p>所有请求和响应的Last-Modified和Etag headers都会被显示出来.</p>
<p><strong>同时使用Etags和Last-Modified.</strong></p>
<p>OkHttp3会按照严格的顺序检查cache headers:</p>
<ul>
<li>1.如果上一个响应包含Etag, 那么同样的Etag值将会被加在下一个请求的If-Not-Match中.</li>
<li>2.如果第一点不满足, 但上一个响应包含Last-Modified, 那么这个值将会被记载下一个请求的If-Modified-Since中.</li>
</ul>
<p>所以如果同时使用了两种, Etag会屏蔽Last-Modified.</p>
<h2 id="Exporting-types-from-Android-app-using-ClassyShark"><a href="#Exporting-types-from-Android-app-using-ClassyShark" class="headerlink" title="Exporting types from Android app using ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-types-from-android-app-using-classyshark-7cd2be18cdf7#.5q7p9qoya" target="_blank" rel="external">Exporting types from Android app using ClassyShark</a></h2><p>如何导出<code>ClassyShark</code>的类型分析.</p>
<h2 id="Fingerprint-authentication"><a href="#Fingerprint-authentication" class="headerlink" title="Fingerprint authentication"></a><a href="http://josiassena.com/android-fingerprint-authentication/" target="_blank" rel="external">Fingerprint authentication</a></h2><p>一个指纹认证的代码例子.</p>
<h2 id="Reactive-Apps-with-MVI-Part-5"><a href="#Reactive-Apps-with-MVI-Part-5" class="headerlink" title="Reactive Apps with MVI - Part 5"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-5" target="_blank" rel="external">Reactive Apps with MVI - Part 5</a></h2><p>MVI模式系列文章第五篇.</p>
<p>之前在第一篇讲过单向数据流的重要性, 应用状态应该由业务逻辑驱动. 本篇我们将看到这样做带来的好处: 调试程序变得简单了.</p>
<p>我们经常会遇到无法复现的bug, 这往往是因为你只知道崩溃栈, 却不知道用户在出现这个bug之前的实际状态.</p>
<p>当我们用MVI的时候, 我们可以把每次用户激发的intent和model(也即状态)都打出log(用Crashlytics或者其他工具).<br>这样做以后, 我们从收集到的log中不仅能看到崩溃前最近的状态, 还能看到用户的整个操作历史.</p>
<p>而且用户的应用状态截图都被当做json发送过来, 我们可以拿到任何状态当做我们的初始状态.</p>
<p>这样做以后, 不仅复现崩溃更加容易, 我们还可以利用这些序列化的状态来写一些回归测试.</p>
<p>这样做也是有缺点的: 状态的序列化需要额外花费一些毫秒; 崩溃时传递的数据量增大了; 对用户的敏感信息, 要么忽略, 会导致信息不完整; 要么加密, 那就会需要更多的处理时间.</p>
<h2 id="Add-some-machine-learning-to-your-apps-with-TensorFlow"><a href="#Add-some-machine-learning-to-your-apps-with-TensorFlow" class="headerlink" title="Add some machine learning to your apps, with TensorFlow"></a><a href="http://nilhcem.com/android/custom-tensorflow-classifier" target="_blank" rel="external">Add some machine learning to your apps, with TensorFlow</a></h2><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a>是一个开源的机器学习的库, 由Google开发.</p>
<p>一个简单快速的开始方法就是用TensorFlow来建立一个图像分类器. 相对于使用<a href="https://cloud.google.com/vision/" target="_blank" rel="external">Google’s Cloud Vision API</a>来说, 我们可以做一个离线和简化版本, 在Android设备上检测和识别图像中物体.</p>
<p>本篇文章中, 我们会创建一个app, 来识别游戏中的角色.</p>
<p>官方有一个<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="external">Demo</a>, 如果你要跑它, 你需要安装NDK和Bazel.</p>
<p>作者创建了这个<a href="https://github.com/Nilhcem/tensorflow-classifier-android" target="_blank" rel="external">Repo</a>, 可以直接clone下来build, 更快.</p>
<p>不管你选择哪种方式, 能够运行之后, 这个sample使用了Inception, 一个提前训练好的可以检测1000个物体的model.</p>
<p>之后作者重新下载了一些图片, 对Inception进行了重新训练, 优化, 最后导入新的model并运行, 文中详细记录了过程.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="AutoplayVideos"><a href="#AutoplayVideos" class="headerlink" title="AutoplayVideos"></a><a href="https://github.com/Krupen/AutoplayVideos" target="_blank" rel="external">AutoplayVideos</a></h2><p>在RecyclerView中显示url对应的Video, 当view出现时自动播放, view不见或部分可见时自动暂停.</p>
<h2 id="PreferenceHolder"><a href="#PreferenceHolder" class="headerlink" title="PreferenceHolder"></a><a href="https://github.com/MarcinMoskala/PreferenceHolder" target="_blank" rel="external">PreferenceHolder</a></h2><p>一个Kotlin的SharedPreferences的包装库.</p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><a href="https://github.com/MarcinMoskala/ActivityStarter" target="_blank" rel="external">ActivityStarter</a></h2><p>提供了一种简化的方式来启动多参数的Activity.<br>用注解简化了从Bundle拿参数的过程, 也有相应的存取状态的方法. 可以用于Activity, Fragment, Service和BroadcastReceiver.</p>
<h2 id="BlockCanaryEx"><a href="#BlockCanaryEx" class="headerlink" title="BlockCanaryEx"></a><a href="https://github.com/lqcandqq13/BlockCanaryEx" target="_blank" rel="external">BlockCanaryEx</a></h2><p>基于<a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">BlockCanary</a>的扩展, 用于检测UI阻塞, 打印出了更多的方法信息, 并显示出最耗时的方法.</p>
<h2 id="EasySP"><a href="#EasySP" class="headerlink" title="EasySP"></a><a href="https://github.com/WhiteDG/EasySP" target="_blank" rel="external">EasySP</a></h2><p>一个简单的SharedPreferences辅助类, 支持流式操作.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> Fingerprint </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> OkHttp </tag>
            
            <tag> MVI </tag>
            
            <tag> Transition </tag>
            
            <tag> Network </tag>
            
            <tag> ClassyShark </tag>
            
            <tag> ViewSwitcher </tag>
            
            <tag> Coroutines </tag>
            
            <tag> SDK </tag>
            
            <tag> Libraries </tag>
            
            <tag> OpenGL </tag>
            
            <tag> JBox2D </tag>
            
            <tag> Etag </tag>
            
            <tag> If-Modified-Since </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 248]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/03/17/android-weekly-notes-issue-248/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-248"><a href="#Android-Weekly-Issue-248" class="headerlink" title="Android Weekly Issue #248"></a>Android Weekly Issue #248</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-248" target="_blank" rel="external">Android Weekly Issue #248</a>.<br>本期内容包括: 为什么有时候应该让你的应用崩溃(而不是一味保护); Trello离线模式实现中两个id的问题; 如何让Dagger的component按照scope保存, 在屏幕旋转时不重建; 用Dagger构建Realm的数据库迁移逻辑;<br>利用各种mock工具写单元测试; Map上markers的动画实现; JUnit5中@DisplayName的使用; RxJava中的Single和Completable使用; 举例说明如何给FindBugs写自定义的探测器; Android中静态代码分析工具的使用; Trello离线实现中sync失败情况的处理.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Why-your-app-should-crash"><a href="#Why-your-app-should-crash" class="headerlink" title="Why your app should crash"></a><a href="http://jeroenmols.com/blog/2017/03/08/appcrash/" target="_blank" rel="external">Why your app should crash</a></h2><p>作者认为有时候让应用崩溃反而是有好处的.</p>
<p>以NPE为例, 有时候我们会习惯性地加很多null判断, 有的是多余的, 有的防御型的代码反而会掩盖了真实问题所在. 比如当一个不合理的情况发生时, 让用户看到一个不可理解的页面, 比如空白, 然后我们开发者根本不知道这种情况的发生.</p>
<p>与其这样掩盖错误, 不如让应用崩溃, 让开发者立即知道问题的原因.</p>
<p>实用建议:</p>
<ul>
<li>永远让应用对外来输入(比如service的响应, UI的输入, 进来的intents)保持健壮性.</li>
<li>在程序的入口点保证数据的完整性. 这样不合理的数据就不会到处都是, 所以你不用到处检查.</li>
<li>如果你不确定某个错误是否会在某个地方发生, 先假装它不会发生, 在测试阶段再验证.</li>
<li>如果某个方法在产品环境不能被调用, 或者只能被调用一次等, 抛出<code>IllegalStateException</code>.</li>
<li>永远在发布之前进行完整测试, 这样你就会在用户之前, catch住可怕的崩溃.</li>
</ul>
<h2 id="The-Two-ID-Problem"><a href="#The-Two-ID-Problem" class="headerlink" title="The Two ID Problem"></a><a href="http://tech.trello.com/sync-two-id-problem/" target="_blank" rel="external">The Two ID Problem</a></h2><p>还是Trello开发离线模式的系列文章, 本篇讲他们遇到的一个很tricky的问题: id问题.</p>
<p>在他们的项目里, 所有的models都有一个id, 用以和server通信, 以及定义model之间的关系.</p>
<p>如果是在离线模式下, 就不能依靠server来提供这个id, 客户端需要自己生成. </p>
<p>所以离线模式下有两种id, 一种是本地生成的, 一种是用来和server通信的. </p>
<p>他们想过几个办法, 比如在sync的时候将local的id转化为server id; 或者干脆存储一个id的Pair类, 但是都有难以维护或者性能缺陷等种种问题.</p>
<p>最后他们提出了一个叫<code>local-server barrier</code>的解决方案. 基本的原则就是, 在app中, 只使用local的id, 同server通信时, 使用server id. 好处: 首先保证了客户端代码的简洁, 只有网络通信层需要考虑到server id; 重构代码量小.</p>
<h2 id="Retaining-Dagger-components"><a href="#Retaining-Dagger-components" class="headerlink" title="Retaining Dagger components"></a><a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a></h2><p>如果你用dagger创建了component,  scope是Activity或者Fragment, 那么你可能遇到过这个问题: 旋转屏幕之后, 所有的依赖都重建了, 因为你创建了一个新的component.</p>
<p>如果你想要在configuration变化的时候不重建, 你就需要把component存储在一个全局的地方, 但是这样的话, 当你真的结束你的Activity和Fragment的时候, 你如何释放这些component呢?</p>
<p>你需要分层地(hierarchical)存储, <a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a>就是用来做分层存储东西的一个工具. </p>
<p>文中基本思想是把Application的component作为根节点, 然后Activity和Fragment的component作为树形结构的叶子节点逐级存储. Activity和Fragment的节点什么时候移除, 有一些判断条件和时机选择, 详见原文代码.</p>
<h2 id="The-Burden-of-Knowledge"><a href="#The-Burden-of-Knowledge" class="headerlink" title="The Burden of Knowledge"></a><a href="https://medium.com/@trionkidnapper/the-burden-of-knowledge-52cc73508081#.1nyndcoo6" target="_blank" rel="external">The Burden of Knowledge</a></h2><p>鼓励在team里分享知识.</p>
<h2 id="Realm-Migrations-Supercharged-with-Dagger"><a href="#Realm-Migrations-Supercharged-with-Dagger" class="headerlink" title="Realm Migrations Supercharged with Dagger"></a><a href="http://www.adavis.info/2017/03/realm-migrations-supercharged-with.html" target="_blank" rel="external">Realm Migrations Supercharged with Dagger</a></h2><p>使用Dagger2可以大幅度改善Realm中的数据迁移处理. 具体的做法是把每一步的迁移处理都放在一个统一接口的实现类里, 然后注入它们.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MigrationsModule</span> </span>&#123;</div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion1Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version1Migration();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@IntoMap</span></div><div class="line">    <span class="meta">@IntKey</span>(<span class="number">2</span>)</div><div class="line">    <span class="function"><span class="keyword">static</span> VersionMigration <span class="title">provideVersion2Migration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Version2Migration();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以最后的迁移类看起来就是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Reusable</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Migration</span> <span class="keyword">implements</span> <span class="title">RealmMigration</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Migration(Map&lt;Integer, Provider&lt;VersionMigration&gt;&gt; versionMigrations) &#123;</div><div class="line">        <span class="keyword">this</span>.versionMigrations = versionMigrations;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="keyword">final</span> DynamicRealm realm, <span class="keyword">long</span> oldVersion, <span class="keyword">long</span> newVersion)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) oldVersion; i &lt; newVersion; i++) &#123;</div><div class="line">            <span class="keyword">final</span> Provider&lt;VersionMigration&gt; provider = versionMigrations.get(i);</div><div class="line">            <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</div><div class="line">                VersionMigration versionMigration = provider.get();</div><div class="line">                versionMigration.migrate(realm, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的好处:</p>
<ul>
<li>1.以后再有数据库升级也不需要再改这个类了.</li>
<li>2.不需要逐个check每个版本号, 自动只从需要的版本号开始做迁移.</li>
<li>3.每个迁移模块都变成了可测试的单元.</li>
</ul>
<p>我觉得作者的这种处理结构很好, 不仅仅限于Realm数据库的迁移, 其他的数据库迁移也可以用类似的结构来处理.</p>
<h2 id="How-to-be-a-Mock-Star…"><a href="#How-to-be-a-Mock-Star…" class="headerlink" title="How to be a Mock-Star…"></a><a href="https://medium.com/fueled-android/how-to-be-a-mock-star-fc00714d8c2f#.aff30qzf6" target="_blank" rel="external">How to be a Mock-Star…</a></h2><p>介绍如何用<a href="http://site.mockito.org/" target="_blank" rel="external">mockito</a>来测试一个MVP的程序.</p>
<p>首先测试Presenter的部分, 这里Mock了数据源和各种错误响应.</p>
<p>测试Repository, 需要用到<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">MockWebServer</a>, 来模拟测试环境下的响应.</p>
<h2 id="Animating-Markers-with-MapOverlayLayout"><a href="#Animating-Markers-with-MapOverlayLayout" class="headerlink" title="Animating Markers with MapOverlayLayout"></a><a href="https://www.thedroidsonroids.com/blog/workcation-app-part-2-animating-markers-with-mapoverlaylayout/" target="_blank" rel="external">Animating Markers with MapOverlayLayout</a></h2><p>作者App的动画实现讨论第二发, 如何让地图上的markers带缩放和渐变动画 -&gt; 用<code>MapOverlayLayout</code>.</p>
<p>文中有详细的实现代码, 基本思路就是在这个<code>MapOverlayLayout</code>中保存一个View的列表, 然后在自定义View中实现每个marker在相应动作时的动画.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-About-Activities-Pt-2" class="headerlink" title="What Unit Tests are Trying to Tell us About Activities Pt 2"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt-2/" target="_blank" rel="external">What Unit Tests are Trying to Tell us About Activities Pt 2</a></h2><p>以Activity/Fragment作为基本构建单元, 让程序难以测试, 本文举例说明了这一点.</p>
<h2 id="JUnit-5-DisplayName"><a href="#JUnit-5-DisplayName" class="headerlink" title="JUnit 5: DisplayName"></a><a href="https://blog.stylingandroid.com/junit-5-displayname/" target="_blank" rel="external">JUnit 5: DisplayName</a></h2><p>JUnit 5提供了<code>@DisplayName</code>, 这样测试报告里case显示的名字将是<code>@DisplayName</code>定义的字符串. </p>
<p>相比原先的方法名来说, 这个字符串是可以带空格的, 所以比之前的可读性增强了.</p>
<h2 id="Clearer-RxJava-intentions-with-Single-and-Completable"><a href="#Clearer-RxJava-intentions-with-Single-and-Completable" class="headerlink" title="Clearer RxJava intentions with Single and Completable"></a><a href="https://medium.com/@ValCanBuild/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8#.kpyh1sal0" target="_blank" rel="external">Clearer RxJava intentions with Single and Completable</a></h2><p>RxJava中我们经常用到的类就是<code>Observable</code>, 然后处理三个事件: <code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>.</p>
<p>但是有些时候我们并不需要关心全部这三个事件, 这时候我们就可以用<code>Single&lt;T&gt;</code>和<code>Completable</code>.</p>
<p><code>Single&lt;T&gt;</code>返回一个值或者一个error.<br>它和<code>Observable</code>之间可以互相转换: 用<code>toObservable()</code>和<code>singleOrError()</code>方法.</p>
<p><code>Completable</code>, 只有<code>onCompleted()</code>和<code>onError()</code>. 它不发射任何值, 可以在它之后用<code>andThen()</code>来添加另一个Observable, 进行后续其他操作.</p>
<p><code>Observable</code>不能直接转换为<code>Completable</code>, 因为不知道<code>Observable</code>到底会不会停止. 可以把<code>Single</code>转换为<code>Completable</code>, 用<code>toCompletable()</code>方法.</p>
<h2 id="Custom-FindBugs-detectors-in-Android"><a href="#Custom-FindBugs-detectors-in-Android" class="headerlink" title="Custom FindBugs detectors in Android"></a><a href="https://rhye.org/post/custom-android-findbugs/" target="_blank" rel="external">Custom FindBugs detectors in Android</a></h2><p>Android中有两种工具可以做进一步的编译期检查: <a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">Android Lint</a>和<a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">FindBugs</a>. </p>
<p>FindBugs是一个静态的分析工具. 本文的主要任务是讲解如何实现一个自定义的检测器来检测一种特定的错误.</p>
<p>作者的例子是<code>try-with-resources</code>模式的代码.<br>这是Java 7新加的模式<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Cursor c = db.query(...)) &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>try语句中声明的资源将会在这个block结束的时候自动close.</p>
<p>但是这个特性最低需要API 19.<br>所以为了兼容旧版本, 我们不得不使用finally来自己close:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.query(...);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.moveToFirst();</div><div class="line">    <span class="keyword">while</span> (!c.isAfterLast()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(</div><div class="line">                c.getString(c.getColumnIndex(...))</div><div class="line">                ...</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    c.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有时候我们会忘记close导致了泄露, 所以需要实现一个自定义的findbugs检测器来检查这种错误. 具体实现步骤和讨论见原文.</p>
<h2 id="Static-Code-Analysis-Tools"><a href="#Static-Code-Analysis-Tools" class="headerlink" title="Static Code Analysis Tools"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-static-code-analysis-tools-b6dd83282921#.e7sc5x1if" target="_blank" rel="external">Static Code Analysis Tools</a></h2><p>Android中流行的静态代码检测工具:</p>
<ul>
<li>Lint</li>
<li>PMD</li>
<li>FindBugs</li>
</ul>
<p>本文介绍它们如何配置和使用.</p>
<h2 id="Sync-Failure-Handling"><a href="#Sync-Failure-Handling" class="headerlink" title="Sync Failure Handling"></a><a href="http://tech.trello.com/sync-failure-handling/" target="_blank" rel="external">Sync Failure Handling</a></h2><p>Trello离线模式文章, sync失败的处理.</p>
<p>在发请求的时候可能会发生各种各样的错误, 分为暂时性的和永久性的两类.<br>对于永久性的错误, 我们可以直接放弃delta; 但是对于暂时性的错误, 我们需要重试. 这里就需要考虑重试的时间和重试的次数.</p>
<p>另外还有一种情况是客户端发了请求, server也收到了, 但是客户端在收响应的时候失败了, 所以客户端可能会找机会重新发请求, 为了保证幂等性, 我们的每一个请求都有一个唯一的id, 如果server发现同样的id, 只处理第一个.</p>
<p>对于多个用户编辑的冲突处理, 当前用的是简单的以后者为准的方式.</p>
<p>撤销本地不合理数据, 以server数据为准, 更新本地数据, 这就需要在sync开始的时候先讲本地改动上传. </p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="LottieFiles"><a href="#LottieFiles" class="headerlink" title="LottieFiles"></a><a href="http://www.lottiefiles.com/" target="_blank" rel="external">LottieFiles</a></h2><p>免费的Lottie动画.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="DiscreteScrollView"><a href="#DiscreteScrollView" class="headerlink" title="DiscreteScrollView"></a><a href="https://github.com/yarolegovich/DiscreteScrollView" target="_blank" rel="external">DiscreteScrollView</a></h2><p>可滚动的列表, 中间的项目放大. (基于RecyclerView, 长得有点像ViewPager.)</p>
<h2 id="SimpleRatingBar"><a href="#SimpleRatingBar" class="headerlink" title="SimpleRatingBar"></a><a href="https://github.com/borjabravo10/SimpleRatingBar" target="_blank" rel="external">SimpleRatingBar</a></h2><p>五星评价View, 用kotlin实现的.</p>
<h2 id="InstaCropper"><a href="#InstaCropper" class="headerlink" title="InstaCropper"></a><a href="https://github.com/yasharpm/InstaCropper" target="_blank" rel="external">InstaCropper</a></h2><p>剪切图像的View, 类似于Instagram的crop.</p>
<h2 id="GuildWars2-APIViewer"><a href="#GuildWars2-APIViewer" class="headerlink" title="GuildWars2_APIViewer"></a><a href="https://github.com/huhx0015/GuildWars2_APIViewer" target="_blank" rel="external">GuildWars2_APIViewer</a></h2><p>一个app, 用来查看Guild Wars 2的API响应.<br>用了Dagger2, Retrofit2, RxJava2, MVVM架构.</p>
<h2 id="here-be-dragons"><a href="#here-be-dragons" class="headerlink" title="here-be-dragons"></a><a href="https://github.com/anupcowkur/here-be-dragons" target="_blank" rel="external">here-be-dragons</a></h2><p>一个Intellij/Android Studio插件, 你可以在一个方法上标记<code>@SideEffect</code>, 之后你调用这个方法的代码行左边会显示出一个龙的图标.</p>
<h2 id="RoboGif"><a href="#RoboGif" class="headerlink" title="RoboGif"></a><a href="https://github.com/izacus/RoboGif" target="_blank" rel="external">RoboGif</a></h2><p>一个python的小工具, 可以把Android设备上的录屏生成一个GIF图.</p>
<h2 id="service-tree"><a href="#service-tree" class="headerlink" title="service-tree"></a><a href="https://github.com/Zhuinden/service-tree" target="_blank" rel="external">service-tree</a></h2><p>一个存储service的树形结构. (本期文章<a href="https://medium.com/@Zhuinden/retaining-dagger-components-across-configuration-change-using-service-tree-3709c78bf6d2#.114aardgd" target="_blank" rel="external">Retaining Dagger components</a>有讲.)</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> RxJava </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Mockito </tag>
            
            <tag> Dagger </tag>
            
            <tag> Realm </tag>
            
            <tag> JUnit 5 </tag>
            
            <tag> Crash </tag>
            
            <tag> MockWebServer </tag>
            
            <tag> Google Map </tag>
            
            <tag> FindBugs </tag>
            
            <tag> Lint </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 247]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/03/08/android-weekly-notes-issue-247/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-247"><a href="#Android-Weekly-Issue-247" class="headerlink" title="Android Weekly Issue #247"></a>Android Weekly Issue #247</h1><p>March 5th, 2017<br><a href="http://androidweekly.net/issues/issue-247" target="_blank" rel="external">Android Weekly Issue #247</a>.</p>
<p>本期内容包括: 离线模式的实现; RxJava2的测试支持; MVI模式中的单向数据流; FlexboxLayout的使用; 用脚本来配置项目的版本名和版本号; Fragment的转场动画; MVP模式的几点原则;<br>RxJava中需要注意的一些点; RxJava在Android中的实现例子; JUnit 5使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Offline-support-“Try-again-later”-no-more"><a href="#Offline-support-“Try-again-later”-no-more" class="headerlink" title="Offline support: “Try again, later”, no more"></a><a href="https://medium.com/@yonatanvlevin/offline-support-try-again-later-no-more-afc33eba79dc#.p90haop40" target="_blank" rel="external">Offline support: “Try again, later”, no more</a></h2><p>作者他们的应用很好地处理了离线模式, 他们的基本原则是, 应用中不需要显示任何的loading控件.</p>
<p>在离线装填下, 在用户看来仍是可以提交请求的, 只不过出现了一个sync的小图标, 一旦当用户再次连上网络, 他的请求就会被发送出去.</p>
<p>然后作者讲了他们的程序设计:<br>首先是MVP结构, 使用了Content Provider包装的SQLite数据库. (此处列举了使用Content Provider的若干优点).</p>
<p>后台的同步工作, 他们选择了<code>GCMNetworkManager</code>.</p>
<p>基本流程是这样: 但用户提交请求, 首先存储在数据库中, 状态为pending, 然后后台service发送请求, 如果成功, 则更新数据库中的状态为synced; 如果失败, 则用<code>GcmNetworkManager</code>schedule一个task, 在网络连接恢复时再做一次尝试, 成功和失败的处理同上一步.</p>
<h2 id="Story-Code"><a href="#Story-Code" class="headerlink" title="Story Code"></a><a href="https://publicobject.com/2017/02/06/story-code/" target="_blank" rel="external">Story Code</a></h2><p>作者讲了一种方法, 以一种叙事的方式来写一个测试故事, 然后把它分成很多个小的测试cases. 这样可以用来驱动API的设计和其实现等.</p>
<h2 id="Testing-RxJava2"><a href="#Testing-RxJava2" class="headerlink" title="Testing RxJava2"></a><a href="https://www.infoq.com/articles/Testing-RxJava2" target="_blank" rel="external">Testing RxJava2</a></h2><p>本文介绍RxJava2中内置的关于测试的支持.</p>
<p>测试一个<code>Observable</code>可以用<code>TestObserver</code>; 测试<code>Flowable</code>可以用<code>TestSubscriber</code>.</p>
<p>如何测试在不同线程上的工作?<br>有几种选择:</p>
<ul>
<li>把Observable变为blocking的. -&gt; <code>blockingIterable()</code>, 缺点: 测试慢.</li>
<li>强制测试等待, 直到某个条件达成. -&gt; <code>awaitTerminalEvent()</code>. 此处还推荐一个库: <a href="https://github.com/awaitility/awaitility" target="_blank" rel="external">awaitility</a>.</li>
<li>把schedular换为一个immediate的. <code>RxJavaPlugins.setComputationSchedulerHandler(scheduler -&gt; Schedulers.trampoline());</code>. 需要最后reset一下, 可以用JUnit的TestRule来进行简化.</li>
</ul>
<p>用<code>TestScheduler</code>可以操纵时间, 进行白盒测试.<br>利用它在测试中可以精确控制时间过去了多少, 我们可以测试在中间的时间点的状态.<br>值得注意的是它控制的并不是真实的时间, 真实的时间还是立即就度过了的, 所以不会降低测试的速度.</p>
<p>我们也可以利用<code>TestRule</code>和<code>RxJavaPlugins</code>来把这个scheduler设置为测试时候要切换成的scheduler.</p>
<h2 id="Syncing-Changes"><a href="#Syncing-Changes" class="headerlink" title="Syncing Changes"></a><a href="http://tech.trello.com/syncing-changes/" target="_blank" rel="external">Syncing Changes</a></h2><p>Trello的离线模式实现文章系列之二. 基本的原则是在离线的时候把改动(deltas)存在数据库里, 之后有机会再同步给server.</p>
<p>本文介绍了他们如何计算delta和将它们按时间上传到服务器.</p>
<h2 id="Reactive-Apps-With-MVI-Part-4"><a href="#Reactive-Apps-With-MVI-Part-4" class="headerlink" title="Reactive Apps With MVI - Part 4"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-4" target="_blank" rel="external">Reactive Apps With MVI - Part 4</a></h2><p>MVI系列文章的第四篇. 本篇讲如何构建独立的UI单元.</p>
<p>作者认为Presenter之间的Parent-Child关系是一种code smell, 因为这样引入了一种强耦合的关系, 不好读, 不好维护.</p>
<p>你也许要问那Presenter之间如何通信呢? 答案是, 它们根本就不需要通信, 它们只需要更新和观测同一个Model(可以说业务逻辑), 让底层来通知它们事件的发生就可以了.</p>
<h2 id="Resources-for-Learning-how-to-Test-Android-Apps"><a href="#Resources-for-Learning-how-to-Test-Android-Apps" class="headerlink" title="Resources for Learning how to Test Android Apps"></a><a href="https://www.philosophicalhacker.com/post/some-resources-for-learning-how-to-test-android-apps/" target="_blank" rel="external">Resources for Learning how to Test Android Apps</a></h2><p>关于Android测试的相关资源分享.</p>
<h2 id="Unboxing-the-FlexboxLayout"><a href="#Unboxing-the-FlexboxLayout" class="headerlink" title="Unboxing the FlexboxLayout"></a><a href="https://blog.devcenter.co/unboxing-the-flexboxlayout-a7cfd125f023#.ulop7q1jz" target="_blank" rel="external">Unboxing the FlexboxLayout</a></h2><p>作者想实现一个动态关键字的流式布局, 可以根据parent的宽度自动换行.</p>
<p>他想了几种方法, 都不太合适, 所以最后选择了<code>FlexboxLayout</code>.</p>
<p>作者尝试了单独使用<code>FlexboxLayout</code>和 将<code>FlexboxLayoutManager()</code>设置为<code>RecyclerView</code>的Layout Manager两种办法来实现他想要的效果.</p>
<h2 id="Configuring-Android-Project-Version-Name-amp-Code"><a href="#Configuring-Android-Project-Version-Name-amp-Code" class="headerlink" title="Configuring Android Project - Version Name &amp; Code"></a><a href="https://medium.com/@dmytrodanylyk/configuring-android-project-version-name-code-b168952f3323#.v20pogayh" target="_blank" rel="external">Configuring Android Project - Version Name &amp; Code</a></h2><p>首先介绍了<a href="https://git-scm.com/docs/git-describe" target="_blank" rel="external">git-describe</a>命令.</p>
<p><code>git describe -tags</code>可以输出当前最近的tag和它之后有几个提交, 还有最新提交的hash.</p>
<p>作者建议使用这个库: <a href="https://github.com/ajoberstar/grgit" target="_blank" rel="external">grgit</a>, 写一个script-git-version.gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;org.ajoberstar:grgit:1.5.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import org.ajoberstar.grgit.Grgit</div><div class="line"></div><div class="line">ext &#123;</div><div class="line">    git = Grgit.open(currentDir: projectDir)</div><div class="line">    gitVersionName = git.describe()</div><div class="line">    gitVersionCode = git.tag.list().size()</div><div class="line">    gitVersionCodeTime = git.head().time</div><div class="line">&#125;</div><div class="line"></div><div class="line">task printVersion() &#123;</div><div class="line">    println(&quot;Version Name: $gitVersionName&quot;)</div><div class="line">    println(&quot;Version Code: $gitVersionCode&quot;)</div><div class="line">    println(&quot;Version Code Time: $gitVersionCodeTime&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在主文件中apply这个文件.</p>
<p>执行printVersion task后会输出类似这样的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Version Name: 1.0-2-gdca226a</div><div class="line">Version Code: 2</div><div class="line">Version Code Time: 1484407970</div></pre></td></tr></table></figure>
<p>这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">    dev &#123;</div><div class="line">        versionCode gitVersionCodeTime</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    prod &#123;</div><div class="line">        versionCode gitVersionCode</div><div class="line">        versionName gitVersionName</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就自动生成了版本号和版本名.<br>你还可以进一步设计, 在版本名中包括分支名, 时间戳之类的.</p>
<h2 id="Workcation-App-Part-1-Fragment-custom-transition"><a href="#Workcation-App-Part-1-Fragment-custom-transition" class="headerlink" title="Workcation App - Part 1. Fragment custom transition"></a><a href="https://www.thedroidsonroids.com/blog/android/workcation-app-part-1-fragments-custom-transition/" target="_blank" rel="external">Workcation App - Part 1. Fragment custom transition</a></h2><p>作者的系列文章, 讨论他的项目中的动画的实现.<br>本文是第一篇, 介绍进入map的转场动画.</p>
<p>首先, 在map加载完毕后, 存一个截图放在缓存里, 然后用一个自定义的Transition来做缩放和渐变的动画, 最后把它设置为fragment的转场动画.</p>
<h2 id="Model-View-Presenter-Android-guidelines"><a href="#Model-View-Presenter-Android-guidelines" class="headerlink" title="Model-View-Presenter: Android guidelines"></a><a href="https://medium.com/@cervonefrancesco/model-view-presenter-android-guidelines-94970b430ddf#.s1d1l3dkt" target="_blank" rel="external">Model-View-Presenter: Android guidelines</a></h2><p>MVP实现的一些guidelines和最佳实践.</p>
<ul>
<li>1.View要无脑和被动.</li>
<li>2.Presenter要和framework无关, 不依赖任何Android的类.</li>
<li>3.写一个协议描述View和Presenter的交互.</li>
<li>4.定义命名规则来区分职责.</li>
<li>5.不要在Presenter里创建生命周期的回调方法.</li>
<li>6.Presenter和View是一对一的关系. 可以定义<code>attach()</code>和<code>detach()</code>或<code>start()</code>和<code>stop()</code>来关联和解除关联.</li>
<li>7.不要在Presenter里用Bundle保存状态. 因为不能包含Android的类.</li>
<li>8.不要保存Presenter. 因为Presenter并不是一个数据类.</li>
<li>9.在Model中提供cache来恢复View的状态.</li>
</ul>
<h2 id="5-Not-So-Obvious-Things-About-RxJava"><a href="#5-Not-So-Obvious-Things-About-RxJava" class="headerlink" title="5 Not So Obvious Things About RxJava"></a><a href="https://medium.com/@jagsaund/5-not-so-obvious-things-about-rxjava-c388bd19efbc#.dl9lo390z" target="_blank" rel="external">5 Not So Obvious Things About RxJava</a></h2><p>RxJava使用学习中的五点(RxJava1.2.6).</p>
<ul>
<li>什么时候用<code>map()</code>或者<code>flatMap()</code>.</li>
<li>不使用<code>Observable.create()</code>来创建observables. 使用其他更方便的方法, 比如<code>syncOnSubscribe</code>, <code>fromCallable</code>, <code>fromEmitter</code>.</li>
<li>如何处理Backpressure.</li>
<li>如和能让流不因为errors而停下来.</li>
<li>如何分享Observable到多个订阅者 -&gt; <code>share()</code>或<code>publish()</code>.</li>
</ul>
<h2 id="Simplify-Concurrency-with-Reactive-Modelling-on-Android"><a href="#Simplify-Concurrency-with-Reactive-Modelling-on-Android" class="headerlink" title="Simplify Concurrency with Reactive Modelling on Android"></a><a href="https://www.toptal.com/android/simplify-concurrency-reactive-modelling-android" target="_blank" rel="external">Simplify Concurrency with Reactive Modelling on Android</a></h2><p>用RxJava来处理Android上的并发和异步.<br>作者的文章中举了很详尽的各种例子.</p>
<h2 id="JUnit-5-Getting-Started"><a href="#JUnit-5-Getting-Started" class="headerlink" title="JUnit 5: Getting Started"></a><a href="https://blog.stylingandroid.com/junit-5-getting-started/" target="_blank" rel="external">JUnit 5: Getting Started</a></h2><p>使用JUnit 5做测试.<br>本文讲了一些在Android上setup可能会遇到的问题及怎么解决.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FastHub"><a href="#FastHub" class="headerlink" title="FastHub"></a><a href="https://github.com/k0shk0sh/FastHub" target="_blank" rel="external">FastHub</a></h2><p>一个Android的Github客户端.</p>
<h2 id="gradle-android-javafmt-plugin"><a href="#gradle-android-javafmt-plugin" class="headerlink" title="gradle-android-javafmt-plugin"></a><a href="https://github.com/f2prateek/gradle-android-javafmt-plugin" target="_blank" rel="external">gradle-android-javafmt-plugin</a></h2><p>一个gradle plugin, 自动format代码.</p>
<h2 id="HtmlCompat"><a href="#HtmlCompat" class="headerlink" title="HtmlCompat"></a><a href="https://github.com/Pixplicity/HtmlCompat" target="_blank" rel="external">HtmlCompat</a></h2><p>Android中Html类的兼容库.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Testing </tag>
            
            <tag> MVI </tag>
            
            <tag> FlexboxLayout </tag>
            
            <tag> Offline </tag>
            
            <tag> Version Name </tag>
            
            <tag> Git </tag>
            
            <tag> Transition </tag>
            
            <tag> JUnit 5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 246]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/03/01/android-weekly-notes-issue-246/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-246"><a href="#Android-Weekly-Issue-246" class="headerlink" title="Android Weekly Issue #246"></a>Android Weekly Issue #246</h1><p>February 26th, 2017<br><a href="http://androidweekly.net/issues/issue-246" target="_blank" rel="external">Android Weekly Issue #246</a><br>本期内容包括: RecyclerView上的Shared Element动画; 使用FileProvider分享文件有可能会碰到的权限问题; 测试和程序架构的一些讨论; FlexboxLayout的使用; RxJava中可以处理前后动作的两个方法;<br>In-App Billing的实现; 如何用组合而非继承的方式来组织应用.</p>
<p>代码中有意思的项目: 一个开源的音乐播放器, 一个带状态的layout.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Shared-Element-Transitions-with-RecyclerView"><a href="#Shared-Element-Transitions-with-RecyclerView" class="headerlink" title="Shared Element Transitions with RecyclerView"></a><a href="http://mikescamell.com/shared-element-transitions-part-4-recyclerview/" target="_blank" rel="external">Shared Element Transitions with RecyclerView</a></h2><p>作者介绍了如何在RecyclerView中实现shared element动画.</p>
<h2 id="Sharing-files-through-Intents-part-2"><a href="#Sharing-files-through-Intents-part-2" class="headerlink" title="Sharing files through Intents (part 2)"></a><a href="https://medium.com/@quiro91/sharing-files-through-intents-part-2-fixing-the-permissions-before-lollipop-ceb9bb0eec3a#.ci4hqoauq" target="_blank" rel="external">Sharing files through Intents (part 2)</a></h2><p>之前介绍过因为Android 7 Nougat对文件权限的限制, 不能再依靠Intent来发送<code>file://uri</code>数据了, 应该用<code>FileProvider</code>. 但是你采用了这些新方法之后, 在一些Android的旧版本上有可能会遇到问题.</p>
<p>你可能遇到这种异常: <code>java.lang.SecurityException: Permission Denial</code>.</p>
<p>在API 16及以上, 系统有一个方法<code>migrateExtraStreamToClipData()</code>会根据你的Intent的action帮你迁移数据到ClipData, 并自动帮你加上权限. 见代码: <a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/content/Intent.java#9037" target="_blank" rel="external">Intent</a>. 但是之前的版本却没有.</p>
<p>所以解决办法是在原本的代码中加上这两句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">    takePictureIntent.setClipData(ClipData.newRawUri(<span class="string">""</span>, photoURI));</div><div class="line">    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION|Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以要包括LOLLIPOP是因为<code>migrateExtraStreamToClipData()</code>这个方法是在preview版本之后才加上的, 所以不能保证所有的LOLLIPOP的设备都有这个方法.</p>
<h2 id="What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1"><a href="#What-Unit-Tests-are-Trying-to-Tell-us-about-Activities-Pt-1" class="headerlink" title="What Unit Tests are Trying to Tell us about Activities: Pt. 1"></a><a href="https://www.philosophicalhacker.com/post/what-unit-tests-are-trying-to-tell-us-about-activities-pt1/" target="_blank" rel="external">What Unit Tests are Trying to Tell us about Activities: Pt. 1</a></h2><p>“android-centric”的构架是指用Activity/Fragment作为屏幕基本构架单元的程序架构. 作者的系列文章要讨论为什么这种架构是对测试不友好的.</p>
<h2 id="Build-flexible-layouts-with-FlexboxLayout"><a href="#Build-flexible-layouts-with-FlexboxLayout" class="headerlink" title="Build flexible layouts with FlexboxLayout"></a><a href="https://android-developers.googleblog.com/2017/02/build-flexible-layouts-with.html" target="_blank" rel="external">Build flexible layouts with FlexboxLayout</a></h2><p>Google去年开源了<a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a>, 目的是将CSS中的<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">Flexible Layout module</a>引入到Android中来. 本文介绍了FlexboxLayout十分有用的几种情况, 附有demos.</p>
<h2 id="Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally"><a href="#Making-RxJava-code-tidier-with-doOnSubscribe-and-doFinally" class="headerlink" title="Making RxJava code tidier with doOnSubscribe and doFinally"></a><a href="https://medium.com/@ValCanBuild/making-rxjava-code-tidier-with-doonsubscribe-and-dofinally-3748f223d32d#.58wup7kxn" target="_blank" rel="external">Making RxJava code tidier with doOnSubscribe and doFinally</a></h2><p>使用<code>doOnSubscribe()</code>和<code>doFinally()</code>(RxJava 2)可以让RxJava的代码更加简洁.</p>
<ul>
<li><p><code>doOnSubscribe()</code>中的代码在subscribe的时候被调用.</p>
</li>
<li><p><code>doFinally()</code>在<code>Observable</code>调用<code>onError()</code>或<code>onCompleted()</code>之后, 或者流被下游放弃的时候调用.</p>
</li>
</ul>
<p>作者举的例子是用它们来show loading和hide loading, 这样它们也作为流的一部分, 而且subscriber可以只处理其他相关逻辑.</p>
<h2 id="Implementing-In-App-Billing-in-Android"><a href="#Implementing-In-App-Billing-in-Android" class="headerlink" title="Implementing In-App Billing in Android"></a><a href="https://hackernoon.com/implementing-in-app-billing-in-android-4896232c7d6b?gi=575af60d0286#.scggjiasz" target="_blank" rel="external">Implementing In-App Billing in Android</a></h2><p>关于Android In-App Billing的实现.</p>
<p>首先你会搜到<a href="https://developer.android.com/google/play/billing/index.html" target="_blank" rel="external">官方文档</a>.</p>
<p>作者在本文中介绍了其他的一些可选方案.</p>
<h2 id="Composite-Views-in-Android-Composition-over-Inheritance"><a href="#Composite-Views-in-Android-Composition-over-Inheritance" class="headerlink" title="Composite Views in Android: Composition over Inheritance"></a><a href="https://medium.com/@manuelvicnt/composite-views-in-android-composition-over-inheritance-4a7114609560#.n55x4611x" target="_blank" rel="external">Composite Views in Android: Composition over Inheritance</a></h2><p>作者介绍了这个库: <a href="https://github.com/passsy/CompositeAndroid" target="_blank" rel="external">CompositeAndroid</a>, 它解决了一个什么问题呢? </p>
<p>在App中, 如果多个Activity或者多个Fragment有一些共同的功能, 那么我们很可能就会创建一个基类Activity或者基类Fragment, 然后继承它. 当一些功能只被一些类共享时, 我们可能会继续不断创建基类, 产生一个无法维护的继承树.</p>
<p>解决的办法就是使用这个库, Activity只需要继承<code>CompositeActivity</code>, 所有共有的功能都会被当做插件加进来.<br>这样我们遵守了一个原则: <code>组合优于继承</code>.</p>
<p>但是这个库也有一些缺点: 它还在alpha阶段; 如果你使用了一些不常用的生命周期, 可能会有问题; 它是基于support library的, 所以如果这个库不更新support库的版本, 你也无法更新.</p>
<p>所以作者提出了一个简单的解决方案, 不使用CompositeAndroid. 文中举例展示了他的实现.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ShapeShifter"><a href="#ShapeShifter" class="headerlink" title="ShapeShifter"></a><a href="https://github.com/alexjlockwood/ShapeShifter" target="_blank" rel="external">ShapeShifter</a></h2><p>创建路径变形动画的一个web-app, 支持导出到<code>AnimatedVectorDrawable</code>.</p>
<h2 id="Shuttle"><a href="#Shuttle" class="headerlink" title="Shuttle"></a><a href="https://github.com/timusus/Shuttle" target="_blank" rel="external">Shuttle</a></h2><p>一个开源的本地音乐播放器.</p>
<h2 id="cortado"><a href="#cortado" class="headerlink" title="cortado"></a><a href="https://github.com/blipinsk/cortado" target="_blank" rel="external">cortado</a></h2><p>在Espresso上提供了一个抽象层, 使用更流畅.</p>
<h2 id="fragment-navigation-2-0"><a href="#fragment-navigation-2-0" class="headerlink" title="fragment-navigation-2.0"></a><a href="https://github.com/gyorgygabor/fragment-navigation-2.0" target="_blank" rel="external">fragment-navigation-2.0</a></h2><p>Fragment导航库.</p>
<h2 id="flexbox-layout"><a href="#flexbox-layout" class="headerlink" title="flexbox-layout"></a><a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">flexbox-layout</a></h2><p>Flexbox for Android.</p>
<h2 id="kotlin-coroutines-retrofit"><a href="#kotlin-coroutines-retrofit" class="headerlink" title="kotlin-coroutines-retrofit"></a><a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="external">kotlin-coroutines-retrofit</a></h2><p>This is small library that provides Kotlin Coroutines suspending extension Call.await() for Retrofit 2.</p>
<h2 id="StatefulLayout"><a href="#StatefulLayout" class="headerlink" title="StatefulLayout"></a><a href="https://github.com/gturedi/StatefulLayout" target="_blank" rel="external">StatefulLayout</a></h2><p>一个内置包含loading, 错误, 空状态的布局.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Testing </tag>
            
            <tag> FileProvider </tag>
            
            <tag> Shared Element </tag>
            
            <tag> FlexboxLayout </tag>
            
            <tag> In-App Billing </tag>
            
            <tag> Music Player </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Realm数据库使用指南]]></title>
      <url>http://mengdd.github.io/Android/Database/Realm/2017/02/27/android-realm-guide/</url>
      <content type="html"><![CDATA[<h1 id="Android-Realm数据库使用指南"><a href="#Android-Realm数据库使用指南" class="headerlink" title="Android Realm数据库使用指南"></a>Android Realm数据库使用指南</h1><p>Realm数据库, 目前有Java, Objective‑C, React Native, Swift, Xamarin的几种实现, 是一套用来取代SQLite的解决方案. </p>
<p>本文面向Android开发, 所以只讨论Java实现.<br>目前Realm Java的最新版本是2.3.1.</p>
<p>官方文档在此: <a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">realm java doc</a>, 花一个下午就可以基本过一遍, 之后随时查用. </p>
<p>我写了一个小程序<a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a>, 使用Realm做数据库实现的一个To-do应用,  在实际使用的过程中也有一些发现.</p>
<p>本文是我自己看文档的时候的一些记录, 有一些实际使用时的发现也穿插在对应的章节了.</p>
<a id="more"></a>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>在项目的根build.gradle的文件中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;io.realm:realm-gradle-plugin:2.3.0&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在app的build.gradle文件中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;realm-android&apos;</div></pre></td></tr></table></figure></p>
<p>Done.</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Model类只要继承<code>RealmObject</code>即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">RealmObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String          name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             age;</div><div class="line"></div><div class="line">    <span class="meta">@Ignore</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>             sessionId;</div><div class="line"></div><div class="line">    <span class="comment">// Standard getters &amp; setters generated by your IDE…</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>    <span class="title">getSessionId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sessionId; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setSessionId</span><span class="params">(<span class="keyword">int</span> sessionId)</span> </span>&#123; <span class="keyword">this</span>.sessionId = sessionId; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>Model类中可以包含的字段类型包括基本数据类型(及它们的装箱类型)和Date类, 另外也可以包含<code>RealmObject</code>的子类或者是<code>RealmList&lt;? extends RealmObject&gt;</code>.</p>
<h3 id="字段性质"><a href="#字段性质" class="headerlink" title="字段性质"></a>字段性质</h3><p>在字段上加注解可以定义字段的性质:</p>
<p><code>@Required</code>表明字段非null.<br>原生类型和<code>RealmList</code>类型默认是非null的.<br><code>RealmObject</code>字段永远是可以为null的.</p>
<p><code>@Ignore</code>表示字段不会被存储.</p>
<p><code>@Index</code>加索引.</p>
<p><code>@PrimaryKey</code>加主键, 主键只能有一个, 主键默认加索引.</p>
<p>但是注意主键默认没有加<code>@Required</code>, 如果主键要求非null, 需要显式添加<code>@Required</code>.</p>
<h3 id="主键使用"><a href="#主键使用" class="headerlink" title="主键使用"></a>主键使用</h3><p>有主键才能使用<code>copyToRealmOrUpdate()</code>这个方法.<br>主键类型必须是String或者整型(byte, short, int, long)或者它们的装箱类型(Byte, Short, Integer, Long).</p>
<p>有主键的对象创建的时候不能使用<code>createObject(Class&lt;E&gt; clazz)</code>方法, 而应该使用<code>createObject(Class&lt;E&gt; clazz, Object primaryKeyValue)</code>附上主键.</p>
<p>或者用<br><code>copyToRealm(obj)</code>或<code>copyToRealmOrUpdate(obj)</code>, 前者遇到主键冲突时会崩溃, 后者遇到主键冲突会更新已有对象.</p>
<h3 id="自动更新的对象"><a href="#自动更新的对象" class="headerlink" title="自动更新的对象"></a>自动更新的对象</h3><p>Realm中的数据对象是自动更新(Auto-Updating)的, 对象一旦被查询出来, 后续发生的任何数据改变也会立即反映在结果中, 不需要刷新对象.</p>
<p>这是一个非常有用的特性, 结合数据变化的通知可以很方便地刷新UI.</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>Realm model对象间可以很方便地建立关系.<br>你可以在Model中存储另一个对象的引用, 建立多对一的关系; 也可以存储一组对象<code>RealmList&lt;T&gt;</code>, 建立一对多或多对多的关系.</p>
<p><code>RealmList&lt;T&gt;</code>的getter永远也不会返回null, 它只会返回一个为空的list.<br>把这个字段设置为null可以清空这个list.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Realm在使用之前需要调用初始化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Realm.init(context);</div></pre></td></tr></table></figure></p>
<p>建议把它放在Application的<code>onCreate()</code>里.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置类: <code>RealmConfiguration</code>定义了Realm的创建配置.<br>最基本的配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div></pre></td></tr></table></figure></p>
<p>它会创建一个叫<code>default.realm</code>的文件, 放在<code>Context.getFilesDir()</code>的目录下.</p>
<p>如果我们想自定义一个配置, 可以这样写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The RealmConfiguration is created using the builder pattern.</span></div><div class="line"><span class="comment">// The Realm file will be located in Context.getFilesDir() with name "myrealm.realm"</span></div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">  .name(<span class="string">"myrealm.realm"</span>)</div><div class="line">  .encryptionKey(getKey())</div><div class="line">  .schemaVersion(<span class="number">42</span>)</div><div class="line">  .modules(<span class="keyword">new</span> MySchemaModule())</div><div class="line">  .migration(<span class="keyword">new</span> MyMigration())</div><div class="line">  .build();</div><div class="line"><span class="comment">// Use the config</span></div><div class="line">Realm realm = Realm.getInstance(config);</div></pre></td></tr></table></figure></p>
<p>所以我们是可以有多个配置, 访问多个Realm实例的.</p>
<p>我们可以把配置设置为默认配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Realm.init(<span class="keyword">this</span>);</div><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder().build();</div><div class="line">Realm.setDefaultConfiguration(config);</div></pre></td></tr></table></figure></p>
<p>之后用<code>Realm.getDefaultInstance()</code>取到的就是这个默认配置对应的实例.</p>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>迁移的策略是通过config指定的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RealmConfiguration config = <span class="keyword">new</span> RealmConfiguration.Builder()</div><div class="line">    .schemaVersion(<span class="number">2</span>) <span class="comment">// Must be bumped when the schema changes</span></div><div class="line">    .migration(<span class="keyword">new</span> MyMigration()) <span class="comment">// Migration to run instead of throwing an exception</span></div><div class="line">    .build()</div></pre></td></tr></table></figure></p>
<p>其中<code>MyMigration</code>实现了<code>RealmMigration</code>接口, 在<code>migrate()</code>方法中根据新旧版本号进行一步一步地升级.</p>
<p>具体例子见<a href="https://github.com/realm/realm-java/blob/master/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java" target="_blank" rel="external">Migration</a>.</p>
<p>开发的时候为了方便我用的是<code>.deleteRealmIfMigrationNeeded()</code>, 这样在需要数据库迁移的时候直接就删了数据重新开始了.</p>
<h2 id="关于Realm的close"><a href="#关于Realm的close" class="headerlink" title="关于Realm的close()"></a>关于Realm的close()</h2><p>一个打开的Realm实例会持有一些资源, 有一些是Java不能自动管理的, 所以就需要打开实例的代码负责在不需要的时候将其关闭.</p>
<p>Realm的instance是引用计数的(reference counted cache), 在同一个线程中获取后续实例是免费的, 但是底层的资源只有当所有实例被释放了之后才能释放. 也即你调用了多少次<code>getInstance()</code>, 就需要调用相应次数的<code>close()</code>方法.</p>
<p>比较建议的方法是在Activity或Fragment的生命周期中处理Realm实例的开启和释放:</p>
<ul>
<li>在Activity的<code>onCreate()</code>中<code>getInstance()</code>, <code>onDestroy()</code>中<code>close()</code>.</li>
<li>在Fragment的<code>onCreateView()</code>中<code>getInstance()</code>, <code>onDestroyView()</code>中<code>close()</code>.</li>
</ul>
<p>如果多个Fragment相关的都是同一个数据库实例, 那么在Activity中处理更好一些.</p>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>写操作一般的流程是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Obtain a Realm instance</span></div><div class="line">Realm realm = Realm.getDefaultInstance();</div><div class="line"></div><div class="line">realm.beginTransaction();</div><div class="line"></div><div class="line"><span class="comment">//... add or update objects here ...</span></div><div class="line"></div><div class="line">realm.commitTransaction();</div></pre></td></tr></table></figure></p>
<p>这里创建对象可以用<code>createObject()</code>方法或者<code>copyToRealm()</code>方法.<br>前者是先创建再set值, 后者是先new对象再更新数据库.</p>
<p>如果不想自己处理<code>beginTransaction()</code>, <code>cancelTransaction()</code>和<code>commitTransaction()</code>, 可以直接调用<code>realm.executeTransaction()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">realm.executeTransaction(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">        User user = realm.createObject(User.class);</div><div class="line">        user.setName(<span class="string">"John"</span>);</div><div class="line">        user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>因为transactions之间是互相阻塞的.<br>异步执行可以用这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">realm.executeTransactionAsync(<span class="keyword">new</span> Realm.Transaction() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm bgRealm)</span> </span>&#123;</div><div class="line">                User user = bgRealm.createObject(User.class);</div><div class="line">                user.setName(<span class="string">"John"</span>);</div><div class="line">                user.setEmail(<span class="string">"john@corporation.com"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnSuccess() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction was a success.</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Realm.Transaction.OnError() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</div><div class="line">                <span class="comment">// Transaction failed and was automatically canceled.</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这两个回调是Optional的, 它们只能在有Looper的线程调用.</p>
<p>注意: 这个方法的返回值对象可以用于在Activity/Fragment生命周期结束的时候取消未完的操作.</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>所有的写操作都要放在transaction中进行, 如上, 不同的操作只是其中具体方法不同.</p>
<p>删除操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> RealmResults&lt;User&gt; users = getUsers();</div><div class="line"><span class="comment">// method 1:</span></div><div class="line">users.get(<span class="number">0</span>).deleteFromRealm();</div><div class="line"><span class="comment">// method 2:</span></div><div class="line">users.deleteFromRealm(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// delete all</span></div><div class="line">users.deleteAllFromRealm();</div></pre></td></tr></table></figure></p>
<p>更新操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.copyToRealmOrUpdate(obj);</div></pre></td></tr></table></figure></p>
<p>注意: 这个方法需要Model有主键, 会更新obj的主键对应的对象, 如果不存在则新建对象.</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询可以流式地写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Or alternatively do the same all at once (the "Fluent interface"):</span></div><div class="line">RealmResults&lt;User&gt; result2 = realm.where(User.class)</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"John"</span>)</div><div class="line">                                  .or()</div><div class="line">                                  .equalTo(<span class="string">"name"</span>, <span class="string">"Peter"</span>)</div><div class="line">                                  .findAll();</div></pre></td></tr></table></figure></p>
<p>查询条件默认是and的关系, or则需要显式指定.</p>
<p>这个<code>RealmResults</code>是继承Java的<code>AbstractList</code>的, 是有序的集合, 可以通过索引访问.<br><code>RealmResults</code>永远不会为null, 当查不到结果时, 它的<code>size()</code>返回0.</p>
<h3 id="查询的线程"><a href="#查询的线程" class="headerlink" title="查询的线程"></a>查询的线程</h3><p>基本上所有的查询都是很快进行的, 足够在UI线程上同步进行.<br>所以绝大多数情况在UI线程上使用<code>findAll()</code>是没有问题的.</p>
<p>如果你要进行非常复杂的查询, 或者你的查询是在非常大的数据集上进行的, 你可以选择异步查询, 使用<code>findAllAsync()</code>.</p>
<h3 id="查询条件是一个集合-gt-in"><a href="#查询条件是一个集合-gt-in" class="headerlink" title="查询条件是一个集合 -&gt; in()"></a>查询条件是一个集合 -&gt; <code>in()</code></h3><p>如果想要查询的某一个字段的值是在一个集合中, 比如我有一个id的集合, 我现在想把id在这个集合中的项目全都查出来, 这就可以使用in操作符:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;TodoList&gt; toDeleteLists = realm.where(TodoList.class).in(<span class="string">"id"</span>, ids).findAll();</div></pre></td></tr></table></figure></p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>查询的时候可以利用link或关系来查询, 比如一个Person类中含有一个<code>RealmList&lt;Dog&gt; dogs</code>的字段.<br>查询的时候可以这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;Person&gt; persons = realm.where(Person.class)</div><div class="line">                                .equalTo(<span class="string">"dogs.color"</span>, <span class="string">"Brown"</span>)</div><div class="line">                                .findAll();</div></pre></td></tr></table></figure></p>
<p>利用字段名<code>dogs.</code>来查询一个dog的属性, 再查出拥有这种特定属性dog的人.</p>
<p>但是反向地, 我们能不能查询主人是满足特定属性的人的所有dogs呢? 目前(2017.2.17)这种查询仍是不支持的. 这里有讨论:  <a href="https://github.com/realm/realm-java/issues/607" target="_blank" rel="external">realm-java-issue-607</a>.</p>
<p> 所以两种解决办法: 一是做两次查询; 二是在Dog类的model里加入对Person的引用.</p>
<h2 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h2><p>可以添加一个listener, 在数据改变的时候收到更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Realm realm;</div><div class="line">    <span class="keyword">private</span> RealmChangeListener realmListener;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">      realm = Realm.getDefaultInstance();</div><div class="line">      realmListener = <span class="keyword">new</span> RealmChangeListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(Realm realm)</span> </span>&#123;</div><div class="line">            <span class="comment">// ... do something with the updates (UI, etc.) ...</span></div><div class="line">        &#125;&#125;;</div><div class="line">      realm.addChangeListener(realmListener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">// Remove the listener.</span></div><div class="line">        realm.removeChangeListener(realmListener);</div><div class="line">        <span class="comment">// Close the Realm instance.</span></div><div class="line">        realm.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意listener需要在不用的时候删除掉. </p>
<p>可以用这样删除所有的listeners:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm.removeAllChangeListeners();</div></pre></td></tr></table></figure></p>
<p>Listener不一定要和Realm绑定, 也可以和具体的<code>RealmObject</code>或者<code>RealmResults</code>绑定.<br>当Listener被调用的时候, 它绑定的对象是自动更新的, 不需要手动刷新.</p>
<h2 id="查看数据库的工具"><a href="#查看数据库的工具" class="headerlink" title="查看数据库的工具"></a>查看数据库的工具</h2><p>用Stetho不能直接查看Realm的数据库, 看不到.<br>需要用这个工具配置一下: <a href="https://github.com/uPhyca/stetho-realm" target="_blank" rel="external">stetho-realm</a>.<br>之后就可以在浏览器中查看Realm的数据库了.</p>
<p>(但是感觉这个工具不是很好用, 有时候不显示数据, 有时候显示的是旧数据.)</p>
<p>也可以用官方提供的Realm Browser来查看, 但是只有Mac版.<br>如何查看看这里: <a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803" target="_blank" rel="external">StackOverflow answer</a>.</p>
<h2 id="实际使用的感想和遇到的问题"><a href="#实际使用的感想和遇到的问题" class="headerlink" title="实际使用的感想和遇到的问题"></a>实际使用的感想和遇到的问题</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>建立Model之间的关系很方便也很直接, 查询的时候自动关联了其中的关系.</li>
<li>自动更新(Auto-Updating)的特性很有用, 不用再关心数据的刷新, 只用关心UI的刷新. </li>
</ul>
<p>比如一旦给Adapter绑定了数据, 之后的数据更新只需要在onChange()里面通知Adapter调用<code>notifyDataSetChanged()</code>即可.</p>
<p>当然我并没有用<code>RealmBaseAdapter</code>和<code>RealmRecyclerViewAdapter</code>, 估计这两个更好用, 官方有例子, 这里不再赘述.</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这里有的也不能说是缺点, 只是使用起来觉得不方便的地方. </p>
<ul>
<li>限制了创建对象和操作对象必须在同一个线程.<br>违反了这条会报错: <code>java.lang.IllegalStateException: Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.</code> 比如我们在UI线程查询出来的对象, 想要异步地删除或者更新, 我们必须在新的线程重新查询.</li>
<li>没有主键自增的功能, 见<a href="https://github.com/realm/realm-java/issues/469" target="_blank" rel="external">Issue #469</a>, 需要自己控制主键自增.</li>
<li>从List中删除了一项之后, 最后的一项会移动过来补到被删除的那一项原来的位置. 这是因为人家就是这么设计的<a href="http://stackoverflow.com/questions/37480785/realm-order-of-records-was-changed" target="_blank" rel="external">stackoverflow</a>. 默认情况下是没有排序的, 数据按照添加的顺序返回, 但是这并不是一种保证, 所以当删除了中间的元素, 后面的会补上这个位置, 以保证底层的数据是放在一起的. 解决办法就是指定一个排序规则.</li>
<li>查询出来的对象不可以临时改变其数据, 否则会报错: <code>java.lang.IllegalStateException: Changing Realm data can only be done from inside a transaction.</code></li>
<li>不支持反向link的查询. (见前面链式查询部分的介绍).</li>
<li>不支持级联删除. 即从数据库中删除一个对象的时候, 不会删除其中<code>RealmObject</code>子类或<code>RealmList</code>类型的字段在数据库中对应的数据. <a href="https://github.com/realm/realm-java/issues/1104" target="_blank" rel="external">Issue #1104</a>, <a href="https://github.com/realm/realm-java/issues/2717" target="_blank" rel="external">Issue #2717</a>. 这点也可以理解, 因为model之间的关系可能是多对多的. 所以需要实现级联删除的地方需要手动处理.</li>
<li>测试不方便: <code>RealmResults</code>对象即不能被mock也不能被new; 所有的Model对象也不能被mock. 因为<code>Mockito can only mock non-private &amp; non-final classes.</code></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/realm/realm-java" target="_blank" rel="external">Github repo realm-java</a></li>
<li><a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">Realm Java Doc</a></li>
</ul>
<p>我的练习Demo:</p>
<ul>
<li><a href="https://github.com/mengdd/TodoRealm" target="_blank" rel="external">TodoRealm</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Database </category>
            
            <category> Realm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Database </tag>
            
            <tag> Realm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 245]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/02/22/android-weekly-notes-issue-245/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-245"><a href="#Android-Weekly-Issue-245" class="headerlink" title="Android Weekly Issue #245"></a>Android Weekly Issue #245</h1><p>February 19th, 2017<br><a href="http://androidweekly.net/issues/issue-245" target="_blank" rel="external">Android Weekly Issue #245</a><br>本期内容: 写好单元测试的几条原则; 如何mock Kotlin的对象; 如何消除God Object -&gt; Context; 如何用Android来打电话和发短信, 以及相应事件的监听; 一个监控用电情况的应用(Android Things);<br>用Keystore保存敏感信息; 依赖注入和Dagger 2的使用; Wear应用向Wear 2.0的迁移; 用ViewPager构建无Fragment的应用结构; Android应用的压力测试讨论; RxJava中<code>Subscription</code>注销处理不当引起的内存泄露; 单元测试并不是完全可靠; Trello向离线模式迁移的架构变化.</p>
<p>本周推荐的代码里有一个顶部提示控件, 一个手势检测库, 还有一个loading view的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Write-awesome-unit-tests"><a href="#Write-awesome-unit-tests" class="headerlink" title="Write awesome unit tests"></a><a href="http://jeroenmols.com/blog/2017/02/16/unittests/" target="_blank" rel="external">Write awesome unit tests</a></h2><p>作者关于写好单元测试提供了三条简单的规则以及每条规则对应的一些建议.</p>
<h3 id="1-尽快尽早地跑测试"><a href="#1-尽快尽早地跑测试" class="headerlink" title="1. 尽快尽早地跑测试."></a>1. 尽快尽早地跑测试.</h3><p>尽量在每次改动之后都跑跑测试, 及早发现问题. 你的测试跑得越快你就越有可能经常跑它们.</p>
<p>为了让测试跑得很快:</p>
<ul>
<li>让测试跑在JVM上而不是设备上.</li>
<li>仅测试独立的逻辑模块.</li>
<li>不要包含UI, 数据库, 或者网络测试在你的主测试套件中.</li>
<li>测试中不要使用wait/sleep.</li>
</ul>
<h3 id="2-小并且关注点集中的测试"><a href="#2-小并且关注点集中的测试" class="headerlink" title="2. 小并且关注点集中的测试"></a>2. 小并且关注点集中的测试</h3><p>对每一个bug来说, 应该有且只有一个测试挂掉, 并且测试失败的原因应该能从测试方法名上看出来.</p>
<p>这样就迫使你每一个测试只检查一件事情, 导致你的测试小并且简单易懂, 也好维护. </p>
<p>实现tips:</p>
<ul>
<li>测试中只有一条assert/verify语句.</li>
<li>有更多的小测试, 而不是几个大测试.</li>
<li>测试的名字能清楚地描述失败的原因.</li>
</ul>
<h3 id="3-100-的可靠性"><a href="#3-100-的可靠性" class="headerlink" title="3. 100%的可靠性"></a>3. 100%的可靠性</h3><p>你的测试应该是完全值得信赖的, 不应该随机失败, 否则你将会对测试失去信任, 也不再会认真对待测试的失败.</p>
<p>所以你的测试应该是100%可靠的, 只在真的有问题的时候才失败.</p>
<p>建议是:</p>
<ul>
<li>在JVM上跑测试, 因为到设备的连接可能会中断.</li>
<li>在测试的时候mock网络通信.</li>
<li>把UI/集成测试移出你的单元测试套件.</li>
</ul>
<h2 id="Helping-to-Mock-Tests-in-Kotlin"><a href="#Helping-to-Mock-Tests-in-Kotlin" class="headerlink" title="Helping to Mock Tests in Kotlin"></a><a href="https://medium.com/@orogersilva/helping-androiddev-to-mock-tests-in-kotlin-ab3be5204559#.wetcvdvbt" target="_blank" rel="external">Helping to Mock Tests in Kotlin</a></h2><p>因为Kotlin中的类默认是<code>final</code>的, 要继承的话需要显示地声明<code>open</code>.</p>
<p>如果只是为了在单元测试中mock就要加个open吗? 不.</p>
<p>本篇文章就介绍如何如何mock Kotlin的对象, 而不用该它的声明.</p>
<p>首先, <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="external">Set up</a>; 然后, 使用这个库<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>.</p>
<p>文中详细介绍了使用细节, 以及对<code>any()</code>方法的讨论.</p>
<h2 id="How-and-Why-I-Kill-God-Objects"><a href="#How-and-Why-I-Kill-God-Objects" class="headerlink" title="How and Why I Kill God Objects"></a><a href="https://www.philosophicalhacker.com/post/towards-godless-android-development-how-and-why-i-kill-god-objects/" target="_blank" rel="external">How and Why I Kill God Objects</a></h2><p>在面向对象编程中, God Objects是应该被避免的.</p>
<p>在Android开发中, 最常见的一种God对象是Context. 本文介绍如何清除这个God对象, 同样的方法也可以用来处理其他对象.</p>
<p>首先说为什么要干掉Context?<br>在做TDD的过程中, 我们希望是面向接口的, 而且我们不应该mock非我们拥有的类型.<br>所以我们不应该直接mock外部的API, 而是应该创建一个自己的接口层.</p>
<p>作者发现很多类其实并不真正需要一个Context, 它们只是需要得到string或者存储的键值对.</p>
<p>之后文中举例介绍了如何通过定义接口摆脱Context.</p>
<h2 id="How-to-Make-Calls-and-Use-SMS-in-Android-Apps"><a href="#How-to-Make-Calls-and-Use-SMS-in-Android-Apps" class="headerlink" title="How to Make Calls and Use SMS in Android Apps"></a><a href="https://code.tutsplus.com/tutorials/how-to-make-calls-and-use-sms-in-android-apps--cms-28168" target="_blank" rel="external">How to Make Calls and Use SMS in Android Apps</a></h2><p><strong>如何拨打电话</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String dial = <span class="string">"tel:"</span> + phoneNo;</div><div class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(dial)));</div></pre></td></tr></table></figure></p>
<p>(不需要权限).</p>
<p>如果想在app里直接拨出去电话, 需要权限<code>android.permission.CALL_PHON</code>, 并且改用<code>ACTION_CALL</code>.</p>
<p><strong>监控电话事件</strong>:</p>
<p>需要权限<code>android.permission.READ_PHONE_STATE</code>.来监控来电, 打出去的电话需要这个权限: <code>android.permission.PROCESS_OUTGOING_CALLS</code>.</p>
<p>具体实现就是在<code>TelephonyManager</code>注册监听器<code>PhoneStateListener</code>. 如果是在Activity中需要在对应的生命周期注销监听器.</p>
<p>如果需要后台监控, 则需要用到<code>BroadcastReceiver</code>, 过滤actions为<code>android.intent.action.PHONE_STATE</code>和<code>android.intent.action.NEW_OUTGOING_CALL</code>.<br>除了获取相应的电话号码, 还可以进一步阻止电话的拨出.</p>
<p><strong>发送短信</strong>:</p>
<p>发短信也是两种方法, 启动一个短信客户端程序, 或者直接从程序里发.</p>
<p>启动其他程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent smsIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, Uri.parse(<span class="string">"smsto:"</span> + phoneNo));</div><div class="line">smsIntent.putExtra(<span class="string">"sms_body"</span>, message);</div><div class="line">startActivity(smsIntent);</div></pre></td></tr></table></figure></p>
<p>自己发: 需要权限<code>android.permission.SEND_SMS</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SmsManager smsManager = SmsManager.getDefault();</div><div class="line">smsManager.sendTextMessage(phoneNo, <span class="keyword">null</span>, message, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>注意Android 6.0以上的设备, 本文提到的这些危险权限都是需要动态请求的.</p>
<p><strong>收短信</strong>:<br>通过<code>BroadcastReceiver</code>, 需要权限<code>android.permission.RECEIVE_SMS</code>.</p>
<h2 id="Android-Things-Electricity-Monitoring-App"><a href="#Android-Things-Electricity-Monitoring-App" class="headerlink" title="Android Things - Electricity Monitoring App"></a><a href="https://riggaroo.co.za/android-things-electricity-monitoring-app/" target="_blank" rel="external">Android Things - Electricity Monitoring App</a></h2><p>作者分享了一个她的Android Things的应用(和Github repo), 可以监控她家的用电情况.</p>
<h2 id="Using-Keystore-system-to-store-and-retrieve-sensitive-information"><a href="#Using-Keystore-system-to-store-and-retrieve-sensitive-information" class="headerlink" title="Using Keystore system to store and retrieve sensitive information"></a><a href="https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454b#.nu3gw39qp" target="_blank" rel="external">Using Keystore system to store and retrieve sensitive information</a></h2><p>利用Android的Keystore来存储一些敏感信息.</p>
<h2 id="The-lost-droid-and-the-magic-Dagger"><a href="#The-lost-droid-and-the-magic-Dagger" class="headerlink" title="The lost droid and the magic Dagger"></a><a href="https://medium.com/rocknnull/the-lost-droid-and-the-magic-dagger-an-intro-to-dependency-injection-for-android-c686f4399117#.k5vgmxsjh" target="_blank" rel="external">The lost droid and the magic Dagger</a></h2><p>一篇依赖注入的介绍文章.<br>先介绍依赖注入是什么, 有什么优点, 接着介绍Dagger 2的使用.</p>
<h2 id="Wear-2-0-Match-Timer-–-Part-1"><a href="#Wear-2-0-Match-Timer-–-Part-1" class="headerlink" title="Wear 2.0: Match Timer – Part 1"></a><a href="https://blog.stylingandroid.com/wear-2-0-match-timer-part-1/" target="_blank" rel="external">Wear 2.0: Match Timer – Part 1</a></h2><p>作者把他的Wear应用升级到了Wear 2.0.</p>
<h2 id="ViewPager-without-Fragments"><a href="#ViewPager-without-Fragments" class="headerlink" title="ViewPager without Fragments"></a><a href="http://www.ottodroid.net/?p=523" target="_blank" rel="external">ViewPager without Fragments</a></h2><p>一些开发者可能不想选择Fragment, 这篇文章里有相关讨论: <a href="https://medium.com/square-corner-blog/advocating-against-android-fragments-81fd0b462c97#.e4k145h1b" target="_blank" rel="external">Advocating Against Android Fragments</a>.</p>
<p>作者推荐了一些在不用Fragment的情况下构建App的库: <a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="external">Conductor</a>, <a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>, <a href="https://github.com/square/flow" target="_blank" rel="external">flow</a>, <a href="https://github.com/square/mortar" target="_blank" rel="external">mortar</a>.</p>
<p>而本篇文章想要展示另一种方法, 既不用Fragment, 也不用上述的第三方库来构建一个App -&gt; 用ViewPager.</p>
<p>在PagerAdapter里管理了一个Presenter的List, 每一个Presenter管理一个View. 具体实现见原文.</p>
<h2 id="Stress-testing-Android-apps"><a href="#Stress-testing-Android-apps" class="headerlink" title="Stress-testing Android apps"></a><a href="https://android.jlelse.eu/stress-testing-android-apps-601311ebf590#.8kqor9m39" target="_blank" rel="external">Stress-testing Android apps</a></h2><p>之前大神JakeWharton有一个Sample App: <a href="https://github.com/JakeWharton/u2020" target="_blank" rel="external">JakeWharton/u2020</a>, 里面有一个debug drawer, 可以用来模拟不同的测试情形, 比如网络连接不好, 延迟, 或者网络错误等等.</p>
<p>作者他们的App也有一个类似的debug drawer, 他们讨论出了一个需要测试的情形的checklist:</p>
<ul>
<li>网络延迟</li>
<li>错误率</li>
<li>离线模式</li>
<li>屏幕旋转</li>
<li>应用在后台被杀死</li>
<li>应用升级</li>
<li>Key Bashing</li>
<li>多窗口模式 (Android N)</li>
<li>TransactionTooLargeException (Android N)</li>
</ul>
<p>作者甚至发现其中的一些项目组合起来测试非常有趣.</p>
<ul>
<li>网络延迟: 可结合方向改变/app后台被杀死测试.</li>
<li>错误率: 可以检查错误是否被正确处理并被报告.</li>
<li>离线模式: 关掉网络或者打开飞行模式, 检测正在执行的网络请求是否会引起崩溃; 是否正确通知了用户连接丢失了; 所有应该被cach的内容是否被正确cach了.</li>
<li>方向改变: 检查:  正在进行的请求会怎么办? app的状态是否被正确恢复了? 是否加载了当前方向对应的正确资源?</li>
<li>App在后台被杀死: 可以通过命令: <code>adb shell am kill YOUR_PACKAGNE_NAME</code>或者”Do not keep activities”来模拟这种情形. 相关阅读: <a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">Optimizing for Doze and App Standby</a>.</li>
<li>App更新: 升级后之前的数据是否被保存了?</li>
<li>Key Bashing: 剧烈的滑动和敲击可能产生一些奇怪的错误. 可以跑Monkey来测试一下你的应用: <code>adb shell monkey -p YOUR_PACKAGNE_NAME</code>.</li>
<li>多窗口模式(Android N): 列出了一些多窗口的测试项目, 详情见原文.</li>
<li>TransactionTooLargeException (Android N): Bundle中的数据不能太大, 超过限制, 在Android N以上会直接抛异常.</li>
</ul>
<h2 id="How-to-leak-memory-with-Subscriptions-in-RxJava"><a href="#How-to-leak-memory-with-Subscriptions-in-RxJava" class="headerlink" title="How to leak memory with Subscriptions in RxJava"></a><a href="https://medium.com/@scanarch/how-to-leak-memory-with-subscriptions-in-rxjava-ae0ef01ad361#.20w4lbkxq" target="_blank" rel="external">How to leak memory with Subscriptions in RxJava</a></h2><p>文中举了一个例子, 用RxJava结合MVP, 做网络请求, 更新UI, 很常见的使用情形. </p>
<p>在生命周期结束的时候调用RxJava的<code>Subscription.unsubscribe()</code>来注销, 以结束还在进行的网络请求.</p>
<p>看上去没有什么问题, 但是程序实际运行, 反复旋转屏幕进行测试, <code>StrictMode</code>报告出了Activity的<code>InstanceCountViolation</code>, dump memory的确看到了多个Activity的实例. 这是为什么呢? </p>
<p>作者深究原因, 发现<code>Subscriber</code>的子类存储的都是final的字段, 比如这个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext;</div><div class="line">    <span class="keyword">final</span> Action1&lt;Throwable&gt; onError;</div><div class="line">    <span class="keyword">final</span> Action0 onCompleted;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionSubscriber</span><span class="params">(Action1&lt;? <span class="keyword">super</span> T&gt; onNext, Action1&lt;Throwable&gt; onError, Action0 onCompleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.onNext = onNext;</div><div class="line">        <span class="keyword">this</span>.onError = onError;</div><div class="line">        <span class="keyword">this</span>.onCompleted = onCompleted;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为它们都是final的, 所以最后即便执行了注销操作, 也是没有办法把它们置为null的.</p>
<p>在生命周期结束的时候注销的操作是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    subscription.unsubscribe();</div><div class="line">    view = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>subscription</code>是<code>subscribe()</code>方法的返回值, 被保存在Presenter的一个字段里, 它实际就是<code>Subscriber</code>对象.</p>
<p>这里的问题就是, 在<code>destroy()</code>之后, 该引用并没有被置为null, 导致了下面的引用链:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Presenter -&gt; subscription字段, 也即匿名的`Subscriber`对象 -&gt; final字段 -&gt; 对view的引用 -&gt; 对Activity的引用.</div></pre></td></tr></table></figure>
<p>从而造成了内存泄露.</p>
<p>解决的办法有两个:</p>
<ul>
<li>在<code>subscription.unsubscribe();</code>之后把<code>subscription</code>字段置为null.</li>
<li>使用<code>CompositeSubscription</code>, 它可以管理多个<code>Subscription</code>对象, 用它的<code>clear()</code>方法, 它会unsubscribe所有项目并且清除所有的引用.</li>
</ul>
<p>文后还列了相关的资料, 作者发现问题并寻找原因的思路很值得学习.</p>
<h2 id="Your-Unit-tests-might-not-be-as-reliable-as-you-thought"><a href="#Your-Unit-tests-might-not-be-as-reliable-as-you-thought" class="headerlink" title="Your Unit tests might not be as reliable as you thought"></a><a href="https://afterecho.uk/blog/your-unit-tests-might-not-be-as-reliable-as-you-thought.html" target="_blank" rel="external">Your Unit tests might not be as reliable as you thought</a></h2><p>作者举了个例子, 说明即便你的单元测试过了, 也不保证你的产品代码一定没问题.</p>
<p>他的例子是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SimpleDateFormat fmt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>);</div></pre></td></tr></table></figure></p>
<p>失败的原因是因为<code>XXX</code>格式是在Android 4.3以上才支持的, 它是在<code>java.text</code>包下的. 所以实际在高版本的设备还运行正常, 换个低版本的设备就崩溃了.</p>
<p>所以单元测试并不一定可靠, 因为跑单元测试的JVM和Android设备上的JVM有可能不一样.</p>
<h2 id="Airplane-Mode-Enabling-Trello-Mobile-Offline"><a href="#Airplane-Mode-Enabling-Trello-Mobile-Offline" class="headerlink" title="Airplane Mode: Enabling Trello Mobile Offline"></a><a href="http://tech.trello.com/sync-architecture/" target="_blank" rel="external">Airplane Mode: Enabling Trello Mobile Offline</a></h2><p>Trello移动移动现在有离线模式了. 作者介绍了他们的心路历程和架构变化. (比较简单和笼统的介绍).</p>
<h2 id="Self-guided-resources-to-Android-development"><a href="#Self-guided-resources-to-Android-development" class="headerlink" title="Self-guided resources to Android development"></a><a href="https://twitter.com/corey_latislaw/status/831624360175603713?s=03" target="_blank" rel="external">Self-guided resources to Android development</a></h2><p>这是一条Twitter, 作者分享了Android的学习资源. (可惜我打不开里面说的链接, 不知为何.)</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Alerter"><a href="#Alerter" class="headerlink" title="Alerter"></a><a href="https://github.com/Tapadoo/Alerter" target="_blank" rel="external">Alerter</a></h2><p>一个加在Window的Decor View上面的顶部提示栏, 类似于Snackbar和Toast一类的东东. 可定制外观, icon, 加多行字, 可添加click事件.</p>
<h2 id="sensey"><a href="#sensey" class="headerlink" title="sensey"></a><a href="https://github.com/nisrulz/sensey" target="_blank" rel="external">sensey</a></h2><p>一个好用的手势检测库.</p>
<h2 id="mkloader"><a href="#mkloader" class="headerlink" title="mkloader"></a><a href="https://github.com/nntuyen/mkloader" target="_blank" rel="external">mkloader</a></h2><p>好看并且平滑的自定义loading view. 目前支持好几种图案.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> Memory Leak </tag>
            
            <tag> Mockito </tag>
            
            <tag> Testing </tag>
            
            <tag> Unit Test </tag>
            
            <tag> Android Things </tag>
            
            <tag> God Objects </tag>
            
            <tag> Call </tag>
            
            <tag> SMS </tag>
            
            <tag> Keystore </tag>
            
            <tag> Wear 2.0 </tag>
            
            <tag> ViewPager </tag>
            
            <tag> Alert </tag>
            
            <tag> Gesture </tag>
            
            <tag> Loading </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 244]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/02/13/android-weekly-notes-issue-244/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-244"><a href="#Android-Weekly-Issue-244" class="headerlink" title="Android Weekly Issue #244"></a>Android Weekly Issue #244</h1><p>February 12th, 2017<br><a href="http://androidweekly.net/issues/issue-244" target="_blank" rel="external">Android Weekly Issue #244</a><br>本期内容包括: Android Fragments使用教程; ClassyShark使用; Firebase的Personal App Indexing功能引出的一些权限问题; 关于应用内没有提供Privacy Policy的后续处理; Kotlin中的annotation processor讨论; Pull和Push模式的讲解; 为什么Android测试这么难; Android 7 Nougat不再支持用Intent发送<code>file:// URI</code>, 应用需要改用<code>FileProvider</code>实现原有功能.<br><a id="more"></a></p>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-Fragments-Tutorial-An-Introduction"><a href="#Android-Fragments-Tutorial-An-Introduction" class="headerlink" title="Android Fragments Tutorial: An Introduction"></a><a href="https://www.raywenderlich.com/149112/android-fragments-tutorial-introduction" target="_blank" rel="external">Android Fragments Tutorial: An Introduction</a></h2><p>一篇如何使用Fragments的讲解.</p>
<h2 id="Exporting-data-from-ClassyShark"><a href="#Exporting-data-from-ClassyShark" class="headerlink" title="Exporting data from ClassyShark"></a><a href="https://medium.com/@BorisFarber/exporting-data-from-classyshark-e3cf3fe3fab8#.e2r76detr" target="_blank" rel="external">Exporting data from ClassyShark</a></h2><p>用<a href="https://github.com/google/android-classyshark" target="_blank" rel="external">ClassyShark</a>的APK dashboardA检查apk的问题(重复依赖, 过期依赖等).<br>本文介绍如何一次性导出全部的数据.</p>
<h2 id="Post-mortem-Firebase-vs-permissions"><a href="#Post-mortem-Firebase-vs-permissions" class="headerlink" title="Post-mortem : Firebase vs permissions"></a><a href="http://jeremie-martinez.com/2017/02/08/firebase-permissions/" target="_blank" rel="external">Post-mortem : Firebase vs permissions</a></h2><p>两周前Firebase发布了一个新功能: <a href="https://firebase.google.com/docs/app-indexing/android/personal-content" target="_blank" rel="external">Personal App Indexing</a>. 之后遇到了一些权限相关的问题, 本文讨论遇到的具体问题和解决方法, 然后他们发布了一个hotfix版本.</p>
<h2 id="Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails"><a href="#Did-you-get-one-of-these-Google-Play-Developer-Policy-Violation-Emails" class="headerlink" title="Did you get one of these Google Play Developer Policy Violation Emails?"></a><a href="https://medium.com/@ali.muzaffar/did-you-get-one-of-these-google-play-developer-policy-violation-emails-6c529ceb082d#.glctt861o" target="_blank" rel="external">Did you get one of these Google Play Developer Policy Violation Emails?</a></h2><p>如果你的应用使用了一些”dangerous permissions”, 你需要在应用或者Google Play上附有privacy policy, 否则你就会收到Google Play的邮件.</p>
<p>作者他的Demo app也收到了这种邮件, 所以他提供了他的解决方法.</p>
<p>他找到了这个<a href="https://privacypolicytemplate.net/" target="_blank" rel="external">网站</a>, 这是他最后写成的<a href="https://gist.github.com/alphamu/c42f6c3fce530ca5e804e672fed70d78" target="_blank" rel="external">Gist</a>. 利用<a href="https://rawgit.com/" target="_blank" rel="external">RawGit</a>可以将github上的文件url转成用HTML显示的url. 之后在app中设置一个链接, 点击打开这个url就可以了.</p>
<h2 id="Pushing-the-limits-of-Kotlin-annotation-processing"><a href="#Pushing-the-limits-of-Kotlin-annotation-processing" class="headerlink" title="Pushing the limits of Kotlin annotation processing"></a><a href="https://medium.com/@workingkills/pushing-the-limits-of-kotlin-annotation-processing-8611027b6711#.7crkk5m68" target="_blank" rel="external">Pushing the limits of Kotlin annotation processing</a></h2><p>关于Kotlin的annotation processor支持, 是一个很复杂的问题, 作者讨论了关于这个问题的历史进展和当前的局限性.</p>
<h2 id="Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming"><a href="#Pull-vs-Push-amp-Imperative-vs-Reactive-Reactive-Programming" class="headerlink" title="Pull vs Push &amp; Imperative vs Reactive - Reactive Programming"></a><a href="http://www.uwanttolearn.com/android/pull-vs-push-imperative-vs-reactive-reactive-programming-android-rxjava2-hell-part2/" target="_blank" rel="external">Pull vs Push &amp; Imperative vs Reactive - Reactive Programming</a></h2><p>作者用浅显的代码例子解释了Pull和Push模式的区别, 一个是自己不停地查询读取, 另一个是等改变发生的时候收到通知. </p>
<h2 id="Why-Android-Testing-is-so-Hard-Historical-Edition"><a href="#Why-Android-Testing-is-so-Hard-Historical-Edition" class="headerlink" title="Why Android Testing is so Hard: Historical Edition"></a><a href="https://www.philosophicalhacker.com/post/why-android-testing-is-so-hard-historical-edition/" target="_blank" rel="external">Why Android Testing is so Hard: Historical Edition</a></h2><p>为什么Android项目这么难测试呢? 作者认为主要有三方面的历史原因: </p>
<ul>
<li>Performance方面的考虑. </li>
<li>对Android组件的误解.</li>
<li>Android和Unit Testing出现的时机.</li>
</ul>
<h2 id="Sharing-files-though-Intents-are-you-ready-for-Nougat"><a href="#Sharing-files-though-Intents-are-you-ready-for-Nougat" class="headerlink" title="Sharing files though Intents: are you ready for Nougat?"></a><a href="https://medium.com/@quiro91/sharing-files-though-intents-are-you-ready-for-nougat-70f7e9294a0b#.h3f06hxg7A" target="_blank" rel="external">Sharing files though Intents: are you ready for Nougat?</a></h2><p>Android 7 Nougat引入了一些文件系统的权限变化, 来增强安全性.</p>
<p>如果你已经把<code>targetSdkVersion</code>升到了24+, 并且你用Intent发送一个<code>file:// URI</code>, 你将会得到一个<code>FileUriExposedException</code>.</p>
<p>解决办法是使用<code>FileProvider</code>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="SlidingSquaresLoader"><a href="#SlidingSquaresLoader" class="headerlink" title="SlidingSquaresLoader"></a><a href="https://github.com/biodunalfet/SlidingSquaresLoader" target="_blank" rel="external">SlidingSquaresLoader</a></h2><p>一个有趣的动画方块的loading图案.</p>
<h2 id="ason"><a href="#ason" class="headerlink" title="ason"></a><a href="https://github.com/afollestad/ason" target="_blank" rel="external">ason</a></h2><p>一个JSON库, 简化了序列化, 更易使用.</p>
<h2 id="Intro-To-RxJava"><a href="#Intro-To-RxJava" class="headerlink" title="Intro-To-RxJava"></a><a href="https://github.com/PareshMayani/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a></h2><p>上一期有一篇文章提过的RxJava练习项目.</p>
<h2 id="chuck"><a href="#chuck" class="headerlink" title="chuck"></a><a href="https://github.com/jgilfelt/chuck" target="_blank" rel="external">chuck</a></h2><p>An in-app HTTP inspector for Android OkHttp clients.<br>截取请求和响应, 点击通知可以查看UI显示.</p>
<h2 id="android-parcelable-intellij-plugin-kotlin"><a href="#android-parcelable-intellij-plugin-kotlin" class="headerlink" title="android-parcelable-intellij-plugin-kotlin"></a><a href="https://github.com/nekocode/android-parcelable-intellij-plugin-kotlin" target="_blank" rel="external">android-parcelable-intellij-plugin-kotlin</a></h2><p>为kotlin的类生成Parcelable代码的插件.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Firebase </tag>
            
            <tag> Nougat </tag>
            
            <tag> Android 7 </tag>
            
            <tag> Testing </tag>
            
            <tag> FileProvider </tag>
            
            <tag> ClassyShark </tag>
            
            <tag> Permission </tag>
            
            <tag> Privacy Policy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 243]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/02/07/android-weekly-notes-issue-243/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-243"><a href="#Android-Weekly-Issue-243" class="headerlink" title="Android Weekly Issue #243"></a>Android Weekly Issue #243</h1><p>February 5th, 2017<br><a href="http://androidweekly.net/issues/issue-243" target="_blank" rel="external">Android Weekly Issue #243</a><br>本期内容包括: ConstraintLayout的动画; 用Kotlin写测试; RxJava的练习项目; 一个库: Coordinators的介绍; 一个自动报告Google Play反馈的工具; Service的测试; 动画工具Lottie的介绍; Mutability的讨论;<br>Nougat的多语言支持和相关的一个有趣的case; 使用StrictMode来发现问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Constraint-Layout-Animations"><a href="#Constraint-Layout-Animations" class="headerlink" title="Constraint Layout Animations"></a><a href="http://www.uwanttolearn.com/android/constraint-layout-animations-dynamic-constraints-ui-java-hell/" target="_blank" rel="external">Constraint Layout Animations</a></h2><p>作者举例说明了如何在Java代码中动态地改变约束条件, 从而使<code>ConstraintLayout</code>中的View动起来.</p>
<h2 id="Android-Testing-with-Kotlin"><a href="#Android-Testing-with-Kotlin" class="headerlink" title="Android Testing with Kotlin"></a><a href="http://fernandocejas.com/2017/02/03/android-testing-with-kotlin/" target="_blank" rel="external">Android Testing with Kotlin</a></h2><p>如果你想逐渐地迁移代码到Kotlin, 你可以从测试开始, 这样你也不用更改产品环境的代码, 就先熟悉了Kotlin.</p>
<p>本篇文章详细讲了如何setup, 然后写各种测试:</p>
<h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>需要JUnit, <a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="external">mockito-kotlin</a>和<a href="https://github.com/MarkusAmshove/Kluent" target="_blank" rel="external">Kluent</a>.</p>
<p>对于在<code>setUp()</code>方法中初始化的变量, 需要标记为<code>lateinit</code>.</p>
<h3 id="Robolectric测试"><a href="#Robolectric测试" class="headerlink" title="Robolectric测试"></a>Robolectric测试</h3><p>作者封装了一个基类, 把所有Mockito相关的东东包装在里面. 这样在Mockito升级的时候不用更改每一个测试文件.</p>
<h3 id="Espresso测试"><a href="#Espresso测试" class="headerlink" title="Espresso测试"></a>Espresso测试</h3><p>同样, 这里作者也创建了几个基类, 将所有Espresso相关的东东包装起来.</p>
<h2 id="Practical-challenges-for-RxJava-learners"><a href="#Practical-challenges-for-RxJava-learners" class="headerlink" title="Practical challenges for RxJava learners"></a><a href="https://medium.com/@sergii/practical-challenges-for-rxjava-learners-1821c454de9#.9icb22hrr" target="_blank" rel="external">Practical challenges for RxJava learners</a></h2><p>作者建议通过实践来检验和学习RxJava技能, 之前他用过这个Repo: <a href="https://github.com/Froussios/Intro-To-RxJava" target="_blank" rel="external">Intro-To-RxJava</a>, 现在他又新推出了这个<a href="https://github.com/sergiiz/RxBasicsKata" target="_blank" rel="external">Repo</a>, 针对RxJava2的.</p>
<h2 id="Coordinators-solving-a-problem-you-didn’t-even-know-you-had"><a href="#Coordinators-solving-a-problem-you-didn’t-even-know-you-had" class="headerlink" title="Coordinators: solving a problem you didn’t even know you had"></a><a href="https://hackernoon.com/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf#.mcx15cssl" target="_blank" rel="external">Coordinators: solving a problem you didn’t even know you had</a></h2><p>Square发布了一个库叫<a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a>, 这个库是用来分离View中的一些控制逻辑.</p>
<h2 id="Review-Reporter-Part-1"><a href="#Review-Reporter-Part-1" class="headerlink" title="Review-Reporter: Part 1 "></a><a href="https://medium.com/azimolabs/review-reporter-part-1-connecting-to-google-play-8abd37edc49f#.a0s5gx66j" target="_blank" rel="external">Review-Reporter: Part 1 </a></h2><p>作者他们做了一个小项目: <a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a>, 可以自动把Google Play上新的用户回复发到slack, firebase, Jira上. 本篇文章讲了他们是怎么做的.</p>
<h2 id="How-to-test-a-Service"><a href="#How-to-test-a-Service" class="headerlink" title="How to test a Service"></a><a href="https://medium.com/@josiassena/android-how-to-unit-test-a-service-67e5340544a5#.qg3751nxg" target="_blank" rel="external">How to test a Service</a></h2><p>Android官方文档介绍了如何测试Service: <a href="https://developer.android.com/training/testing/integration-testing/service-testing.html" target="_blank" rel="external">Testing your Service</a>. 本文作者介绍他是如何做的.</p>
<h2 id="Introducing-Lottie"><a href="#Introducing-Lottie" class="headerlink" title="Introducing Lottie"></a><a href="https://medium.com/airbnb-engineering/introducing-lottie-4ff4a0afac0e#.e7wojthmp" target="_blank" rel="external">Introducing Lottie</a></h2><p><a href="http://airbnb.design/lottie/" target="_blank" rel="external">Lottie</a>是一个iOS, Android和React Native的库, 可以实时渲染After Effects的动画, 让native的应用像使用静态文件一样简单地使用复杂的动画.</p>
<h2 id="Learning-to-use-and-abuse-Mutability"><a href="#Learning-to-use-and-abuse-Mutability" class="headerlink" title="Learning to use and abuse Mutability"></a><a href="https://medium.com/google-developer-experts/learning-to-use-and-abuse-mutability-b4c71576299#.diungnuw6" target="_blank" rel="external">Learning to use and abuse Mutability</a></h2><blockquote>
<p>An immutable class is a class whose state cannot be changed once it has been created.</p>
</blockquote>
<p>这篇文章分享了作者关于Java中的mutability &amp; immutability的一些想法.</p>
<h2 id="A-Curious-Case-of-Multiple-Locales"><a href="#A-Curious-Case-of-Multiple-Locales" class="headerlink" title="A Curious Case of Multiple Locales"></a><a href="https://blog.egorand.me/a-curious-case-of-multiple-locales/" target="_blank" rel="external">A Curious Case of Multiple Locales</a></h2><p>Android N的一个新feature就是可以在设置中选择多种语言.</p>
<p>比如一个用户, 她会说意大利语和德语, 她使用的是一个低于Android 7的手机, 她把手机语言设置为意大利语.</p>
<p>有一个app, 支持两种语言, 默认是英语, 然后还支持德语.</p>
<p>但是这个应用在这个用户的手机上打开时, 发现自己并不支持意大利语, 于是会显示英语(默认)而不是德语, 因为应用又不知道这个用户还会德语.</p>
<p>后来用户把手机升级了, 用了Android 7的系统, 她发现可以设置支持多种语言, 于是, 于是她设置了两种语言, 意大利语和德语. 在新手机上装之前那个app的时候发现现在显示的是德语.</p>
<p>因为应用现在知道了用户还会讲德语.</p>
<p>现在, 假设我们需要进行向下兼容以前的旧版本设备, 我们加入了<code>appcompat-v7</code>, 用户更新后, 英语又出现了. </p>
<p>这是因为<code>appcompat-v7</code>中含有一些意大利语的资源, 因为所有的资源在build的时候都会merge到一起, 所以现在app也包含了这些资源. 系统认为现在app能够支持用户的第一语言了, 然后就查找对应的资源, 当然没查找到, 于是就使用了默认资源, 也就是英语.</p>
<p>我们有什么办法可以解决这个问题呢? 答案是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;  </div><div class="line">  ...</div><div class="line"></div><div class="line">  resConfigs &quot;en&quot;, &quot;de&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就告诉了Gradle我们只支持这两种语言, 所有其他的资源都不会被打包进来.</p>
<p>验证的方法是使用Android Studio的<code>Analyze APK</code>来查看string有多少种configurations.</p>
<h2 id="Use-StrictMode-To-Find-Things-You-Did-By-Accident"><a href="#Use-StrictMode-To-Find-Things-You-Did-By-Accident" class="headerlink" title="Use StrictMode To Find Things You Did By Accident"></a><a href="https://blog.mindorks.com/use-strictmode-to-find-things-you-did-by-accident-in-android-development-4cf0e7c8d997#.l5tbilx16" target="_blank" rel="external">Use StrictMode To Find Things You Did By Accident</a></h2><p><code>StrictMode</code>是一个开发工具, 用于发现一些问题, 好让你来修复它们. </p>
<p>一个常用的情景是用来捕捉主线程的IO操作, 避免ANR弹框.</p>
<p>如何使用呢? 很简单, 只需要在应用启动时初始化一下, 可以是你的Application, Activity或其他组件的<code>onCreate()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</div><div class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</div><div class="line">                .detectDiskReads()</div><div class="line">                .detectDiskWrites()</div><div class="line">                .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></div><div class="line">                .penaltyLog()</div><div class="line">                .build());</div><div class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</div><div class="line">                .detectLeakedSqlLiteObjects()</div><div class="line">                .detectLeakedClosableObjects()</div><div class="line">                .penaltyLog()</div><div class="line">                .penaltyDeath()</div><div class="line">                .build());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以决定检测到问题时要发生什么, 比如:</p>
<ul>
<li><code>penaltyDeath()</code>: 整个进程崩溃.</li>
<li><code>penaltyDialog()</code>: 显示Dialog.</li>
<li><code>penaltyLog()</code>: 显示log.</li>
</ul>
<p>更多的处理见: <a href="https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html" target="_blank" rel="external">StrictMode.ThreadPolicy.Builder</a>.</p>
<p>StrictMode文档: <a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">StrictMode</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-material-stepper"><a href="#android-material-stepper" class="headerlink" title="android-material-stepper"></a><a href="https://github.com/stepstone-tech/android-material-stepper" target="_blank" rel="external">android-material-stepper</a></h2><p>一个Material steppers的库, 类似于配合ViewPager使用的indicators.</p>
<h2 id="AOSP-Support-Library-Contribution-Guide"><a href="#AOSP-Support-Library-Contribution-Guide" class="headerlink" title="AOSP Support Library Contribution Guide"></a><a href="https://android.googlesource.com/platform/frameworks/support/" target="_blank" rel="external">AOSP Support Library Contribution Guide</a></h2><p>Google开放了对support library的bug修改和文档更新.</p>
<h2 id="sqlite-android"><a href="#sqlite-android" class="headerlink" title="sqlite-android"></a><a href="https://github.com/requery/sqlite-android" target="_blank" rel="external">sqlite-android</a></h2><p>一个Android的SQLite库, 包含了最新的SQLite版本.</p>
<h2 id="Review-Reporter"><a href="#Review-Reporter" class="headerlink" title="Review-Reporter"></a><a href="https://github.com/AzimoLabs/Review-Reporter" target="_blank" rel="external">Review-Reporter</a></h2><p>Google Play反馈的自动提示, 支持提示到Slack和Jira.</p>
<h2 id="SimpleRecyclerView"><a href="#SimpleRecyclerView" class="headerlink" title="SimpleRecyclerView"></a><a href="https://github.com/jaychang0917/SimpleRecyclerView" target="_blank" rel="external">SimpleRecyclerView</a></h2><p>更简单好用的RecyclerView.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> Animation </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> Nougat </tag>
            
            <tag> Android 7 </tag>
            
            <tag> Testing </tag>
            
            <tag> Service </tag>
            
            <tag> Lottie </tag>
            
            <tag> Mutability </tag>
            
            <tag> Locales </tag>
            
            <tag> StrictMode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Say Hello to ConstraintLayout]]></title>
      <url>http://mengdd.github.io/Android/2017/02/06/hello-constraint-layout/</url>
      <content type="html"><![CDATA[<h2 id="ConstraintLayout介绍"><a href="#ConstraintLayout介绍" class="headerlink" title="ConstraintLayout介绍"></a>ConstraintLayout介绍</h2><p><code>ConstraintLayout</code>让你可以在很平的view结构(没有多层布局嵌套)中构建一个复杂的布局结构. 有点像<code>RelativeLayout</code>, 所有的view都是根据它和兄弟View和父layout的关系布局的, 但是它比<code>RelativeLayout</code>要更加灵活, 在Layout Editor中也更加好用.</p>
<a id="more"></a>
<p>在Layout Editor中你可以直接靠拖拽来构建<code>ConstraintLayout</code>.</p>
<p>为了在<code>ConstraintLayout</code>中定义一个view的位置, 你必须给view加上两条或多条约束(constraints). 每一条约束代表了一种和其他View(或parent, 或不可见的guideline)之间的联系或者对齐关系.</p>
<p>每一条约束都规定了这个view沿着水平或竖直轴的一个位置, 所以每个View在每个轴上都必须至少有一条约束(但是通常需要更多).</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>首先确认下载support库, 在<code>Tools &gt; Android &gt; SDK Manager</code>的<code>SDK Tools</code>tab下:<br>展开<code>Support Repository</code>, check <code>ConstraintLayout for Android</code>和<code>Solver for ConstraintLayout</code>.<br>Check <code>Show Package Details</code>, 显示版本信息.</p>
<p>比如当前我最新的版本信息是1.0.0-beta4, 我在module的build.gradle中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后点击Sync即可.</p>
<h2 id="转换已有布局"><a href="#转换已有布局" class="headerlink" title="转换已有布局"></a>转换已有布局</h2><p>我们可以新建布局, 然后让它的根节点是<code>android.support.constraint.ConstraintLayout</code>.</p>
<p>除此之外, 我们还可以直接转换已有布局.<br>打开Layout, 切换到<code>Design</code>tab, 然后在<code>Component Tree</code>窗口, 右击布局然后选择最底部的<code>Convert XXXLayout(这里是你布局节点的类型) to ConstraintLayout</code>.</p>
<h2 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h2><p>在Design模式下, 从Palette窗口中拖一个View到editor中去. 当你把一个View加入到ConstraintLayout中之后, 它会展示出一个bounding box, 四角的四个小方块用来拖拽调节大小, 每一个边上都有一个小圆点用来建立约束.<br>这些小方块和小圆点都被称为<code>handles</code>.</p>
<p>点击View, 然后点击并拖住一个约束handle, 把它拖拽到一个可用的anchor point(另一个View的边缘, layout的边缘, 或者一个guideline).当你松手的时候, 约束就生效了. (有一个默认的<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-margins" target="_blank" rel="external">margin</a>)</p>
<p>有几个规则:</p>
<ul>
<li>每个View都至少有两条约束: 一个水平的一个竖直的.</li>
<li>你只能在共享平面的handle和anchor point之间建立约束. 比如一个View的竖直平面只能和另一个竖直平面建立约束, baseline也只能和其他baseline建立约束.</li>
<li>每一个handle只能被用来建立一个约束, 但是你可以对一个anchor point建立(来自多个View的)多个约束.</li>
</ul>
<p>要删掉一个约束, 只需要选择这个view, 点击那个对应的handle.</p>
<p>如果你给同一个View加了两个相反的约束, 约束的线条就会变成弹簧状, 来显示两个相反方向的约束.  当View内容的尺寸固定或者是wrap的时候, 在这种情况下View就会在两个约束下居中显示, 如果你想让它展开, 那么就应该修改它的尺寸为<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-view-size" target="_blank" rel="external">Any Size</a>; 如果你想要保持当前的尺寸, 你可以<a href="https://developer.android.com/training/constraint-layout/index.html#adjust-the-constraint-bias" target="_blank" rel="external">调节约束的权重</a>.</p>
<p>通常情况下可以加的有这几种约束:</p>
<ul>
<li>Parent constraint: View的边和Parent的边的关系.</li>
<li>Position constraint: View之间水平和竖直的位置关系, 拖动可改变相对的margin距离.</li>
<li>Alignment constraint: View边之间的对齐关系, 对齐后可以调节偏移量.</li>
<li>Baseline alignment constraint: 对齐View的text baseline, 要创建baseline约束, 首先选中View, 然后把鼠标放在baseline上方两秒钟, 等它变白就可以拖到另一个baseline去建立约束了.</li>
<li>Constrain to a guideline: 可以创建竖直或水平的guideline, 然后往上绑定约束, guideline对于用户来说是不可见的. 放置guideline的时候可以根据相对于layout边缘dp单位的距离, 也可以根据百分比.<br>Toolbar上有Guideline的按钮, 点击可选择水平或竖直.<br>点击Guideline尾部的小圆圈可以切换它到底是根据距离还是百分比放置的, 然后拖动它放到一个想要的位置.</li>
</ul>
<h2 id="使用Autoconnect和Infer-Constraints"><a href="#使用Autoconnect和Infer-Constraints" class="headerlink" title="使用Autoconnect和Infer Constraints"></a>使用Autoconnect和Infer Constraints</h2><p>当打开<code>Autoconnect</code>模式之后, 每一个<strong>新加的View</strong>都会自动创建约束. Autoconnect模式默认是关闭的.</p>
<p>点击<code>Infer Constraints</code>会给layout中当前所有的View创建约束, 这是一个一次性的action. 它会选择建立最有效的约束, 所以它可能会建立离得很远的两个view之间的约束. 不像Autoconnect模式开启下, 只给新加的View建立约束, 并且只选择最近的元素.</p>
<h2 id="调整View大小"><a href="#调整View大小" class="headerlink" title="调整View大小"></a>调整View大小</h2><p>可以通过拖拽View四个角的handles来改变View的大小, 但是这样生成的是hard-coded的尺寸, 对于适配来讲这样是不好的.</p>
<p>你可以点击View然后在Properties窗口编辑尺寸.<br><img src="/images/constraint-layout-properties-window.png" alt="ConstraintLayout Properties Window"></p>
<p>有三种尺寸模式:</p>
<ul>
<li>Wrap Content:  用<code>&gt;&gt;&gt;</code>图形表示.</li>
<li>Any Size: 用弹簧图形表示. 说明View会一直展开到满足所有约束, 实际的值是0dp. 可以把它想象成”match constraints”. 如果此时只有单边的约束, 那么它只展开到能放下自己的内容为止. </li>
<li>Fixed: 用图形<code>|-|</code>表示, 固定尺寸.</li>
</ul>
<p>可以通过点击图形符号来切换这些模式.</p>
<p>注意: 在<code>ConstraintLayout</code>中的View中不应该使用<code>match_parent</code>, 而是用”Any Size”(0dp).</p>
<h2 id="调整约束偏差"><a href="#调整约束偏差" class="headerlink" title="调整约束偏差"></a>调整约束偏差</h2><p>当你给一个View的对立两边都添加了约束, 而View的尺寸是fixed或者wrap_content, 那么默认情况下View就会居中显示在两个anchor point之间(bias=50%).<br>你可以通过拖拽View或者在Properties窗口中拖拽bias slider来改变它的偏移权重.</p>
<h2 id="调节View边距"><a href="#调节View边距" class="headerlink" title="调节View边距"></a>调节View边距</h2><p>可以在toolbar上点击默认边距(8)来修改.</p>
<p>注意这个修改只对修改后新添加的View生效.</p>
<p>每一个View的边距都可以通过Properties窗口修改: 点击约束线条上的margin数字.</p>
<p>注意提供的值都是8的倍数, 以确保你遵循了Material Design的建议.</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="https://developer.android.com/training/constraint-layout/index.html" target="_blank" rel="external">Build a Responsive UI with ConstraintLayout</a></li>
<li>Demo: <a href="https://github.com/mengdd/HelloConstraintLayout" target="_blank" rel="external">HelloConstraintLayout</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> ConstraintLayout </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 242]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/02/03/android-weekly-notes-issue-242/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-242"><a href="#Android-Weekly-Issue-242" class="headerlink" title="Android Weekly Issue #242"></a>Android Weekly Issue #242</h1><p>January 29th, 2017<br><a href="http://androidweekly.net/issues/issue-242" target="_blank" rel="external">Android Weekly Issue #242</a><br>本期内容包括: Android中常用的设计模式; 基于NoSQL的移动对象数据库–ObjectBox; MVC, MVP和MVVM模式的讨论; 一个Google Actions的Java SDK; 一个带黏性动画的FAB的实现; Kotlin 1.1的新功能; Firebase的实时数据库讨论; Model-View-Intent模式应用的实现; 关于实现gradient时透明颜色的使用.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Common-Design-Patterns-for-Android"><a href="#Common-Design-Patterns-for-Android" class="headerlink" title="Common Design Patterns for Android"></a><a href="https://www.raywenderlich.com/109843/common-design-patterns-for-android" target="_blank" rel="external">Common Design Patterns for Android</a></h2><h3 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h3><ul>
<li>Builder</li>
<li>依赖注入: 举例: Dagger </li>
<li>Singleton</li>
</ul>
<h3 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h3><ul>
<li>Adapter</li>
<li>Facade: 举例: Retrofit</li>
</ul>
<h3 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h3><ul>
<li>Command: 举例: EventBus</li>
<li>Observer: 举例: RxAndroid</li>
<li>Model View Controller</li>
<li>Model View ViewModel</li>
</ul>
<h2 id="ObjectBox-The-new-Mobile-Database"><a href="#ObjectBox-The-new-Mobile-Database" class="headerlink" title="ObjectBox - The new Mobile Database"></a><a href="http://greenrobot.org/announcement/introducing-objectbox-beta/" target="_blank" rel="external">ObjectBox - The new Mobile Database</a></h2><p><a href="http://greenrobot.org/objectbox/" target="_blank" rel="external">ObjectBox</a>是greenrobot发布的一个新的mobile对象数据库, 主要关注于性能, 据说superfast.</p>
<p>在ObjectBox中, 主要是把NoSQL技术迁移到mobile端使用. 之前他们创建的greenDAO, 据说是最快的Object/Relational Mapper (ORM) for Android and SQLite.</p>
<p>ObjectBox的5大特性:</p>
<ul>
<li>Superfast.</li>
<li>Object API.</li>
<li>Instant unit testing.</li>
<li>Simple threading.</li>
<li>No manual schema migrations.</li>
</ul>
<p><a href="http://greenrobot.org/objectbox/documentation/" target="_blank" rel="external">文档</a><br><a href="https://github.com/greenrobot/ObjectBoxExamples" target="_blank" rel="external">Demo</a></p>
<h2 id="MVC-vs-MVP-vs-MVVM-on-Android"><a href="#MVC-vs-MVP-vs-MVVM-on-Android" class="headerlink" title="MVC vs. MVP vs. MVVM on Android"></a><a href="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/" target="_blank" rel="external">MVC vs. MVP vs. MVVM on Android</a></h2><p>MVC, MVP, MVVM模式的介绍.</p>
<h2 id="Building-Google-Actions-with-Java"><a href="#Building-Google-Actions-with-Java" class="headerlink" title="Building Google Actions with Java"></a><a href="https://medium.com/@froger_mcs/building-google-actions-with-java-696cffedbd01#.d6uuck1ho" target="_blank" rel="external">Building Google Actions with Java</a></h2><p>非官方的<a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google Actions Java SDK</a>, 本文为开发者介绍其如何使用.</p>
<h2 id="Android-Gooey-FAB-is-EASY"><a href="#Android-Gooey-FAB-is-EASY" class="headerlink" title="Android Gooey FAB is EASY"></a><a href="http://myhexaville.com/2017/01/18/android-gooey-fab-easy/" target="_blank" rel="external">Android Gooey FAB is EASY</a></h2><p>实现一个胶黏的FAB.<br>首先作者展示了效果, 点击FAB, 从中逐渐分离中一个新的小按钮. 作者讨论了这种效果可能的实现方法:</p>
<ul>
<li>用bitmap的mesh transformation, 这是能高度自定义的.</li>
<li>创建自定义View, 自己绘制Path.</li>
<li>最简单的办法: 用Animated Vector Drawable, 即本文所介绍的方法.</li>
</ul>
<p>源码在这里: <a href="https://github.com/IhorKlimov/Android-Animations" target="_blank" rel="external">Android-Animations</a></p>
<h2 id="What-Comes-in-Kotlin-1-1-for-Android-Developers"><a href="#What-Comes-in-Kotlin-1-1-for-Android-Developers" class="headerlink" title="What Comes in Kotlin 1.1 for Android Developers?"></a><a href="https://blog.elpassion.com/what-comes-in-kotlin-1-1-for-android-developers-831d559f780f#.wlmujxwi3" target="_blank" rel="external">What Comes in Kotlin 1.1 for Android Developers?</a></h2><p>Kotlin 1.1的新features.</p>
<ul>
<li>Coroutines. 改善Kotlin中的异步编程.</li>
<li>Type Aliases. 可以为类型起别名.</li>
<li>Inlining Property Accessors.</li>
<li>Less Restrictive Inheritance. sealed类的子类不用再放在同一个类中; 非final的类现在也可以继承data类了.</li>
<li>Destructuring and Underscores.</li>
<li>Methods Count. 作者对比了一个sample程序, 用kotlin的不同版本, 发现用最新版kotlin确实会增加一些方法数, 但它仍然算是一个很轻量的库.</li>
</ul>
<h2 id="Understanding-the-Power-of-Firebase-Security-Rules"><a href="#Understanding-the-Power-of-Firebase-Security-Rules" class="headerlink" title="Understanding the Power of Firebase Security Rules"></a><a href="https://medium.com/@dftaiwo/understanding-the-power-of-firebase-security-rules-part-1-f46aae773a24#.cw34j1v2z" target="_blank" rel="external">Understanding the Power of Firebase Security Rules</a></h2><p>作者要写关于Firebase的一系列文章: 第一和第二篇主要介绍实时数据库的规则, 第三篇介绍Storage的规则.</p>
<p>关于实时数据库规则的主要内容包括:</p>
<ul>
<li>识别你的用户.</li>
<li>控制数据访问权限.</li>
<li>验证创建, 更新和删除操作.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-3"><a href="#Reactive-apps-with-Model-View-Intent-Part-3" class="headerlink" title="Reactive apps with Model-View-Intent - Part 3"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-3" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 3</a></h2><p>上一篇中介绍了用Model-View-Intent模式来构建一个单相数据流的简单屏. 这篇文章接着讲如何用MVI和state reducer来构建一个复杂屏.</p>
<p>(感觉太复杂了我没仔细看).</p>
<h2 id="Android-Dev-Tip-3-A-gotcha-with-color-transparent"><a href="#Android-Dev-Tip-3-A-gotcha-with-color-transparent" class="headerlink" title="Android Dev Tip #3: A gotcha with color/transparent"></a><a href="https://android.jlelse.eu/android-dev-tip-3-99da754151ad#.rarx8jafm" target="_blank" rel="external">Android Dev Tip #3: A gotcha with color/transparent</a></h2><p>如果你要在xml中用gradient写一个渐变色, 对于透明色<code>@android:color/transparent.</code>的使用一定要注意.</p>
<p>透明色<code>@android:color/transparent.</code>的色值是<code>#00000000</code>, 所以它实际上代表的是一个透明的黑色.</p>
<p>在gradient进行插值的时候, 会对ARGB每一个通道的色值都分别进行插值然后叠加.</p>
<p>所以如果你想要保持颜色不变, 只改变透明度, 也即Alpha通道的值, 你就应该把透明色中RGB颜色设置为和原来的颜色一样. </p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PreviewSeekBar"><a href="#PreviewSeekBar" class="headerlink" title="PreviewSeekBar"></a><a href="https://github.com/rubensousa/PreviewSeekBar" target="_blank" rel="external">PreviewSeekBar</a></h2><p>一个带Preview的SeekBar.</p>
<h2 id="AndroidTestingBox"><a href="#AndroidTestingBox" class="headerlink" title="AndroidTestingBox"></a><a href="https://roroche.github.io/AndroidTestingBox/" target="_blank" rel="external">AndroidTestingBox</a></h2><p>一个Android项目, 用于实验各种测试工具.</p>
<h2 id="FunctionalRx2"><a href="#FunctionalRx2" class="headerlink" title="FunctionalRx2"></a><a href="https://github.com/pakoito/FunctionalRx2" target="_blank" rel="external">FunctionalRx2</a></h2><p>a collection of constructs to simplify a functional programming approach to Java and Android.</p>
<h2 id="gradle-completion"><a href="#gradle-completion" class="headerlink" title="gradle-completion"></a><a href="https://github.com/eriwen/gradle-completion" target="_blank" rel="external">gradle-completion</a></h2><p>gradle的tab补全, for bash and zsh.</p>
<h2 id="ObjectBox"><a href="#ObjectBox" class="headerlink" title="ObjectBox"></a><a href="https://github.com/greenrobot/ObjectBox" target="_blank" rel="external">ObjectBox</a></h2><p>超快的移动平台对象数据库.</p>
<h2 id="superlightstack"><a href="#superlightstack" class="headerlink" title="superlightstack"></a><a href="https://github.com/nextdimension/superlightstack" target="_blank" rel="external">superlightstack</a></h2><p>一个轻量级的库, 用于创建View的stack, 并处理转换和状态维持.</p>
<h2 id="PicassoFaceDetectionTransformation"><a href="#PicassoFaceDetectionTransformation" class="headerlink" title="PicassoFaceDetectionTransformation"></a><a href="https://github.com/aryarohit07/PicassoFaceDetectionTransformation" target="_blank" rel="external">PicassoFaceDetectionTransformation</a></h2><p>一个配合picasso使用的图像转换库, 可以根据人脸检测自动确定范围而切图.</p>
<p>(Readme中附有配合Glide和Fresco使用的版本.)</p>
<h2 id="cwac-netsecurity"><a href="#cwac-netsecurity" class="headerlink" title="cwac-netsecurity"></a><a href="https://github.com/commonsguy/cwac-netsecurity" target="_blank" rel="external">cwac-netsecurity</a></h2><p>This library contains a backport of the Android 7.0 network security configuration subsystem.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Firebase </tag>
            
            <tag> MVP </tag>
            
            <tag> Animation </tag>
            
            <tag> MVVM </tag>
            
            <tag> MVC </tag>
            
            <tag> Color </tag>
            
            <tag> Design Patterns </tag>
            
            <tag> ObjectBox </tag>
            
            <tag> Google Actions </tag>
            
            <tag> FAB </tag>
            
            <tag> Model-View-Intent </tag>
            
            <tag> Gradient </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 241]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/01/25/android-weekly-notes-issue-241/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-241"><a href="#Android-Weekly-Issue-241" class="headerlink" title="Android Weekly Issue #241"></a>Android Weekly Issue #241</h1><p>January 22nd, 2017<br><a href="http://androidweekly.net/issues/issue-241" target="_blank" rel="external">Android Weekly Issue #241</a><br>本期内容包括: 经典导航模式Master/Detail的设计和实现; APK的大小讨论和增量下载大小的预估工具; Model-View-Intent模式的讨论和实现; 分多个modules对build时间的影响; 测试中能够利用的一些Android特有的接缝设计(manifest, build config, resource).</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Case-Study-Master-Detail-Pattern-Revisited"><a href="#Case-Study-Master-Detail-Pattern-Revisited" class="headerlink" title="Case Study. Master/Detail Pattern Revisited"></a><a href="http://goneremote.io/master-detail-pattern/" target="_blank" rel="external">Case Study. Master/Detail Pattern Revisited</a></h2><p>Master/Detail是一种经典的导航流, master屏包含一个list, detail显示某一项的详细信息. <a href="https://developer.android.com/training/implementing-navigation/descendant.html" target="_blank" rel="external">Android Doc</a>.</p>
<p>作者讲了他适配多种屏幕(包括平板)的设计, 以及简单的实现.</p>
<h2 id="Tracking-app-update-sizes"><a href="#Tracking-app-update-sizes" class="headerlink" title="Tracking app update sizes"></a><a href="https://medium.com/google-developers/tracking-app-update-sizes-1a1f57634f7b#.v2ecs8u4t" target="_blank" rel="external">Tracking app update sizes</a></h2><p>以前作者有一系列的<a href="https://medium.com/google-developers/smallerapk-part-1-anatomy-of-an-apk-da83c25e7003#.dv2tfqdyq" target="_blank" rel="external">文章</a>讲过apk的组成以及如何减少apk的大小.</p>
<p>事实上app的大小可以分下面四种:</p>
<ul>
<li>提交到Google Play的APK文件大小.</li>
<li>初始的下载大小.</li>
<li>在设备上的安装大小.</li>
<li>更新下载大小.</li>
</ul>
<p>之前的一些文章可能都在讨论如何减少初始的大小, 但是大多数情况用户可能只安装你的应用一次, 之后就只是从Play Store更新, 所以应用的更新大小也是很重要的.</p>
<p>事实上Android Studio(2.2+)改善了打包apk的机制, (<a href="https://android-developers.googleblog.com/2016/11/understanding-apk-packaging-in-android-studio-2-2.html" target="_blank" rel="external">apk packaging</a>), 使得每一个build都尽可能地相似, 这样Play Store就能计算出一个较小的delta更新. 另外, Play Store也引入了新的算法, 比如最近的<a href="https://android-developers.googleblog.com/2016/12/saving-data-reducing-the-size-of-app-updates-by-65-percent.html" target="_blank" rel="external">File-By-File patching</a>, 同样也有效减小了更新的大小.</p>
<p>所以我们要注意的就是不要介入和干扰当前Android Studio和Play Store的这些优化, 比如不要用自定义的ZIP加密设置来自己压缩APK. 也不要用Zopfli来再次压缩APK.</p>
<p>Play Store上会显示应用的下载大小, 如果用户已经安装了, 则显示的是更新大小.</p>
<p>对于开发者来说, 如果能在发布前知道这些信息就更好了, 所以作者他们开源了这个库: <a href="https://github.com/googlesamples/apk-patch-size-estimator" target="_blank" rel="external">apk-patch-size-estimator</a></p>
<p>这是一个命令行的工具, 可以集成到CI里, 也可以手动比较两个apk文件.</p>
<p>这个工具实现了当前Play Store的算法, 可以帮你估计出初始的apk下载大小和更新下载大小.</p>
<p>(注意下载大小和apk文件大小不同因为Play Store可能会做进一步压缩.)</p>
<p>同样, Android Studio中也有一个图形化的 APK Analyzer工具, 可以做apk的比较, 让你看到到底是哪一部分的尺寸增长了.</p>
<h2 id="Reactive-Apps-with-Model-View-Intent-Part-2"><a href="#Reactive-Apps-with-Model-View-Intent-Part-2" class="headerlink" title="Reactive Apps with Model-View-Intent - Part 2"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-2" target="_blank" rel="external">Reactive Apps with Model-View-Intent - Part 2</a></h2><p>上一篇文章讨论了一个好的Model层可以解决很多问题. 这篇来介绍<code>Model-View-Intent</code>模式.</p>
<h3 id="Model-View-Intent模式"><a href="#Model-View-Intent模式" class="headerlink" title="Model-View-Intent模式"></a>Model-View-Intent模式</h3><p>Model-View-Intent模式是在一个JavaScript的framework <code>cycle.js</code>中提出的.</p>
<p><img src="/images/view-model-intent.png" alt="view-model-intent"></p>
<ul>
<li><code>intent()</code>: 这个方法接收用户输入, 然后输出将会作为参数传给<code>model()</code>.</li>
<li><code>model()</code>: 接收<code>intent()</code>的输出作为自己的输入, 来操纵Model, 这个方法的输出是一个新的Model(状态变化). 所以它不应该更新一个已经存在的Model. 因为我们想要不可变性. 注意这里是唯一一个允许创建新Model的地方.</li>
<li><code>view()</code>: 接收<code>model()</code>方法返回的model作为输入, 然后将其展示出来.</li>
</ul>
<h3 id="用RxJava连接"><a href="#用RxJava连接" class="headerlink" title="用RxJava连接"></a>用RxJava连接</h3><p>我们希望数据流是单向的, 于是我们用了RxJava, 它很适合这种基于事件的编程, 在这里主要是UI事件.</p>
<p>作者之后举了一个实现的例子, 在这个例子中他们的Model层用了ViewState后缀. <code>SearchInteractor</code>用来执行搜索, 返回的结果是<code>Observable&lt;SearchViewState&gt;</code>.</p>
<p>这个模式中定义的View接口里包含了<code>render()</code>方法, 根据传入的状态model显示UI; 这个View接口其实还包含了<code>intent()</code>的方法, 返回的是一个<code>Observable</code>, UI中用了<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>.</p>
<p>最后一步就是, 如何将View的intent和业务逻辑联系起来呢? 这里用到了一个额外的组件: <code>Presenter</code>.</p>
<p>这个Presenter看起来像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchPresenter</span> <span class="keyword">extends</span> <span class="title">MviBasePresenter</span>&lt;<span class="title">SearchView</span>, <span class="title">SearchViewState</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SearchInteractor searchInteractor;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindIntents</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;SearchViewState&gt; search =</div><div class="line">        intent(SearchView::searchIntent)</div><div class="line">            .switchMap(searchInteractor::search) <span class="comment">// I have used flatMap() in the video above, but switchMap() makes more sense here</span></div><div class="line">            .observeOn(AndroidSchedulers.mainThread());</div><div class="line"></div><div class="line">    subscribeViewState(search, SearchView::render);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>MviBasePresenter</code>是<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>中的一个类.<br>这个类做的事情就是当View第一次attach到Prensenter上时, 调用<code>bindIntent()</code>方法将来自view的intent绑定到业务逻辑上, 只有第一次会绑定, 当View再次attach时不会发生.</p>
<p>而<code>subscribeViewState()</code>方法则处理了定于管理, 避免内存泄露(具体原因见原文).</p>
<h2 id="How-modularization-affects-build-time-of-an-Android-application"><a href="#How-modularization-affects-build-time-of-an-Android-application" class="headerlink" title="How modularization affects build time of an Android application"></a><a href="https://medium.com/@nikita.kozlov/how-modularisation-affects-build-time-of-an-android-application-43a984ce9968#.hzgv3h6cm" target="_blank" rel="external">How modularization affects build time of an Android application</a></h2><p>一个Android应用至少有一个application module, build这个module之后得到一个.apk文件.</p>
<p>application module之间不能相互依赖, 它只能依赖于library, build library module的结果是得到一个.aar(Android Archive Library)文件.</p>
<p>build的过程可以粗略分为5个阶段:</p>
<ul>
<li>1.准备依赖.</li>
<li>2.Merge资源和manifest.</li>
<li>3.编译. 从annotation processors开始, 把源码编译成字节码.</li>
<li>4.后处理. 所有以<code>transform</code>开头的gradle tasks都属于这个阶段. 其中最重要的是<code>transformClassesWithMultidexlist</code>和<code>transformClassesWithDex</code>, 它们生成了.dex文件.</li>
<li>5.打包发布. 对library来说是生成.aar, 对application来说是生成.apk.</li>
</ul>
<p>我们都知道gradle只有在输入变化了的情况下才会重跑task. 而且如果一个module没有变化, 也不会被重新build, 那么就出现了一种假设: 多个module应用的增量build要比单个module的快, 因为只有被改变了的module才会重新编译.</p>
<p>作者想验证这种假设是否正确.<br>他用的工具就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradle assembleDebug --profile</div></pre></td></tr></table></figure></p>
<p>做了一系列实验之后证明这个假设还是有道理的.</p>
<p>实验过程中的一些发现:</p>
<p>1.当应用被拆分为多个modules之后, 改变application module中的代码, build时间会减少; 但是library中的代码, build时间反而会增加. 这是因为library build的时候debug和release的tasks都执行了(并不知道为什么).</p>
<p>当library module被这样添加的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile project(path: &apos;:app2&apos;)</div><div class="line">    compile project(path: &apos;:app3&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管app当前的build type是什么, app永远依赖的是library的release版本.</p>
<p>这是一个Gradle当前的限制. 参见<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Library-Publication" target="_blank" rel="external">Library-Publication</a>.</p>
<p>幸运的是, 我们可以改变这一行为:<br>首先在library中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        defaultPublishConfig &apos;release&apos;</div><div class="line">        publishNonDefault true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>让它也可以发布debug版.<br>在app中依赖的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    debugCompile project(path: &apos;:app2&apos;, configuration: &quot;debug&quot;)</div><div class="line">    releaseCompile project(path: &apos;:app2&apos;, configuration: &quot;release&quot;)</div><div class="line"></div><div class="line">    debugCompile project(path: &apos;:app3&apos;, configuration: &quot;debug&quot;)</div><div class="line">    releaseCompile project(path: &apos;:app3&apos;, configuration: &quot;release&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样debug和release都只依赖各自对应版本的library了.</p>
<p>2.不管我们改动的是library中的代码还是application中的代码, application module永远都会被重新编译, 所以减小app module的尺寸很有意义.</p>
<p>3.上面这些都是library之间互相独立的情况, 如果library之间还有相互依赖, 那么build时间也会变长.</p>
<p>4.如果应用超出了DEX的方法数限制, 用了multidex, 也会增加build时间, Android 5.0开始使用了一个叫做ART的runtime, 在这方面有一些优化, 可以减少build时间, 所以我们可以在开发的时候设置最小API是21: <a href="https://developer.android.com/studio/build/multidex.html#dev-build" target="_blank" rel="external">Optimize multidex in development builds</a>.</p>
<h2 id="Exploiting-Android-Seams-for-Testing-and-Flexibility"><a href="#Exploiting-Android-Seams-for-Testing-and-Flexibility" class="headerlink" title="Exploiting Android Seams for Testing and Flexibility"></a><a href="https://www.philosophicalhacker.com/post/exploiting-android-specific-seams-for-testing-and-flexibility/" target="_blank" rel="external">Exploiting Android Seams for Testing and Flexibility</a></h2><p>如何让Android应用代码可测试? 答案是创建一些接缝. 这篇文章中, 作者将一些Android特有的接缝, 来让我们的应用更加灵活和易测.</p>
<h3 id="Manifest接缝"><a href="#Manifest接缝" class="headerlink" title="Manifest接缝"></a>Manifest接缝</h3><p>使用<a href="https://developer.android.com/studio/build/manifest-merge.html#merge_rule_markers" target="_blank" rel="external">Merge rule markers</a>可以方便地更改manifest.</p>
<p>比如在build variant是mock的时候, 由于我们在src/mock/AndroidManifest.xml里这样写:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- src/mock/AndroidManifest.xml --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">  <span class="attr">android:name</span>=<span class="string">".StubConfigActivity"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">  <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">tools:node</span>=<span class="string">"remove"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以在build mock的时候, 启动Activity会被替换成上面这个<code>StubConfigActivity</code>.</p>
<p>还有更多的可能值得探索, 比如你可以替换filter的内容, 从而改变默认intent启动的Activity.</p>
<h3 id="BuildConfig接缝"><a href="#BuildConfig接缝" class="headerlink" title="BuildConfig接缝"></a>BuildConfig接缝</h3><p>在gradle中可以根据不同的build variant来定义<code>BuildConfig</code>中的变量值. </p>
<p>默认情况下<code>BuildConfig</code>中会包含一些有用的变量比如<code>DEBUG</code>和<code>FLAVOR</code>.</p>
<p>我们可以创建更多额外的变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">  mock &#123;</div><div class="line">    buildConfigField(&apos;Boolean&apos;, &apos;MOCK&apos;, &quot;true&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个简单的应用case是我们可以定义不同的base url:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">  buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;api.awesomecompany.com\&quot;&apos;)</div><div class="line">&#125;</div><div class="line">productFlavors &#123;</div><div class="line">  sandbox &#123;</div><div class="line">    buildConfigField(&apos;String&apos;, &apos;API_BASE&apos;, &apos;\&quot;localhost:8080\&quot;&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Resource接缝"><a href="#Resource接缝" class="headerlink" title="Resource接缝"></a>Resource接缝</h3><p>不同build variants的资源就像manifest一样, 最后会被merged. 但是对于资源我们没有markers可以控制它们如何merge. </p>
<p>我们可以利用默认的merge行为: <a href="https://developer.android.com/studio/write/add-resources.html#resource_merging" target="_blank" rel="external">Resource merging</a>.</p>
<p>优先级是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</div></pre></td></tr></table></figure></p>
<p>所以我们可以把默认的资源放在main里, 然后在特定的build variant再创建一份覆盖它们.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Reptar"><a href="#Reptar" class="headerlink" title="Reptar"></a><a href="https://github.com/Commit451/Reptar" target="_blank" rel="external">Reptar</a></h2><p>RxJava2.x的有用的类的集合.</p>
<h2 id="Toasty"><a href="#Toasty" class="headerlink" title="Toasty"></a><a href="https://github.com/GrenderG/Toasty" target="_blank" rel="external">Toasty</a></h2><p>前面加了一个icon的Toast, 带背景颜色, 除了内置的error, info, success, warning等几种形式, 还可以自定义.</p>
<h2 id="Google-Actions-Java-SDK"><a href="#Google-Actions-Java-SDK" class="headerlink" title="Google-Actions-Java-SDK"></a><a href="https://github.com/frogermcs/Google-Actions-Java-SDK" target="_blank" rel="external">Google-Actions-Java-SDK</a></h2><p>非官方的Google Actions Java SDK.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> RxJava </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Testing </tag>
            
            <tag> APK </tag>
            
            <tag> Master/Detail </tag>
            
            <tag> MVI </tag>
            
            <tag> Build Time </tag>
            
            <tag> Toast </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 240]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/01/24/android-weekly-notes-issue-240/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-240"><a href="#Android-Weekly-Issue-240" class="headerlink" title="Android Weekly Issue #240"></a>Android Weekly Issue #240</h1><p>January 15th, 2017<br><a href="http://androidweekly.net/issues/issue-240" target="_blank" rel="external">Android Weekly Issue #240</a><br>Hello, 各位亲, 从本篇笔记开始, 以后并不包含Android Weekly的每一篇文章了, 只是选一些我感兴趣的做笔记. 想要看全部文章的还请点击上面的链接.</p>
<p>本期内容包括: 一个Android的RxJava教程; 关于测试中的注释讨论; Dagger2的实现细节讨论; Kotlin语言设计中和Effective Java相关的点和优化; Reactive app的构建模式, 一个好的model层的重要性; 怎样写数据库测试.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="RxAndroid-Tutorial"><a href="#RxAndroid-Tutorial" class="headerlink" title="RxAndroid Tutorial"></a><a href="https://www.raywenderlich.com/141980/rxandroid-tutorial" target="_blank" rel="external">RxAndroid Tutorial</a></h2><p>一个RxAndroid的Tutorial, 内容包括:</p>
<ul>
<li>Reactive Programming是什么. -&gt; 把reactive programming比喻成excel里面的表达式.</li>
<li>observable是什么.</li>
<li>如何把按钮点击和输入文字改变事件事件变为observables.</li>
<li>转换.</li>
<li>过滤.</li>
<li>指定线程.</li>
<li>把多个observables联合成一个.</li>
</ul>
<h2 id="Clean-tests-Part-2-Comments"><a href="#Clean-tests-Part-2-Comments" class="headerlink" title="Clean tests, Part 2: Comments"></a><a href="https://android.jlelse.eu/clean-tests-part-2-comments-4016ee82f186#.15u9kq7jz" target="_blank" rel="external">Clean tests, Part 2: Comments</a></h2><p>上一篇文章里作者讨论了测试代码的命名, 这篇讨论注释.<br>在测试里我们经常会见到这样的注释:</p>
<ul>
<li>// GIVEN</li>
<li>// WHEN</li>
<li>// THEN</li>
</ul>
<p>注意每一次添加注释的时候都应该想清楚自己的代码是不是能够自解释, 而不是依赖于注释. 这条原则同样适用于产品代码和测试代码.</p>
<p>为每一个测试重复这三行其实没有什么意义, 因为这个顺序是显而易见的.</p>
<p>理想情况下, 简单的测试并不需要这些注释就显得很好看了, 如果是复杂的测试, 一般执行应该是一行, 验证也应该是一行, 如果需要太多验证我们应该考虑把它们抽取成多个测试方法. 而关于准备阶段, 如果我们真的需要很多准备的代码, 这是一种code smell, 可能说明我们要测试的这个方法做了太多事情, 可能我们应该先重构一下再进行测试.</p>
<p>我们也应该好好利用<code>setUp()</code>方法, 让我们的测试看起来更干净.</p>
<p>最后建议用一些比较好的assert库让最后的断言语句看起来更易懂.</p>
<h2 id="Android-Dagger2-Critical-things-to-know-before-you-implement"><a href="#Android-Dagger2-Critical-things-to-know-before-you-implement" class="headerlink" title="Android Dagger2: Critical things to know before you implement"></a><a href="https://blog.mindorks.com/android-dagger2-critical-things-to-know-before-you-implement-275663aecc3e#.nxpqzmohn" target="_blank" rel="external">Android Dagger2: Critical things to know before you implement</a></h2><p>关于Dagger2的实现, 你应该搞清楚的几个关键点.</p>
<ul>
<li>实现单例的时候, 如果提供了@Provides方法, 那么@Singleton也要在这个provides方法上声明, 声明在类上是没有用的. (类的单例声明只和构造@Inject配合使用).</li>
<li>在component中提供了get方法后, 如果这个get方法没有被调用, 则对象不会被实例化.</li>
<li>Scope可以定义在该scope下的单例.</li>
</ul>
<h2 id="How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin"><a href="#How-“Effective-Java”-may-have-influenced-the-design-of-Kotlin" class="headerlink" title="How “Effective Java” may have influenced the design of Kotlin"></a><a href="https://medium.com/@lukleDev/how-effective-java-may-have-influenced-the-design-of-kotlin-part-1-45fd64c2f974#.nqwl31wn6" target="_blank" rel="external">How “Effective Java” may have influenced the design of Kotlin</a></h2><p>Kotlin的设计中考虑到的和Effective Java相关的几个点:</p>
<ul>
<li>Kotlin的构造默认参数值进一步简化了Builder模式.</li>
<li>更容易创建单例: 用object声明.</li>
<li>用了data声明后, 再也不用自己写<code>equals()</code>和<code>hashCode()</code>了.</li>
<li>properties自带了默认的get/set, 使用更加简洁, 也支持后续扩展.</li>
<li>Kotlin中的override关键字是强制的而不是可选的.</li>
</ul>
<h2 id="Reactive-apps-with-Model-View-Intent-Part-1"><a href="#Reactive-apps-with-Model-View-Intent-Part-1" class="headerlink" title="Reactive apps with Model-View-Intent - Part 1"></a><a href="http://hannesdorfmann.com/android/mosby3-mvi-1" target="_blank" rel="external">Reactive apps with Model-View-Intent - Part 1</a></h2><p>作者用RxJava + Model-View-Intent (MVI)构建的Reactive App, 也即UI响应状态变化的App.</p>
<p>首先作者列举了Android流行的模式MVC, MVP, MVVM, 这里面都会有一个Model. 但是作者发现大多数时候程序并没有Model这一层.</p>
<p>构建一个好的Model层可以解决很多问题:</p>
<ul>
<li>状态.</li>
<li>屏幕方向旋转.</li>
<li>后退导航.</li>
<li>进程死亡.</li>
<li>不可变和单向的数据流.</li>
<li>可调试和重复的状态.</li>
<li>可测试性.</li>
</ul>
<p>最基本的理念就是把这个Model层作为唯一的真实状态来源.</p>
<h2 id="Testing-SQLite-on-Android-–-Medium"><a href="#Testing-SQLite-on-Android-–-Medium" class="headerlink" title="Testing SQLite on Android – Medium"></a><a href="https://medium.com/@MAFI8919/testing-sqlite-on-android-bfa0733e11e7#.a4hufzbc7" target="_blank" rel="external">Testing SQLite on Android – Medium</a></h2><p>如何写SQLite数据库测试.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Desertplaceholder"><a href="#Desertplaceholder" class="headerlink" title="Desertplaceholder"></a><a href="https://github.com/JetradarMobile/desertplaceholder" target="_blank" rel="external">Desertplaceholder</a></h2><p>一个沙漠空白页面.</p>
<h2 id="Android-SwitchIcon"><a href="#Android-SwitchIcon" class="headerlink" title="Android-SwitchIcon"></a><a href="https://github.com/zagum/Android-SwitchIcon" target="_blank" rel="external">Android-SwitchIcon</a></h2><p>Google launcher风格的Switch icon, enable时点亮, disable时灰去.</p>
<h2 id="SlidesCodeHighlighter"><a href="#SlidesCodeHighlighter" class="headerlink" title="SlidesCodeHighlighter"></a><a href="https://github.com/romannurik/SlidesCodeHighlighter" target="_blank" rel="external">SlidesCodeHighlighter</a></h2><p>一个web应用, 让你可以把带有高亮的代码拷贝进slides.</p>
<h2 id="GithubWidget"><a href="#GithubWidget" class="headerlink" title="GithubWidget"></a><a href="https://github.com/Nightonke/GithubWidget" target="_blank" rel="external">GithubWidget</a></h2><p>一个Github Widget, 显示Contributions, stars, followers, trending etc.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> Testing </tag>
            
            <tag> SQLite </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 239]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/01/10/android-weekly-notes-issue-239/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-239"><a href="#Android-Weekly-Issue-239" class="headerlink" title="Android Weekly Issue #239"></a>Android Weekly Issue #239</h1><p>January 8th, 2017<br><a href="http://androidweekly.net/issues/issue-239" target="_blank" rel="external">Android Weekly Issue #239</a><br>本期内容包括: Android Things开发; Android中有用却不常见的一些API介绍(拼写检查, 文字识别, 时间log, 截图, 创建PDF); Gradle依赖管理冲突和解决办法; Looper, Handler和HandlerThread; 兼顾Wear1.0和2.0的部署方式; 打开PDF的实现方法; 单元测试的命名; Robolectric的弊病; 迁移到RxJava2的好处和面临的挑战. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Preparing-your-computer-for-Android-dev"><a href="#Preparing-your-computer-for-Android-dev" class="headerlink" title="Preparing your computer for Android dev"></a><a href="https://medium.com/@rafael_toledo/preparing-your-android-environment-for-development-android-tutorials-pt-1-5f76ca2b8a32#.yxa0bvkp5" target="_blank" rel="external">Preparing your computer for Android dev</a></h2><p>在Windows, OSX和Linux上设置开发环境.</p>
<h2 id="Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things"><a href="#Beginner’s-guide-to-Raspberry-Pi-3-B-and-Android-Things" class="headerlink" title="Beginner’s guide to Raspberry Pi 3 B and Android Things"></a><a href="http://www.andtuts.com/a-beginners-guide-to-raspberry-pi-3-b-and-android-things/" target="_blank" rel="external">Beginner’s guide to Raspberry Pi 3 B and Android Things</a></h2><p>如何Set up with Android Things.</p>
<h2 id="Creating-new-project-and-emulator-on-Android-Studio"><a href="#Creating-new-project-and-emulator-on-Android-Studio" class="headerlink" title="Creating new project and emulator on Android Studio"></a><a href="https://medium.com/@rafael_toledo/creating-a-new-project-and-an-emulator-on-android-studio-android-tutorials-2-35bd965ac42b#.lwlhy72wf" target="_blank" rel="external">Creating new project and emulator on Android Studio</a></h2><p>如何创建新项目和模拟器.</p>
<h2 id="Discovering-Android-API"><a href="#Discovering-Android-API" class="headerlink" title="Discovering Android API"></a><a href="https://blog.autsoft.hu/discovering-the-android-api-part-1/" target="_blank" rel="external">Discovering Android API</a></h2><p>Android是基于Java的, Java本身已经有四千多个类, Android API也有很多个类, 有一些不太常见但是却很有用的API我们应该了解一下.</p>
<p>这篇文章就旨在发现那些不常见却很有用的API, 并且附有一个<a href="https://github.com/peekler/GDG" target="_blank" rel="external">Demo</a>.</p>
<h3 id="No-1-Spell-Checker"><a href="#No-1-Spell-Checker" class="headerlink" title="No.1 - Spell Checker"></a>No.1 - Spell Checker</h3><p><a href="https://developer.android.com/reference/android/view/textservice/TextServicesManager.html" target="_blank" rel="external">TextServicesManager</a>从API 14开始支持, 可以发现拼写错误, 并返回正确的单词拼写.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextServicesManager tsm = (TextServicesManager) getSystemService(Context.TEXT_SERVICES_MANAGER_SERVICE);  </div><div class="line">SpellCheckerSession spellCheckerSession = tsm.newSpellCheckerSession(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">this</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<h3 id="No-2-Text-Recognizer"><a href="#No-2-Text-Recognizer" class="headerlink" title="No.2 - Text Recognizer"></a>No.2 - Text Recognizer</h3><p>Google Play Services Vision API中的文字识别.</p>
<p>Version API中包括了人脸识别, 二维码扫描和文字识别.</p>
<p>这个例子中可以从图像中扫描出文字信息.</p>
<h3 id="No-3-TimingLogger"><a href="#No-3-TimingLogger" class="headerlink" title="No.3 - TimingLogger"></a>No.3 - TimingLogger</h3><p><a href="https://developer.android.com/reference/android/util/TimingLogger.html" target="_blank" rel="external">TimingLogger</a>是用来测量流逝时间的一个好工具.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TimingLogger timings = <span class="keyword">new</span> TimingLogger(TAG, <span class="string">"methodA"</span>);</div><div class="line"><span class="comment">// ... do some work A ...</span></div><div class="line">timings.addSplit(<span class="string">"work A"</span>);</div><div class="line"><span class="comment">// ... do some work B ...</span></div><div class="line">timings.addSplit(<span class="string">"work B"</span>);</div><div class="line"><span class="comment">// ... do some work C ...</span></div><div class="line">timings.addSplit(<span class="string">"work C"</span>);</div><div class="line">timings.dumpToLog();</div></pre></td></tr></table></figure></p>
<p>最后一句执行后, 会在log中一次性输出下面的log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D/TAG     ( 3459): methodA: begin</div><div class="line">D/TAG     ( 3459): methodA:      9 ms, work A</div><div class="line">D/TAG     ( 3459): methodA:      1 ms, work B</div><div class="line">D/TAG     ( 3459): methodA:      6 ms, work C</div><div class="line">D/TAG     ( 3459): methodA: end, 16 ms</div></pre></td></tr></table></figure></p>
<p>注意需要在adb中使能TAG:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setprop log.tag.TAG_MYJOB VERBOSE</div></pre></td></tr></table></figure></p>
<p>假设本例子中TAG = “TAG_MYJOB”.</p>
<h3 id="No-4-Taking-screenshots"><a href="#No-4-Taking-screenshots" class="headerlink" title="No.4 - Taking screenshots"></a>No.4 - Taking screenshots</h3><p>有一些库可以提供截屏, 比如<a href="https://github.com/jraska/Falcon" target="_blank" rel="external">Falcon</a>. </p>
<p>在Android 21之上用<a href="https://developer.android.com/reference/android/media/projection/MediaProjection.html" target="_blank" rel="external">MediaProjection</a>甚至可以录屏.</p>
<p>但是得到屏幕图像更简单的一种方法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">View viewRoot = getWindow().getDecorView().getRootView();  </div><div class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">true</span>);  </div><div class="line">Bitmap screenShotAsBitmap = Bitmap.createBitmap(viewRoot.getDrawingCache());  </div><div class="line">viewRoot.setDrawingCacheEnabled(<span class="keyword">false</span>);  </div><div class="line"><span class="comment">// use screenShotAsBitmap as you need</span></div></pre></td></tr></table></figure></p>
<h3 id="No-5-PDF-Creation-API"><a href="#No-5-PDF-Creation-API" class="headerlink" title="No.5 - PDF Creation API"></a>No.5 - PDF Creation API</h3><p>从API 19开始Android就提供了API可以创建PDF文档.<br>文中的例子是创建了一个PDF文档, 然后把当前屏幕内容放进去.</p>
<h2 id="Avoiding-Conflicts-in-android-gradle-dependencies"><a href="#Avoiding-Conflicts-in-android-gradle-dependencies" class="headerlink" title="Avoiding Conflicts in android gradle dependencies"></a><a href="https://blog.mindorks.com/avoiding-conflicts-in-android-gradle-dependencies-28e4200ca235#.x66q6p4v4" target="_blank" rel="external">Avoiding Conflicts in android gradle dependencies</a></h2><p>如果两个依赖又都依赖了同一个库, 但是是不同的版本, 那会发生什么呢?</p>
<p>比如下面这个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">androidTestCompile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</div><div class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</div></pre></td></tr></table></figure></p>
<p>这两个库都依赖于”org.hamcrest:hamcrest-core”, 但是版本却不同.</p>
<p>这种情况下, 最终被包含进build的是最高版本的库.</p>
<p>在依赖被声明的module里运行下面这个命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew dependencies.</div></pre></td></tr></table></figure></p>
<p>会显式地看到gradle自动把第二个依赖中的hamcrest库从1.1升级到了1.3.</p>
<p>前面, 两个依赖都是test依赖, 所以gradle自动解决了冲突.  如果两个依赖属于不同的配置, 如, 把第一个<code>androidTestCompile</code>改为<code>compile</code>, gradle将会报错.</p>
<p>原因是:</p>
<blockquote>
<p>When instrumentation tests are run, both the main APK and test APK share the same classpath. Gradle build will fail if the main APK and the test APK use the same library (e.g. Guava) but in different versions. If gradle didn’t catch that, your app could behave differently during tests and during normal run (including crashing in one of the cases).</p>
</blockquote>
<p><strong>解决依赖冲突</strong><br>一旦有了依赖冲突, 就需要开发者决定最后到底用什么版本的库, 有几种解决方法:</p>
<ul>
<li>方法1: 从依赖中排除这个库.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Now junit will not include hamcrest library. Therefore there will be no </div><div class="line">//dependency conflict. </div><div class="line"> compile (&apos;junit:junit:4.12&apos;)&#123;</div><div class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">androidTestCompile (&apos;org.mockito:mockito-core:1.10.19&apos;)&#123;</div><div class="line">    exclude group: &apos;org.hamcrest&apos;, module:&apos;hamcrest-core&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>真实的项目中可能有多个依赖依赖于同一个库, 那么我们就需要写多个排除语句.</p>
<ul>
<li>方法2: 显式地声明冲突库的版本.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compile &apos;junit:junit:4.12&apos; //(Depends on version 1.3)</div><div class="line">androidTestCompile &apos;org.mockito:mockito-core:1.10.19&apos; //(Depends on version 1.1)</div><div class="line">androidTestCompile &apos;org.hamcrest:hamcrest-core:1.3&apos; //(We explictly mention </div><div class="line">//that include version 1.3)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方法不用写exclude, 但是当升级直接依赖库的时候需要注意更新这种间接依赖库的版本.</p>
<ul>
<li>方法3: 强制解析.</li>
</ul>
<p>强制设置所有configuration的依赖版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    configurations.all &#123;</div><div class="line">        resolutionStrategy.force &apos;org.hamcrest:hamcrest-core:1.1&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这种方法的时候需要小心, 因为与方法2不同, 它是把所有configuration中的版本都强制设置了. 当直接依赖更新的时候, 要注意更新间接依赖的版本.</p>
<h2 id="Looper-Handler-and-HandlerThread"><a href="#Looper-Handler-and-HandlerThread" class="headerlink" title="Looper, Handler, and HandlerThread"></a><a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a#.zf2nhog1x" target="_blank" rel="external">Looper, Handler, and HandlerThread</a></h2><p>这篇文章讨论Looper, Handler和HandlerThread.</p>
<p>首先, 读者应该了解Java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" target="_blank" rel="external">Thread</a>和<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" target="_blank" rel="external">Runnable</a>.</p>
<p>然后让我们带着问题来探索和复习:</p>
<h3 id="Java的Thread存在什么问题"><a href="#Java的Thread存在什么问题" class="headerlink" title="Java的Thread存在什么问题?"></a>Java的Thread存在什么问题?</h3><p>Java的Thread是一次性的, 当它执行完<code>run()</code>方法之后, 它就死了.</p>
<h3 id="我们可以改善这个问题吗"><a href="#我们可以改善这个问题吗" class="headerlink" title="我们可以改善这个问题吗?"></a>我们可以改善这个问题吗?</h3><p>线程本身是个双刃剑, 我们可以把任务分发到多个线程来加速, 但同时线程过多又会降低速度. 线程创建也会花费时间, 所以最好我们能有一个固定优化数量的线程, 然后用它们来执行任务.</p>
<p><strong>线程复用模型</strong>:</p>
<ul>
<li>1.一个线程保持活跃, 通过它的<code>run()</code>方法不断循环.</li>
<li>2.任务由该线程连续执行, 并保持在一个队列中(MessageQueue).</li>
<li>3.当完成之后结束这个线程.</li>
</ul>
<h3 id="Android是以什么方式来做这件事的呢"><a href="#Android是以什么方式来做这件事的呢" class="headerlink" title="Android是以什么方式来做这件事的呢?"></a>Android是以什么方式来做这件事的呢?</h3><p>Android用<code>Looper</code>, <code>Handler</code>和<code>HandlerThread</code>实现了上述模型.<br>系统可以用这样的图表示:<br><img src="/images/Android-Looper-Handler.jpeg" alt="Android Looper Handler"></p>
<ul>
<li>1.<code>MessageQueue</code>是一个队列, 里面含有需要被处理的任务(消息).</li>
<li>2.<code>Handler</code>利用<code>Looper</code>往队列中加任务, 同时也在任务出队列的时候进行处理.</li>
<li>3.<code>Looper</code>是一个工人, 保持一个线程的活跃, 循环消息队列, 把消息发给对应的handler去处理.(一个线程只能对应一个唯一的<code>Looper</code>, 但是可以有多个关联的<code>Handler</code>).</li>
<li>4.最后<code>Looper.quit()</code>会让线程终止.</li>
</ul>
<p>为一个线程创建<code>Looper</code>和<code>MessageQueue</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Handler mHandler; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        Looper.prepare();</div><div class="line"></div><div class="line">        mHandler = <span class="keyword">new</span> Handler() &#123; </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; </div><div class="line">               <span class="comment">// process incoming messages here</span></div><div class="line">               <span class="comment">// this will run in non-ui/background thread</span></div><div class="line">            &#125; </div><div class="line">        &#125;; </div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建<code>Handler</code>的时候自动和当前线程的Looper关联, 但是也可以通过构造传入Looper来使Handler关联到特定的线程.</p>
<p>用<code>Handler</code>发消息有两种方式: <code>Message</code>和<code>Runnable</code>.</p>
<p>自己创建一个线程并提供Looper和消息队列的方式是不好的, 所以Android提供了<code>HandlerThread</code>来简化这个过程, 它内部的实现和我们之前做的差不多, 但是是以一种更加稳健的方式. 所以我们应该使用<code>HandlerThread</code>而不是自己实现.</p>
<p>大多数时候你只需要继承<code>HandlerThread</code>来创建它的子类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</div><div class="line"></div><div class="line">    Handler handler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</div><div class="line">        handler = <span class="keyword">new</span> Handler(getLooper()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                <span class="comment">// process incoming messages here</span></div><div class="line">                <span class="comment">// this will run in non-ui/background thread</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li><code>Looper</code>只有在<code>HandlerThread</code>的<code>start()</code>方法被调用(线程开始跑)后才会进入prepared状态.</li>
<li>只有在<code>HandlerThread</code>的<code>Looper</code>处于parepared状态以后, <code>Handler</code>才可以关联.</li>
</ul>
<p>另一种创建<code>HandlerThread</code>的方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"MyHandlerThread"</span>);</div><div class="line">handlerThread.start();</div><div class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</div></pre></td></tr></table></figure></p>
<p>注意: <code>HandlerThread</code>需要调用<code>quit()</code>方法来停止线程执行和释放资源.</p>
<p>作者文后还附有一个练习的demo.</p>
<h2 id="Android-Wear-packaging"><a href="#Android-Wear-packaging" class="headerlink" title="Android Wear packaging"></a><a href="https://www.novoda.com/blog/android-wear-packaging/" target="_blank" rel="external">Android Wear packaging</a></h2><p>Android Wear 2.0将在2017年发布, 本文讨论了如何同时支持1.0和2.0的应用部署.</p>
<h2 id="Simple-Things-–-Part-1"><a href="#Simple-Things-–-Part-1" class="headerlink" title="Simple Things – Part 1"></a><a href="https://blog.stylingandroid.com/simple-things-part-1/" target="_blank" rel="external">Simple Things – Part 1</a></h2><p>Android Things应用.</p>
<h2 id="Options-for-Viewing-PDFs"><a href="#Options-for-Viewing-PDFs" class="headerlink" title="Options for Viewing PDFs"></a><a href="https://commonsware.com/blog/2017/01/04/options-viewing-pdfs.html" target="_blank" rel="external">Options for Viewing PDFs</a></h2><p>显示PDF传统的方法是通过ACTION_VIEW发出去, 用一个第三方应用打开.</p>
<p>但是有一些开发者不愿意这样做.</p>
<p>还有一种方法是把文件上传, 然后用Google Docs URL用WebView打开它. </p>
<p>除了这些传统的方法, 还有一些选项, 虽然它们各自都有一些问题.</p>
<p>比如用<code>PdfRenderer</code>, 它是Android 5.0加入的.</p>
<p>Mozilka在Firefox上用的是<a href="https://mozilla.github.io/pdf.js/" target="_blank" rel="external">PDF.js</a>, 在Android 4.4+的WebView上可用, 它会给apk带来2MB左右的增加.</p>
<p>Google在Chrominum上用的是<a href="https://pdfium.googlesource.com/pdfium/" target="_blank" rel="external">pdfium</a>, 这是C++. <a href="https://github.com/barteksc/AndroidPdfViewer" target="_blank" rel="external">barteksc/AndroidPdfViewer</a>封装了Pdfium, 处理了渲染和基本的手势, 在一些较老的Android版本上也使用, 但是大约每个CPU架构会给APK增加5MB, 默认情况下你会增加30MB.</p>
<h2 id="Clean-tests-Part-1-Naming"><a href="#Clean-tests-Part-1-Naming" class="headerlink" title="Clean tests, Part 1: Naming"></a><a href="https://android.jlelse.eu/clean-tests-part-1-naming-cce94edf0522#.5nmmqx81y" target="_blank" rel="external">Clean tests, Part 1: Naming</a></h2><p>关于怎么写干净的单元测试, 本文作者提出了几点他对于命名的看法.</p>
<ul>
<li>不要用”test”开头写测试名.</li>
<li>不要把被测试的方法名字写在测试名里.</li>
<li>测试是一种规范.</li>
</ul>
<h2 id="Why-I-Don’t-use-Robolectric"><a href="#Why-I-Don’t-use-Robolectric" class="headerlink" title="Why I Don’t use Robolectric"></a><a href="http://www.philosophicalhacker.com/post/why-i-dont-use-roboletric/" target="_blank" rel="external">Why I Don’t use Robolectric</a></h2><p>作者觉得Robolectric不好的几点:</p>
<ul>
<li>Robolectric mock了一些我们并不拥有的type.</li>
<li>Robolectric turns TDD on its head.</li>
</ul>
<p>所以最好的做法是我们在写Android代码的时候将逻辑代码抽象出来, 与framework分离, 这样在测试的时候不依赖于Android SDK的类, 也不需要robolectric来模拟一个中间层.</p>
<h2 id="The-Next-Step-for-Reactive-Android-Programming"><a href="#The-Next-Step-for-Reactive-Android-Programming" class="headerlink" title="The Next Step for Reactive Android Programming"></a><a href="http://futurice.com/blog/the-next-step-for-reactive-android-programming" target="_blank" rel="external">The Next Step for Reactive Android Programming</a></h2><p>RxJava 2已经推出了, 本篇文章讨论从RxJava 1迁移到RxJava 2会带来的好处和挑战.</p>
<p>好处:</p>
<ul>
<li>兼容了<a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="external">Reactive Streams</a>.</li>
<li>Backpressure的处理.</li>
<li>Performance.</li>
</ul>
<p>挑战:</p>
<ul>
<li>流中不能再使用null.</li>
<li>方法数限制. RxJava 1(5500), RxJava 2(9200).</li>
<li>自定义操作符变得很难写.</li>
</ul>
<p>Note: 可以对比简单的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java" target="_blank" rel="external">map</a>和复杂的操作符<a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java" target="_blank" rel="external">flatMap</a>.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introducing-Auto-Layout-for-Sketch"><a href="#Introducing-Auto-Layout-for-Sketch" class="headerlink" title="Introducing Auto-Layout for Sketch"></a><a href="https://medium.com/sketch-app-sources/introducing-auto-layout-for-sketch-24e7b5d068f9#.tusju2z7k" target="_blank" rel="external">Introducing Auto-Layout for Sketch</a></h2><p>一个Sketch插件, 让你查看不同屏幕上的效果.</p>
<h2 id="Designing-for-Both-Android-and-iOS"><a href="#Designing-for-Both-Android-and-iOS" class="headerlink" title="Designing for Both Android and iOS"></a><a href="https://webdesign.tutsplus.com/articles/a-tale-of-two-platforms-designing-for-both-android-and-ios--cms-23616" target="_blank" rel="external">Designing for Both Android and iOS</a></h2><p>Android和iOS的设计, 很详细的介绍, 最后附有一些resources.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="flowless"><a href="#flowless" class="headerlink" title="flowless"></a><a href="https://github.com/Zhuinden/flowless" target="_blank" rel="external">flowless</a></h2><p>一个框架, 给你Activity的UI状态命名, 管理并记录状态转换.</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a><a href="https://github.com/NYTimes/Store" target="_blank" rel="external">Store</a></h2><p>异步数据加载和缓存的库.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Wear </tag>
            
            <tag> Gradle </tag>
            
            <tag> RxJava </tag>
            
            <tag> Test </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Handler </tag>
            
            <tag> Android Things </tag>
            
            <tag> Looper </tag>
            
            <tag> HandlerThread </tag>
            
            <tag> PDF </tag>
            
            <tag> Robolectric </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 238]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2017/01/03/android-weekly-notes-issue-238/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-238"><a href="#Android-Weekly-Issue-238" class="headerlink" title="Android Weekly Issue #238"></a>Android Weekly Issue #238</h1><p>January 1st, 2017<br><a href="http://androidweekly.net/issues/issue-238" target="_blank" rel="external">Android Weekly Issue #238</a><br>本期内容包括: Firebase发送Notification; RecyclerView的预取; 后台工作的实现方式讨论; RecyclerView分组数据; 跨平台应用工具Flutter介绍; Gradle依赖管理;<br>写测试的一些注意事项; Android Things应用搭建及一些思考; 如何搭建CI等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Mastering-Firebase-Notifications"><a href="#Mastering-Firebase-Notifications" class="headerlink" title="Mastering Firebase Notifications"></a><a href="https://medium.com/@Miqubel/mastering-firebase-notifications-36a3ffe57c41#.ykkpzrs4l" target="_blank" rel="external">Mastering Firebase Notifications</a></h2><p>用Firebase发通知:</p>
<ul>
<li>Console Notifications.</li>
<li>使用命令行, 发送curl命令.</li>
<li><code>FirebaseMessagingService</code>在应用前台的时候处理通知.</li>
<li>如果应用前后台的时候都需要处理, 则发送data而不是notification.<br>官方文档<a href="https://firebase.google.com/docs/cloud-messaging/android/receive" target="_blank" rel="external">Firebase cloud-messaging</a>.</li>
</ul>
<h2 id="RecyclerView-Prefetch"><a href="#RecyclerView-Prefetch" class="headerlink" title="RecyclerView Prefetch"></a><a href="https://medium.com/google-developers/recyclerview-prefetch-c2f269075710#.21takened" target="_blank" rel="external">RecyclerView Prefetch</a></h2><p>作者研究了RecyclerView的渲染时间, 发现在滚动的时候很多的时间会花在新item的创建和bind上, 这样会推迟UI线程的其他工作, 还有RenderThread的后续工作, 如果超出了frame boundary, 就有可能会造成明显的卡顿.</p>
<p>而同时前一帧, UI线程可能处于空闲状态.</p>
<p>那么我们有没有可能以一种预取的方式, 把即将出现的View在提前的空闲阶段准备好呢?</p>
<p>pre-fetch的优化已经在<a href="https://developer.android.com/topic/libraries/support-library/revisions.html#rev25-0-0" target="_blank" rel="external">Support Library v25</a>加入, <a href="https://developer.android.com/topic/libraries/support-library/revisions.html#25-1-0" target="_blank" rel="external">v25.1.0</a>有进一步的加强. 如果你没有自定义LayoutManager, 也没有嵌套<code>RecyclerView</code>, 那么你升级support library之后就自动获得了这项优化. 其他两种情况你还需要调用一些方法.</p>
<p>你可以设置<code>LayoutManager.setItemPrefetchEnabled()</code>来对比开启和关闭预取功能前后的不同. 性能测量用<a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="external">Systrace</a>和<a href="https://developer.android.com/studio/profile/dev-options-rendering.html" target="_blank" rel="external">GPU profiling</a>.</p>
<h2 id="Things-to-consider-before-running-background-tasks"><a href="#Things-to-consider-before-running-background-tasks" class="headerlink" title="Things to consider before running background tasks"></a><a href="https://blog.yipl.com.np/things-to-consider-before-running-background-tasks-e71f00d2ad3a#.baugcaodi" target="_blank" rel="external">Things to consider before running background tasks</a></h2><p>完成后台任务的几种方式和各自的优缺点分析.</p>
<ul>
<li>Thread.</li>
<li>AsyncTask.</li>
<li>Service.</li>
<li>IntentService.</li>
<li>Loader.</li>
<li>JobService and JobScheduler. GCM Network Manager.</li>
<li>RxJava.</li>
</ul>
<h2 id="Android-RecyclerView-Grouping-Data"><a href="#Android-RecyclerView-Grouping-Data" class="headerlink" title="Android RecyclerView - Grouping Data"></a><a href="https://krtkush.github.io/2016/07/08/android-recyclerview-grouping-data.html" target="_blank" rel="external">Android RecyclerView - Grouping Data</a></h2><p>作者展示了如何将RecyclerView中的数据分组展示, 在他的例子中是按照时间分组, 每一组开始是该组的时间占据一行.</p>
<p>其实主要是前期的数据处理, 首先创建一个HashMap, 分组依据作为key, 符合该依据的数据作为值存在对应key的value list里; 然后给日期和数据创建一个共同的基类, 把HashMap再重新展开成一个List, 里面穿插好数据. 最后用RecyclerView按照数据类型不同显示两种布局.</p>
<h2 id="Flutter-Intro"><a href="#Flutter-Intro" class="headerlink" title="Flutter Intro"></a><a href="https://medium.com/@develodroid/flutter-i-intro-and-install-a8bf6dfcc7c8#.f9ktsu3r8" target="_blank" rel="external">Flutter Intro</a></h2><p><a href="https://flutter.io/" target="_blank" rel="external">Flutter</a>是一个Google推出的新工具, 用来构建跨平台的应用.</p>
<p>本文介绍了如何setup和创建一个Hello World.</p>
<h2 id="How-to-add-Gradle-dependencies-using-‘foreach’"><a href="#How-to-add-Gradle-dependencies-using-‘foreach’" class="headerlink" title="How to add Gradle dependencies using ‘foreach’"></a><a href="https://hackernoon.com/android-how-to-add-gradle-dependencies-using-foreach-c4cbcc070458#.aplxhrmn3" target="_blank" rel="external">How to add Gradle dependencies using ‘foreach’</a></h2><p>一种管理依赖的方式, 把所有的依赖定义在同一个文件的不同分组里, 然后在每个module各自添加自己的分组即可.</p>
<h2 id="Best-practices-to-improve-app-engagement"><a href="#Best-practices-to-improve-app-engagement" class="headerlink" title="Best practices to improve app engagement"></a><a href="https://android-developers.googleblog.com/2016/12/important-best-practices-to-improve-app-engagement.html" target="_blank" rel="external">Best practices to improve app engagement</a></h2><p>如何提高app的用户参与度.</p>
<h2 id="The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android"><a href="#The-Do’s-and-Don’ts-of-Writing-Test-cases-in-Android" class="headerlink" title="The Do’s and Don’ts of Writing Test cases in Android"></a><a href="https://blog.mindorks.com/the-dos-and-don-ts-of-writing-test-cases-in-android-70f1b5dab3e1#.7ol81s1wo" target="_blank" rel="external">The Do’s and Don’ts of Writing Test cases in Android</a></h2><p>作者分享了在写测试的时候需要注意的几点:</p>
<ul>
<li>首先明确我们要测试的是什么, 预先条件是否满足, 如果是因为前置条件不满足, 那么并不是我们的测试本身失败了.</li>
<li>每个测试都是独立完成的, 测试的执行顺序不应该影响结果.</li>
<li>在测试中不要写条件语句. 条件语句是在实际代码中的, 每一个条件都应该对应一个单独的测试case.</li>
<li>测试应该不受外部因素影响, 比如server和网络. 因为如果因为这类原因测试失败了, 并不代表我们的代码有bug.</li>
</ul>
<h2 id="Making-Rainbow-HAT-Work-with-the-Android-Things"><a href="#Making-Rainbow-HAT-Work-with-the-Android-Things" class="headerlink" title="Making Rainbow HAT Work with the Android Things"></a><a href="https://blog.egorand.me/making-rainbow-hat-work-with-the-android-things-2/" target="_blank" rel="external">Making Rainbow HAT Work with the Android Things</a></h2><p>一个Android Things应用.</p>
<h2 id="Christmas-Voice-–-Part-2"><a href="#Christmas-Voice-–-Part-2" class="headerlink" title="Christmas Voice – Part 2"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-2/" target="_blank" rel="external">Christmas Voice – Part 2</a></h2><p>一个小应用, 录音, 做转换并播放.</p>
<h2 id="Will-Android-do-for-the-IoT-what-it-did-for-mobile"><a href="#Will-Android-do-for-the-IoT-what-it-did-for-mobile" class="headerlink" title="Will Android do for the IoT what it did for mobile?"></a><a href="https://medium.com/@carl.whalley/will-android-do-for-iot-what-it-did-for-mobile-c9ac79d06c#.41phc9zbb" target="_blank" rel="external">Will Android do for the IoT what it did for mobile?</a></h2><p>关于Android Things的一些看法.</p>
<h2 id="Set-up-a-CI-server-for-Android-dev"><a href="#Set-up-a-CI-server-for-Android-dev" class="headerlink" title="Set up a CI server for Android dev"></a><a href="https://medium.com/@pamartineza/how-to-set-up-a-continuous-integration-server-for-android-development-ubuntu-jenkins-sonarqube-43c1ed6b08d3#.lzs2m4zg8" target="_blank" rel="external">Set up a CI server for Android dev</a></h2><p>如何搭建Android项目的CI, (Ubuntu + Jenkins + SonarQube).</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Material-Growth-amp-communications"><a href="#Material-Growth-amp-communications" class="headerlink" title="Material: Growth &amp; communications"></a><a href="https://material.io/guidelines/growth-communications/introduction.html#" target="_blank" rel="external">Material: Growth &amp; communications</a></h2><p>如何进行用户引导, feature发现和手势教育.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PanoramaImageView"><a href="#PanoramaImageView" class="headerlink" title="PanoramaImageView"></a><a href="https://github.com/gjiazhe/PanoramaImageView" target="_blank" rel="external">PanoramaImageView</a></h2><p>一个ImageView, 在设备转动的时候可以自动滚动内容.</p>
<h2 id="TextDecorator"><a href="#TextDecorator" class="headerlink" title="TextDecorator"></a><a href="https://github.com/nntuyen/text-decorator" target="_blank" rel="external">TextDecorator</a></h2><p>可以给文字分段加上各种装饰, 下划线, 点击事件等.</p>
<h2 id="Delightful-SQLBrite"><a href="#Delightful-SQLBrite" class="headerlink" title="Delightful-SQLBrite"></a><a href="https://github.com/geralt-encore/Delightful-SQLBrite" target="_blank" rel="external">Delightful-SQLBrite</a></h2><p>一个示例应用, 展示<a href="https://github.com/square/sqldelight" target="_blank" rel="external">SQLDelight</a>和<a href="https://github.com/square/sqlbrite" target="_blank" rel="external">SQLBrite</a>结合使用.</p>
<h2 id="mainframer"><a href="#mainframer" class="headerlink" title="mainframer"></a><a href="https://github.com/gojuno/mainframer" target="_blank" rel="external">mainframer</a></h2><p>一个远程build的脚本.</p>
<h2 id="material-about-library"><a href="#material-about-library" class="headerlink" title="material-about-library"></a><a href="https://github.com/daniel-stoneuk/material-about-library" target="_blank" rel="external">material-about-library</a></h2><p>创建一个Material风格about页面的库.</p>
<h2 id="android-snowfall"><a href="#android-snowfall" class="headerlink" title="android-snowfall"></a><a href="https://github.com/JetradarMobile/android-snowfall" target="_blank" rel="external">android-snowfall</a></h2><p>下雪View.</p>
<h2 id="Android-ExpandIcon"><a href="#Android-ExpandIcon" class="headerlink" title="Android-ExpandIcon"></a><a href="https://github.com/zagum/Android-ExpandIcon" target="_blank" rel="external">Android-ExpandIcon</a></h2><p>展开/合上的上下箭头icon, 支持点击和手势滑动切换.</p>
<h2 id="RxAnimations"><a href="#RxAnimations" class="headerlink" title="RxAnimations"></a><a href="https://github.com/0ximDigital/RxAnimations" target="_blank" rel="external">RxAnimations</a></h2><p>Rx形式的动画库.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Firebase </tag>
            
            <tag> Gradle </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> Notification </tag>
            
            <tag> Testing </tag>
            
            <tag> Android Things </tag>
            
            <tag> Background work </tag>
            
            <tag> Flutter </tag>
            
            <tag> CI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 237]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/12/30/android-weekly-notes-issue-237/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-237"><a href="#Android-Weekly-Issue-237" class="headerlink" title="Android Weekly Issue #237"></a>Android Weekly Issue #237</h1><p>December 25th, 2016<br><a href="http://androidweekly.net/issues/issue-237" target="_blank" rel="external">Android Weekly Issue #237</a><br>这是本年的最后一篇issue, 感谢大家.<br>本期内容包括: ConstraintLayout的使用; Android Things的应用; 如何利用第三方库使得Java具有Kotlin的一些新特性; Firebase是如何利用<code>ContentProvider</code>进行初始化的; Kotlin上的并发处理; 其他还有一些关于程序架构, 代码优化相关的讨论.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Building-interfaces-with-ConstraintLayout"><a href="#Building-interfaces-with-ConstraintLayout" class="headerlink" title="Building interfaces with ConstraintLayout"></a><a href="https://medium.com/google-developers/building-interfaces-with-constraintlayout-3958fa38a9f7#.al6p1anu7" target="_blank" rel="external">Building interfaces with ConstraintLayout</a></h2><p>本文介绍<code>ConstraintLayout</code>的chains和ratios. 另外还提到很多使用<code>ConstraintLayout</code>的实现细节.</p>
<p>所谓chains就是几个View之间建立的双向约束.</p>
<p>ratios是帮助你设置View的宽高比, 它所做的事情和<a href="https://developer.android.com/reference/android/support/percent/PercentFrameLayout.html" target="_blank" rel="external">PercentFrameLayout</a>差不多, 但是不用添加额外的ViewGroup.</p>
<h2 id="Electronic-Candle-using-Android-Things"><a href="#Electronic-Candle-using-Android-Things" class="headerlink" title="Electronic Candle using Android Things"></a><a href="https://plus.google.com/+DaveSmithDev/posts/4JN7ZaSKxaM" target="_blank" rel="external">Electronic Candle using Android Things</a></h2><p>用ObjectAnimator和Android Things搭建的一个电子蜡烛.</p>
<h2 id="ExoPlayer-2-1-What’s-new"><a href="#ExoPlayer-2-1-What’s-new" class="headerlink" title="ExoPlayer 2.1 - What’s new"></a><a href="https://medium.com/google-exoplayer/exoplayer-2-1-whats-new-2832c09fedab#.po64o4uha" target="_blank" rel="external">ExoPlayer 2.1 - What’s new</a></h2><p>ExoPlayer 2.1有什么新功能.<br>这是他们的<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="external">release notes</a>.</p>
<h2 id="Living-Android-without-Kotlin"><a href="#Living-Android-without-Kotlin" class="headerlink" title="Living (Android) without Kotlin"></a><a href="https://hackernoon.com/living-android-without-kotlin-db7391a2b170#.7fm956ryk" target="_blank" rel="external">Living (Android) without Kotlin</a></h2><p>如果你因为种种原因不能在项目中使用kotlin, 这篇文章告诉你如何借助于一些工具和库用Java实现Kotlin的一些features.</p>
<h2 id="Christmas-Voice-–-Part-1"><a href="#Christmas-Voice-–-Part-1" class="headerlink" title="Christmas Voice – Part 1"></a><a href="https://blog.stylingandroid.com/christmas-voice-part-1/" target="_blank" rel="external">Christmas Voice – Part 1</a></h2><p>作者发布了一个改变声音的应用, 并且将其开源了: <a href="https://github.com/StylingAndroid/ChristmasVoice" target="_blank" rel="external">ChristmasVoice</a>.</p>
<h2 id="How-does-Firebase-initialize-on-Android"><a href="#How-does-Firebase-initialize-on-Android" class="headerlink" title="How does Firebase initialize on Android?"></a><a href="https://firebase.googleblog.com/2016/12/how-does-firebase-initialize-on-android.html" target="_blank" rel="external">How does Firebase initialize on Android?</a></h2><p>Firebase在Android上是如何初始化的?</p>
<p>很多SDK在初始化的时候会要求应用传入<code>Context</code>. Firebase简化了这一步骤. 解决方案就是用了<code>ContentProvider</code>, 既解决了时间问题, 也得到了sdk需要的<code>Context</code>. 并且不需要应用的开发者添加任何额外的初始化代码.</p>
<p>选择<code>ContentProvider</code>主要有两点原因:</p>
<ul>
<li><code>ContentProvider</code>初始化早.<br>当一个Android进程启动的时候, 首先会初始化每一个ContentProvider, 然后是Application, 最后是被Intent启动的组件. </li>
</ul>
<p>在ContentProvider初始化的时候, 就可以拿到Context了.</p>
<ul>
<li><code>ContentProvider</code>可以merge到最终的manifest里.<br><a href="https://developer.android.com/studio/build/manifest-merge.html" target="_blank" rel="external">Manifest merge</a>是在build的时候来定义你的应用最终的manifest. 最终的manifest会包含所有依赖的库的manifest中声明的组件.</li>
</ul>
<p>如果你也想选择用<code>ContentProvider</code>来做应用或库的初始化, 请注意authority的唯一性问题和<code>ContentProvider</code>只在主进程运行的问题.</p>
<h2 id="Seductive-Code"><a href="#Seductive-Code" class="headerlink" title="Seductive Code"></a><a href="https://publicobject.com/2016/12/19/seductive-code/" target="_blank" rel="external">Seductive Code</a></h2><p>当我们在改善代码可读性的时候, 很有可能会影响到性能和可维护性. </p>
<p>作者举例说明了他在实际编程中遇到的几个问题.</p>
<h2 id="Testing-Android-Things-–-Unit-amp-Vendor-tests"><a href="#Testing-Android-Things-–-Unit-amp-Vendor-tests" class="headerlink" title="Testing Android Things – Unit &amp; Vendor tests"></a><a href="http://blog.blundellapps.co.uk/testing-android-things-iot-meets-java/" target="_blank" rel="external">Testing Android Things – Unit &amp; Vendor tests</a></h2><p>如何开发Android Things应用, 才能让测试更加容易. 本文以一个很小的LED灯闪烁程序为例.</p>
<h2 id="Engineering-the-Architecture-Behind-Uber’s-New-Rider-App"><a href="#Engineering-the-Architecture-Behind-Uber’s-New-Rider-App" class="headerlink" title="Engineering the Architecture Behind Uber’s New Rider App"></a><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">Engineering the Architecture Behind Uber’s New Rider App</a></h2><p>Uber团队重新打造了他们的ride app, 提出了一个新的构架模式: Riblets.</p>
<p>关于架构的选型, 已有的类型可以查看这个<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tmcojtwgg" target="_blank" rel="external">iOS Architecture Patterns</a>.</p>
<h2 id="Rebuilding-the-Buffer-Android-Composer"><a href="#Rebuilding-the-Buffer-Android-Composer" class="headerlink" title="Rebuilding the Buffer Android Composer"></a><a href="https://overflow.buffer.com/2016/12/22/rebuild-android-composer/" target="_blank" rel="external">Rebuilding the Buffer Android Composer</a></h2><p>作者重构了自己应用的代码, 应用了clean architecture, 本文讲述了其过程.</p>
<h2 id="Papercut"><a href="#Papercut" class="headerlink" title="Papercut"></a><a href="http://stu.ie/?page_id=3133" target="_blank" rel="external">Papercut</a></h2><p><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a>是一个库, 用来标记那些我们觉得需要删除或者需要重构的代码.</p>
<h2 id="Concurrency-Primitives-in-Kotlin"><a href="#Concurrency-Primitives-in-Kotlin" class="headerlink" title="Concurrency Primitives in Kotlin"></a><a href="https://blog.egorand.me/concurrency-primitives-in-kotlin/" target="_blank" rel="external">Concurrency Primitives in Kotlin</a></h2><p>作者最近看了一本书, 讲Android的并发, 觉得很好, 想要用Kotlin来重写书中的例子, 结果发现:</p>
<ul>
<li>Kotlin中没有<code>synchronized</code>关键字.</li>
<li>Kotlin中没有<code>volatile</code>关键字.</li>
<li>Kotlin中的<code>Any</code>, 类比于Java中的<code>Object</code>, 但是却没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法.</li>
</ul>
<p>所以Kotlin中的并发是怎么处理呢? 这里有个问题: <a href="https://discuss.kotlinlang.org/t/concurrency-in-kotlin/858" target="_blank" rel="external">Kotlin forum</a>, Kotlin语言的开发人员表示这些应该由库来处理, 而不是语言本身.</p>
<p>尽管Kotlin不支持, 但是它还是提供了一些底层的并发工具.</p>
<ul>
<li>创建线程. 因为Kotlin可以调用Java代码, 所以仍然可以通过两种方法来创建线程.</li>
<li><code>@Synchronized</code>注解和<code>synchronized()</code>方法.</li>
<li><code>@Volatile</code>注解.</li>
<li>没有<code>wait()</code>, <code>notify()</code>和<code>notifyAll()</code>方法, 但是可以把<code>Object</code>对象作为锁, 然后调用锁的这些方法.</li>
</ul>
<p><a href="http://stackoverflow.com/questions/35520583/why-there-are-no-concurrency-keywords-in-kotlin" target="_blank" rel="external">stackoverflow</a>上有一个相关问题, 答案很不错, 列了处理并发的一些有用的库.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KataScreenshotAndroid"><a href="#KataScreenshotAndroid" class="headerlink" title="KataScreenshotAndroid"></a><a href="https://github.com/Karumi/KataScreenshotAndroid" target="_blank" rel="external">KataScreenshotAndroid</a></h2><p>一个Screen Kata应用, 用来练习做UI测试的.</p>
<h2 id="Papercut-1"><a href="#Papercut-1" class="headerlink" title="Papercut"></a><a href="https://github.com/Stuie/papercut" target="_blank" rel="external">Papercut</a></h2><p>一个用来标记需要重构或者移除代码的工具库.</p>
<h2 id="Squint"><a href="#Squint" class="headerlink" title="Squint"></a><a href="https://github.com/IntruderShanky/Squint" target="_blank" rel="external">Squint</a></h2><p>一个可以自定义的对角线切割View.</p>
<h2 id="Colorful"><a href="#Colorful" class="headerlink" title="Colorful"></a><a href="https://github.com/garretyoder/Colorful" target="_blank" rel="external">Colorful</a></h2><p>一个动态的主题库, 让你可以方便地修改应用的颜色.</p>
<h2 id="scytale"><a href="#scytale" class="headerlink" title="scytale"></a><a href="https://github.com/yakivmospan/scytale" target="_blank" rel="external">scytale</a></h2><p>包装了JCA API和AndroidKeyStore API, 让创建, 加密和管理任何Android API的keys变得更容易.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Firebase </tag>
            
            <tag> ExoPlayer </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> Android Things </tag>
            
            <tag> Java </tag>
            
            <tag> ContentProvider </tag>
            
            <tag> Architecture </tag>
            
            <tag> Concurrency </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 236]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/Design/2016/12/21/android-weekly-notes-issue-236/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-236"><a href="#Android-Weekly-Issue-236" class="headerlink" title="Android Weekly Issue #236"></a>Android Weekly Issue #236</h1><p>December 18th, 2016<br><a href="http://androidweekly.net/issues/issue-236" target="_blank" rel="external">Android Weekly Issue #236</a></p>
<p>本期内容包括: Google的物联网平台Android Things; FileProvider; Android Studio的Layout Preview使用; Retrofit2使用; Google Sign-In和SmartLock; 把敏感信息放入NDK的解决方式.</p>
<p>设计部分讨论了调色板的灵感来源和几个开发app的时候应该注意的问题.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Getting-started-with-Android-Things"><a href="#Getting-started-with-Android-Things" class="headerlink" title="Getting started with Android Things"></a><a href="https://medium.com/@alexsimo/getting-started-with-android-things-b73be3295b42#.c1arra4ps" target="_blank" rel="external">Getting started with Android Things</a></h2><p>Internet of Things (物联网, IoT), 是互联网, 传统电信网等咨询承载体, 让所有能行使独立功能的物品之间实现互联互通的网络.</p>
<p>2016年12月, Google发布了Android Things的开发者预览版, 这是一个专门为IoT设备定制的Android系统.</p>
<p>本篇文章一步一步地教你如何写一个IoT的基本程序, 跑在Raspberry Pi 3 Model B上.</p>
<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><a href="https://blog.stylingandroid.com/fileprovider/" target="_blank" rel="external">FileProvider</a></h2><p>上次我们提到了用<code>DownloadManager</code>下载的东西可以和其他应用分享, 那么如果我们下载的时候没有用<code>DownloadManager</code>呢? </p>
<p>比较常见的情况是我们的应用需要分享内容到其他应用, 或者是文件的类型是我们应用不能自己处理的, 需要找一个支持这种文件类型的其他应用来帮我们打开它.</p>
<p>怎么解决呢? 答案是用<code>FileProvider</code>.</p>
<p>上一期有一篇文章也说过Android 7开始废弃了”file://“, 解决方案就是用<code>FileProvider</code>, 所以实现是一样的, 这里就不重复了.</p>
<h2 id="Working-with-the-Layout-Preview"><a href="#Working-with-the-Layout-Preview" class="headerlink" title="Working with the Layout Preview"></a><a href="https://www.novoda.com/blog/layout-preview-101/" target="_blank" rel="external">Working with the Layout Preview</a></h2><p>Layout Preview向你展示了你的xml将如何在设备上显示. 你可以用它查看布局在不同的配置下如何显示, 比如可以切换横竖屏, 语言等等.</p>
<p>但是它同样也有一些问题:</p>
<p><strong>Issue #1: Preview显示空白</strong><br>当你的布局是由动态获取的数据来填充的, preview不知道如何填充, 所以你看到的是空白的. </p>
<p>一个好的practice是使用<code>tools</code>命名空间, 指定一些只在preview阶段使用的属性. 这样你就可以指定一些text或src用来预览.</p>
<p><strong>Tip #2: 使得动态内容在Preview可见</strong><br>如果你的图片是动态资源, 你也可以设置一些最大宽高给parent view, 以防真实的图片比期待的大太多或者是比例不对. 你可以设置<code>tools:layout_height</code> 和<code>tools:layout_width</code>, 还有<code>tools:background</code>在preview中查看view占多大.</p>
<p>本文还推荐了另一个阅读资料: <a href="https://tips.seebrock3r.me/tools-of-the-trade-part-1-f3c1c73de898#.e038jlqyy" target="_blank" rel="external">Tools of the trade — Part 1</a></p>
<p><strong>Tip #3: 修复坏掉的Previews</strong><br>当你创建一个自定义View的时候, 你需要确保你的View不需要任何外部依赖即可被实例化, 否则Preview可能看不到你的View. 因为Preview不是运行在你的app上的, 它只是运行在IDE的JVM上, 所以View framework之外的东西它是访问不到的.</p>
<p>解决办法是在你的自定义View中做一些特殊处理, 比如把依赖注入放在<code>!isInEditMode()</code>里, 或者用<code>tools:</code>命名空间加一些默认值.</p>
<p><strong>Tip #4: <merge> 布局没有被渲染</merge></strong></p>
<p><merge>里面的控件在preview里会被重叠在一起.<br>解决的办法是使用<code>tools:showIn=&quot;layout&quot;</code>, 指定<merge>具体是显示在哪个布局里. 如果你有多个布局都用到这个<merge>, 你可以选一个.</merge></merge></merge></p>
<p>从Android Studio 2.2开始, 你可以使用<code>tools:parentTag</code>来指定parent的类型, 比如<code>tools:parentTag=&quot;LinearLayout&quot;</code>.</p>
<p><strong>Tip #5: 在Preview中显示隐藏的View</strong><br>如果你在layout中把view的visibility设置为gone, 那么它是不会在Preview中显示的. </p>
<p>解决办法: 使用<code>tools:visibility=&quot;visible&quot;</code>.</p>
<h2 id="Android-Things-Tutorials"><a href="#Android-Things-Tutorials" class="headerlink" title="Android Things Tutorials"></a><a href="https://blog.mindorks.com/android-things-tutorials-getting-started-8464c11009ff#.dhacx13kq" target="_blank" rel="external">Android Things Tutorials</a></h2><p>Android Things教程.</p>
<h2 id="Get-Started-With-Retrofit-2-HTTP-Client"><a href="#Get-Started-With-Retrofit-2-HTTP-Client" class="headerlink" title="Get Started With Retrofit 2 HTTP Client"></a><a href="https://code.tutsplus.com/tutorials/getting-started-with-retrofit-2--cms-27792" target="_blank" rel="external">Get Started With Retrofit 2 HTTP Client</a></h2><p>本篇文章以实例讲述如何使用Retrofit, 虽然都是基础内容, 但讲解很详细.</p>
<h2 id="Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock"><a href="#Improving-sign-in-experience-with-Google-Sign-In-and-SmartLock" class="headerlink" title="Improving sign-in experience with Google Sign-In and SmartLock"></a><a href="https://medium.com/@p.tournaris/android-improving-sign-in-experience-with-google-sign-in-and-smartlock-f0bfd789602a#.dqh1aptm4" target="_blank" rel="external">Improving sign-in experience with Google Sign-In and SmartLock</a></h2><p>Google提供了两种方式来帮助我们改善用户的登录体验:<br>Google Sign-In(之前被称为Google+ Sign-In)和SmartLock.</p>
<p>这篇文章举例解释了Google Sign-In和SmartLock的实现.</p>
<p>Google Sign-In的部分比较简单.</p>
<p>SmartLock让我们可以:</p>
<ul>
<li>让用户保存credentials.</li>
<li>在打开应用的时候请求credentials.</li>
<li>使用存在Chrome上的credentials, 这样我们的网站和app就可以共享credentials.</li>
<li>显示Email提示, 让用户选择email地址.</li>
<li>所有的这些信息都保存在Google的server里, 用户可以保存或删除.</li>
</ul>
<p>Demo app: <a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">charbgr/AuthManager</a></p>
<h2 id="Storing-your-secure-information-in-the-NDK"><a href="#Storing-your-secure-information-in-the-NDK" class="headerlink" title="Storing your secure information in the NDK"></a><a href="https://www.androidsecurity.info/2016/12/15/storing-your-secure-information-in-the-ndk/" target="_blank" rel="external">Storing your secure information in the NDK</a></h2><p>这篇文章说敏感信息放在Java代码里不安全, 很容易被人反编译查看出来, 如果放在NDK里面就好一些, 你打开查看的只能是二进制文件, 很难找到.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Introduction-to-Natural-palettes"><a href="#Introduction-to-Natural-palettes" class="headerlink" title="Introduction to Natural palettes"></a><a href="https://stories.uplabs.com/introduction-to-natural-palettes-9503bfeee3d5#.z9y0xf7zc" target="_blank" rel="external">Introduction to Natural palettes</a></h2><p>作者从大自然的图像中得到颜色组合的灵感.<br>文章中举了几个例子, 如何用相关的照片找到相关主题的调色板.</p>
<p>另推荐一个网站: <a href="http://color.romanuke.com/" target="_blank" rel="external">IN COLOR<br> BALANCE</a></p>
<h2 id="Make-your-Android-app-look-better"><a href="#Make-your-Android-app-look-better" class="headerlink" title="Make your Android app look better"></a><a href="https://hackernoon.com/make-your-android-app-look-less-shitty-5dd63c4938f1#.4q5ro3ty8" target="_blank" rel="external">Make your Android app look better</a></h2><p>让你的App看起来更好的几点建议:</p>
<ul>
<li>使用同一个图标集的图标.<br>(这里推荐了一些图片工具和网站.)</li>
<li>使用Material Design设计的keylines, 使用固定的格子大小.</li>
<li>使用颜色的时候小心一些. (这里推荐了一些调色板网站)</li>
<li>选择字体要明智一些.</li>
</ul>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Material-Components"><a href="#Material-Components" class="headerlink" title="Material Components"></a><a href="https://github.com/material-components" target="_blank" rel="external">Material Components</a></h2><p>模块化和可定制的Material Design UI组件. Android, iOS, Web.</p>
<h2 id="Android-oss-from-Kickstarter"><a href="#Android-oss-from-Kickstarter" class="headerlink" title="Android-oss from Kickstarter"></a><a href="https://github.com/kickstarter/android-oss" target="_blank" rel="external">Android-oss from Kickstarter</a></h2><p>Kickstarter开源了他们的Android应用.</p>
<h2 id="stencil"><a href="#stencil" class="headerlink" title="stencil"></a><a href="https://github.com/thoughtbot/stencil" target="_blank" rel="external">stencil</a></h2><p>一个kotlin写的Android库, 实现一种文字路径的动画.</p>
<h2 id="AuthManager"><a href="#AuthManager" class="headerlink" title="AuthManager"></a><a href="https://github.com/charbgr/AuthManager" target="_blank" rel="external">AuthManager</a></h2><p>包装了Google Sign-In和SmartLock的Manager.</p>
<h2 id="FolioReader-Android"><a href="#FolioReader-Android" class="headerlink" title="FolioReader-Android"></a><a href="https://github.com/FolioReader/FolioReader-Android" target="_blank" rel="external">FolioReader-Android</a></h2><p>一个ePub阅读器和解析框架.</p>
<h2 id="BufferTextInputLayout"><a href="#BufferTextInputLayout" class="headerlink" title="BufferTextInputLayout"></a><a href="https://github.com/bufferapp/BufferTextInputLayout" target="_blank" rel="external">BufferTextInputLayout</a></h2><p>对Support Library中的<code>TextInputLayout</code>的扩展, 增加了字数统计.</p>
<h2 id="TextLayoutBuilder"><a href="#TextLayoutBuilder" class="headerlink" title="TextLayoutBuilder"></a><a href="https://facebookincubator.github.io/TextLayoutBuilder/" target="_blank" rel="external">TextLayoutBuilder</a></h2><p>使用Builder模式来配置创建一个Layout的属性.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
            <category> Design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Security </tag>
            
            <tag> Android Studio </tag>
            
            <tag> Design </tag>
            
            <tag> IoT </tag>
            
            <tag> Android Things </tag>
            
            <tag> FileProvider </tag>
            
            <tag> IDE </tag>
            
            <tag> Retrofit2 </tag>
            
            <tag> Sign In </tag>
            
            <tag> SmartLock </tag>
            
            <tag> NDK </tag>
            
            <tag> Color </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 235]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/12/16/android-weekly-notes-issue-235/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-235"><a href="#Android-Weekly-Issue-235" class="headerlink" title="Android Weekly Issue #235"></a>Android Weekly Issue #235</h1><p>December 11th, 2016<br><a href="http://androidweekly.net/issues/issue-235" target="_blank" rel="external">Android Weekly Issue #235</a><br>本期内容包括: 开发一个自定义View并发布为开源库的完整流程介绍; 用<code>AnimatedVectorDrawable</code>实现的动画; 什么样的程序是可测试的; <code>DownloadManager</code>介绍; Okhttp的重试; Android 7取消了<code>file://</code>; Android Studio即将推出的build cache功能; 支持离线模式的app构架; 如何写自定义的lint规则; Epoxy, 一个处理复杂RecyclerView屏的库; <code>FragmentPagerAdapter</code>和<code>FragmentStatePagerAdapter</code>的比较等. </p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Make-an-android-custom-view-publish-and-open-source"><a href="#Make-an-android-custom-view-publish-and-open-source" class="headerlink" title="Make an android custom view, publish and open source "></a><a href="https://medium.com/dualcores-studio/make-an-android-custom-view-publish-and-open-source-99a3d86df228#.zc8s14lek" target="_blank" rel="external">Make an android custom view, publish and open source </a></h2><p>作者开发了一个环形的SeekBar, 并把它作为一个库发布到了JCenter.</p>
<p><strong>作者首先讲了自定义View的实现</strong>:<br>首先是关于View生命周期的介绍, 在写自定义View的时候有几个关键的生命周期回调需要处理:<br><img src="/images/view-lifecycle-diagram-lite-version.png" alt="view-lifecycle-diagram-lite-version"></p>
<p>作者实现的几个关键步骤讲解:</p>
<ul>
<li>自定义属性并获取.</li>
<li>在<code>onMeasure()</code>中控制尺寸.</li>
<li>在<code>onDraw()</code>中绘制: 避免在<code>onDraw()</code>中分配内存; 用<code>invalidate()</code>方法来激发重绘.</li>
<li>在<code>onTouchEvent()</code>处理用户手势. 在他的环形SeekBar的实现里, 这里涉及到了点击坐标到角度的转换. </li>
</ul>
<p><strong>将自定义View库开源到Github</strong>:<br>开源到Github有个好的README很重要, 这里有几个tips:</p>
<ul>
<li>提供截图, Gif或者Video.</li>
<li>提供安装/使用说明.<br>作者自己的库: <a href="https://github.com/enginebai/SwagPoints" target="_blank" rel="external">SwagPoints</a></li>
</ul>
<p><strong>发布库</strong>:</p>
<ul>
<li>去<a href="https://bintray.com/" target="_blank" rel="external">JFrog Bintray</a>注册.</li>
<li>创建repository, package, 和版本号.</li>
<li>生成并上传, 用了<a href="https://github.com/blundell/release-android-library" target="_blank" rel="external">这个library</a>.</li>
<li>添加到Jcenter.</li>
<li>被接受之后收到邮件, 就可以使用了.</li>
</ul>
<h2 id="Animation-Jump-through"><a href="#Animation-Jump-through" class="headerlink" title="Animation: Jump-through"></a><a href="https://medium.com/google-developers/animation-jump-through-861f4f5b3de4#.k238d5tw2" target="_blank" rel="external">Animation: Jump-through</a></h2><p>用<code>AnimatedVectorDrawable</code>实现的一个很fancy的位置标志动画.</p>
<h2 id="What-makes-Android-Apps-Testable"><a href="#What-makes-Android-Apps-Testable" class="headerlink" title="What makes Android Apps Testable"></a><a href="http://www.philosophicalhacker.com/post/what-makes-android-apps-testable/" target="_blank" rel="external">What makes Android Apps Testable</a></h2><p>如果程序的架构不适合测试, 那么硬要写一些测试很可能就会面临这样的局面: 要么就是发现没法写测试, 要么就是为了写测试而破坏了代码, 做了一些奇怪的事情.</p>
<p>那么到底是什么样的程序才是适合写测试, 或者是可测试的呢?</p>
<p>有一个有趣的定义是seam(接缝), 在接缝处你可以改变程序的行为, 而不用编辑当前程序. 如果程序没有接缝, 你将无法设置测试的初始条件和验证测试结果.</p>
<p>本文中举了一个实际的例子, 开始的时候程序没有seam, 所以导致无法测试, 后来把静态方法改为实例的方法之后, 我们就可以通过Mockito来模拟行为, 设置条件, 最后通过验证某一方法的调用与否来进行验证.</p>
<h2 id="DownloadManager-–-Part-3"><a href="#DownloadManager-–-Part-3" class="headerlink" title="DownloadManager – Part 3"></a><a href="https://blog.stylingandroid.com/downloadmanager-part-3/" target="_blank" rel="external">DownloadManager – Part 3</a></h2><p>用<code>DownloadManager</code>来处理下载.<br>首先它在设备上有自己的UI, 还有notification, 还有Downloads app能让用户管理下载文件.</p>
<p> 我们可以查询到文件的一些信息, 比如MIME type, 文件尺寸, 下载状态等.</p>
<p> 我们还可以用<code>getUriForDownloadedFile()</code>方法来获取一个URI, 配合MIME type, 发送Intent, 来打开一个相关的查看程序.</p>
<p> 关于储存文件的合适地点:</p>
<ul>
<li>文件小, 仅app自己使用 -&gt; 私有数据区域(默认行为).</li>
<li>文件大, 仅app自己使用 -&gt; 外部存储的私有数据区域(不需要权限). <code>setDestinationInExternalFilesDir()</code>.</li>
<li>文件需要被别的应用访问 -&gt; 外部存储的共有区域, 需要<code>WRITE_EXTERNAL_STORAGE</code>权限. <code>setDestinationInExternalPublicDir()</code>.</li>
</ul>
<h2 id="OkHttp-is-quietly-retrying-requests-Is-your-API-ready"><a href="#OkHttp-is-quietly-retrying-requests-Is-your-API-ready" class="headerlink" title="OkHttp is quietly retrying requests. Is your API ready?"></a><a href="https://medium.com/inloop/okhttp-is-quietly-retrying-requests-is-your-api-ready-19489ef35ace#.ldxyyly7t" target="_blank" rel="external">OkHttp is quietly retrying requests. Is your API ready?</a></h2><p>在网路较慢或不稳定的时候, OkHttp有可能会重复发送请求, 直到成功. </p>
<p>这个重试的逻辑是通过<a href="https://github.com/square/okhttp/blob/07309c1c7d9e296014268ebd155ebf7ef8679f6c/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java" target="_blank" rel="external">RetryAndFollowUpInterceptor.java</a>实现的.</p>
<p>那么, 我们可以关掉这个重试行为吗? 有一些issues就在讨论这个问题: <a href="https://github.com/square/okhttp/issues/1043" target="_blank" rel="external">Issue # 1043</a>. 后来有两个pull requests:  <a href="https://github.com/square/okhttp/pull/1259" target="_blank" rel="external">PR #1259</a>和<a href="https://github.com/square/okhttp/pull/2479" target="_blank" rel="external">PR #2479</a>改进了这个问题, 减少(但并没有消除)了不必要的retry请求.</p>
<p>全局关闭重试行为: <code>OkHttpClient.Builder .retryOnConnectionFailure()</code>设置为false. 但是注意这样是很粗暴并具有破坏性的, 消除了retry逻辑带来的好处:</p>
<ul>
<li>如果Url有多个IP, 失败了一个还可以试另一个.</li>
<li>连接池中的连接偶尔会time out, 减少这种意外导致的后果.</li>
<li>可以顺次查找多个代理, 如果都失败了再转向直接连接.</li>
</ul>
<p><strong>解决真正的问题</strong>: 关闭静默重试在某些情形下有帮助, 但是其实它隐藏了真正的问题, 就是你的API是否是幂等的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">idempotent</a>. server端可以根据客户端的GUID来检测重复, 这样server就不会多次执行操作, 会通知发送者.</p>
<h2 id="File-scheme-is-now-not-allowed-with-Intent-on-N"><a href="#File-scheme-is-now-not-allowed-with-Intent-on-N" class="headerlink" title="File scheme is now not allowed with Intent on N"></a><a href="https://inthecheesefactory.com/blog/how-to-share-access-to-file-with-fileprovider-on-android-nougat/en" target="_blank" rel="external">File scheme is now not allowed with Intent on N</a></h2><p>Android N (Nougat, API 24)开始, 不再允许发送<code>file://</code>的Intent, 将会直接抛出<code>FileUriExposedException</code>异常.</p>
<p>所以当你把<code>targetSdkVersion</code>改为24之后, 你必须要确保你修复了这些问题再发布.</p>
<p>解决方案是什么呢? 用<code>content://</code>, 结合<code>FileProvider</code>:<br>首先在manifest里面声明:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></div><div class="line">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.provider"</span></div><div class="line">    <span class="attr">android:exported</span>=<span class="string">"false"</span></div><div class="line">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></div><div class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>res\xml\provider_paths.xml</code>文件里指明路径:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external_files"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最后, 把<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uri photoURI = Uri.fromFile(createImageFile());</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri photoURI = FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,</div><div class="line">        BuildConfig.APPLICATION_ID + <span class="string">".provider"</span>,</div><div class="line">        createImageFile());</div></pre></td></tr></table></figure></p>
<p>然后放在Intent里发送就好了.</p>
<p>注意, 如果你的<code>targetSdkVersion</code>还没有更新到24, 那么即便是在Nougat的手机上<code>file://</code>也仍然是能正常使用的.</p>
<h2 id="Use-Android-Studio-Gradle-Build-Cache-for-faster-builds"><a href="#Use-Android-Studio-Gradle-Build-Cache-for-faster-builds" class="headerlink" title="Use Android Studio Gradle Build Cache for faster builds"></a><a href="http://zeroturnaround.com/rebellabs/using-build-cache-in-android-studio-makes-gradle-build-faster/" target="_blank" rel="external">Use Android Studio Gradle Build Cache for faster builds</a></h2><p>Android Studio当前的最新版是2.3 Canary 2. 有一些新的改进, 但是其中最吸引人的是这个<a href="http://tools.android.com/tech-docs/build-cache" target="_blank" rel="external">build cache</a>. 它会使你的clean build更快.</p>
<p>本文后面解析了build cache的工作原理.</p>
<h2 id="Offline-App-Architecture-build-for-the-Next-Billion"><a href="#Offline-App-Architecture-build-for-the-Next-Billion" class="headerlink" title="Offline App Architecture, build for the Next Billion"></a><a href="https://hackernoon.com/so-you-want-to-develop-for-the-next-billion-9eb072c26bc8#.1zklimr3o" target="_blank" rel="external">Offline App Architecture, build for the Next Billion</a></h2><p>一个好的应用应该在网络不好甚至离线的时候仍然可以使用, 我们应该做些什么呢?</p>
<ul>
<li>确定连接状况. 可以使用这个<a href="https://github.com/facebook/network-connection-class" target="_blank" rel="external">network-connection-class
</a>. 如果你使用的是Okhttp, 可以加一个Intercepter来进行采样.</li>
<li>有效地缓存. 从网络取数据很慢并且昂贵, 所以有效地利用之前取到的数据是很关键的优化. (Cache-Control, Etag).</li>
<li>在本地操作, 在全局同步. 等网络请求的时候可以先显示本地数据, 而不是loading.</li>
<li>有效地处理线程.</li>
<li>优化图片. 网络不好的时候先用RGB_565, 等网络变好了再取高质量图片.</li>
<li>使用大Cookie. 尽量一次传输更多的数据(big cookie), 而不是频繁发送一些小请求(small cookies).</li>
</ul>
<h2 id="Writing-custom-lint-rules-and-integrating-them"><a href="#Writing-custom-lint-rules-and-integrating-them" class="headerlink" title="Writing custom lint rules and integrating them"></a><a href="https://medium.com/@mosesJay/writing-custom-lint-rules-and-integrating-them-with-android-studio-inspections-or-carefulnow-c54d72f00d30#.5y0o98bor" target="_blank" rel="external">Writing custom lint rules and integrating them</a></h2><p>如何创建自定义的lint规则.<br>事情的由来是作者发现了一个死循环调用, 然后他想做一个什么标记以防以后其他人会犯同样的错误.</p>
<p>然后他想到的是<a href="https://developer.android.com/studio/write/annotations.html#adding-nullness" target="_blank" rel="external">@Nullable注解</a>, 的检查, 实质是依靠<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">lint</a>来实现的.</p>
<p>于是他自己写了一个自定义的lint规则, 来提示使用用他的注解<code>@CarefulNow</code>标记的方法时应当注意.<br>详细的实现方式请看原文.</p>
<h2 id="Epoxy-Airbnb’s-View-Architecture-on-Android"><a href="#Epoxy-Airbnb’s-View-Architecture-on-Android" class="headerlink" title="Epoxy: Airbnb’s View Architecture on Android"></a><a href="https://medium.com/airbnb-engineering/epoxy-airbnbs-view-architecture-on-android-c3e1af150394#.uyvuayspc" target="_blank" rel="external">Epoxy: Airbnb’s View Architecture on Android</a></h2><p><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a>是一个Android库, 用来处理复杂的RecyclerView屏. 本文介绍了它在项目中实际的使用.</p>
<h2 id="Adventures-with-FragmentStatePagerAdapter"><a href="#Adventures-with-FragmentStatePagerAdapter" class="headerlink" title="Adventures with FragmentStatePagerAdapter"></a><a href="https://medium.com/inloop/adventures-with-fragmentstatepageradapter-4f56a643f8e0#.qk6aygake" target="_blank" rel="external">Adventures with FragmentStatePagerAdapter</a></h2><p>可能有很多Android开发者对于<br><a href="https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html" target="_blank" rel="external">FragmentPagerAdapter</a>和<a href="https://developer.android.com/reference/android/support/v4/app/FragmentStatePagerAdapter.html" target="_blank" rel="external">FragmentStatePagerAdapter</a>的区别不是太清楚或根本不知道, 本文作者就具体介绍了二者的不同.</p>
<p><strong>基本不同</strong></p>
<p><code>FragmentPagerAdapter</code><br>适用于项目个数确定的情形.<br>为什么呢? 因为一旦fragment的实例被创建, 它永远也不会从<code>FragmentManager</code>中移除, 直到Activity被销毁.</p>
<p>当Fragment不见的时候, 仅仅是<code>onDestroyView()</code>被调用, 当fragment再次回来时, 再调用<code>onCreateView()</code>.</p>
<p><code>FragmentStatePagerAdapter</code><br>当fragment的实例不可达的时候, 实例就会立即从<code>FragmentManager</code>移除. 被移除的fragment实例的状态由<code>FragmentStatePagerAdapter</code>保存, 当你再次回到该项的时候, fragment会重建新实例, 并且状态被恢复. 所以这种adapter适用于项目个数不确定或的情况.</p>
<p>所以使用<code>FragmentPagerAdapter</code>的时候需要注意内存问题.</p>
<p><strong>notifyDatasetChanged()的问题</strong>.</p>
<p><code>notifyDataSetChanged()</code>是用来处理数据集变化的情况, 比如一些项目增删的情况. 这个方法不是用来刷新当前显示的Fragment或其中的Views的.</p>
<p>文章中还有一些关于数据改变实现以及现有issue的讨论. 为了解决issue作者还发布了一个库<a href="https://github.com/inloop/UpdatableFragmentStatePagerAdapter" target="_blank" rel="external">UpdatableFragmentStatePagerAdapter</a>.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="KeepActivitiesTile"><a href="#KeepActivitiesTile" class="headerlink" title="KeepActivitiesTile"></a><a href="https://github.com/Stocard/KeepActivitiesTile" target="_blank" rel="external">KeepActivitiesTile</a></h2><p>一个quick settings tile来开启”Don’t keep activities”.</p>
<h2 id="WaveLoading"><a href="#WaveLoading" class="headerlink" title="WaveLoading"></a><a href="https://github.com/race604/WaveLoading" target="_blank" rel="external">WaveLoading</a></h2><p>一个波形的loading图, 水面上涨代表loading程度.</p>
<h2 id="coordinators"><a href="#coordinators" class="headerlink" title="coordinators"></a><a href="https://github.com/square/coordinators" target="_blank" rel="external">coordinators</a></h2><p>Simple MVWhatever for Android.</p>
<h2 id="epoxy"><a href="#epoxy" class="headerlink" title="epoxy"></a><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a></h2><p>一个处理复杂的RecyclerView屏的库.</p>
<h2 id="Screen-Record-for-Android"><a href="#Screen-Record-for-Android" class="headerlink" title="Screen Record for Android"></a><a href="https://gist.github.com/tasomaniac/93cefd97af13e2ea2b2f248affb373bd" target="_blank" rel="external">Screen Record for Android</a></h2><p>录屏脚本.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> AnimatedVectorDrawable </tag>
            
            <tag> Animation </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> Android Studio </tag>
            
            <tag> Nougat </tag>
            
            <tag> Android 7 </tag>
            
            <tag> Test </tag>
            
            <tag> Custom View </tag>
            
            <tag> JCenter </tag>
            
            <tag> DownloadManager </tag>
            
            <tag> OkHttp </tag>
            
            <tag> Offline Architecture </tag>
            
            <tag> lint </tag>
            
            <tag> FragmentPagerAdapter </tag>
            
            <tag> FragmentStatePagerAdapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 234]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/React-Native/Java/2016/12/13/android-weekly-notes-issue-234/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-234"><a href="#Android-Weekly-Issue-234" class="headerlink" title="Android Weekly Issue #234"></a>Android Weekly Issue #234</h1><p>December 4th, 2016<br><a href="http://androidweekly.net/issues/issue-234" target="_blank" rel="external">Android Weekly Issue #234</a><br>本期内容包括: ConstraintLayout的使用; React Native教程; fastlane管理模拟器; Android中的任务调度; 文字sticker的实现; 给Android library加flavor; 更好的关键帧动画; SQLDelight的使用; icon Animation; OkLog的使用等等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Guide-to-ConstraintLayout"><a href="#Guide-to-ConstraintLayout" class="headerlink" title="Guide to ConstraintLayout"></a><a href="https://medium.com/@loutry/guide-to-constraintlayout-407cd87bc013#.pdg54u72z" target="_blank" rel="external">Guide to ConstraintLayout</a></h2><p>这篇文章教你如何使用<code>ConstraintLayout</code>, 有很多实际的例子.</p>
<h2 id="React-Native-Express"><a href="#React-Native-Express" class="headerlink" title="React Native Express"></a><a href="http://www.reactnativeexpress.com/" target="_blank" rel="external">React Native Express</a></h2><p>一步一步地教你跨平台的Reactive Native, 比官方的文档要深入, 并且提供例子.</p>
<h2 id="Managing-Android-Virtual-Devices-during-test-session"><a href="#Managing-Android-Virtual-Devices-during-test-session" class="headerlink" title="Managing Android Virtual Devices during test session"></a><a href="https://medium.com/azimolabs/managing-android-virtual-devices-during-test-session-98a403acffc2#.cu4nfhl6u" target="_blank" rel="external">Managing Android Virtual Devices during test session</a></h2><p>作者他们用<a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">fastlane</a>管理模拟器, 并且开发了一个插件.</p>
<h2 id="You-don’t-have-to-use-WeakReference-to-avoid-memory-leaks"><a href="#You-don’t-have-to-use-WeakReference-to-avoid-memory-leaks" class="headerlink" title="You don’t have to use WeakReference to avoid memory leaks"></a><a href="https://medium.com/google-developer-experts/weakreference-in-android-dd1e66b9be9d#.vmxu20g30" target="_blank" rel="external">You don’t have to use WeakReference to avoid memory leaks</a></h2><p>并不是到处都要用<code>WeakReference</code>来避免内存泄漏.</p>
<h2 id="Effective-Java-for-Android"><a href="#Effective-Java-for-Android" class="headerlink" title="Effective Java for Android"></a><a href="https://medium.com/rocknnull/effective-java-for-android-cheatsheet-bf4e3433889a#.8t44xdb4t" target="_blank" rel="external">Effective Java for Android</a></h2><p>一个cheat-sheet, Effective Java中提到的内容, 作者列出了他认为在Android开发中最重要的几项:</p>
<ul>
<li>用private来限制不可实例化.</li>
<li>使用静态工厂方法.</li>
<li>使用Builders.</li>
<li>避免互换性.</li>
<li>静态内部类.</li>
<li>使用泛型.</li>
<li>返回空的集合而不是null.</li>
<li>字符串连接用StringBuilder, 不要用+.</li>
<li>可恢复的异常.</li>
</ul>
<h2 id="Scheduling-tasks-in-Android-made-easy"><a href="#Scheduling-tasks-in-Android-made-easy" class="headerlink" title="Scheduling tasks in Android made easy"></a><a href="https://blog.hypertrack.io/2016/12/01/scheduling-tasks-in-android-made-easy/" target="_blank" rel="external">Scheduling tasks in Android made easy</a></h2><p>分发异步任务的时候, 用很多选择: <code>AlarmManager</code>, <code>Handler</code>, <code>JobSheduler</code>, <code>GcmNetworkManager</code>. 作者他们的库: <a href="https://github.com/hypertrack/smart-scheduler-android" target="_blank" rel="external">smart-scheduler-android</a>就是用来有效地处理异步任务调度问题.</p>
<h2 id="How-to-create-beautiful-text-stickers-for-Android"><a href="#How-to-create-beautiful-text-stickers-for-Android" class="headerlink" title="How to create beautiful text stickers for Android"></a><a href="https://medium.com/uptech-team/how-to-create-beautiful-text-stickers-for-android-10eeea0cee09#.11x8ar94q" target="_blank" rel="external">How to create beautiful text stickers for Android</a></h2><p>之前作者有一篇文章讲了如何创建Snapchat一样的图片stickers.</p>
<p>本篇讲如何创建文字的stickers, 代码: <a href="https://github.com/uptechteam/MotionViews-Android" target="_blank" rel="external">MotionViews-Android</a>.</p>
<h2 id="Elite-Worship"><a href="#Elite-Worship" class="headerlink" title="Elite Worship"></a><a href="http://blog.sqisland.com/2016/12/elite-worship.html" target="_blank" rel="external">Elite Worship</a></h2><p>Chiu-Ki Chan分享了一些她的看法, 关于精英崇拜, 和如何让社区更加平等, 鼓励每一个人都参与进来.</p>
<h2 id="Product-Flavors-for-Android-Libraries"><a href="#Product-Flavors-for-Android-Libraries" class="headerlink" title="Product Flavors for Android Libraries"></a><a href="https://medium.com/@sahildave/product-flavors-for-android-library-d3b2d240fca2#.ravhhk30a" target="_blank" rel="external">Product Flavors for Android Libraries</a></h2><p>如何给Android Library加上不同的flavor使用.</p>
<h2 id="Keyframes-Delivering-scalable-high-quality-animations"><a href="#Keyframes-Delivering-scalable-high-quality-animations" class="headerlink" title="Keyframes: Delivering scalable, high-quality animations"></a><a href="https://code.facebook.com/posts/354469174916519" target="_blank" rel="external">Keyframes: Delivering scalable, high-quality animations</a></h2><p>Facebook分享了一个库<a href="https://github.com/facebookincubator/Keyframes" target="_blank" rel="external">Keyframes</a>用来导出AE的动画, 并且在移动设备上播放它.</p>
<h2 id="SQLDelight-Getting-Started"><a href="#SQLDelight-Getting-Started" class="headerlink" title="SQLDelight: Getting Started"></a><a href="https://medium.com/@tonyowen/sqldelight-getting-started-67054fe51306#.rske25ore" target="_blank" rel="external">SQLDelight: Getting Started</a></h2><p><a href="https://github.com/square/sqldelight" target="_blank" rel="external">sqldelight</a>是一个库, 可以用SQL语句来生成Java Model类.<br>SQLDelight也是一个Intellij插件.</p>
<p>作者介绍了如何使用SQLDelight, 注意生成models需要结合AutoValue.</p>
<h2 id="Your-ViewHolders-are-Dumb-Make-’em-Not-Dumb"><a href="#Your-ViewHolders-are-Dumb-Make-’em-Not-Dumb" class="headerlink" title="Your ViewHolders are Dumb. Make ’em Not Dumb"></a><a href="https://medium.com/@jonfhancock/your-viewholders-are-dumb-make-em-not-dumb-82e6f73f630c#.auaur0y3r" target="_blank" rel="external">Your ViewHolders are Dumb. Make ’em Not Dumb</a></h2><p>作者举例说明ViewHolder应该如何优化代码, 解放Adapter.</p>
<h2 id="An-Introduction-to-Icon-Animation-Techniques"><a href="#An-Introduction-to-Icon-Animation-Techniques" class="headerlink" title="An Introduction to Icon Animation Techniques"></a><a href="http://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html" target="_blank" rel="external">An Introduction to Icon Animation Techniques</a></h2><p>如何创建漂亮的icon动画.</p>
<h2 id="OkLog-2-0-—-improved-Android-network-logging"><a href="#OkLog-2-0-—-improved-Android-network-logging" class="headerlink" title="OkLog 2.0 — improved Android network logging"></a><a href="https://medium.com/@simonpercic/oklog-2-0-improved-android-network-logging-a72b2ffe4c66#.6h8w44eh8" target="_blank" rel="external">OkLog 2.0 — improved Android network logging</a></h2><p><a href="https://github.com/simonpercic/OkLog" target="_blank" rel="external">OkLog</a>是一个库, 可以在logcat中打印网络请求和响应, 点击进入页面查看, 本文介绍2.0版本的改进.</p>
<h2 id="How-to-Build-an-Android-App-for-Fire-TV-Part-4"><a href="#How-to-Build-an-Android-App-for-Fire-TV-Part-4" class="headerlink" title="How to Build an Android App for Fire TV (Part 4)"></a><a href="https://medium.com/amazon-appstore/developing-for-the-living-room-how-to-build-an-android-app-for-fire-tv-part-4-cbe572a6f1e6#.zfg39casg" target="_blank" rel="external">How to Build an Android App for Fire TV (Part 4)</a></h2><p>本文是为Fire TV搭建一个Android App系列文章的第四篇.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-PageFlip"><a href="#android-PageFlip" class="headerlink" title="android-PageFlip"></a><a href="https://github.com/eschao/android-PageFlip" target="_blank" rel="external">android-PageFlip</a></h2><p>3D的翻页效果.</p>
<h2 id="smart-scheduler-android"><a href="#smart-scheduler-android" class="headerlink" title="smart-scheduler-android"></a><a href="https://github.com/hypertrack/smart-scheduler-android" target="_blank" rel="external">smart-scheduler-android</a></h2><p>用于周期性和非周期性任务分发的工具类.</p>
<h2 id="PageLoader"><a href="#PageLoader" class="headerlink" title="PageLoader"></a><a href="https://github.com/arieridwan8/pageloader" target="_blank" rel="external">PageLoader</a></h2><p>一个简单的可定制化的loading页面库.</p>
<h2 id="fastlane-plugin-automated-test-emulator-run"><a href="#fastlane-plugin-automated-test-emulator-run" class="headerlink" title="fastlane-plugin-automated-test-emulator-run"></a><a href="https://github.com/AzimoLabs/fastlane-plugin-automated-test-emulator-run" target="_blank" rel="external">fastlane-plugin-automated-test-emulator-run</a></h2><p>fastlane插件, 用于启动模拟器进行自动化测试.</p>
<h2 id="Keyframes"><a href="#Keyframes" class="headerlink" title="Keyframes"></a><a href="https://github.com/facebookincubator/Keyframes" target="_blank" rel="external">Keyframes</a></h2><p>导出AE动画并在移动设备上播放的库.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
            <category> React Native </category>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Animation </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> React Native </tag>
            
            <tag> fastlane </tag>
            
            <tag> Effective Java </tag>
            
            <tag> Sticker </tag>
            
            <tag> Flavor </tag>
            
            <tag> SQLDelight </tag>
            
            <tag> OkLog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 233]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/Java/2016/12/01/android-weekly-notes-issue-233/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-233"><a href="#Android-Weekly-Issue-233" class="headerlink" title="Android Weekly Issue #233"></a>Android Weekly Issue #233</h1><p>November 27th, 2016<br><a href="http://androidweekly.net/issues/issue-233" target="_blank" rel="external">Android Weekly Issue #233</a><br>本期内容包括: 用Mockito做RxJava的单元测试; Android开发中的命令行使用; Android 7.1的App Shortcuts; 自定义View的绘制; 用Firebase的Remote Config进行feature逐步分发; APK分析工具的使用, APK瘦身讨论; RxJava处理网络请求和缓存; presenter的设计; 用Firebase发送push notification; transient关键字的使用等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Testing-asynchronous-RxJava-code-using-Mockito"><a href="#Testing-asynchronous-RxJava-code-using-Mockito" class="headerlink" title="Testing asynchronous RxJava code using Mockito"></a><a href="https://medium.com/@fabioCollini/testing-asynchronous-rxjava-code-using-mockito-8ad831a16877#.yhndxn3y1" target="_blank" rel="external">Testing asynchronous RxJava code using Mockito</a></h2><p>这篇文章讲了如何用Mockito给RxJava的异步请求代码写单元测试.<br>内容包括了:</p>
<ul>
<li>如何设置Mockito的默认返回值. (通过自定义的<code>MockitoConfiguration</code>类).</li>
<li>如何把异步变为同步测试. (1.用<code>blockingGet()</code>; 2.在RxJava2中, 可以使用<code>TestObserver</code>的<code>awaitTerminalEvent()</code>).</li>
<li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a>的使用.</li>
<li>测试异步代码. 使用Rule来替换原来的scheduler.</li>
<li><code>flatMap()</code>, <code>concatMap()</code>, <code>concatMapEager()</code>操作符的使用.</li>
<li>测试Timeout.</li>
<li>测试异常和retry逻辑.</li>
</ul>
<p>好用的工具: <a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a><br>用来更方便地写Java测试中的assert语句.</p>
<h2 id="Mastering-the-Terminal-side-of-Android-development"><a href="#Mastering-the-Terminal-side-of-Android-development" class="headerlink" title="Mastering the Terminal side of Android development"></a><a href="https://medium.com/@cesarmcferreira/mastering-the-terminal-side-of-android-development-e7520466c521#.5pjzgdn2s" target="_blank" rel="external">Mastering the Terminal side of Android development</a></h2><p>作者分享了在Android开发中他是如何使用命令行的.</p>
<p>使用更好的命令行程序: <a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a>.<br>它有很多有用的<a href="https://www.iterm2.com/features.html" target="_blank" rel="external">features</a>, 比如分屏, 自定义颜色, 粘贴历史等.</p>
<p><strong>on-my-zsh</strong>: </p>
<p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">on-my-zsh</a>内置了一个<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="external">git plugin</a>, 提供了很多aliases和功能.</p>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="external">zsh-autosuggestions</a>会在你输入的时候根据历史提供建议.</p>
<p>你可以用Ctrl + R在命令历史中进行逆向智能搜索(Reverse intelligent search). 你开始输入这个命令, 命令行会在历史中寻找并自动补全. 你可以按Enter来执行这个命令, 或者左右箭头来编辑命令, 或者继续按Ctrl + R在其他可能的命令中寻找.</p>
<p><strong>dryrun</strong></p>
<p>如果你在github上看到一个程序, 想要运行一下看看, 你不必再把它下载下来, 导入Android Studio了.</p>
<p>你只需要用<a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="external">dryrun</a>, 一句命令就可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dryrun REMOTE_GIT_URL</div></pre></td></tr></table></figure></p>
<p><strong>Build faster, build offline</strong></p>
<p>在build的时候使用–offline可以让所有依赖都使用缓存版本, 不再进行网络请求, 从而加快执行速度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./gradlew assembleDevelopDebug --offline</div><div class="line">./gradlew test --offline</div></pre></td></tr></table></figure></p>
<p>在Android Studio中也可以进行设置.<br>在<code>Settings -&gt; Build, Execution, Deployment -&gt; Build tools -&gt; Gradle</code>中勾选<code>Offline work</code>即可.</p>
<p><strong>alfi</strong><br><a href="https://github.com/cesarferreira/alfi" target="_blank" rel="external">alfi</a>是一个工具, 装了这个工具之后, 用一行命令就可以查到第三方库的依赖语句, 然后你就可以把它拷贝粘贴到<code>build.gradle</code>中去了.</p>
<p><strong>gradle tasks shortcuts</strong><br>gradle的task有缩写版的, 比如:</p>
<ul>
<li>iDD for installDevelopmentDebug</li>
<li>aDD for assembleDevelopmentDebug</li>
<li>cC for connectedCheck</li>
</ul>
<p><strong>Android Rocket Launcher</strong><br><a href="https://github.com/cesarferreira/android-rocket-launcher" target="_blank" rel="external">Android Rocket Launcher</a>增加新的tasks, 在命令行启动应用.</p>
<p><strong>直接在console输出单元测试结果</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  ...</div><div class="line">  testOptions.unitTests.all &#123;</div><div class="line">    testLogging &#123;</div><div class="line">      events &apos;passed&apos;, &apos;skipped&apos;, &apos;failed&apos;, &apos;standardOut&apos;, &apos;standardError&apos;</div><div class="line">      outputs.upToDateWhen &#123; false &#125;</div><div class="line">      showStandardStreams = true</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个工具<a href="https://github.com/JakeWharton/pidcat" target="_blank" rel="external">pidcat</a>可以指定包名显示log.</p>
<h2 id="Exploring-Android-Nougat-7-1-App-Shortcuts"><a href="#Exploring-Android-Nougat-7-1-App-Shortcuts" class="headerlink" title="Exploring Android Nougat 7.1 App Shortcuts"></a><a href="https://www.novoda.com/blog/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></h2><p>这篇文章讲Android 7.1推出的App Shortcuts如何实现.</p>
<h2 id="The-Quirks-of-Supporting-SDK-25"><a href="#The-Quirks-of-Supporting-SDK-25" class="headerlink" title="The Quirks of Supporting SDK 25"></a><a href="http://www.zdominguez.com/2016/11/the-quirks-of-supporting-sdk-25.html" target="_blank" rel="external">The Quirks of Supporting SDK 25</a></h2><p>作者分享了她在适配Nougat, API 25时学到的东西, 包括更换SDK版本, 圆形的启动icon, 还有app shortcuts. (根据文中的图标, 这个app居然是domain).</p>
<h2 id="Android-draw-a-custom-view"><a href="#Android-draw-a-custom-view" class="headerlink" title="Android: draw a custom view"></a><a href="https://medium.com/@romandanylyk96/android-draw-a-custom-view-ef79fe2ff54b#.i4ipiz2u7" target="_blank" rel="external">Android: draw a custom view</a></h2><p>作者自定义了一个ViewPager的page indicator: <a href="https://github.com/romandanylyk/PageIndicatorView" target="_blank" rel="external">PageIndicatorView</a>.</p>
<p>这篇文章讲述了如何自定义View, 首先是View的生命周期, 然后是具体如何实现, 如何避免一些常见的错误, 最后是如何添加View的动画.<br><img src="/images/view-lifecycle.png" alt="view-lifecycle"></p>
<p><strong>各个生命周期中应该干的事情</strong>:</p>
<ul>
<li>构造函数中: 解析自定义属性.</li>
<li><code>onAttachedToWindow()</code>中: 可以发现同一布局中相关的其他View, 其id是上一步通过自定义属性传入的.</li>
<li><code>onMeasure()</code>: 自定义View尺寸相关, 当覆盖这个方法时, 最后要调用<code>setMeasuredDimension(int width, int height)</code>.</li>
<li><code>onLayout()</code>: 一般这个方法是给ViewGroup的child指定位置和尺寸的, 对于自定义View来说, 没有child就没有必要覆盖这个方法.</li>
<li><code>onDraw()</code>: 这里是画东西的地方. 用canvas和Paint结合绘制. 需要注意的是<code>onDraw()</code>会被多次调用, 当你有一些变化, 滚动滑动等, 都会重绘, 所以这个方法中不要创建新对象. </li>
</ul>
<p><strong>View更新</strong><br>有两个方法可以让View重绘:</p>
<ul>
<li><code>invalidate()</code>: 只是重新绘制, 调用<code>onDraw()</code>方法.</li>
<li><code>requestLayout()</code>: 将会从<code>onMeasure()</code>开始, 可能会改变尺寸, 然后根据新尺寸重新绘制.</li>
</ul>
<p><strong>Animation</strong><br>自定义View的动画是一帧帧进行的, 这就意味着你每一步都要调用<code>invalidate()</code>来画它.</p>
<p>在自定义View中你的动画好助手是<code>ValueAnimator</code>, 它可以让你动画任何值.</p>
<h2 id="How-to-Stage-Rollout-Features-using-Firebase-Remote-Config"><a href="#How-to-Stage-Rollout-Features-using-Firebase-Remote-Config" class="headerlink" title="How to Stage Rollout Features using Firebase Remote Config"></a><a href="https://riggaroo.co.za/stage-rollout-features-firebase-remote-config-ios-android/" target="_blank" rel="external">How to Stage Rollout Features using Firebase Remote Config</a></h2><p><a href="https://support.google.com/googleplay/android-developer/answer/6346149?hl=en" target="_blank" rel="external">Staged Rollout</a>是Google Play Store的一个feature. 让你可以慢慢地把新版App发布给一部分用户, 并逐渐增大比例. 使用Firebase Remote Config, 我们可以做的更多,  我们可以控制某个feature的发布.</p>
<h2 id="Making-the-most-of-the-APK-analyzer"><a href="#Making-the-most-of-the-APK-analyzer" class="headerlink" title="Making the most of the APK analyzer"></a><a href="https://medium.com/google-developers/making-the-most-of-the-apk-analyzer-c066cb871ea2#.36ccm5y0c" target="_blank" rel="external">Making the most of the APK analyzer</a></h2><p>Android Studio中Build菜单有一项是<code>Analyze APK...</code>, 这是一个很有用的功能.</p>
<p><code>Raw File Size</code>是apk在磁盘上的大小.<br><code>Download size</code>是估计下载你的应用所需要的数据流量大小, 考虑到了Play Store的压缩.</p>
<p>文件和文件夹是按照大小降序排列的. 这对于Apk瘦身来说很有用, 很容易发现最占地方的原因.</p>
<p>比如作者发现了一些png很占地方, 于是就用<a href="https://developer.android.com/studio/write/vector-asset-studio.html" target="_blank" rel="external">PSD support in the Vector Asset import tool</a>把它们转成了<code>VectorDrawable</code>, 后向兼容用<code>VectorDrawableCompat</code>.</p>
<p>有一些没有压缩的WAV可以转成OGG. </p>
<p>在lib/里面, 发现它们要支持的三个ABI: x86, armeabi-v7a, armeabi, 解决的办法就是利用<a href="https://developer.android.com/studio/build/configure-apk-splits.html" target="_blank" rel="external">apk拆分</a>, 针对每一个ABI有一个不同的版本.</p>
<p>还有一个优化是把<code>android:extractNativeLibs</code> 属性设置为false, 这样系统就不会把.so文件在安装的时候从apk中拷贝到文件系统了. 这样应用的增量更新也会小一点.</p>
<p>这个功能有一个”Compare with”按钮, 利用它你可以比较两个apk的改变.</p>
<p>可以通过查看DEX文件来查看方法数限制 (Referenced Methods), 类混淆等问题.</p>
<h2 id="Rxify-The-Anti-Cache-then-Network-OR-Network-then-Cache-Problem"><a href="#Rxify-The-Anti-Cache-then-Network-OR-Network-then-Cache-Problem" class="headerlink" title="Rxify : The Anti Cache-then-Network OR Network-then-Cache Problem"></a><a href="http://www.andevcon.com/news/rxify-the-anti-cache-then-network-or-network-then-cache-problem" target="_blank" rel="external"><code>Rxify</code> : The Anti Cache-then-Network OR Network-then-Cache Problem</a></h2><p>用RxJava处理网络请求和缓存.</p>
<ul>
<li>如果先使用Cache, 没有缓存的时候再进行网络请求. -&gt; 用<code>.concatWith()</code>和<code>.take(1)</code>.</li>
<li>如果优先取网络最新数据, 没网的时候才用缓存数据. -&gt; <code>.onErrorReturn()</code>.</li>
</ul>
<h2 id="Your-presenters-don’t-need-all-those-lifecycle-events"><a href="#Your-presenters-don’t-need-all-those-lifecycle-events" class="headerlink" title="Your presenters don’t need all those lifecycle events"></a><a href="https://medium.com/@anupcowkur/your-presenters-dont-need-all-those-lifecycle-events-721f500eeef4#.f7nupw3jo" target="_blank" rel="external">Your presenters don’t need all those lifecycle events</a></h2><p>作者认为在Presenter中放入太多生命周期的方法不太好, 他觉得最基本的只需要这两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewAttached</span><span class="params">(MVPView view)</span></span>; </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewDetached</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然当你需要更多的时候可以加入更多, 但是我们不应该每个生命周期方法都加进去.</p>
<h2 id="How-to-send-notifications-using-Android-Firebase"><a href="#How-to-send-notifications-using-Android-Firebase" class="headerlink" title="How to send notifications using Android Firebase"></a><a href="http://www.survivingwithandroid.com/2016/09/android-firebase-push-notification.html" target="_blank" rel="external">How to send notifications using Android Firebase</a></h2><p>使用Firebase Messaging如何发送push notification.</p>
<h2 id="RxRecipes-Wrap-your-way-to-Rx"><a href="#RxRecipes-Wrap-your-way-to-Rx" class="headerlink" title="RxRecipes: Wrap your way to Rx"></a><a href="https://hackernoon.com/rxrecipes-wrap-your-way-to-rx-fd40eb5254b6#.hbtcjp4rm" target="_blank" rel="external">RxRecipes: Wrap your way to Rx</a></h2><p>使用<code>.fromCallable()</code>来把一个同步方法包装成一个Observable. </p>
<p>并比较了和<code>.just()</code>的区别. (<code>.just()</code>发射的东西在创建的时候就确定了, 而<code>.fromCallable()</code>是在subscribe的时候确定的.)</p>
<h2 id="Diving-deeper-into-the-Java-transient-modifier"><a href="#Diving-deeper-into-the-Java-transient-modifier" class="headerlink" title="Diving deeper into the Java transient modifier"></a><a href="https://medium.com/google-developer-experts/diving-deeper-into-the-java-transient-modifier-3b16eff68f42#.8pbk9i6fm" target="_blank" rel="external">Diving deeper into the Java transient modifier</a></h2><p><code>transient</code>修饰符加在字段上时, 在对象被序列化的时候, 这个字段将被排除在外, 反序列化时这个字段将被初始化一个默认值.</p>
<p>可能的使用场景: </p>
<ul>
<li>实现了Serializable的User对象中的password字段.</li>
<li>一个Serializable的类中的某个字段是通过其他字段推导或派生出来的, 这些派生的字段没有必要被序列化, 于是把它们标记为<code>transient</code>.</li>
</ul>
<p>注意transient和static是不能并存的, 因为static默认是transient的.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a><a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a></h2><p>腾讯的热补丁(hot-fix)解决方案, 支持不重新安装app的dex, library和资源更新.</p>
<h2 id="Android-Debug-Database"><a href="#Android-Debug-Database" class="headerlink" title="Android-Debug-Database"></a><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" target="_blank" rel="external">Android-Debug-Database</a></h2><p>在浏览器里看应用的数据库和shared preferences.</p>
<h2 id="blurkit-android"><a href="#blurkit-android" class="headerlink" title="blurkit-android"></a><a href="https://github.com/wonderkiln/blurkit-android" target="_blank" rel="external">blurkit-android</a></h2><p>实时模糊布局. 像iOS一样.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Firebase </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> Nougat </tag>
            
            <tag> Mockito </tag>
            
            <tag> Custom View </tag>
            
            <tag> Java </tag>
            
            <tag> Terminal </tag>
            
            <tag> Android 7.1 </tag>
            
            <tag> App Shortcuts </tag>
            
            <tag> Remote Config </tag>
            
            <tag> APK analyzer </tag>
            
            <tag> Cache </tag>
            
            <tag> push notification </tag>
            
            <tag> transient </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Java笔记一 创建和销毁对象]]></title>
      <url>http://mengdd.github.io/Java/2016/11/25/effective-java-notes-1/</url>
      <content type="html"><![CDATA[<h1 id="Effective-Java笔记一-创建和销毁对象"><a href="#Effective-Java笔记一-创建和销毁对象" class="headerlink" title="Effective Java笔记一 创建和销毁对象"></a>Effective Java笔记一 创建和销毁对象</h1><ul>
<li>第1条 考虑用静态工厂方法代替构造器</li>
<li>第2条 遇到多个构造器参数时要考虑用构建器</li>
<li>第3条 用私有构造器或者枚举类型强化Singleton属性</li>
<li>第4条 通过私有构造器强化不可实例化的能力</li>
<li>第5条 避免创建不必要的对象</li>
<li>第6条 消除过期的对象引用</li>
<li>第7条 避免使用终结方法</li>
</ul>
<a id="more"></a>
<h2 id="第1条-考虑用静态工厂方法代替构造器"><a href="#第1条-考虑用静态工厂方法代替构造器" class="headerlink" title="第1条 考虑用静态工厂方法代替构造器"></a>第1条 考虑用静态工厂方法代替构造器</h2><p>对于类而言, 最常用的获取实例的方法就是提供一个公有的构造器, 还有一种方法, 就是提供一个公有的静态工厂方法(static factory method), 返回类的实例.</p>
<p>(注意此处的静态工厂方法与设计模式中的工厂方法模式不同.)</p>
<p>提供静态工厂方法而不是公有构造, 这样做有几大<strong>优势</strong>:</p>
<ul>
<li>静态工厂方法<strong>有名称</strong>. 可以更确切地描述正被返回的对象.<br>当一个类需要多个带有相同签名的构造器时, 可以用静态工厂方法, 并且慎重地选择名称以便突出它们之间的区别.</li>
<li><strong>不必在每次调用它们的时候都创建一个新对象.</strong> 可以重复利用实例. 如果程序经常请求创建相同的对象, 并且创建对象的代价很高, 这项改动可以提升性能. (不可变类, 单例, 枚举).</li>
<li><strong>可以返回原类型的子类型对象.</strong> 适用于基于接口的框架, 可以隐藏实现类API, 也可以根据参数返回不同的子类型.<br>由于接口不能有静态方法, 因此按照惯例, 接口Type的静态工厂方法被放在一个名为Types的不可实例化的类中.<br>(Java的java.util.Collections). 服务提供者框架(Service Provider Framework, 如JDBC)的基础, 从实现中解耦.</li>
<li><strong>在创建参数化类型实例的时候, 使代码更简洁.</strong> </li>
</ul>
<p>静态工厂方法的<strong>缺点</strong>:</p>
<ul>
<li>类如果不含public或者protected的构造器, 就不能被子类化. 对于公有的静态工厂方法所返回的非公有类, 也同样如此.</li>
<li>静态工厂方法与其他的静态方法没有区别. 在API文档中没有明确标识出来. 可以使用一些惯用的名称来弥补这一劣势:<ul>
<li><code>valueOf()</code>: 类型转换方法, 返回的实例与参数具有相同的值.</li>
<li><code>of()</code>: valueOf()的一种更简洁的替代.</li>
<li><code>getInstance()</code>: 返回的实例通过参数来描述, 对于单例来说, 该方法没有参数, 返回唯一的实例.</li>
<li><code>newInstance()</code>: 像getInstance()一样, 但newInstance()能确保返回的每个实例都与其他实例不同.</li>
<li><code>getType()</code>: 像getInstance()一样, Type表示返回的对象类型, 在工厂方法处于不同的类中的时候使用.</li>
<li><code>newType()</code>: 和newInstance()一样, Type表示返回类型, 在工厂方法处于不同的类中的时候使用.</li>
</ul>
</li>
</ul>
<h2 id="第2条-遇到多个构造器参数时要考虑用构建器"><a href="#第2条-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="第2条 遇到多个构造器参数时要考虑用构建器"></a>第2条 遇到多个构造器参数时要考虑用构建器</h2><p>静态工厂和构造器有一个共同的局限性: 它们都不能很好地扩展到大量的可选参数.</p>
<p>重载多个构造器方法可行, 但是当有许多参数的时候, 代码会很难写难读.</p>
<p>第二种替代方法是JavaBeans模式, 即一个无参数构造来创建对象, 然后调用setter方法来设置每个参数. 这种模式也有严重的缺点, 因为构造过程被分到了几个调用中, 在构造过程中JavaBean可能处于不一致的状态.<br>类无法通过检验构造器参数的有效性来保证一致性. 另一点是这种模式阻止了把类做成不可变的可能.</p>
<p>第三种方法就是<strong>Builder模式</strong>. 不直接生成想要的对象, 而是利用必要参数调用构造器(或者静态工厂)得到一个builder对象, 然后在builder对象上调用类似setter的方法, 来设置可选参数, 最后调用无参的<code>build()</code>方法来生成不可变的对象.</p>
<p>这个Builder是它构建的类的静态成员类.<br>Builder的setter方法返回Builder本身, 可以链式操作.</p>
<p><strong>Builder模式的优势</strong>: 可读性增强; 可以有多个可变参数;  易于做参数检查和构造约束检查; 比JavaBeans更加安全; 灵活性: 可以利用单个builder构建多个对象, 可以自动填充某些域, 比如自增序列号.</p>
<p>Builder模式的不足: 为了创建对象必须先创建Builder, 在某些十分注重性能的情况下, 可能就成了问题; Builder模式较冗长, 因此只有参数很多时才使用.</p>
<h2 id="第3条-用私有构造器或者枚举类型强化Singleton属性"><a href="#第3条-用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="第3条 用私有构造器或者枚举类型强化Singleton属性"></a>第3条 用私有构造器或者枚举类型强化Singleton属性</h2><p><code>Singleton(单例)</code>指仅仅被实例化一次的类. 通常用来代表那些本质上唯一的系统组件. </p>
<p>使类成为Singleton会使得它的客户端代码测试变得困难, 因为无法给它替换模拟实现, 除非它实现了一个充当其类型的接口.</p>
<p>单例的实现: 私有构造方法, 类中保留一个字段实例(static, final), 用public直接公开字段或者用一个public static的<code>getInstance()</code>方法返回该字段.</p>
<p>为了使单例实现序列化(<code>Serializable</code>), 仅仅在声明中加上<code>implements Serializable</code>是不够的, 为了维护并保证单例, 必须声明所有实例域都是<code>transient</code>的, 并提供一个<code>readResolve()</code>方法, 返回单例的实例. 否则每次反序列化一个实例时, 都会创建一个新的实例.</p>
<p>从Java 1.5起, <strong>可以使用枚举来实现单例</strong>: 只需要编写一个包含单个元素的枚举类型.<br>这种方法无偿地提供了序列化机制, 绝对防止多次实例化.</p>
<h2 id="第4条-通过私有构造器强化不可实例化的能力"><a href="#第4条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第4条 通过私有构造器强化不可实例化的能力"></a>第4条 通过私有构造器强化不可实例化的能力</h2><p>只包含静态方法和静态域的类名声不太好, 因为有些人会滥用它们来编写过程化的程序. 尽管如此, 它们确实也有特有的用处, 比如:<br><code>java.lang.Math</code>, <code>java.util.Arrays</code>把基本类型的值或数组类型上的相关方法组织起来; <code>java.util.Collections</code>把实现特定接口的对象上的静态方法组织起来; 还可以利用这种类把final类上的方法组织起来, 以取代扩展该类的做法.</p>
<p>这种工具类(utility class)不希望被实例化, 然而在缺少显式构造器的情况下, 系统会提供默认构造器, 可能会造成这些类被无意识地实例化.</p>
<p>通过做成抽象类来强制该类不可被实例化, 这是行不通的, 因为可能会造成”这个类是用来被继承的”的误解, 而继承它的子类又可以被实例化.</p>
<p>所以只要让这个类包含一个私有的构造器, 它就不能被实例化了. 进一步地, 可以在这个私有构造器中抛出异常. </p>
<p>这种做法还会导致这个类不能被子类化, 因为子类构造器必须显式或隐式地调用super构造器. 在这种情况下, 子类就没有可访问的超类构造器可调用了.</p>
<h2 id="第5条-避免创建不必要的对象"><a href="#第5条-避免创建不必要的对象" class="headerlink" title="第5条 避免创建不必要的对象"></a>第5条 避免创建不必要的对象</h2><p>一般来说, 最好能重用对象而不是每次需要的时候创建一个相同功能的新对象. 如果对象是<strong>不可变的(immutable)</strong>, 它就始终可以被重用.</p>
<p>比如应该用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = <span class="string">"stringette"</span>;</div></pre></td></tr></table></figure></p>
<p>而不是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = <span class="keyword">new</span> String(<span class="string">"stringette"</span>); <span class="comment">// Don't do this</span></div></pre></td></tr></table></figure></p>
<p>包含相同字符串的字面常量对象是会被重用的.</p>
<p>对于同时提供了静态工厂方法和构造方法的<strong>不可变类</strong>, 通常可以使用静态工厂方法而不是构造器, 以避免创建不必要的对象.<br>比如<code>Boolean.valueOf()</code>.</p>
<p>除了重用不可变对象以外, 也可以重用那些已知不会被修改的可变对象. 比如把一个方法中需要用到的不变的数据保存成常量对象(<code>static final</code>), 只在初始化的时候创建一次(<code>用static块</code>), 这样就不用每次调用方法都重复创建.</p>
<p>如果该方法永远不会调用, 那也不需要初始化相关的字段, 可以通过延迟初始化(lazily initializing)把这些对象的初始化放到方法第一次被调用的时候. (但是不建议这样做, 没有性能的显著提高, 并且会使方法看起来复杂.)</p>
<p>前面的例子中, 所讨论的对象显然是能够被重用的, 因为它们被初始化之后不会再改变. 其他有些情形则并不总是这么明显了. (适配器(adapter)模式, Map的接口keySet()方法返回同样的Set实例).</p>
<p>Java 1.5中加入了自动装箱(autoboxing), 会创建对象. 所以程序中优先使用基本类型而不是装箱基本类型, 要当心无意识的自动装箱. </p>
<p>小对象的构造器只做很少量的显式工作, 创建和回收都是很廉价的, 所以通过创建附加的对象提升程序的清晰简洁性也是好事.</p>
<p>通过维护自己的对象池(object pool)来避免创建对象并不是一种好的做法(代码, 内存), 除非池中的对象是非常重量级的. 正确使用的典型: 数据库连接池.</p>
<h2 id="第6条-消除过期的对象引用"><a href="#第6条-消除过期的对象引用" class="headerlink" title="第6条 消除过期的对象引用"></a>第6条 消除过期的对象引用</h2><p>一个内存泄露的例子: 一个用数组实现的Stack, 依靠size标记来管理栈的深度, 但是这样从栈中弹出来的过期对象并没有被释放. </p>
<p>称内存泄露为”无意识的对象保持(unintentional object retention)”更为恰当.</p>
<p>修复方法: 一旦对象引用已经过期, 只需清空这些引用即可.</p>
<p>清空对象引用应该是一种例外, 而不是一种规范行为. 消除过期引用最好的方法是让包含该引用的变量结束其生命周期. 如果你是在最紧凑的作用域范围内定义变量, 这种情形就会自然发生.</p>
<p><strong>一般而言, 只要类是自己管理内存</strong>, 程序员就应该警惕内存泄露问题. 一旦元素被释放掉, 则该元素中包含的任何对象引用都应该被清空.</p>
<p>内存泄露的<strong>另一个常见来源是缓存</strong>. 这个问题有这几种可能的解决方案: </p>
<ul>
<li>1.缓存项的生命周期由该键的外部引用决定 -&gt; <code>WeakHashMap</code>; </li>
<li>2.缓存项的生命周期是否有意义并不是很容易确定 -&gt; 随着时间的推移或者新增项的时候删除没用的项.</li>
</ul>
<p>内存泄露的<strong>第三个常见来源是监听器和其他回调</strong>.<br>如果你实现了一个API, 客户端注册了回调却没有注销, 就会积聚对象.<br>API端可以只保存对象的弱引用来确保回调对象生命周期结束后会被垃圾回收. </p>
<h2 id="第7条-避免使用终结方法"><a href="#第7条-避免使用终结方法" class="headerlink" title="第7条 避免使用终结方法"></a>第7条 避免使用终结方法</h2><p>终结方法(finalizer)通常是不可预测的, 也是很危险的, 一般情况下是不必要的.<br>使用终结方法会导致行为不稳定, 降低性能, 以及可移植性问题.</p>
<p>不要把finalizer当成是C++中的析构器(destructors)的对应物.<br>在Java中, 当一个对象变得不可到达的时候, 垃圾回收器会回收与该对象相关联的存储空间.</p>
<p>C++的析构器也可以用来回收其他的非内存资源, 而在Java中, 一般用try-finally块来完成类似的工作.</p>
<p>终结方法的缺点在于不能保证会被及时地执行. 从一个对象变得不可到达开始, 到它的终结方法被执行, 所花费的时间是任意长的. JVM会延迟执行终结方法. </p>
<p>及时地执行终结方法正是垃圾回收算法的一个主要功能. 这种算法在不同的JVM上不同. </p>
<p>Java语言规范不仅不保证终结方法会被及时地执行, 而且根本就不保证它们会被执行. 所以不应该依赖于终结方法来更新重要的持久状态. </p>
<p>不要被<code>System.gc()</code>和<code>System.runFinalization()</code>这两个方法所迷惑, 它们确实增加了终结方法被执行的机会, 但是它们并不保证终结方法一定会被执行. </p>
<p>如果未捕获的异常在终结过程中被抛出来, 那么这种异常可以被忽略, 而且该对象的终结过程也会终止. </p>
<p>使用终结方法有一个严重的性能损失. </p>
<p>如果类的对象中封装的资源(例如文件或线程)确实需要终止, 应该怎么做才能不用编写终结方法呢? 只需<strong>提供一个显式的终止方法</strong>. 并要求该类的客户端在每个实例不再有用的时候调用这个方法. 注意, 该实例必须记录下自己是否已经被终止了, 如果被终止之后再被调用, 要抛出异常.<br>例子: <code>InputStream</code>, <code>OutputStream</code>和<code>java.sql.Connection</code>上的<code>close()</code>方法; <code>java.util.Timer</code>的<code>cancel()</code>方法.<br><code>Image.flush()</code>会释放实例相关资源, 但该实例仍处于可用的状态, 如果有必要会重新分配资源. </p>
<p><strong>显式的终止方法通常与try-finally块结合使用, 以确保及时终止.</strong></p>
<p>终结方法的好处, 它有两种合法用途:</p>
<ul>
<li>当显式终止方法被忘记调用时, 终结方法可以充当安全网(safety net). <strong>但是如果终结方法发现资源还未被终止, 应该记录日志警告, 这表示客户端代码中的bug.</strong></li>
<li>对象的本地对等体(native peer), 垃圾回收器不会知道它, 当它的Java对等体被回收的时候, 它不会被回收. 如果本地对等体拥有必须被及时终止的资源, 那么该类就应该有一个显式的终止方法, 如前, 可以是本地方法或者它也可以调用本地方法; 如果本地对等体并不拥有关键资源, 终结方法是执行这项任务最合适的工具. </li>
</ul>
<p>注意, 终结方法链(finalizer chaining)并不会自动执行. 子类覆盖终结方法时, 必须手动调用超类的终结方法. try中终结子类, finally中终结超类. </p>
<p>为了避免忘记调用超类的终结方法, 还有一种写法, 是在子类中写一个匿名的类, 该匿名类的单个实例被称为<strong>终结方法守卫者(finalizer guardian)</strong>, 当守卫者被终结的时候, 它执行外围实例的终结行为. 这样外围类并没有覆盖超类的终结方法, 保证了超类的终结方法一定会被执行. </p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 232]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/11/25/android-weekly-notes-issue-232/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-232"><a href="#Android-Weekly-Issue-232" class="headerlink" title="Android Weekly Issue #232"></a>Android Weekly Issue #232</h1><p>November 20th, 2016<br><a href="http://androidweekly.net/issues/issue-232" target="_blank" rel="external">Android Weekly Issue #232</a><br>本期内容包括: Kotlin的优势讨论; MVVM模式结合RxJava和Retrofit的应用构架实现; Android中传感器使用; 如何给App写单元测试; Reductor的组合使用; Android应用进程被杀死的状态恢复和问题处理; Kotlin中的Anko; 后台任务处理库”Android Job”; VectorDrawable和PNG的使用问题等.</p>
<p>本期开源库: 给ImageView和RelativeLayout的底部加曲线; 长按弹框; Switch Button控件; 给View加深度/厚度的库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="How-Kotlin-became-our-primary-language-for-Android"><a href="#How-Kotlin-became-our-primary-language-for-Android" class="headerlink" title="How Kotlin became our primary language for Android"></a><a href="https://medium.com/uptech-team/how-kotlin-became-our-primary-language-for-android-3af7fd6a994c#.a50t4ple8" target="_blank" rel="external">How Kotlin became our primary language for Android</a></h2><p>作者他们team想要完全用kotlin开发一个应用.<br>本文是他们的心得体会.</p>
<p>关于函数式编程的学习, 作者推荐: <a href="https://www.coursera.org/specializations/scala" target="_blank" rel="external">一个Scala的课程</a>.</p>
<p>Kotlin的优势: 和Java可以互相调用; 函数式语言; function purity; 高阶函数(函数可以作为参数或返回值); 不可变性(val); Null-safety; Anko;  Kotlin Android extensions(移除了ButterKnife); 还有对初学者很友好, 可以摆脱很多第三方的依赖, 函数扩展等等优势.</p>
<h2 id="RxJava-2-Android-MVVM-Lifecycle-App-Structure-with-Retrofit-2"><a href="#RxJava-2-Android-MVVM-Lifecycle-App-Structure-with-Retrofit-2" class="headerlink" title="RxJava 2: Android MVVM Lifecycle App Structure with Retrofit 2"></a><a href="https://medium.com/@manuelvicnt/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e#.jx3vg232m" target="_blank" rel="external">RxJava 2: Android MVVM Lifecycle App Structure with Retrofit 2</a></h2><p>作者一年多以前写过一个这个文章: <a href="https://medium.com/@manuelvicnt/rxjava-android-mvvm-app-structure-with-retrofit-a5605fa32c00#.44uq87s6w" target="_blank" rel="external">RxJava: Android MVVM App structure with Retrofit</a>, 介绍MVVM结合Retrofit和RxJava的App架构模式. 此篇文章是一年后作者对此的改进.</p>
<p>主要内容有:</p>
<ul>
<li>1.通过View和ViewModel之间的协议接口, 让ViewModel知道View的生命周期变化.</li>
<li>2.RxJava2的流式类型: Completable, Maybe, Flowable的使用.</li>
<li>3.用RxJava操作符组合网络请求: 让不同的网络请求一起发送, 并且都返回以后才得到通知 -&gt; 用<code>.zip()</code>. 顺序连接不同的网络请求 -&gt; <code>.flatMap()</code>, <code>.andThen()</code>.</li>
<li>4.后台网络请求和View更新的处理: 不取消网络请求, 等View再次resume的时候检查状态再更新. 这里提供了两种选择, 一种是用前面提到的协议接口中的生命周期方法, 另一种是用<code>AsyncProcessor</code>.</li>
<li>5.Mock Retrofit的网络请求.</li>
</ul>
<h2 id="Tech-Talks-You-Do-Have-Something-To-Say"><a href="#Tech-Talks-You-Do-Have-Something-To-Say" class="headerlink" title="Tech Talks - You Do Have Something To Say!"></a><a href="https://medium.com/upday-devs/tech-talks-you-do-have-something-to-say-a1a0ae23fa0#.61m7x6rj8" target="_blank" rel="external">Tech Talks - You Do Have Something To Say!</a></h2><p>这篇文章鼓励你分享你的知识, 经验, 问题及解决方法,  无论是通过演讲还是写出来的方式.</p>
<h2 id="Da-Real-Fragmentation-Sensors"><a href="#Da-Real-Fragmentation-Sensors" class="headerlink" title="Da Real Fragmentation - Sensors"></a><a href="http://pguardiola.com/blog/darealfragmentation-sensors/" target="_blank" rel="external">Da Real Fragmentation - Sensors</a></h2><p>介绍了Android中传感器的使用.</p>
<h2 id="Simple-unit-tests-for-Android"><a href="#Simple-unit-tests-for-Android" class="headerlink" title="Simple unit tests for Android"></a><a href="https://stfalcon.com/en/blog/post/simple-unit-tests-for-android" target="_blank" rel="external">Simple unit tests for Android</a></h2><p>如何给你的App写简单的单元测试.</p>
<h2 id="Reductor-Redux-for-Android-Part-2"><a href="#Reductor-Redux-for-Android-Part-2" class="headerlink" title="Reductor - Redux for Android. Part 2"></a><a href="https://yarikx.github.io/Reductor-composition/" target="_blank" rel="external">Reductor - Redux for Android. Part 2</a></h2><p>这是系列文章中的一篇, 继续讲<a href="https://github.com/Yarikx/reductor" target="_blank" rel="external">Reductor</a> library – Redux的Android版实现.</p>
<p>这篇文章结合例子将如何组合使用以及用@CombinedState来生成代码.</p>
<h2 id="Android-process-death-—-and-the-big-implications-for-your-app"><a href="#Android-process-death-—-and-the-big-implications-for-your-app" class="headerlink" title="Android process death — and the (big) implications for your app"></a><a href="https://medium.com/inloop/android-process-kill-and-the-big-implications-for-your-app-1ecbed4921cb#.iipoq2fne" target="_blank" rel="external">Android process death — and the (big) implications for your app</a></h2><p>本文探讨进程被杀死有可能导致的种种问题.</p>
<p>你的Android应用如果在paused或者stopped状态, 那么它任何时候都有可能会被系统杀死. 这时候你的Activity, Fragment和View状态将被保存, 当你回到应用的时候, 系统会重新启动进程, 重新创建Activity, 存储的状态会在bundle中返回.</p>
<p><strong>这个过程存在一个问题</strong>: 整个进程都被杀死了, 所有单例(或application scope的对象), 临时数据, 还有retained Fragment中的数据, 这些所有都会处于一种全新创建的状态, 但唯有一个不同, 一些在bundle中存储的状态被恢复出来了.</p>
<p>这样有可能会导致一些异常, 比如你的界面想要恢复一种状态, 但是数据已经被清空了.</p>
<p><strong>如何测试这种情况呢?</strong></p>
<ul>
<li>使用App, home键把它放进后台, 杀死app, 再恢复.</li>
<li>打开选项”Don’t Keep Activities”. 这种测试并不会杀死进程, 只会测试Activity的状态恢复.</li>
<li>设置Developer options中的Background Process Limit为”No background processes”. 这样把应用放在后台, 打开另一个应用, 再回来自己的应用, 将会重启进程.</li>
</ul>
<p><strong>相关问题信号</strong></p>
<ul>
<li>单例</li>
<li>保存可变数据的共享的实例</li>
<li>Application类中保存的数据和状态</li>
<li>可变的静态字段</li>
<li>Retained fragments(状态恢复了, 但是数据却丢失了)</li>
<li>基本上任何没有在<code>onSaveInstanceState()</code>中保存但是你却依赖的状态</li>
</ul>
<p>这些问题没有唯一的解决方案, 取决于你的应用.</p>
<h2 id="400-faster-layouts-with-Anko"><a href="#400-faster-layouts-with-Anko" class="headerlink" title="400% faster layouts with Anko"></a><a href="https://medium.com/@vergauwen.simon/400-faster-layouts-with-anko-da17f32c45dd#.bz6a3y8ql" target="_blank" rel="external">400% faster layouts with Anko</a></h2><p>作者把自己的一个布局改为用Kotlin的Anko, 然后测试性能.</p>
<p>好处是:</p>
<ul>
<li>1.性能提升了, 避免了XML的运行时解析所花费的时间.</li>
<li>2.可以动态地加入逻辑, 比如版本判断, 屏幕尺寸, 方向判断等.</li>
</ul>
<p>作者用的测试性能的工具是: <a href="https://github.com/frogermcs/AndroidDevMetrics" target="_blank" rel="external">AndroidDevMetrics</a></p>
<h2 id="Background-Work-with-Android-Job-and-Dagger"><a href="#Background-Work-with-Android-Job-and-Dagger" class="headerlink" title="Background Work with Android Job and Dagger"></a><a href="http://www.adavis.info/2016/11/background-work-with-android-job-and.html" target="_blank" rel="external">Background Work with Android Job and Dagger</a></h2><p>在Android上的后台工作, 你可以选择<code>Alarm Manager</code>, <code>Job Scheduler</code>或<code>GCM Network Manager</code>.</p>
<p>为了帮开发者从每种实现中抽象出来, Evernote开源了一个库: Android Job. 本文介绍了这个库如何使用.</p>
<h2 id="VectorDrawable-PNG"><a href="#VectorDrawable-PNG" class="headerlink" title="VectorDrawable PNG"></a><a href="https://blog.stylingandroid.com/vectordrawable-png/" target="_blank" rel="external">VectorDrawable PNG</a></h2><p>作者他们的应用中有VectorDrawable的版本兼容问题, 用support library中的Compat版本也不好使, 于是他们在旧版本决定使用自动生成的png.</p>
<p>然后发现了生成png的颜色设置问题, 在旧版本生成的图片用的是fillColor而不是tintColor. 把fillColor设置成想要的颜色即可.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Depth-Library-by-Daniel-Zeller"><a href="#Depth-Library-by-Daniel-Zeller" class="headerlink" title="Depth Library by Daniel Zeller"></a><a href="https://www.androidexperiments.com/experiment/depth-library" target="_blank" rel="external">Depth Library by Daniel Zeller</a></h2><p>一个应用, 展示了<a href="https://github.com/danielzeller/Depth-LIB-Android-" target="_blank" rel="external">Depth-LIB-Android-</a>的功能.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Crescento"><a href="#Crescento" class="headerlink" title="Crescento"></a><a href="https://github.com/developer-shivam/crescento/" target="_blank" rel="external">Crescento</a></h2><p>在<code>ImageView</code>和<code>RelativeLayout</code>底部加上曲线的库.</p>
<h2 id="LongPressPopup"><a href="#LongPressPopup" class="headerlink" title="LongPressPopup"></a><a href="https://github.com/RiccardoMoro/LongPressPopup" target="_blank" rel="external">LongPressPopup</a></h2><p>长按出现弹框的库.</p>
<h2 id="RMSwitch"><a href="#RMSwitch" class="headerlink" title="RMSwitch"></a><a href="https://github.com/RiccardoMoro/RMSwitch" target="_blank" rel="external">RMSwitch</a></h2><p>一个Switch Button的库, 带有更多自定义扩展功能.</p>
<h2 id="Depth-LIB-Android"><a href="#Depth-LIB-Android" class="headerlink" title="Depth-LIB-Android"></a><a href="https://github.com/danielzeller/Depth-LIB-Android-" target="_blank" rel="external">Depth-LIB-Android</a></h2><p>这个库给View加上深度/厚度.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
            <tag> Reductor </tag>
            
            <tag> Redux </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> MVVM </tag>
            
            <tag> Sensor </tag>
            
            <tag> Testing </tag>
            
            <tag> Unit Test </tag>
            
            <tag> Process </tag>
            
            <tag> State </tag>
            
            <tag> Anko </tag>
            
            <tag> VectorDrawable </tag>
            
            <tag> PNG </tag>
            
            <tag> Switch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 231]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/11/17/android-weekly-notes-issue-231/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-231"><a href="#Android-Weekly-Issue-231" class="headerlink" title="Android Weekly Issue #231"></a>Android Weekly Issue #231</h1><p>November 13th, 2016<br><a href="http://androidweekly.net/issues/issue-231" target="_blank" rel="external">Android Weekly Issue #231</a></p>
<p>Android Weekly阅读笔记, Issue #231, 本期内容包括: MVP中的View做成passive响应式的, 返回Observable; Android Studio使用技巧; <code>BottomNavigationView</code>的使用; App tracking; Kotlin; 用Kotlin实现的Filter Animation效果; Dagger2的<code>Scope</code>和<code>Subcomponent</code>使用; Espresso测试中mock dagger注入; Android和Java中的Reference和内存泄露; MVVM + RxJava构架实际使用的经验分享; 还有TV以及Audio相关的内容等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Reactive-Views-retrying-errors"><a href="#Reactive-Views-retrying-errors" class="headerlink" title="Reactive Views: retrying errors"></a><a href="https://medium.com/xing-engineering/reactive-views-retrying-errors-a59fffbd827f#.m2n2c6v6i" target="_blank" rel="external">Reactive Views: retrying errors</a></h2><p>作者他们的app近来重构采用了RxJava和Clean Architecture, 进而想要使用<a href="http://martinfowler.com/eaaDev/PassiveScreen.html" target="_blank" rel="external">passive view</a>, 然后他们就发现了关于Reactive Views的一系列文章, 尤其是这一篇: <a href="https://artemzin.com/blog/rxui-talking-to-android-view-layer-in-a-reactive-way/" target="_blank" rel="external">RxUi: Talking to Android View layer in a Reactive way</a>.</p>
<p>他们的主要工作就是把View也改成响应式的, 即View返回Observable. 在Presenter初始化的时候和View的Observable绑定, 所以事件发生的时候会trigger到presenter.</p>
<p>这项工作主要需要依赖于<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>, 由于RxBinding没有提供长按RecyclerView item的bind, 所以他们自己写了<a href="https://gist.github.com/Shyish/92257b6348312b541aa4f6b205eb14e4" target="_blank" rel="external">一个</a>.<br>Snackbar也是: <a href="https://gist.github.com/Shyish/8af4cd774320c57ced0ec21f8840797e" target="_blank" rel="external">SnackbarActionOnSubscribe</a>.</p>
<p>作者采用这种方式重构了他们的代码, 使得view变成完全passive的.</p>
<p>并且其中还有一个<code>retryWhen()</code>使用的解释: <a href="http://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/" target="_blank" rel="external">RxJava’s repeatWhen and retryWhen, explained</a>.</p>
<h2 id="50-Android-Studio-Tips-Tricks-amp-Resources"><a href="#50-Android-Studio-Tips-Tricks-amp-Resources" class="headerlink" title="50 Android Studio Tips, Tricks &amp; Resources"></a><a href="https://medium.com/@mmbialas/50-android-studio-tips-tricks-resources-you-should-be-familiar-with-as-an-android-developer-af86e7cf56d2#.gzyghprf0" target="_blank" rel="external">50 Android Studio Tips, Tricks &amp; Resources</a></h2><p>设置Logcat的颜色; 使用<a href="https://medium.com/google-developers/writing-more-code-by-writing-less-code-with-android-studio-live-templates-244f648d17c7#.2p54ef8jr" target="_blank" rel="external">Live Templates</a>; 快捷键使用; Android Studio的插件; 还有一些资源分享.</p>
<h2 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a><a href="https://blog.stylingandroid.com/bottomnavigationview/" target="_blank" rel="external">BottomNavigationView</a></h2><p>Design support library 25.0.0推出了BottomNavigationView, 本文介绍其使用.</p>
<h2 id="The-key-concepts-of-app-tracking-for-developers"><a href="#The-key-concepts-of-app-tracking-for-developers" class="headerlink" title="The key concepts of app tracking for developers"></a><a href="https://medium.com/@sergii/the-key-concepts-of-app-tracking-for-developers-a11bebf1e65e#.mhdpwt9x9" target="_blank" rel="external">The key concepts of app tracking for developers</a></h2><p>这篇文章主要讲移动应用数据追踪和分析的几个原则:</p>
<ul>
<li>为什么你需要tracking;  </li>
<li>什么时候需要收集数据; </li>
<li>用什么Analytics tool; </li>
<li>用户隐私相关; </li>
<li>代码设计模式以及挑战; </li>
<li>如何debug和测试输出;</li>
<li>如何分析数据;</li>
</ul>
<h2 id="Why-You-Must-Try-Kotlin-For-Android-Development"><a href="#Why-You-Must-Try-Kotlin-For-Android-Development" class="headerlink" title="Why You Must Try Kotlin For Android Development?"></a><a href="https://medium.com/@amitshekhar/why-you-must-try-kotlin-for-android-development-e14d00c8084b#.z0xt70upu" target="_blank" rel="external">Why You Must Try Kotlin For Android Development?</a></h2><p>为什么要使用Kotlin来做Android开发? 简洁, 安全, 灵活, 和Java可互相操作.</p>
<p>文中介绍了Null Safety, Smart Casting, Default Arguments, Named Arguments, Functional Programming, Concise Code.</p>
<h2 id="Implementing-Filter-Animation-in-Kotlin"><a href="#Implementing-Filter-Animation-in-Kotlin" class="headerlink" title="Implementing Filter Animation in Kotlin"></a><a href="https://yalantis.com/blog/develop-filter-animation-kotlin-android/" target="_blank" rel="external">Implementing Filter Animation in Kotlin</a></h2><p>作者他们搞了一个应用FIT, 为女性IT工作者提供社区和交流平台, 想要成为Quora加上Linkedin.</p>
<p>为了让用户选择分类和过滤器tag进行搜索, 他们开发了一个组件: <a href="https://github.com/Yalantis/SearchFilter" target="_blank" rel="external">SearchFilter</a>. </p>
<p>文中讨论了这种设计的动画实现, 库是用Kotlin写的.</p>
<h2 id="DI-101-—-Part-3"><a href="#DI-101-—-Part-3" class="headerlink" title="DI 101 — Part 3"></a><a href="https://medium.com/di-101/di-101-part-3-f0136e67db8#.rdp4e4fwc" target="_blank" rel="external">DI 101 — Part 3</a></h2><p>本文讲什么是Scope, 如何定义Scope, 如何使用Scope和@Subcomponent.</p>
<p>Subcomponent会继承父类的所有bindings.</p>
<p>作者定义了一个Activity的Scope, 然后定义了一个Subcomponent专门给这个Activity用, 这个Subcomponent只在这个Activity的生命周期里存活. 代码例子比较简洁易懂.</p>
<h2 id="How-Dagger-2-Helps-In-Android-Espresso-Tests"><a href="#How-Dagger-2-Helps-In-Android-Espresso-Tests" class="headerlink" title="How Dagger 2 Helps In Android Espresso Tests"></a><a href="http://www.ottodroid.net/?p=514" target="_blank" rel="external">How Dagger 2 Helps In Android Espresso Tests</a></h2><p>这篇文章介绍了如何在写Espresso测试的时候, 使用一个测试用的Dagger Component.</p>
<h2 id="Finally-understanding-how-references-work-in-Android-and-Java"><a href="#Finally-understanding-how-references-work-in-Android-and-Java" class="headerlink" title="Finally understanding how references work in Android and Java"></a><a href="https://medium.com/google-developer-experts/finally-understanding-how-references-work-in-android-and-java-26a0d9c92f83#.95piwft68" target="_blank" rel="external">Finally understanding how references work in Android and Java</a></h2><p>这篇文章讲了Java中的引用类型和Android中的内存泄露.</p>
<p>Java中的引用类型:</p>
<ul>
<li>Strong reference</li>
<li>WeakReference</li>
<li>SoftReference</li>
<li>PhantomReference</li>
</ul>
<p>作者详细介绍了每一种引用并用例子说明了使用场景. </p>
<h2 id="MVVM-RxJava-Learnings"><a href="#MVVM-RxJava-Learnings" class="headerlink" title="MVVM + RxJava: Learnings"></a><a href="https://medium.com/upday-devs/mvvm-rxjava-learnings-1819423f9592#.3rat89dq5" target="_blank" rel="external">MVVM + RxJava: Learnings</a></h2><p>作者他们的新闻应用采用MVVM + RxJava架构, 本文总结了他们遇到的问题和学到的两点:</p>
<ol>
<li>暴露状态, 而不是事件;</li>
<li>所有的事情都应该通过ViewModel.</li>
</ol>
<h2 id="Adding-TV-Channels-to-Your-App-with-the-TIF-Companion-Library"><a href="#Adding-TV-Channels-to-Your-App-with-the-TIF-Companion-Library" class="headerlink" title="Adding TV Channels to Your App with the TIF Companion Library"></a><a href="http://android-developers.blogspot.com.au/2016/11/adding-tv-channels-to-your-app-with-the-tif-companion-library.html" target="_blank" rel="external">Adding TV Channels to Your App with the TIF Companion Library</a></h2><p>TV Input Framework(TIF)和Android TV让第三方应用开发者可以很容易地创建自己的电视频道. </p>
<h2 id="Background-Audio-in-Android-With-MediaSessionCompat"><a href="#Background-Audio-in-Android-With-MediaSessionCompat" class="headerlink" title="Background Audio in Android With MediaSessionCompat"></a><a href="https://code.tutsplus.com/tutorials/background-audio-in-android-with-mediasessioncompat--cms-27030" target="_blank" rel="external">Background Audio in Android With MediaSessionCompat</a></h2><p>Android support library中的<code>MediaSessionCompat</code>使用, 以及如何用它来做一个背景音乐.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="FirebaseUI-Android"><a href="#FirebaseUI-Android" class="headerlink" title="FirebaseUI-Android"></a><a href="https://github.com/firebase/FirebaseUI-Android" target="_blank" rel="external">FirebaseUI-Android</a></h2><p>FirebaseUI for Android — UI Bindings for Firebase.</p>
<h2 id="ChipsLayoutManager"><a href="#ChipsLayoutManager" class="headerlink" title="ChipsLayoutManager"></a><a href="https://github.com/BelooS/ChipsLayoutManager" target="_blank" rel="external">ChipsLayoutManager</a></h2><p>一个自定义的RecyclerView的layout manager, 流式地显示很多小块的TextView.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> TV </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> Android Studio </tag>
            
            <tag> Tools </tag>
            
            <tag> Memory Leak </tag>
            
            <tag> BottomNavigationView </tag>
            
            <tag> MVVM </tag>
            
            <tag> Audio </tag>
            
            <tag> Passive View </tag>
            
            <tag> RxBinding </tag>
            
            <tag> Tracking </tag>
            
            <tag> Analytics </tag>
            
            <tag> Scope </tag>
            
            <tag> Subcomponent </tag>
            
            <tag> Reference </tag>
            
            <tag> Media </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 230]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/11/11/android-weekly-notes-issue-230/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-230"><a href="#Android-Weekly-Issue-230" class="headerlink" title="Android Weekly Issue #230"></a>Android Weekly Issue #230</h1><p>November 6th, 2016<br><a href="http://androidweekly.net/issues/issue-230" target="_blank" rel="external">Android Weekly Issue #230</a>.</p>
<p>Android Weekly笔记, 本期内容包括: Mockito的扩展; ConstraintLayout的链式约束; Kotlin的Async-Await; RxJava2.0; 屏幕旋转导致的Activity重建; Throwable类的设计问题; Espresso测试中如何等待异步请求返回; Kotlin的扩展和运算符重载; Android KeyStore实现用户验证.</p>
<p>代码部分有proguard的库, mvp的库和WifiManager, ConfigurationManager的包装库.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Extending-Mockito"><a href="#Extending-Mockito" class="headerlink" title="Extending Mockito"></a><a href="http://jeroenmols.com/blog/2016/10/31/mockitomatchers/" target="_blank" rel="external">Extending Mockito</a></h2><p>这篇文章讲了如何扩展Mockito, 简化对参数的验证.</p>
<p>首先作者举了之前验证参数的例子, 用的是ArgumentCaptor, 写起来很麻烦, 用了自定义的matcher之后简化了很多.</p>
<h2 id="ConstraintLayout-Chains-–-Part-2"><a href="#ConstraintLayout-Chains-–-Part-2" class="headerlink" title="ConstraintLayout Chains – Part 2"></a><a href="https://blog.stylingandroid.com/constraintlayout-chains-part-2/" target="_blank" rel="external">ConstraintLayout Chains – Part 2</a></h2><p>上一篇文章讲过在ConstraintLayout中如何创建对称的链式约束, 本篇文章介绍chainStyle的不同设置和比较.</p>
<p>默认的spread chain: 均匀分布;<br>inside spread chain: 边缘元素顶边, 中间均匀分布.</p>
<p>如果指定了权重, 将会按照权重布局. 那么spread chain和inside spread chain就没有区别了.</p>
<p>packed chain: 默认会把所有元素都放在一起放在中间, 可以指定bias来定义偏移基准, 默认bias是0.5, bias设置为0.25的意思就是往左偏. </p>
<h2 id="A-glimpse-of-Async-Await-on-Android"><a href="#A-glimpse-of-Async-Await-on-Android" class="headerlink" title="A glimpse of Async-Await on Android"></a><a href="https://medium.com/@haarman.niek/async-await-in-android-f0202cf31088#.bdf3jarxd" target="_blank" rel="external">A glimpse of Async-Await on Android</a></h2><p>Kotlin 1.1推出了<a href="https://github.com/Kotlin/kotlin-coroutines" target="_blank" rel="external">coroutines</a>, 这是一个让计算可以在某个点暂停然后之后又恢复的功能, 例子是几年前C#的<a href="http://blog.stephencleary.com/2012/02/async-and-await.html" target="_blank" rel="external">Async-Await</a>.</p>
<p>作者先举例说明了异步操作的几种常见实现, 最后结合自己的库用Async-Await做了一个例子.</p>
<h2 id="What’s-different-in-2-0"><a href="#What’s-different-in-2-0" class="headerlink" title="What’s different in 2.0"></a><a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0" target="_blank" rel="external">What’s different in 2.0</a></h2><p>RxJava2.0.0已经发布了. 这是它的wiki page来介绍2.0有什么不同.</p>
<h2 id="Activity-Revival-and-the-case-of-the-Rotating-Device"><a href="#Activity-Revival-and-the-case-of-the-Rotating-Device" class="headerlink" title="Activity Revival and the case of the Rotating Device"></a><a href="https://medium.com/google-developers/activity-revival-and-the-case-of-the-rotating-device-167e34f9a30d#.fwrqz8nit" target="_blank" rel="external">Activity Revival and the case of the Rotating Device</a></h2><p>本篇文章讲configuration变化(比如屏幕旋转)导致的Activity重建.</p>
<p>为什么configuration变化的时候要重建Activity呢? 因为系统想要尽力地做一些helpful的事情, 希望在这种时候能重新加载正确的资源.</p>
<p>怎么处理呢?</p>
<p>方法一: 让系统自动处理. 在屏幕旋转时, <code>onSaveInstanceState()</code>会在Activity销毁前调用, 可以存储一些状态, 之后重建的时候从bundle中拿出来恢复.</p>
<p>方法二: 自己处理. 如果你想要获取更多控制, 那么你可以在manifest中声明<code>configChanges</code>类型, 然后在Activity中覆写<code>onConfigurationChanged()</code>方法, 来自己做处理.</p>
<p>另外文章中还讨论了网络请求, 屏幕方向设置, retained fragment的使用等.</p>
<h2 id="RxJava-and-Retrofit-Throwing-a-Tantrum"><a href="#RxJava-and-Retrofit-Throwing-a-Tantrum" class="headerlink" title="RxJava and Retrofit Throwing a Tantrum"></a><a href="https://medium.com/square-corner-blog/no-cause-for-concern-rxjava-and-retrofit-throwing-a-tantrum-96c9e4ba8a6c#.p1ck4zijo" target="_blank" rel="external">RxJava and Retrofit Throwing a Tantrum</a></h2><p>作者讨论了他们在项目中遇到的一个问题.<br>他们用<code>RxJavaHooks.enableAssemblyTracking();</code>来收集RxJava崩溃栈信息, 可以显示出到底是哪一个Observable崩了.<br>使用这个工具以后发现了一个问题, 进而研究了JDK的<code>Throwable</code>类.</p>
<p>原来cause不存在(this)和cause未知(null)是两种不同的情况, 但是<code>Throwable</code>的<code>getCause()</code>方法都会返回null.</p>
<h2 id="Retrofitting-Espresso"><a href="#Retrofitting-Espresso" class="headerlink" title="Retrofitting Espresso"></a><a href="http://collectiveidea.com/blog/archives/2016/10/13/retrofitting-espresso/" target="_blank" rel="external">Retrofitting Espresso</a></h2><p>用Espresso做测试, 如何等待网络请求结束再验证UI.</p>
<h2 id="Composing-functions-in-Kotlin-with-extensions-and-operators"><a href="#Composing-functions-in-Kotlin-with-extensions-and-operators" class="headerlink" title="Composing functions in Kotlin with extensions and operators"></a><a href="https://www.novoda.com/blog/composing-functions-in-kotlin-with-extensions-and-operators/" target="_blank" rel="external">Composing functions in Kotlin with extensions and operators</a></h2><p>结合Kotlin的extensions和operator overloading功能, 改善function, 让代码变得更优雅.</p>
<h2 id="Authentication-sucks-Bad-security-too"><a href="#Authentication-sucks-Bad-security-too" class="headerlink" title="Authentication sucks. Bad security too"></a><a href="https://medium.com/@flschweiger/authentication-sucks-bad-security-too-345ed20463d4#.yl40vbtgd" target="_blank" rel="external">Authentication sucks. Bad security too</a></h2><p>一个例子, 说明为什么老的验证方法用户体验不好, 我们如何在仍然考虑用户安全的情况下进行改善.</p>
<p>解决方案是用Android 6.0推出的Android Keystore.<br>作者展示了如何实现并提供了<a href="https://github.com/flschweiger/SafeApp" target="_blank" rel="external">Demo</a>.</p>
<h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="Eight-don’ts-for-your-Material-Design-app"><a href="#Eight-don’ts-for-your-Material-Design-app" class="headerlink" title="Eight don’ts for your Material Design app"></a><a href="https://blog.prototypr.io/common-material-design-bad-practices-to-avoid-b7995f251329#.ij9u38lu7" target="_blank" rel="external">Eight don’ts for your Material Design app</a></h2><p>Material Design app需要避免的8个点.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Android-proguards"><a href="#Android-proguards" class="headerlink" title="Android-proguards"></a><a href="https://github.com/yongjhih/android-proguards" target="_blank" rel="external">Android-proguards</a></h2><p>使用一行就可以加上所有流行库的proguard.</p>
<h2 id="Moxy"><a href="#Moxy" class="headerlink" title="Moxy"></a><a href="https://github.com/Arello-Mobile/Moxy" target="_blank" rel="external">Moxy</a></h2><p>一个MVP的库.</p>
<h2 id="WiseFy"><a href="#WiseFy" class="headerlink" title="WiseFy"></a><a href="https://github.com/isuPatches/WiseFy" target="_blank" rel="external">WiseFy</a></h2><p>包装了Android的WifiManager和ConnectivityManager的一个库.</p>
<h1 id="VIDEOS-amp-PODCASTS"><a href="#VIDEOS-amp-PODCASTS" class="headerlink" title="VIDEOS &amp; PODCASTS"></a>VIDEOS &amp; PODCASTS</h1><p><a href="https://www.youtube.com/playlist?list=PLnVy79PaFHMXJha06t6pWfkYcATV4oPvC" target="_blank" rel="external">Droidcon NYC 2016</a><br>所有Droidcon NYC 2016的视频资源.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> Mockito </tag>
            
            <tag> Async-Await </tag>
            
            <tag> Activity </tag>
            
            <tag> Rotation </tag>
            
            <tag> JDK </tag>
            
            <tag> Authentication </tag>
            
            <tag> KeyStore </tag>
            
            <tag> proguard </tag>
            
            <tag> WifiManager </tag>
            
            <tag> ConfigurationManager </tag>
            
            <tag> Material Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit结合RxJava使用指南]]></title>
      <url>http://mengdd.github.io/Android/Retrofit/RxJava/2016/11/08/hello-retrofit-with-rxjava/</url>
      <content type="html"><![CDATA[<h1 id="Retrofit结合RxJava使用指南"><a href="#Retrofit结合RxJava使用指南" class="headerlink" title="Retrofit结合RxJava使用指南"></a>Retrofit结合RxJava使用指南</h1><p>Retrofit是一个当前很流行的网络请求库, 官网的介绍是: “Type-safe HTTP client for Android and Java”. 本文介绍Retrofit的使用.<br>先介绍单独使用Retrofit进行网络请求, 后面主要介绍和RxJava结合的请求, 有实例代码.</p>
<a id="more"></a>
<h2 id="Retrofit单独使用"><a href="#Retrofit单独使用" class="headerlink" title="Retrofit单独使用"></a>Retrofit单独使用</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>首先在manifest中加上网络权限:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>app/build.gradle</code>中加上依赖:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:retrofit:2.1.0'</span></div><div class="line"><span class="keyword">compile</span> <span class="string">'com.google.code.gson:gson:2.8.0'</span></div><div class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span></div></pre></td></tr></table></figure></p>
<h3 id="准备API和model类"><a href="#准备API和model类" class="headerlink" title="准备API和model类"></a>准备API和model类</h3><p>本例子中使用<a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API</a>做请求.</p>
<p>以Github的Root Endpoint为例:<br><code>https://api.github.com</code>.<br>首先, 我们在命令行发送:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl https://api.github.com</div></pre></td></tr></table></figure></p>
<p>或者在Postman发送这个请求, 两种方法都可以得到结果.</p>
<p>这个请求返回的是一个json.</p>
<p>利用这个网站: <a href="http://www.jsonschema2pojo.org/" target="_blank" rel="external">jsonschema2pojo</a>, 可以用json生成一个java类, 比如上面这个, 我们给它起名字叫<code>Endpoints.java</code>.</p>
<p>之后例子中的API都是这种方式, 先发送请求得到json, 然后转成java的model类.</p>
<h3 id="利用Retrofit发送请求并得到结果"><a href="#利用Retrofit发送请求并得到结果" class="headerlink" title="利用Retrofit发送请求并得到结果"></a>利用Retrofit发送请求并得到结果</h3><p>首先写一个<code>ServiceGenerator</code>类, 用于生成service:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceGenerator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_BASE_URL = <span class="string">"https://api.github.com"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient.Builder httpClient = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit.Builder builder =</div><div class="line">            <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                    .baseUrl(API_BASE_URL)</div><div class="line">                    .addConverterFactory(GsonConverterFactory.create());</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">S <span class="title">createService</span><span class="params">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</div><div class="line">        Retrofit retrofit = builder.client(httpClient.build()).build();</div><div class="line">        <span class="keyword">return</span> retrofit.create(serviceClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里指定了我们的base url.<br><code>createService()</code>方法返回的是一个泛型.</p>
<p>然后我们创建<code>GithubService</code>, 注意这是一个<strong>接口</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.ddmeng.helloretrofit.data.models.Endpoints;</div><div class="line"></div><div class="line"><span class="keyword">import</span> retrofit2.Call;</div><div class="line"><span class="keyword">import</span> retrofit2.http.GET;</div><div class="line"><span class="keyword">import</span> retrofit2.http.Url;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">    <span class="meta">@GET</span></div><div class="line">    <span class="function">Call&lt;Endpoints&gt; <span class="title">getAllEndpoints</span><span class="params">(@Url String url)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里<code>@GET</code>指定了是一个GET请求, 因为我们请求的就是base url, 所以是这样写的.<br><code>Endpoints</code>类是这个请求所返回的json转化的java类.</p>
<p>好了, 准备工作做完了, 现在就可以请求并得到结果:<br>请求github api的root url, 得到所有的endpoints:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">GitHubService gitHubService = ServiceGenerator.createService(GitHubService.class);</div><div class="line">Call&lt;Endpoints&gt; endpointsCall = gitHubService.getAllEndpoints(<span class="string">""</span>);</div><div class="line">endpointsCall.enqueue(<span class="keyword">new</span> Callback&lt;Endpoints&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Endpoints&gt; call, Response&lt;Endpoints&gt; response)</span> </span>&#123;</div><div class="line">        Endpoints endpoints = response.body();</div><div class="line">        String repositoryUrl = endpoints.getRepositoryUrl();</div><div class="line">        LogUtils.i(repositoryUrl);</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"repository url: "</span> + repositoryUrl, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Endpoints&gt; call, Throwable t)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>说明:<br>首先利用前面的ServiceGenerator来创建Service, 然后调用接口中定义的<code>getAllEndpoints()</code>方法, 此处传入了空字符串, 因为我请求的就是base url.</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>这里注意用Retrofit请求的返回值是<code>Call&lt;T&gt;</code> (后面我们还会介绍用RxJava的情形), 泛型T是model类型, 它有两个方法:</p>
<ul>
<li><code>execute()</code>是同步方法, 返回<code>Response&lt;T&gt;</code>;</li>
<li><code>enqueue()</code>是异步方法, 在上面的例子中用的就是这个, 在回调<code>onResponse()</code>中返回了<code>Response&lt;T&gt;</code>.</li>
</ul>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>Converter的作用: 如果不指定Converter, 默认情况下Retrofit只能返回<code>ResponseBody</code>类型, 加了Converter之后就可以返回我们定义的Model类型了.<br>所以Converter替我们做了json -&gt; model的工作.</p>
<p>本例子中ConverterFactory指定的是<code>GsonConverterFactory</code>. 这里我们选的是Gson Converter, 所以依赖的是<code>com.squareup.retrofit2:converter-gson</code>.</p>
<p>Retrofit支持多种converters:</p>
<ul>
<li>Gson: com.squareup.retrofit2:converter-gson</li>
<li>Jackson: com.squareup.retrofit2:converter-jackson</li>
<li>Moshi: com.squareup.retrofit2:converter-moshi</li>
<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>
<li>Wire: com.squareup.retrofit2:converter-wire</li>
<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>
<li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li>
</ul>
<h3 id="Path和参数"><a href="#Path和参数" class="headerlink" title="Path和参数"></a>Path和参数</h3><p>从上面返回的endpoints可以看到, user_url是: <code>https://api.github.com/users/{user}</code><br>这是一个带path参数的url, 我们发请求的时候在{user}处写一个github用户名, 即可得到该用户的信息, 比如:<br><code>https://api.github.com/users/mengdd</code>.</p>
<p>那么用Retrofit如何处理呢?<br>只需要在<code>GithubService</code>中增加一个方法, 这样写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">    <span class="meta">@GET</span></div><div class="line">    <span class="function">Call&lt;Endpoints&gt; <span class="title">getAllEndpoints</span><span class="params">(@Url String url)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;"</span>)</div><div class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用时的方法完全一样, 不再赘述, 同理, 如果要在后面加参数, 可以用<code>@Query</code>.<br>更多注解的例子见官方网站: <a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a></p>
<h2 id="Retrofit-RxJava"><a href="#Retrofit-RxJava" class="headerlink" title="Retrofit + RxJava"></a>Retrofit + RxJava</h2><p>RxJava近年来很流行, 主要优势是流式操作, 可以处理并行发送请求, 使用灵活, 线程切换容易.<br>当你要处理的逻辑比较复杂时, 就会发现使用RxJava的优势.</p>
<p>以我们的例子来说, 当前我们利用一个请求可以得到一个用户的信息并显示出来.<br>如果我们想得到这个用户的所有repo的所有者或者其他信息, 所有他follow的人的信息, 以及他们的repo的信息呢?</p>
<p>这就需要发很多个请求, 并且其中有些请求是并行发送的, 如果按照前面的方法, 不断地在callback里面嵌套, 那就太难看了.</p>
<h3 id="Setup-with-RxJava"><a href="#Setup-with-RxJava" class="headerlink" title="Setup with RxJava"></a>Setup with RxJava</h3><h4 id="添加RxJava依赖"><a href="#添加RxJava依赖" class="headerlink" title="添加RxJava依赖"></a>添加RxJava依赖</h4><p>首先, 添加RxJava和RxAndroid的依赖:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.2.2'</span></div><div class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.2.1'</span></div></pre></td></tr></table></figure></p>
<p>注: 虽然在我写这篇文章的时候(2016.11.4)RxJava2.0刚刚release, 但是我们还是先用RxJava1来写这个demo.</p>
<p>然后添加retrofit的adapter-rxjava:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.1.0'</span></div></pre></td></tr></table></figure></p>
<p>所以现在我们的依赖总的看起来是这样:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</div><div class="line">    androidTestCompile(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</div><div class="line">        <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.android.support'</span>, module: <span class="string">'support-annotations'</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">compile</span> <span class="string">"com.android.support:appcompat-v7:$&#123;supportLibVersion&#125;"</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">"com.android.support:design:$&#123;supportLibVersion&#125;"</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">"com.jakewharton:butterknife:$&#123;butterKnifeVersion&#125;"</span></div><div class="line">    apt <span class="string">"com.jakewharton:butterknife-compiler:$&#123;butterKnifeVersion&#125;"</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:retrofit:2.1.0'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.google.code.gson:gson:2.8.0'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.1.0'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.2.2'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.2.1'</span></div><div class="line">    testCompile <span class="string">'junit:junit:4.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Retrofit结合RxJava"><a href="#Retrofit结合RxJava" class="headerlink" title="Retrofit结合RxJava"></a>Retrofit结合RxJava</h4><p>Retrofit.Builder()中加入这一行:<br><code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create());</code></p>
<p>ServiceGenerator变成这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceGenerator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_BASE_URL = <span class="string">"https://api.github.com"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient.Builder httpClient = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit.Builder builder =</div><div class="line">            <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                    .baseUrl(API_BASE_URL)</div><div class="line">                    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create());</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">S <span class="title">createService</span><span class="params">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</div><div class="line">        Retrofit retrofit = builder.client(httpClient.build()).build();</div><div class="line">        <span class="keyword">return</span> retrofit.create(serviceClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们在<code>GithubService</code>中定义的接口方法, 既可以像原来一样返回<code>Call</code>, 也可以返回<code>Observable</code>.</p>
<h3 id="Retrofit-RxJava请求实例"><a href="#Retrofit-RxJava请求实例" class="headerlink" title="Retrofit + RxJava请求实例"></a>Retrofit + RxJava请求实例</h3><p>以单个请求为例,<br><strong>不用RxJava的时候</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/following"</span>)</div><div class="line">Call&lt;List&lt;User&gt;&gt; getUserFollowing(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div></pre></td></tr></table></figure></p>
<p>请求的时候是这样的:<br>请求指定用户follow的所有人:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GitHubService service = ServiceGenerator.createService(GitHubService.class);</div><div class="line">Call&lt;List&lt;User&gt;&gt; userFollowing = service.getUserFollowing(inputUserNameView.getText().toString());</div><div class="line">userFollowing.enqueue(<span class="keyword">new</span> Callback&lt;List&lt;User&gt;&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;User&gt;&gt; call, Response&lt;List&lt;User&gt;&gt; response)</span> </span>&#123;</div><div class="line">        List&lt;User&gt; followingUsers = response.body();</div><div class="line">        peopleListAdapter.setUsers(followingUsers);</div><div class="line">        peopleListAdapter.notifyDataSetChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;User&gt;&gt; call, Throwable t)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>现在改用RxJava了, 返回的不是Call而是Observable:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/following"</span>)</div><div class="line">Observable&lt;List&lt;User&gt;&gt; getUserFollowingObservable(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div></pre></td></tr></table></figure></p>
<p>结合RxJava请求的时候变为这样:<br>还是请求用户follow的所有人:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">GitHubService service = ServiceGenerator.createService(GitHubService.class);</div><div class="line">String username = inputUserNameView.getText().toString();</div><div class="line">service.getUserFollowingObservable(username)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;List&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                LogUtils.i(<span class="string">"onNext: "</span> + users.size());</div><div class="line">                peopleListAdapter.setUsers(users);</div><div class="line">                peopleListAdapter.notifyDataSetChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>用RxJava实现后, 请求返回的是一个Observable, 用<code>subscribe()</code>添加一个订阅者, 即它的观察者.<br>当请求返回后, 回到主线程, 更新UI.<br>这是单个请求的例子, 所以RxJava的优势不是很明显, 如果我们有多个请求, 用RxJava进行变换组合显然就是更好的选择.</p>
<h4 id="用RxJava进行线程切换"><a href="#用RxJava进行线程切换" class="headerlink" title="用RxJava进行线程切换"></a>用RxJava进行线程切换</h4><p>上个例子中<code>.subscribeOn(Schedulers.io())</code>指定Observable的工作, 在我们的例子中Observable的工作即发送请求, 在io线程做, 指定了被观察者的处理线程;<br><code>.observeOn(AndroidSchedulers.mainThread())</code>指定最后onNext()回调在主线程, 即指定了通知后续观察者的线程.<br>关于这两个操作符的更多说明请看官方文档: <a href="http://reactivex.io/documentation/operators/subscribeon.html" target="_blank" rel="external">subscribeOn</a>和<a href="http://reactivex.io/documentation/operators/observeon.html" target="_blank" rel="external">observeOn</a>.</p>
<h3 id="RxJava处理多个请求的例子"><a href="#RxJava处理多个请求的例子" class="headerlink" title="RxJava处理多个请求的例子"></a>RxJava处理多个请求的例子</h3><p>设计这样一个场景, 我们现在取到了一个用户follow的所有人, 但是取回的信息中并不包含每个人拥有的repo个数, 只有一个url可用户查看所有repo.</p>
<p>接下来我们要取其中每一个人的详细信息, 就要查询另一个API, 重新查询这个人的完整信息.<br>查询用户follow的所有人, 然后查询每一个人的详细信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">subscription = service.getUserFollowingObservable(username)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(users);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;User, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.getUserObservable(user.getLogin());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .toList()</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;List&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                peopleListAdapter.setUsers(users);</div><div class="line">                peopleListAdapter.notifyDataSetChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>可以看到我们加了两个<code>flatMap()</code>和一个<code>toList()</code>来做这个事情.</p>
<p>首先, 第一步我们用<code>getUserFollowingObservable()</code>得到的是一个<code>Observable&lt;List&lt;User&gt;&gt;</code>;<br>我们之后用<code>.flatMap()</code>, 它的输入是<code>List&lt;User&gt;</code>, 返回的是<code>Observable&lt;User&gt;</code>. 我们在其中用了一个<code>.from()</code>来生成一个发射一组User的<code>Observable</code>;</p>
<p>之后第二个<code>.flatMap()</code>里, 输入是前一个<code>Observable</code>的输出, 即User, 调用了<code>getUserObservable()</code>, 返回的结果是<code>Observable&lt;User&gt;</code>, 之后加一个<code>.toList()</code>, 把输出的结果从单个的User变为List<user>, 即和我们最初的例子一样. </user></p>
<p>只不过此时得到的用户信息是更详细的用户信息, 包含了他的repo数据和follow数据. 因为它们是通过单独查询每一个人得到的.</p>
<p>运行, 虽然可以得到我们想要的结果, 但是这个例子仍然是有问题的.</p>
<h4 id="线程问题处理"><a href="#线程问题处理" class="headerlink" title="线程问题处理"></a>线程问题处理</h4><p>上面多个请求的例子, 发现虽然实现了我们的需求, 但是结果回来得很慢.<br>我们加上一个<code>.map</code>操作符来加上log:<br>(这里省略了一些前后的代码, 只是在<code>.flatMap()</code>里加了一个<code>.map()</code>)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">subscription = service.getUserFollowingObservable(username)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(users);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;User, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.getUserObservable(user.getLogin())</div><div class="line">                        .map(<span class="keyword">new</span> Func1&lt;User, User&gt;() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> User <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                                <span class="comment">// this .map is used to output log information to check the threads</span></div><div class="line">                                LogUtils.i(<span class="string">"getUserObservable: "</span> + user.getLogin());</div><div class="line">                                <span class="keyword">return</span> user;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .toList()</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<p>由Log可以发现(log中的线程号是一样的)单独取每一个用户详细信息的请求都发生在同一个线程, 是顺次进行的.</p>
<p>查看代码:<br>Demo地址: <a href="https://github.com/mengdd/HelloRetrofit" target="_blank" rel="external">https://github.com/mengdd/HelloRetrofit</a>.<br><code>git checkout multiple-requests-in-single-thread</code></p>
<p>回头梳理一下我们的需求, 请求一个所有follow的人, 返回一个follow的人的List, 然后对List中的每一个人, 单独请求详细信息.</p>
<p>那么按理来说, 第二个批量的请求是可以同时发送, 并行进行的.<br>所以我们想要的行为其实是平行发送多个请求, 然后最后统一结果到UI线程. </p>
<p>改动如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">subscription = service.getUserFollowingObservable(username)</div><div class="line">        .subscribeOn(Schedulers.io()) <span class="comment">// 从io线程开始, 取用户follow的所有人</span></div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                LogUtils.i(<span class="string">"from"</span>);</div><div class="line">                <span class="keyword">return</span> Observable.from(users);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;User, Observable&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.getUserObservable(user.getLogin()) <span class="comment">// 取每个人的详细信息</span></div><div class="line">                        .subscribeOn(Schedulers.io()) <span class="comment">// 指定取每个人详细信息的工作都在单独的io线程</span></div><div class="line">                        .map(<span class="keyword">new</span> Func1&lt;User, User&gt;() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> User <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">                                <span class="comment">// this map operation is just used for showing log</span></div><div class="line">                                LogUtils.i(<span class="string">"getUserObservable: "</span> + user.getLogin());</div><div class="line">                                <span class="keyword">return</span> user;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .toList()</div><div class="line">        .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 最后返回到主线程</span></div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;List&lt;User&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</div><div class="line">                LogUtils.i(<span class="string">"onNext: "</span> + users.size());</div><div class="line">                peopleListAdapter.setUsers(users);</div><div class="line">                peopleListAdapter.notifyDataSetChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;)</div></pre></td></tr></table></figure></p>
<p>给改动的部分加上了注释, 这样更清楚一些.</p>
<p>注意<code>subscribeOn()</code>指定的是当前的这个Observable的工作在什么线程进行.<br>所以在本例子中, <code>subscribeOn(Schedulers.io())</code>的位置放在<code>.flatMap()</code>里面才会产生多个请求并行的效果.</p>
<p>这样一改, 我们的显示时间不再是所有请求时间之和, 而是只取决于最慢的那个请求时间.</p>
<p>查看代码:<br>Demo地址: <a href="https://github.com/mengdd/HelloRetrofit" target="_blank" rel="external">https://github.com/mengdd/HelloRetrofit</a><br><code>git checkout multiple-requests-in-multiple-threads</code></p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>正常情况下, 行为结束之后, 到达<code>onComplete()</code>或者<code>onError()</code>, RxJava的订阅会自动取消.<br>但是在处理网络请求的时候, 很可能会出现请求还没有返回, 界面就已经结束了的情况.</p>
<p>上面的代码中已经出现了, 订阅方法<code>subscribe()</code>的返回值是一个<code>Subscription</code>对象, 我们保存了这个对象的引用, 然后在<code>onPause()</code>的时候取消了请求, 防止内存泄露.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPause();</div><div class="line">    <span class="keyword">if</span> (subscription != <span class="keyword">null</span> &amp;&amp; subscription.isUnsubscribed()) &#123;</div><div class="line">        subscription.unsubscribe();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然也可以选别的生命周期回调, 比如<code>onDestroyView()</code>或者<code>onDestroy()</code>.</p>
<p>如果有多个请求, 可以用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> CompositeSubscription compositeSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">// 在发请求的地方, 返回subscription</span></div><div class="line">compositeSubscription.add(subscription);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 选一个生命周期注销所有请求</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPause();</div><div class="line">    compositeSubscription.unsubscribe();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Demo说明"><a href="#Demo说明" class="headerlink" title="Demo说明"></a>Demo说明</h2><p>Demo地址: <a href="https://github.com/mengdd/HelloRetrofit" target="_blank" rel="external">https://github.com/mengdd/HelloRetrofit</a></p>
<p>本Demo只用于展示Retrofit和RxJava结合的使用, 为了清晰起见所以没有采用MVP构架, 也没有用Dagger进行依赖注入, 有的请求也没有在生命周期结束时取消, 也没有UI的loading效果和没网情况的处理等, 大家使用时请根据实际需要做一些处理.</p>
<p>这些没有的东西会在我最近在做一个应用repo中出现: <a href="https://github.com/mengdd/GithubClient" target="_blank" rel="external">https://github.com/mengdd/GithubClient</a>, 还在开发中, 可以关注一下. </p>
<p>另, Demo使用有时候用着用着请求就返回了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;message&quot;:&quot;API rate limit exceeded for xxx ip...</div></pre></td></tr></table></figure></p>
<p>这是因为没授权的用户每小时最多只能发60个请求:<a href="https://developer.github.com/v3/#rate-limiting" target="_blank" rel="external">https://developer.github.com/v3/#rate-limiting</a><br>解决办法就是..查following的人时, 不要查那种follow了很多人的账号. orz.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit Github</a></li>
<li><a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit Website</a></li>
<li><a href="https://guides.codepath.com/android/Consuming-APIs-with-Retrofit" target="_blank" rel="external">CodePath- Consuming APIs with Retrofit</a></li>
<li><a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">Future Studio 系列教程</a></li>
<li><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="external">RxJava 与 Retrofit 结合的最佳实践</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Retrofit </category>
            
            <category> RxJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 229]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/11/01/android-weekly-notes-issue-229/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-229"><a href="#Android-Weekly-Issue-229" class="headerlink" title="Android Weekly Issue #229"></a>Android Weekly Issue #229</h1><p>October 30th, 2016<br><a href="http://androidweekly.net/issues/issue-229" target="_blank" rel="external">Android Weekly Issue #229</a><br>Android Weekly笔记, 本期内容包括: 性能库Pury的插件化; 一种新的多选设计和实现; 音频播放; Dagger的测试mock方案; ConstraintLayout的链式约束; Mobile Vision API的二维码扫描功能; RxJava的使用缺陷讨论; SOLID原则图解.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Get-access-to-raw-profiling-results-with-plugins-for-Pury"><a href="#Get-access-to-raw-profiling-results-with-plugins-for-Pury" class="headerlink" title="Get access to raw profiling results with plugins for Pury"></a><a href="https://medium.com/@nikita.kozlov/get-access-to-raw-profiling-results-with-plugins-for-pury-f9a7cc5e8345#.y26lx22wo" target="_blank" rel="external">Get access to raw profiling results with plugins for Pury</a></h2><p>Pury是一个做profile的工具, 前面有过一篇文章介绍: <a href="https://medium.com/@nikita.kozlov/pury-new-way-to-profile-your-android-application-7e248b5f615e#.57ggfep5p" target="_blank" rel="external">Pury</a>.</p>
<p>本文是作者的另一篇文章, 讲Pury的插件化和扩展.</p>
<p>另外, 作者最近正在集成Google Analytics到Pury中.</p>
<h2 id="Building-a-Multiselection-Solution-for-Android-in-Kotlin"><a href="#Building-a-Multiselection-Solution-for-Android-in-Kotlin" class="headerlink" title="Building a Multiselection Solution for Android in Kotlin"></a><a href="https://yalantis.com/blog/how-we-created-a-multiselection-solution-for-android/" target="_blank" rel="external">Building a Multiselection Solution for Android in Kotlin</a></h2><p>在移动应用上的多选设计很难, 通常不是很灵活, 用起来也不舒服. </p>
<p>本文推荐了一种全新的多选设计: 把屏幕分为两部分: 包括主要的列表和选中列表. 选中的项目自动移动到选中列表中去.</p>
<p>这个设计概念的实现: <code>ViewPager</code> + 两个<code>RecyclerView</code>.</p>
<p>作者选用了kotlin来实现. 列举了几个kotlin的features: Extension functions, Null safety, Collections, Better syntax.</p>
<p>作者的库: <a href="https://github.com/Yalantis/Multi-Selection" target="_blank" rel="external">Multi-Selection</a>.</p>
<p>本文中还介绍了如何使用这个库.</p>
<h2 id="Audio-not-playing-in-Android"><a href="#Audio-not-playing-in-Android" class="headerlink" title="Audio (not) playing in Android"></a><a href="https://medium.com/uptech-team/audio-not-playing-in-android-cde9a0fdfafd#.kp7qsjuha" target="_blank" rel="external">Audio (not) playing in Android</a></h2><p>关于Android上的音频播放, 作者的总结文章. </p>
<p>音频播放的方式有:</p>
<ul>
<li><a href="https://developer.android.com/reference/android/media/MediaPlayer.html" target="_blank" rel="external">MediaPlayer</a></li>
<li><a href="https://developer.android.com/reference/android/media/SoundPool.html" target="_blank" rel="external">SoundPool</a></li>
<li><a href="https://developer.android.com/reference/android/media/AudioTrack.html" target="_blank" rel="external">AudioTrack</a></li>
<li><a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">ExoPlayer</a></li>
</ul>
<p>关于<code>MediaPlayer</code>的使用, 官方文档: <a href="https://developer.android.com/guide/topics/media/mediaplayer.html" target="_blank" rel="external">Media Playback</a>, 本文中有一张图是<code>MediaPlayer</code>的生命周期图.</p>
<p>作者逐个列举了实际使用这些API时可能会遇到的一些issues. 并且最终选择的最佳解决方案是Google的<a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">ExoPlayer</a>, 2.0版本已经解决了她之前遇到的所有issues.</p>
<h2 id="Providing-test-doubles-with-Dagger-1-and-Dagger-2"><a href="#Providing-test-doubles-with-Dagger-1-and-Dagger-2" class="headerlink" title="Providing test doubles with Dagger 1 and Dagger 2"></a><a href="https://blog.egorand.me/providing-test-doubles-with-dagger-1-and-dagger-2/" target="_blank" rel="external">Providing test doubles with Dagger 1 and Dagger 2</a></h2><p>这篇文章讲在使用Dagger1和Dagger2的项目中, 如何为测试mock依赖.</p>
<h2 id="ConstraintLayout-Chains-–-Part-1"><a href="#ConstraintLayout-Chains-–-Part-1" class="headerlink" title="ConstraintLayout Chains – Part 1"></a><a href="https://blog.stylingandroid.com/constraintlayout-chains-spread-chains/" target="_blank" rel="external">ConstraintLayout Chains – Part 1</a></h2><p>作者讲了<code>ConstraintLayout</code>的一个重要特性: chains, 链.<br>chains是一个机制, 把一些独立的Views链起来, 然后我们可以对这一个集合来采取一些行为.</p>
<p>比如选中一个parent下的两个TextView(这两个本来是分别对齐parent的左右), 然后选择”Center Horizontally”, 就是建立了一个链.<br>在xml中实际上给这两个view都各自加上了一条限制条件, 限制它们在对方的(左/右)边, 这两条对称性的限制条件就构成了一个链.</p>
<p>这种链叫spread chains, 是默认的style.</p>
<h2 id="Machine-Learning-with-the-Mobile-Vision-API-—-Part-2"><a href="#Machine-Learning-with-the-Mobile-Vision-API-—-Part-2" class="headerlink" title="Machine Learning with the Mobile Vision API — Part 2 "></a><a href="https://hackernoon.com/machine-learning-for-android-developers-with-the-mobile-vision-api-part-2-barcode-detection-61e84c858518#.3dy9fgj56" target="_blank" rel="external">Machine Learning with the Mobile Vision API — Part 2 </a></h2><p>使用<a href="https://developers.google.com/vision/barcodes-overview" target="_blank" rel="external">Mobile Vision的Barcode API</a>来进行二维码检测.<br>Code: <a href="https://github.com/moyheen/barcode-detector" target="_blank" rel="external">barcode-detector</a>.</p>
<h2 id="Reactive-Frustrations"><a href="#Reactive-Frustrations" class="headerlink" title="Reactive Frustrations"></a><a href="https://upday.github.io/blog/reactive_frustrations_1/" target="_blank" rel="external">Reactive Frustrations</a></h2><p>大多数Rx相关的文章都说优点, 本篇不同, 作者分享了在使用RxJava过程中碰到的一些烦人的事情.<br>不过尽管有这些挫折, RxJava仍然是一个很棒的工具.</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>RxJava的文档有时候对初学者来说会很具迷惑性.<br>推荐看: <a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>, 有操作符图解.</p>
<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>RxJava的使用中会构建很多匿名类.<br>推荐使用: <a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">Retrolambda</a>, <a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>, 或<a href="https://source.android.com/source/jack.html" target="_blank" rel="external">Jack</a>.</p>
<h3 id="忘记subscribe"><a href="#忘记subscribe" class="headerlink" title="忘记subscribe"></a>忘记subscribe</h3><p>这是一个常见的错误, 如果只写好了Observable但没有触发, 通常是没有subscribe, 因为Observable是被动的, 只有当被订阅的时候才会触发.</p>
<h3 id="代码的推理"><a href="#代码的推理" class="headerlink" title="代码的推理"></a>代码的推理</h3><p>有时候很难看见一块代码就知道执行结果, 必须往上游排查.</p>
<p>所以作者在他们的项目中规定了一项对于Observable的命名规范:<br><code>...Once</code>表示只发射一次; <code>...Stream</code>表示会发射值, 或者不发射, 但是不会completes; <code>...OnceAndStream</code>订阅时会发射值, 之后可能会继续发射, 但是不会停止.</p>
<h3 id="map操作符"><a href="#map操作符" class="headerlink" title="...map操作符"></a><code>...map</code>操作符</h3><p>有一些比较容易混淆的操作符:</p>
<ul>
<li><code>flatMap</code>: 并行;</li>
<li><code>switchMap</code>: 中断前一个, 串行;</li>
<li><code>concatMap</code>: 等待前一个结束, 串行;</li>
</ul>
<h2 id="Designing-something-S-O-L-I-D"><a href="#Designing-something-S-O-L-I-D" class="headerlink" title="Designing something S.O.L.I.D"></a><a href="https://www.novoda.com/blog/designing-something-solid/" target="_blank" rel="external">Designing something S.O.L.I.D</a></h2><p><strong>SOLID</strong>是软件开发的五项原则:</p>
<p>SOLID (single responsibility, open-closed, Liskov substitution, interface segregation and dependency inversion).</p>
<p>这里是<a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="external">Wiki</a>)的解释.</p>
<p>这篇文章图形化地解释了SOLID, 配图和例子都很有趣.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Design-Is-Never-Done"><a href="#Design-Is-Never-Done" class="headerlink" title="Design Is Never Done"></a><a href="https://design.google.com/articles/design-is-never-done/" target="_blank" rel="external">Design Is Never Done</a></h2><p>Material Design的新工具套件和开源项目.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="EasyMVP"><a href="#EasyMVP" class="headerlink" title="EasyMVP"></a><a href="http://6thsolution.github.io/EasyMVP/" target="_blank" rel="external">EasyMVP</a></h2><p>一个MVP库. 比较特别的几点:</p>
<ul>
<li>使用注解来注入Presenter(可以和Dagger2结合使用, 否则只能注入无参构造), 绑定Presenter和View的生命周期;</li>
<li>使用Loaders来字啊configurations changes时保存Presenter;</li>
<li>加上<code>easymvp-rx</code>插件后, 遵循Clean Architecture原则, 加入了domain层, 提供了UseCase的基类;</li>
</ul>
<h2 id="Input-Mask"><a href="#Input-Mask" class="headerlink" title="Input Mask"></a><a href="https://github.com/RedMadRobot/input-mask-android" target="_blank" rel="external">Input Mask</a></h2><p>一个小的工具库, 可以按格式显示用户的输入. 比如在输入上加括号, 每三位数字空一格之类的.</p>
<h2 id="sdk-artifact-sync"><a href="#sdk-artifact-sync" class="headerlink" title="sdk-artifact-sync"></a><a href="https://github.com/JakeWharton/sdk-artifact-sync" target="_blank" rel="external">sdk-artifact-sync</a></h2><p>一个脚本, 同步你local Android SDK中的所有artifacts到一个remote的Maven artifact host上.</p>
<h2 id="material-remixer"><a href="#material-remixer" class="headerlink" title="material-remixer"></a><a href="https://github.com/material-foundation/material-remixer" target="_blank" rel="external">material-remixer</a></h2><p>material-remixer是一个工具, 利用它可以实时调整产品的UI参数. 目标平台: Android, iOS和Web都能用的工具.</p>
<h1 id="News"><a href="#News" class="headerlink" title="News"></a>News</h1><h2 id="ConstraintLayout-beta-2-is-now-available"><a href="#ConstraintLayout-beta-2-is-now-available" class="headerlink" title="ConstraintLayout beta 2 is now available"></a><a href="https://sites.google.com/a/android.com/tools/recent/constraintlayoutbeta2isnowavailable" target="_blank" rel="external">ConstraintLayout beta 2 is now available</a></h2><p>ConstraintLayout beta 2发布啦, 修改了一些issues并改善了性能.</p>
<h2 id="Google-Play-Services-Release-Notes"><a href="#Google-Play-Services-Release-Notes" class="headerlink" title="Google Play Services Release Notes"></a><a href="https://developers.google.com/android/guides/releases#october_2016_-_v98" target="_blank" rel="external">Google Play Services Release Notes</a></h2><p>Google Play Service 9.8发布了.</p>
<h2 id="Some-new-Firebase-libraries"><a href="#Some-new-Firebase-libraries" class="headerlink" title="Some new Firebase libraries"></a><a href="https://firebase.googleblog.com/2016/10/start-your-week-off-with-some-new-firebase-libraries.html" target="_blank" rel="external">Some new Firebase libraries</a></h2><p>Firebase也发了新版.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> RxJava </tag>
            
            <tag> Mobile Vision </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> Test </tag>
            
            <tag> Dagger </tag>
            
            <tag> Pury </tag>
            
            <tag> Multiselection </tag>
            
            <tag> Audio </tag>
            
            <tag> Barcode Detection </tag>
            
            <tag> SOLID </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Android Studio开发最常用到的快捷键]]></title>
      <url>http://mengdd.github.io/Android/Tools/IDE/2016/10/27/android-studio-shortcuts-used-frequently/</url>
      <content type="html"><![CDATA[<h1 id="Android-Studio常用快捷键"><a href="#Android-Studio常用快捷键" class="headerlink" title="Android Studio常用快捷键"></a>Android Studio常用快捷键</h1><p>Android Studio日常开发常用快捷键.<br>快捷键版本: Mac OS X 10.5+</p>
<a id="more"></a>
<h2 id="搜索查看类"><a href="#搜索查看类" class="headerlink" title="搜索查看类"></a>搜索查看类</h2><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">搜索所有文件</td>
<td style="text-align:left">double Shift</td>
</tr>
<tr>
<td style="text-align:left">搜索文件</td>
<td style="text-align:left">Cmd + Shift + O</td>
</tr>
<tr>
<td style="text-align:left">搜索类文件</td>
<td style="text-align:left">Cmd + O</td>
</tr>
<tr>
<td style="text-align:left">搜索符号</td>
<td style="text-align:left">Cmd + Opt + O</td>
</tr>
<tr>
<td style="text-align:left">打开最近的文件</td>
<td style="text-align:left">Cmd + E</td>
</tr>
<tr>
<td style="text-align:left">打开最近编辑过的文件</td>
<td style="text-align:left">Cmd + Shift + E</td>
</tr>
<tr>
<td style="text-align:left">在文件内搜索</td>
<td style="text-align:left">Cmd + F</td>
</tr>
<tr>
<td style="text-align:left">全文搜索</td>
<td style="text-align:left">Cmd + Shift + F</td>
</tr>
<tr>
<td style="text-align:left">显示结构, 类中方法</td>
<td style="text-align:left">Cmd + F12</td>
</tr>
<tr>
<td style="text-align:left">跳到当前文件</td>
<td style="text-align:left">F4</td>
</tr>
<tr>
<td style="text-align:left">从以上查找中途退出</td>
<td style="text-align:left">ESC</td>
</tr>
<tr>
<td style="text-align:left">发现引用</td>
<td style="text-align:left">Opt + F7(显示在下面)/ Opt + Cmd + F7(显示在当前)</td>
</tr>
<tr>
<td style="text-align:left">查找定义</td>
<td style="text-align:left">Cmd + B/ Cmd + 单击, 找到定义后再次点击会显示所有引用</td>
</tr>
<tr>
<td style="text-align:left">找子类/实现</td>
<td style="text-align:left">Cmd + Opt + B</td>
</tr>
<tr>
<td style="text-align:left">找基类/接口</td>
<td style="text-align:left">Cmd + U</td>
</tr>
<tr>
<td style="text-align:left">高亮Usages</td>
<td style="text-align:left">Cmd + Shift + F7</td>
</tr>
<tr>
<td style="text-align:left">查找Action</td>
<td style="text-align:left">Cmd + Shift + A</td>
</tr>
<tr>
<td style="text-align:left">显示文件在项目中的位置</td>
<td style="text-align:left">Opt + F1, 再加Enter</td>
</tr>
<tr>
<td style="text-align:left">复制当前文件的路径</td>
<td style="text-align:left">Cmd + Shift + C</td>
</tr>
</tbody>
</table>
<h2 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h2><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">复制</td>
<td style="text-align:left">Cmd + C</td>
</tr>
<tr>
<td style="text-align:left">剪切</td>
<td style="text-align:left">Cmd + X</td>
</tr>
<tr>
<td style="text-align:left">粘贴</td>
<td style="text-align:left">Cmd + V</td>
</tr>
<tr>
<td style="text-align:left">从剪切板粘贴</td>
<td style="text-align:left">Cmd + Shift + V</td>
</tr>
<tr>
<td style="text-align:left">复制当前行或当前选中块</td>
<td style="text-align:left">Cmd + D</td>
</tr>
<tr>
<td style="text-align:left">以光标位置向前, 删除一个词</td>
<td style="text-align:left">Opt + delete</td>
</tr>
<tr>
<td style="text-align:left">删除一行</td>
<td style="text-align:left">Cmd + delete</td>
</tr>
<tr>
<td style="text-align:left">把代码包起来: try-catch等</td>
<td style="text-align:left">Cmd + Opt + T</td>
</tr>
<tr>
<td style="text-align:left">查看方法的参数信息</td>
<td style="text-align:left">Cmd + P</td>
</tr>
</tbody>
</table>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">生成方法</td>
<td style="text-align:left">Cmd + N</td>
</tr>
<tr>
<td style="text-align:left">生成未定义的方法</td>
<td style="text-align:left">Opt + Enter</td>
</tr>
<tr>
<td style="text-align:left">Override方法</td>
<td style="text-align:left">Ctrl + O</td>
</tr>
<tr>
<td style="text-align:left">实现(implement)方法</td>
<td style="text-align:left">Ctrl + I</td>
</tr>
</tbody>
</table>
<h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加import语句</td>
<td style="text-align:left">Opt + Enter</td>
</tr>
<tr>
<td style="text-align:left">显示Warning信息并采用快捷修复</td>
<td style="text-align:left">Opt + Enter</td>
</tr>
</tbody>
</table>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">重命名</td>
<td style="text-align:left">Shift + F6</td>
</tr>
<tr>
<td style="text-align:left">更改签名(重构方法)</td>
<td style="text-align:left">Cmd + F6</td>
</tr>
<tr>
<td style="text-align:left">提取方法M,变量V,字段F,常量C,参数P</td>
<td style="text-align:left">Cmd + Opt + M,V,F,C,P</td>
</tr>
<tr>
<td style="text-align:left">内联</td>
<td style="text-align:left">Cmd + Opt + N</td>
</tr>
</tbody>
</table>
<h3 id="选择-移动"><a href="#选择-移动" class="headerlink" title="选择, 移动"></a>选择, 移动</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">移动到某一行</td>
<td style="text-align:left">Cmd + L</td>
</tr>
<tr>
<td style="text-align:left">选中行</td>
<td style="text-align:left">Cmd + Shift + 方向</td>
</tr>
<tr>
<td style="text-align:left">选中词</td>
<td style="text-align:left">Opt + 上下方向</td>
</tr>
<tr>
<td style="text-align:left">按词移动光标</td>
<td style="text-align:left">Opt + 左右方向</td>
</tr>
<tr>
<td style="text-align:left">返回上/下一次光标所在的地方</td>
<td style="text-align:left">Cmd + Opt + 左右方向</td>
</tr>
<tr>
<td style="text-align:left">移动当前行</td>
<td style="text-align:left">Cmd + Shift + 上下方向</td>
</tr>
</tbody>
</table>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">格式化代码</td>
<td style="text-align:left">Cmd + Opt + L</td>
</tr>
<tr>
<td style="text-align:left">优化imports</td>
<td style="text-align:left">Ctrl + Opt + O</td>
</tr>
</tbody>
</table>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">行注释</td>
<td style="text-align:left">Cmd + /</td>
</tr>
<tr>
<td style="text-align:left">块注释</td>
<td style="text-align:left">Cmd + Opt + /</td>
</tr>
</tbody>
</table>
<h2 id="运行调试类"><a href="#运行调试类" class="headerlink" title="运行调试类"></a>运行调试类</h2><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">运行</td>
<td style="text-align:left">Ctrl + R</td>
</tr>
<tr>
<td style="text-align:left">运行…</td>
<td style="text-align:left">Ctrl + Opt + R</td>
</tr>
<tr>
<td style="text-align:left">调试</td>
<td style="text-align:left">Ctrl + D</td>
</tr>
<tr>
<td style="text-align:left">调试…</td>
<td style="text-align:left">Ctrl + Opt + D</td>
</tr>
<tr>
<td style="text-align:left">设置断点</td>
<td style="text-align:left">Cmd + F8</td>
</tr>
<tr>
<td style="text-align:left">单步执行</td>
<td style="text-align:left">F8</td>
</tr>
<tr>
<td style="text-align:left">跑到光标处</td>
<td style="text-align:left">Opt + F9</td>
</tr>
<tr>
<td style="text-align:left">看表达式</td>
<td style="text-align:left">Opt + F8</td>
</tr>
<tr>
<td style="text-align:left">Resume</td>
<td style="text-align:left">Opt + Cmd + R</td>
</tr>
<tr>
<td style="text-align:left">查看所有断点</td>
<td style="text-align:left">Shift + Cmd + F8</td>
</tr>
</tbody>
</table>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">生成或打开测试类</td>
<td style="text-align:left">Cmd + Shift + T</td>
</tr>
<tr>
<td style="text-align:left">运行测试</td>
<td style="text-align:left">Ctrl + Shift + R</td>
</tr>
<tr>
<td style="text-align:left">调试测试</td>
<td style="text-align:left">Ctrl + Shift + D</td>
</tr>
</tbody>
</table>
<h2 id="版本控制类"><a href="#版本控制类" class="headerlink" title="版本控制类"></a>版本控制类</h2><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">显示版本控制窗口</td>
<td style="text-align:left">Cmd + 9</td>
</tr>
<tr>
<td style="text-align:left">显示Diff</td>
<td style="text-align:left">Cmd + D</td>
</tr>
<tr>
<td style="text-align:left">下一个Diff</td>
<td style="text-align:left">F7</td>
</tr>
<tr>
<td style="text-align:left">在Diff中打开文件</td>
<td style="text-align:left">F4</td>
</tr>
</tbody>
</table>
<h2 id="窗口类"><a href="#窗口类" class="headerlink" title="窗口类"></a>窗口类</h2><table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">Mac快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">显示Android Monitor</td>
<td style="text-align:left">Cmd + 6</td>
</tr>
<tr>
<td style="text-align:left">代码全屏或退出</td>
<td style="text-align:left">Cmd + Shift + F12</td>
</tr>
<tr>
<td style="text-align:left">打开Preferences</td>
<td style="text-align:left">Cmd + ,</td>
</tr>
<tr>
<td style="text-align:left">打开项目结构窗口</td>
<td style="text-align:left">Cmd + ;</td>
</tr>
<tr>
<td style="text-align:left">快速切换scheme</td>
<td style="text-align:left">Ctrl + `</td>
</tr>
</tbody>
</table>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="https://developer.android.com/studio/intro/keyboard-shortcuts.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://saulmm.github.io/the-powerful-android-studio" target="_blank" rel="external">The powerful Android Studio</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Tools </category>
            
            <category> IDE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 228]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/Nougat/Design-Support-Library/2016/10/26/android-weekly-notes-issue-228/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-228"><a href="#Android-Weekly-Issue-228" class="headerlink" title="Android Weekly Issue #228"></a>Android Weekly Issue #228</h1><p>October 23rd, 2016<br><a href="http://androidweekly.net/issues/issue-228" target="_blank" rel="external">Android Weekly Issue #228</a></p>
<p>本期内容包括:<br>Android 7.1的App Shortcuts; Searchbar的设计讨论; Nougat的Direct Reply; Alarms API讨论; Support Library的BottomNavigationView; MVVM模式; Dagger2的subcomponent实现; Test Rules介绍等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-7-1-Static-Shortcut"><a href="#Android-7-1-Static-Shortcut" class="headerlink" title="Android 7.1 Static Shortcut"></a><a href="https://medium.com/@tonyowen/android-7-1-static-shortcut-6c42d81ba11b#.8emk7ssh1" target="_blank" rel="external">Android 7.1 Static Shortcut</a></h2><h2 id="Exploring-Android-Nougat-7-1-App-Shortcuts"><a href="#Exploring-Android-Nougat-7-1-App-Shortcuts" class="headerlink" title="Exploring Android Nougat 7.1 App Shortcuts"></a><a href="https://catinean.com/2016/10/20/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></h2><p>这两篇文章都在介绍Android 7.1的App Shortcuts.</p>
<p>本博客相关文章: <a href="http://www.cnblogs.com/mengdd/p/5996665.html" target="_blank" rel="external">Android 7.1 App Shortcuts使用
</a> .</p>
<h2 id="Exposing-the-Searchbar"><a href="#Exposing-the-Searchbar" class="headerlink" title="Exposing the Searchbar"></a><a href="https://medium.com/@alexstyl/https-medium-com-alexstyl-animating-the-toolbar-7a8f1aab39dd#.283nz252o" target="_blank" rel="external">Exposing the Searchbar</a></h2><p>比起点击一个search icon, 然后进入搜索屏, 用户更喜欢一个search bar, 然后直接就可以在主屏上进行搜索.</p>
<p>作者对于他们的应用想到的解决方式就是, 在主屏上放一个search bar,然后 用一个transition, 把主屏和搜索屏(两个Activity)衔接起来, 这样用户在点击search bar之后, 不会感觉到他们打开了一个新屏.</p>
<p>另一个效果就是, 在点击search bar之后, 当前屏fade away, search bar展开, 在第二屏直接打开键盘, 用户可以进行搜索.</p>
<p>Code: <a href="https://github.com/alexstyl/Material-SearchTransition" target="_blank" rel="external">Material-SearchTransition</a>.</p>
<h2 id="Nougat-Direct-Reply"><a href="#Nougat-Direct-Reply" class="headerlink" title="Nougat - Direct Reply"></a><a href="https://blog.stylingandroid.com/nougat-direct-reply/" target="_blank" rel="external">Nougat - Direct Reply</a></h2><p>Direct Reply是指用户可以直接回复Notification, 而不用打开app.<br>这篇文章作者示例了如何实现在message app中用Direct Reply清除消息和直接回复.</p>
<h2 id="Da-Real-Fragmentation-Alarms"><a href="#Da-Real-Fragmentation-Alarms" class="headerlink" title="Da Real Fragmentation - Alarms"></a><a href="http://pguardiola.com/blog/darealfragmentation-alarms/" target="_blank" rel="external">Da Real Fragmentation - Alarms</a></h2><p>作者这篇文章先是详细介绍了Alarm的各个选项和使用情形, 以及它的API版本变化.</p>
<h2 id="Bottom-Navigation-View-in-the-Design-Support-Library"><a href="#Bottom-Navigation-View-in-the-Design-Support-Library" class="headerlink" title="Bottom Navigation View in the Design Support Library"></a><a href="https://blog.autsoft.hu/now-you-can-use-the-bottom-navigation-view-in-the-design-support-library/" target="_blank" rel="external">Bottom Navigation View in the Design Support Library</a></h2><p>在Design Support Library 25.0.0中, Google发布了Bottom Navigation的官方实现: <a href="https://developer.android.com/reference/android/support/design/widget/BottomNavigationView.html" target="_blank" rel="external">BottomNavigationView</a>.<br>这篇文章写了如何使用这个View, 并且最后列出了一些第三方库.</p>
<h2 id="Shades-of-MVVM"><a href="#Shades-of-MVVM" class="headerlink" title="Shades of MVVM"></a><a href="https://www.bignerdranch.com/blog/shades-of-mvvm/" target="_blank" rel="external">Shades of MVVM</a></h2><p>作者讨论了MVVM模式及它的几种变形.</p>
<h2 id="Activities-Subcomponents-Multibinding-in-Dagger-2"><a href="#Activities-Subcomponents-Multibinding-in-Dagger-2" class="headerlink" title="Activities Subcomponents Multibinding in Dagger 2"></a><a href="https://medium.com/azimolabs/activities-subcomponents-multibinding-in-dagger-2-85d6053d6a95#.p9bh8bjoc" target="_blank" rel="external">Activities Subcomponents Multibinding in Dagger 2</a></h2><p><a href="https://github.com/google/dagger/releases/tag/dagger-2.7" target="_blank" rel="external">dagger-2.7</a> 添加了<code>@Modules.subcomponents</code>.<br>本文演示了如何用这个更好地添加子ActivityComponent. 而不用每次都借助AppComponent. 这样做除了解耦之外, 对于测试时很有帮助.</p>
<p>例子代码: <a href="https://github.com/frogermcs/Dagger2Recipes-ActivitiesMultibinding" target="_blank" rel="external">Dagger2Recipes-ActivitiesMultibinding</a></p>
<h2 id="Experimenting-with-TensorFlow-on-Android-Part-1"><a href="#Experimenting-with-TensorFlow-on-Android-Part-1" class="headerlink" title="Experimenting with TensorFlow on Android Part 1 "></a><a href="https://medium.com/@mgazar/experimenting-with-tensorflow-on-android-pt-1-362683b31838#.ylwet4d3p" target="_blank" rel="external">Experimenting with TensorFlow on Android Part 1 </a></h2><p><a href="https://www.tensorflow.org/" target="_blank" rel="external">TensorFlow</a>是一个Machine Intelligence开源库, 主要的用途是数据计算, deep learning等.</p>
<p><a href="https://www.bazel.io/" target="_blank" rel="external">bazel</a>是一个build tool, 功能类似于gradle.</p>
<p>本文讲了如何setup.</p>
<h2 id="Understanding-Test-Rules"><a href="#Understanding-Test-Rules" class="headerlink" title="Understanding Test Rules"></a><a href="https://blog.egorand.me/understanding-test-rules/" target="_blank" rel="external">Understanding Test Rules</a></h2><p>Espresso中的Rule是如何工作的呢?<br>之前有一个文章: <a href="http://cwd.dhemery.com/2010/12/junit-rules/" target="_blank" rel="external">Using Rules To Influence JUnit Test Execution</a>说明JUnit中的Rule是如何工作的.</p>
<p>然后作者讲了如何自定义一个TestRule.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Sketch-template-for-app-shortcuts"><a href="#Sketch-template-for-app-shortcuts" class="headerlink" title="Sketch template for app shortcuts"></a><a href="https://plus.google.com/+RomanNurik/posts/3HMBgjn546j" target="_blank" rel="external">Sketch template for app shortcuts</a></h2><p>作者分享了为Android 7.1的app shortcuts功能而准备的sketch模板.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="PageIndicatorView"><a href="#PageIndicatorView" class="headerlink" title="PageIndicatorView"></a><a href="https://github.com/romandanylyk/PageIndicatorView" target="_blank" rel="external">PageIndicatorView</a></h2><p>Page Indicator, 结合Android ViewPager使用的, 转换时有点点连接的功能.</p>
<h2 id="PermissionUtil"><a href="#PermissionUtil" class="headerlink" title="PermissionUtil"></a><a href="https://github.com/kayvannj/PermissionUtil" target="_blank" rel="external">PermissionUtil</a></h2><p>一个Android 6.0 permission请求的库.</p>
<h2 id="DeviceAnimationTestRule"><a href="#DeviceAnimationTestRule" class="headerlink" title="DeviceAnimationTestRule"></a><a href="https://github.com/VictorAlbertos/DeviceAnimationTestRule" target="_blank" rel="external">DeviceAnimationTestRule</a></h2><p>一个JUnit rule, 用来disable和enable设备动画.</p>
<h2 id="DiagonalLayout"><a href="#DiagonalLayout" class="headerlink" title="DiagonalLayout"></a><a href="https://github.com/florent37/DiagonalLayout" target="_blank" rel="external">DiagonalLayout</a></h2><p>对角线布局, 感觉怪怪的.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="Android-7-1-Developer-Preview"><a href="#Android-7-1-Developer-Preview" class="headerlink" title="Android 7.1 Developer Preview"></a><a href="http://android-developers.blogspot.com.au/2016/10/android71-dev-preview-available.html" target="_blank" rel="external">Android 7.1 Developer Preview</a></h2><p>Android 7.1发了Developer Preview啦.<br>官网Overview在这里: <a href="https://developer.android.com/preview/api-overview.html" target="_blank" rel="external">Android 7.1 for Developers</a></p>
<h2 id="ConstraintLayout-beta-1-is-now-available"><a href="#ConstraintLayout-beta-1-is-now-available" class="headerlink" title="ConstraintLayout beta 1 is now available"></a><a href="https://sites.google.com/a/android.com/tools/recent/constraintlayoutbeta1isnowavailable" target="_blank" rel="external">ConstraintLayout beta 1 is now available</a></h2><p>ConstraintLayout beta 1发布啦.</p>
<h1 id="TOOLS"><a href="#TOOLS" class="headerlink" title="TOOLS"></a>TOOLS</h1><h2 id="Learn-You-a-Git"><a href="#Learn-You-a-Git" class="headerlink" title="Learn You a Git"></a><a href="https://karumi.github.io/learnyougit/" target="_blank" rel="external">Learn You a Git</a></h2><p>教你学习Git的工具.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
            <category> Nougat </category>
            
            <category> Design Support Library </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> Nougat </tag>
            
            <tag> Android 7 </tag>
            
            <tag> Shortcuts </tag>
            
            <tag> Test </tag>
            
            <tag> Alarm </tag>
            
            <tag> BottomNavigationView </tag>
            
            <tag> MVVM </tag>
            
            <tag> Dagger </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 7.1 App Shortcuts使用]]></title>
      <url>http://mengdd.github.io/Android/Nougat/2016/10/25/nougat-app-shortcuts/</url>
      <content type="html"><![CDATA[<h1 id="Android-7-1-App-Shortcuts使用"><a href="#Android-7-1-App-Shortcuts使用" class="headerlink" title="Android 7.1 App Shortcuts使用"></a>Android 7.1 App Shortcuts使用</h1><p>Android 7.1已经发了预览版, 这里是API Overview: <a href="https://developer.android.com/preview/api-overview.html" target="_blank" rel="external">API overview</a>.<br>其中App Shortcuts是新提供的一种快捷访问方式, 形式为长按应用图标出现的长条.</p>
<p><img src="/images/app-shortcuts.png" alt="app shortcuts"><br>图来自: <a href="https://catinean.com/2016/10/20/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></p>
<p>点击快捷方式可以访问应用功能, 并且这种快捷方式也可以被拖拽到桌面单独放置.</p>
<a id="more"></a>
<h2 id="App-Shortcuts-是什么"><a href="#App-Shortcuts-是什么" class="headerlink" title="App Shortcuts 是什么"></a>App Shortcuts 是什么</h2><p>其中App Shortcuts是指在桌面长按app图标而出现的快捷方式, 可以为你的app的关键功能添加更快速的入口而不用先打开app.</p>
<p><img src="/images/app-shortcuts-doc.png" alt="app shortcuts"></p>
<p>点击快捷方式可以访问应用功能, 并且这种快捷方式也可以被拖拽到桌面单独放置, 变成单独的桌面快捷方式(pinned shortcuts).</p>
<p>有两种shortcuts:</p>
<ul>
<li>静态的: 在xml中定义, 适用于一些通用的动作.</li>
<li>动态的: 由<a href="https://developer.android.com/reference/android/content/pm/ShortcutManager.html" target="_blank" rel="external">ShortcutManager</a>发布, 可以根据用户的行为或者偏好添加, 可以动态更新.</li>
</ul>
<p>每一个应用目前最多可以有5个shortcuts(静态 + 动态).</p>
<p>运行条件:<br>应用添加App Shortcuts是Android 7.1(API 25)的API, 所以只能在Android 7.1的设备上显示, 同时需要launcher支持, 比如Pixel launcher(Pixel设备的默认launcher), Now launcher(Nexus设备上的launcher)现在就支持, 其他launcher也可以提供支持.</p>
<h2 id="静态Shortcuts使用"><a href="#静态Shortcuts使用" class="headerlink" title="静态Shortcuts使用"></a>静态Shortcuts使用</h2><p>静态的Shortcuts是写在xml中的, 直到下一次应用升级, 不能被改变.<br>要添加静态shortcuts只需两步:<br>首先, 在应用的Manifest中启动Activity上添加<code>&lt;meta-data&gt;</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">        <span class="attr">android:name</span>=<span class="string">"android.app.shortcuts"</span></div><div class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/shortcuts"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在<code>res/xml/</code>目录下创建<code>shortcuts.xml</code>文件, 里面包含静态的shortcuts:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">shortcuts</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shortcut</span></span></div><div class="line">        <span class="attr">android:enabled</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_check_circle_black_24dp"</span></div><div class="line">        <span class="attr">android:shortcutDisabledMessage</span>=<span class="string">"@string/static_shortcut_disabled_message"</span></div><div class="line">        <span class="attr">android:shortcutId</span>=<span class="string">"static"</span></div><div class="line">        <span class="attr">android:shortcutLongLabel</span>=<span class="string">"@string/static_shortcut_long_label_1"</span></div><div class="line">        <span class="attr">android:shortcutShortLabel</span>=<span class="string">"@string/static_shortcut_short_label_1"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">intent</span></span></div><div class="line">            <span class="attr">android:action</span>=<span class="string">"android.intent.action.VIEW"</span></div><div class="line">            <span class="attr">android:targetClass</span>=<span class="string">"com.ddmeng.hellonougat.shortcuts.StaticShortcutActivity"</span></div><div class="line">            <span class="attr">android:targetPackage</span>=<span class="string">"com.ddmeng.hellonougat"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">shortcut</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shortcut</span></span></div><div class="line">        <span class="attr">android:enabled</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_android_black_24dp"</span></div><div class="line">        <span class="attr">android:shortcutDisabledMessage</span>=<span class="string">"@string/static_shortcut_disabled_message"</span></div><div class="line">        <span class="attr">android:shortcutId</span>=<span class="string">"static_2"</span></div><div class="line">        <span class="attr">android:shortcutLongLabel</span>=<span class="string">"@string/static_shortcut_long_label_2"</span></div><div class="line">        <span class="attr">android:shortcutShortLabel</span>=<span class="string">"@string/static_shortcut_short_label_2"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">intent</span></span></div><div class="line">            <span class="attr">android:action</span>=<span class="string">"android.intent.action.MAIN"</span></div><div class="line">            <span class="attr">android:targetClass</span>=<span class="string">"com.ddmeng.hellonougat.MainActivity"</span></div><div class="line">            <span class="attr">android:targetPackage</span>=<span class="string">"com.ddmeng.hellonougat"</span> /&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">intent</span></span></div><div class="line">            <span class="attr">android:action</span>=<span class="string">"com.ddmeng.hellonougat.action.STATIC_SHORTCUT_2"</span></div><div class="line">            <span class="attr">android:targetClass</span>=<span class="string">"com.ddmeng.hellonougat.shortcuts.StaticShortcutActivity"</span></div><div class="line">            <span class="attr">android:targetPackage</span>=<span class="string">"com.ddmeng.hellonougat"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">shortcut</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">shortcuts</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这就好了, 这个文件添加了两个shortcuts, 点击都将打开指定的Activity, 本例子中是<code>StaticShortcutActivity</code>.</p>
<h3 id="用多个Intent构建back-stack"><a href="#用多个Intent构建back-stack" class="headerlink" title="用多个Intent构建back stack"></a>用多个Intent构建back stack</h3><p>上面这个文件里添加了两个静态的shortcuts, 第一个关联了一个Activity, 点击shortcut将直接打开这个Activity, 回退的时候回到桌面.</p>
<p>如果你想要的效果是点击back键回到应用里的某个界面, 那么可以利用多个intents来构建back stack, 比如在第二个shortcut里面, 点击shortcut还是打开目标Activity, 这个指定目标Activity的Intent放在最后, 但是回退会返回到MainActivity, 即之前的那个Intent.</p>
<h2 id="动态Shortcuts使用"><a href="#动态Shortcuts使用" class="headerlink" title="动态Shortcuts使用"></a>动态Shortcuts使用</h2><p>动态的shortcuts可以在用户使用app的过程中构建, 更新, 或者删除.<br>使用<a href="https://developer.android.com/reference/android/content/pm/ShortcutManager.html" target="_blank" rel="external">ShortcutManager</a>可以对动态shortcuts完成下面几种操作:</p>
<ul>
<li>Publish发布: <code>setDynamicShortcuts()</code>, <code>addDynamicShortcuts(List)</code>;</li>
<li>Update更新: <code>updateShortcuts(List)</code>;</li>
<li>Remove删除: <code>removeDynamicShortcuts(List)</code>, <code>removeAllDynamicShortcuts()</code>.</li>
</ul>
<p>比如添加一个动态shortcut:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);</div><div class="line"></div><div class="line">ShortcutInfo shortcut = <span class="keyword">new</span> ShortcutInfo.Builder(<span class="keyword">this</span>, <span class="string">"id1"</span>)</div><div class="line">    .setShortLabel(<span class="string">"Web site"</span>)</div><div class="line">    .setLongLabel(<span class="string">"Open the web site"</span>)</div><div class="line">    .setIcon(Icon.createWithResource(context, R.drawable.icon_website))</div><div class="line">    .setIntent(<span class="keyword">new</span> Intent(Intent.ACTION_VIEW,</div><div class="line">                   Uri.parse(<span class="string">"https://www.mysite.example.com/"</span>)))</div><div class="line">    .build();</div><div class="line"></div><div class="line">shortcutManager.setDynamicShortcuts(Arrays.asList(shortcut));</div></pre></td></tr></table></figure></p>
<p>点击这个shortcut会发出一个打开网页的Intent, 让你选择浏览器, 从而打开网址.</p>
<h3 id="多个Intent构建back-stack"><a href="#多个Intent构建back-stack" class="headerlink" title="多个Intent构建back stack"></a>多个Intent构建back stack</h3><p>动态的shortcut仍然可以用多个Intent来指定一个back stack, 那么打开目标Activity之后就可以返回到应用中的指定界面而不是回到launcher:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ShortcutInfo dynamicShortcut2 = <span class="keyword">new</span> ShortcutInfo.Builder(<span class="keyword">this</span>, <span class="string">"shortcut_dynamic"</span>)</div><div class="line">        .setShortLabel(<span class="string">"Dynamic Shortcut"</span>)</div><div class="line">        .setLongLabel(<span class="string">"Open Dynamic shortcut 2"</span>)</div><div class="line">        .setIcon(Icon.createWithResource(<span class="keyword">this</span>, R.drawable.ic_favorite_border_black_24dp))</div><div class="line">        .setIntents(</div><div class="line">                <span class="comment">// this dynamic shortcut set up a back stack using Intents, when pressing back, will go to MainActivity</span></div><div class="line">                <span class="comment">// the last Intent is what the shortcut really opened</span></div><div class="line">                <span class="keyword">new</span> Intent[]&#123;</div><div class="line">                        <span class="keyword">new</span> Intent(Intent.ACTION_MAIN, Uri.EMPTY, <span class="keyword">this</span>, MainActivity.class).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK),</div><div class="line">                        <span class="keyword">new</span> Intent(DynamicShortcutActivity.ACTION_OPEN_DYNAMIC)</div><div class="line">                        <span class="comment">// intent's action must be set</span></div><div class="line">                &#125;)</div><div class="line">        .build();</div></pre></td></tr></table></figure></p>
<p>和静态一样, 最后一个Intent对应的是shortcut打开的界面<code>DynamicShortcutActivity</code>, 前面的都是用来构建back stack, 即back退回到MainActivity.<br>注意这里的Intent必须指定Action, 否则会抛出异常.</p>
<h2 id="Shortcuts的个数限制"><a href="#Shortcuts的个数限制" class="headerlink" title="Shortcuts的个数限制"></a>Shortcuts的个数限制</h2><p>Shortcuts的总数不能超过5个, 即静态和动态shortcuts加起来总数最多是五个.<br>当我们尝试添加第六个shortcut时, 应用会抛出异常: <code>java.lang.IllegalArgumentException: Max number of dynamic shortcuts exceeded</code>.</p>
<p>虽然总数限制是5个, 但是当我正好有5个(2个静态 + 3个动态)的时候, 长按只显示了4个shortcuts.<br>如图:</p>
<p><img src="/images/app-shortcuts-demo-screenshot.png" alt="app shortcuts"></p>
<p>本文完整代码见: Demo地址: <a href="https://github.com/mengdd/HelloNougat" target="_blank" rel="external">HelloNougat</a>.</p>
<h2 id="Shortcuts的次序"><a href="#Shortcuts的次序" class="headerlink" title="Shortcuts的次序"></a>Shortcuts的次序</h2><p>当我们有多个Shortcuts之后, 默认它们是按照添加顺序排列的, 即按照添加顺序rank递增.</p>
<p>可以通过<code>setRank()</code>来改变长按时它们显示的排序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TargetApi</span>(<span class="number">25</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDynamicShortcuts</span><span class="params">()</span> </span>&#123;</div><div class="line">    ShortcutInfo webShortcut = <span class="keyword">new</span> ShortcutInfo.Builder(MainActivity.<span class="keyword">this</span>, <span class="string">"shortcut_blog"</span>)</div><div class="line">            .setRank(<span class="number">1</span>)</div><div class="line">            .build();</div><div class="line"></div><div class="line">    ShortcutInfo dynamicShortcut = <span class="keyword">new</span> ShortcutInfo.Builder(MainActivity.<span class="keyword">this</span>, <span class="string">"shortcut_dynamic"</span>)</div><div class="line">            .setRank(<span class="number">0</span>)</div><div class="line">            .build();</div><div class="line">    <span class="comment">// the rank value can not be set to negative, otherwise will throw</span></div><div class="line">    <span class="comment">// java.lang.IllegalArgumentException: Rank cannot be negative or bigger than MAX_RANK</span></div><div class="line"></div><div class="line">    <span class="comment">// the static shortcuts have the rank 0, so they will always be closest to launcher icon</span></div><div class="line"></div><div class="line">    shortcutManager.updateShortcuts(Arrays.asList(webShortcut, dynamicShortcut));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样更改之后, 原先排在最远端的<code>shortcut_dynamic</code>被移到了第三个, <code>shortcut_blog</code>被移到了它的后面.</p>
<p><code>setRank()</code>不接受负值, 会抛出异常.</p>
<p>我们只能改变动态shortcuts的排序, 静态的shortcuts等级为0, 它们是按照xml中写定的先后顺序排的, 所以:<br><code>静态的shortcuts永远离应用icon最近, 动态shortcuts在其之上排序, rank越大的离应用icon越远.</code><br>如果没有指定rank, 则按生成的顺序递增.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>App Shortcuts的官方文档: <a href="https://developer.android.com/preview/shortcuts.html" target="_blank" rel="external">App Shortcuts</a><br><a href="https://catinean.com/2016/10/20/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></p>
<p>Demo地址: <a href="https://github.com/mengdd/HelloNougat" target="_blank" rel="external">HelloNougat</a>.<br>近期考虑加入更多Android 7 Nougat特性sample.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Nougat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Nougat </tag>
            
            <tag> Android 7 </tag>
            
            <tag> Shortcuts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android MVP模式 谷歌官方代码解读]]></title>
      <url>http://mengdd.github.io/Android/Architecture/2016/10/22/android-architecture-google-samples-analysis/</url>
      <content type="html"><![CDATA[<h1 id="Google官方MVP-Sample代码解读"><a href="#Google官方MVP-Sample代码解读" class="headerlink" title="Google官方MVP Sample代码解读"></a>Google官方MVP Sample代码解读</h1><p>关于Android程序的构架, 当前(2016.10)最流行的模式即为MVP模式, Google官方提供了Sample代码来展示这种模式的用法.<br>Repo地址: <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>.<br>本文为阅读官方sample代码的阅读笔记和分析.</p>
<a id="more"></a>
<p>官方Android Architecture Blueprints [beta]:<br>Android在如何组织和构架一个app方面提供了很大的灵活性, 但是同时这种自由也可能会导致app在测试, 维护, 扩展方面变得困难.</p>
<p>Android Architecture Blueprints展示了可能的解决方案. 在这个项目里, 我们用各种不同的构架概念和工具实现了同一个应用(<a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="external">To Do App</a>). 主要的关注点在于代码结构, 构架, 测试和维护性.<br>但是请记住, 用这些模式构架app的方式有很多种, 要根据你的需要, 不要把这些当做绝对的典范.</p>
<h2 id="MVP模式-概念"><a href="#MVP模式-概念" class="headerlink" title="MVP模式 概念"></a>MVP模式 概念</h2><p>之前有一个MVC模式: Model-View-Controller.<br>MVC模式 有两个主要的缺点: 首先, View持有Controller和Model的引用; 第二, 它没有把对UI逻辑的操作限制在单一的类里, 这个职能被Controller和View或者Model共享.<br>所以后来提出了MVP模式来克服这些缺点.</p>
<p>MVP(Model-View-Presenter)模式:</p>
<ul>
<li>Model: 数据层. 负责与网络层和数据库层的逻辑交互.</li>
<li>View: UI层. 显示数据, 并向Presenter报告用户行为.</li>
<li>Presenter: 从Model拿数据, 应用到UI层, 管理UI的状态, 决定要显示什么, 响应用户的行为.<br>MVP模式的最主要优势就是耦合降低, Presenter变为纯Java的代码逻辑, 不再与Android Framework中的类如Activity, Fragment等关联, 便于写单元测试.</li>
</ul>
<h2 id="todo-mvp-基本的Model-View-Presenter架构"><a href="#todo-mvp-基本的Model-View-Presenter架构" class="headerlink" title="todo-mvp 基本的Model-View-Presenter架构"></a>todo-mvp 基本的Model-View-Presenter架构</h2><p>app中有四个功能:</p>
<ul>
<li>Tasks</li>
<li>TaskDetail</li>
<li>AddEditTask</li>
<li>Statistics</li>
</ul>
<p>每个功能都有:</p>
<ul>
<li>一个定义View和Presenter接口的<code>Contract</code>接口;</li>
<li>一个Activity用来管理fragment和presenter的创建;</li>
<li>一个实现了View接口的Fragment;</li>
<li>一个实现了Presenter接口的presenter.</li>
</ul>
<p><img src="/images/mvp.png" alt="mvp"></p>
<h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>Presenter基类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中这个<code>start()</code>方法都在Fragment的<code>onResume()</code>中调用.</p>
<p>View基类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="View实现"><a href="#View实现" class="headerlink" title="View实现"></a>View实现</h3><ul>
<li>Fragment作为每一个View接口的实现, 主要负责数据显示和在用户交互时调用Presenter, 但是例子代码中也是有一些直接操作的部分, 比如点击开启另一个Activity, 点击弹出菜单(菜单项的点击仍然是调用presenter的方法).</li>
<li><p>View接口中定义的方法多为<code>showXXX()</code>方法. </p>
</li>
<li><p>Fragment作为View实现, 接口中定义了方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> isAdded();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在Presenter中数据回调的方法中, 先检查View.isActive()是否为true, 来保证对Fragment的操作安全.</p>
<h3 id="Presenter实现"><a href="#Presenter实现" class="headerlink" title="Presenter实现"></a>Presenter实现</h3><ul>
<li>Presenter的<code>start()</code>方法在<code>onResume()</code>的时候调用, 这时候取初始数据; 其他方法均对应于用户在UI上的交互操作. </li>
<li>New Presenter的操作是在每一个Activity的<code>onCreate()</code>里做的: 先添加了Fragment(View), 然后把它作为参数传给了Presenter. 这里并没有存Presenter的引用.</li>
<li>Presenter的构造函数有两个参数, 一个是Model(Model类一般叫XXXRepository), 一个是View. 构造中先用guava的<code>checkNotNull()</code><br>检查两个参数是否为null, 然后赋值到字段; 之后再调用View的<code>setPresenter()</code>方法把Presenter传回View中引用.</li>
</ul>
<h3 id="Model实现细节"><a href="#Model实现细节" class="headerlink" title="Model实现细节"></a>Model实现细节</h3><ul>
<li>Model只有一个类, 即<code>TasksRepository</code>. 它还是一个单例. 因为在这个应用的例子中, 我们操作的数据就这一份.</li>
</ul>
<p>它由手动实现的注入类<code>Injection</code>类提供:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Injection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">provideTasksRepository</span><span class="params">(@NonNull Context context)</span> </span>&#123;</div><div class="line">        checkNotNull(context);</div><div class="line">        <span class="keyword">return</span> TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(),</div><div class="line">                TasksLocalDataSource.getInstance(context));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">TasksRepository</span><span class="params">(@NonNull TasksDataSource tasksRemoteDataSource,</span></span></div><div class="line">                        @NonNull TasksDataSource tasksLocalDataSource) &#123;</div><div class="line">    mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</div><div class="line">    mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>数据分为local和remote两大部分. local部分负责数据库的操作, remote部分负责网络. Model类中还有一个内存缓存.</li>
<li><code>TasksDataSource</code>是一个接口. 接口中定义了Presenter查询数据的回调接口, 还有一些增删改查的方法.</li>
</ul>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>MVP模式的主要优势就是便于为业务逻辑加上单元测试.<br>本例子中的单元测试是给<code>TasksRepository</code>和四个feature的Presenter加的.<br>Presenter的单元测试, Mock了View和Model, 测试调用逻辑, 如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskPresenterTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Mock</span></div><div class="line">    <span class="keyword">private</span> TasksRepository mTasksRepository;</div><div class="line">    <span class="meta">@Mock</span></div><div class="line">    <span class="keyword">private</span> AddEditTaskContract.View mAddEditTaskView;</div><div class="line">    <span class="keyword">private</span> AddEditTaskPresenter mAddEditTaskPresenter;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMocksAndView</span><span class="params">()</span> </span>&#123;</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">        when(mAddEditTaskView.isActive()).thenReturn(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNewTaskToRepository_showsSuccessMessageUi</span><span class="params">()</span> </span>&#123;</div><div class="line">        mAddEditTaskPresenter = <span class="keyword">new</span> AddEditTaskPresenter(<span class="string">"1"</span>, mTasksRepository, mAddEditTaskView);</div><div class="line"></div><div class="line">        mAddEditTaskPresenter.saveTask(<span class="string">"New Task Title"</span>, <span class="string">"Some Task Description"</span>);</div><div class="line"></div><div class="line">        verify(mTasksRepository).saveTask(any(Task.class)); <span class="comment">// saved to the model</span></div><div class="line">        verify(mAddEditTaskView).showTasksList(); <span class="comment">// shown in the UI</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="todo-mvp-loaders-用Loader取数据的MVP"><a href="#todo-mvp-loaders-用Loader取数据的MVP" class="headerlink" title="todo-mvp-loaders 用Loader取数据的MVP"></a>todo-mvp-loaders 用Loader取数据的MVP</h2><p>基于上一个例子todo-mvp, 只不过这里改为用Loader来从Repository得到数据.<br><img src="/images/mvp-loaders.png" alt="todo-mvp-loaders"></p>
<p>使用Loader的优势:</p>
<ul>
<li>去掉了回调, 自动实现数据的异步加载;</li>
<li>当内容改变时回调出新数据;</li>
<li>当应用因为configuration变化而重建loader时, 自动重连到上一个loader.</li>
</ul>
<h3 id="Diff-with-todo-mvp"><a href="#Diff-with-todo-mvp" class="headerlink" title="Diff with todo-mvp"></a>Diff with todo-mvp</h3><p>既然是基于todo-mvp, 那么之前说过的那些就不再重复, 我们来看一下都有什么改动:<br><code>git difftool -d todo-mvp</code></p>
<p>添加了两个类:<br><code>TaskLoader</code>和<code>TasksLoader</code>.</p>
<p>在Activity中new Loader类, 然后传入Presenter的构造方法.</p>
<p><code>Contract</code>中View接口删掉了<code>isActive()</code>方法, Presenter删掉了<code>populateTask()</code>方法.</p>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>添加的两个新类是<code>TaskLoader</code>和<code>TasksLoader</code>, 都继承于<code>AsyncTaskLoader</code>, 只不过数据的类型一个是单数, 一个是复数.</p>
<p><code>AsyncTaskLoader</code>是基于<code>ModernAsyncTask</code>, 类似于<code>AsyncTask</code>,<br>把load数据的操作放在<code>loadInBackground()</code>里即可, <code>deliverResult()</code>方法会将结果返回到主线程, 我们在listener的<code>onLoadFinished()</code>里面就可以接到返回的数据了, (在这个例子中是几个Presenter实现了这个接口).</p>
<p><code>TasksDataSource</code>接口的这两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;Task&gt; <span class="title">getTasks</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Task <span class="title">getTask</span><span class="params">(@NonNull String taskId)</span></span>;</div></pre></td></tr></table></figure></p>
<p>都变成了同步方法, 因为它们是在<code>loadInBackground()</code>方法里被调用.</p>
<p>Presenter中保存了<code>Loader</code>和<code>LoaderManager</code>, 在<code>start()</code>方法里<code>initLoader</code>, 然后<code>onCreateLoader</code>返回构造传入的那个loader.<br><code>onLoadFinished()</code>里面调用View的方法. 此时Presenter实现<code>LoaderManager.LoaderCallbacks</code>.</p>
<h3 id="数据改变监听"><a href="#数据改变监听" class="headerlink" title="数据改变监听"></a>数据改变监听</h3><p><code>TasksRepository</code>类中定义了observer的接口, 保存了一个listener的list:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;TasksRepositoryObserver&gt; mObservers = <span class="keyword">new</span> ArrayList&lt;TasksRepositoryObserver&gt;();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksRepositoryObserver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每次有数据改动需要刷新UI时就调用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyContentObserver</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (TasksRepositoryObserver observer : mObservers) &#123;</div><div class="line">        observer.onTasksChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在两个Loader里注册和注销自己为<code>TasksRepository</code>的listener: 在<code>onStartLoading()</code>里add, <code>onReset()</code>里面remove方法.<br>这样每次<code>TasksRepository</code>有数据变化, 作为listener的两个Loader都会收到通知, 然后force load:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isStarted()) &#123;</div><div class="line">        forceLoad();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样<code>onLoadFinished()</code>方法就会被调用.</p>
<h2 id="todo-databinding"><a href="#todo-databinding" class="headerlink" title="todo-databinding"></a>todo-databinding</h2><p>基于todo-mvp, 使用<a href="http://developer.android.com/tools/data-binding/guide.html#data_objects" target="_blank" rel="external">Data Binding library</a>来显示数据, 把UI和动作绑定起来.</p>
<p>说到ViewModel, 还有一种模式叫MVVM(Model-View-ViewModel)模式.<br>这个例子并没有严格地遵循<code>Model-View-ViewModel</code>模式或者<code>Model-View-Presenter</code>模式, 因为它既用了ViewModel又用了Presenter.</p>
<p><img src="/images/mvp-databinding.png" alt="todo-databinding"></p>
<p>Data Binding Library让UI元素和数据模型绑定:</p>
<ul>
<li>layout文件用来绑定数据和UI元素;</li>
<li>事件和action handler绑定;</li>
<li>数据变为可观察的, 需要的时候可以自动更新.</li>
</ul>
<h3 id="Diff-with-todo-mvp-1"><a href="#Diff-with-todo-mvp-1" class="headerlink" title="Diff with todo-mvp"></a>Diff with todo-mvp</h3><p>添加了几个类:</p>
<ul>
<li><code>StatisticsViewModel</code>;</li>
<li><code>SwipeRefreshLayoutDataBinding</code>;</li>
<li><code>TasksItemActionHandler</code>;</li>
<li><code>TasksViewModel</code>;</li>
</ul>
<p>从几个View的接口可以看出方法数减少了, 原来需要多个showXXX()方法, 现在只需要一两个方法就可以了.</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>以<code>TasksDetailFragment</code>为例:<br>以前在todo-mvp里需要这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateView</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    mDetailDescription = (TextView)</div><div class="line">root.findViewById(R.id.task_detail_description);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDescription</span><span class="params">(String description)</span> </span>&#123;</div><div class="line">    mDetailDescription.setVisibility(View.VISIBLE);</div><div class="line">    mDetailDescription.setText(description);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在只需要这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    View view = inflater.inflate(R.layout.taskdetail_frag, container, <span class="keyword">false</span>);</div><div class="line">    mViewDataBinding = TaskdetailFragBinding.bind(view);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTask</span><span class="params">(Task task)</span> </span>&#123;</div><div class="line">    mViewDataBinding.setTask(task);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为所有数据绑定的操作都写在了xml里:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/task_detail_description"</span></div><div class="line">    <span class="attr">...</span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@&#123;task.description&#125;"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>数据绑定省去了<code>findViewById()</code>和<code>setText()</code>, 事件绑定则是省去了<code>setOnClickListener()</code>.</p>
<p>比如<code>taskdetail_frag.xml</code>中的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/task_detail_complete"</span></div><div class="line">    <span class="attr">...</span></div><div class="line">    <span class="attr">android:checked</span>=<span class="string">"@&#123;task.completed&#125;"</span></div><div class="line">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;(cb, isChecked) -&gt;</span></div><div class="line">    presenter.completeChanged(task, isChecked)&#125;" /&gt;</div></pre></td></tr></table></figure></p>
<p>其中Presenter是这时候传入的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</div><div class="line">    mViewDataBinding.setPresenter(mPresenter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数据监听"><a href="#数据监听" class="headerlink" title="数据监听"></a>数据监听</h3><p>在显示List数据的界面<code>TasksFragment</code>, 仅需要知道数据是否为空, 所以它使用了<code>TasksViewModel</code>来给layout提供信息, 当尺寸设定的时候, 只有一些相关的属性被通知, 和这些属性绑定的UI元素被更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskListSize</span><span class="params">(<span class="keyword">int</span> taskListSize)</span> </span>&#123;</div><div class="line">    mTaskListSize = taskListSize;</div><div class="line">    notifyPropertyChanged(BR.noTaskIconRes);</div><div class="line">    notifyPropertyChanged(BR.noTasksLabel);</div><div class="line">    notifyPropertyChanged(BR.currentFilteringLabel);</div><div class="line">    notifyPropertyChanged(BR.notEmpty);</div><div class="line">    notifyPropertyChanged(BR.tasksAddViewVisible);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其他实现细节"><a href="#其他实现细节" class="headerlink" title="其他实现细节"></a>其他实现细节</h3><ul>
<li><p>Adapter中的Data Binding, 见<code>TasksFragment</code>中的<code>TasksAdapter</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> i, View view, ViewGroup viewGroup)</span> </span>&#123;</div><div class="line">    Task task = getItem(i);</div><div class="line">    TaskItemBinding binding;</div><div class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Inflate</span></div><div class="line">        LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());</div><div class="line"></div><div class="line">        <span class="comment">// Create the binding</span></div><div class="line">        binding = TaskItemBinding.inflate(inflater, viewGroup, <span class="keyword">false</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        binding = DataBindingUtil.getBinding(view);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// We might be recycling the binding for another task, so update it.</span></div><div class="line">    <span class="comment">// Create the action handler for the view</span></div><div class="line">    TasksItemActionHandler itemActionHandler =</div><div class="line">            <span class="keyword">new</span> TasksItemActionHandler(mUserActionsListener);</div><div class="line">    binding.setActionHandler(itemActionHandler);</div><div class="line">    binding.setTask(task);</div><div class="line">    binding.executePendingBindings();</div><div class="line">    <span class="keyword">return</span> binding.getRoot();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Presenter可能会被包在ActionHandler中, 比如<code>TasksItemActionHandler</code>.</p>
</li>
<li>ViewModel也可以作为View接口的实现, 比如<code>StatisticsViewModel</code>.</li>
<li><code>SwipeRefreshLayoutDataBinding</code>类定义的<code>onRefresh()</code>动作绑定.</li>
</ul>
<h2 id="todo-mvp-clean"><a href="#todo-mvp-clean" class="headerlink" title="todo-mvp-clean"></a>todo-mvp-clean</h2><p>这个例子是基于Clean Architecture的原则:<br><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">The Clean Architecture</a>.<br>关于Clean Architecture, 还可以看这个Sample App: <a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">Android-CleanArchitecture</a>.</p>
<p>这个例子在todo-mvp的基础上, 加了一层domain层, 把应用分为了三层:<br><img src="/images/mvp-clean.png" alt="mvp-clean"></p>
<p>Domain: 盛放了业务逻辑, domain层包含use cases或者interactors, 被应用的presenters使用. 这些use cases代表了所有从presentation层可能进行的行为.</p>
<p><strong>关键概念</strong><br>和基本的mvp sample最大的不同就是domain层和use cases. 从presenters中抽离出来的domain层有助于避免presenter中的代码重复.</p>
<p>Use cases定义了app需要的操作, 这样增加了代码的可读性, 因为类名反映了目的.</p>
<p>Use cases对于操作的复用来说也很好. 比如<code>CompleteTask</code>在两个Presenter中都用到了.</p>
<p>Use cases的执行是在后台线程, 使用<a href="http://www.oodesign.com/command-pattern.html" target="_blank" rel="external">command pattern</a>. 这样domain层对于Android SDK和其他第三方库来说都是完全解耦的.</p>
<h3 id="Diff-with-todo-mvp-2"><a href="#Diff-with-todo-mvp-2" class="headerlink" title="Diff with todo-mvp"></a>Diff with todo-mvp</h3><p>每一个feature的包下都新增了domain层, 里面包含了子目录model和usecase等.</p>
<p><code>UseCase</code>是一个抽象类, 定义了domain层的基础接口点.<br><code>UseCaseHandler</code>用于执行use cases, 是一个单例, 实现了command pattern.<br><code>UseCaseThreadPoolScheduler</code>实现了<code>UseCaseScheduler</code>接口, 定义了use cases执行的线程池, 在后台线程异步执行, 最后把结果返回给主线程.<br><code>UseCaseScheduler</code>通过构造传给<code>UseCaseHandler</code>.<br>测试中用了<code>UseCaseScheduler</code>的另一个实现<code>TestUseCaseScheduler</code>, 所有的执行变为同步的.</p>
<p><code>Injection</code>类中提供了多个Use cases的依赖注入, 还有<code>UseCaseHandler</code>用来执行use cases.</p>
<p>Presenter的实现中, 多个use cases和<code>UsseCaseHandler</code>都由构造传入, 执行动作, 比如更新一个task:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTask</span><span class="params">(String title, String description)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mTaskId == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"updateTask() was called but task is new."</span>);</div><div class="line">    &#125;</div><div class="line">    Task newTask = <span class="keyword">new</span> Task(title, description, mTaskId);</div><div class="line">    mUseCaseHandler.execute(mSaveTask, <span class="keyword">new</span> SaveTask.RequestValues(newTask),</div><div class="line">            <span class="keyword">new</span> UseCase.UseCaseCallback&lt;SaveTask.ResponseValue&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SaveTask.ResponseValue response)</span> </span>&#123;</div><div class="line">                    <span class="comment">// After an edit, go back to the list.</span></div><div class="line">                    mAddTaskView.showTasksList();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</div><div class="line">                    showSaveError();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="todo-mvp-dagger"><a href="#todo-mvp-dagger" class="headerlink" title="todo-mvp-dagger"></a>todo-mvp-dagger</h2><p><strong>关键概念</strong>:<br><a href="http://google.github.io/dagger/" target="_blank" rel="external">dagger2</a> 是一个静态的编译期依赖注入框架.<br>这个例子中改用dagger2实现依赖注入. 这样做的主要好处就是在测试的时候我们可以用替代的modules. 这在编译期间通过flavors就可以完成, 或者在运行期间使用一些调试面板来设置.</p>
<h3 id="Diff-with-todo-mvp-3"><a href="#Diff-with-todo-mvp-3" class="headerlink" title="Diff with todo-mvp"></a>Diff with todo-mvp</h3><p><code>Injection</code>类被删除了.<br>添加了5个Component, 四个feature各有一个, 另外数据对应一个: <code>TasksRepositoryComponent</code>, 这个Component被保存在Application里.</p>
<p>数据的module: <code>TasksRepositoryModule</code>在<code>mock</code>和<code>prod</code>目录下各有一个.</p>
<p>对于每一个feature的Presenter的注入是这样实现的:<br>首先, 把Presenter的构造函数标记为@Inject, 然后在Activity中构造component并注入到字段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> AddEditTaskPresenter mAddEditTasksPresenter;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.addtask_act);</div><div class="line">    .....</div><div class="line">    </div><div class="line">    <span class="comment">// Create the presenter</span></div><div class="line">    DaggerAddEditTaskComponent.builder()</div><div class="line">            .addEditTaskPresenterModule(</div><div class="line">                    <span class="keyword">new</span> AddEditTaskPresenterModule(addEditTaskFragment, taskId))</div><div class="line">            .tasksRepositoryComponent(</div><div class="line">                    ((ToDoApplication) getApplication()).getTasksRepositoryComponent()).build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个module里provide了view和taskId:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskPresenterModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AddEditTaskContract.View mView;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String mTaskId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddEditTaskPresenterModule</span><span class="params">(AddEditTaskContract.View view, @Nullable String taskId)</span> </span>&#123;</div><div class="line">        mView = view;</div><div class="line">        mTaskId = taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    AddEditTaskContract.<span class="function">View <span class="title">provideAddEditTaskContractView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function">String <span class="title">provideTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mTaskId;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意原来构造方法里调用的setPresenter方法改为用方法注入实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Method injection is used here to safely reference &#123;<span class="doctag">@code</span> this&#125; after the object is created.</div><div class="line"> * For more information, see Java Concurrency in Practice.</div><div class="line"> */</div><div class="line"><span class="meta">@Inject</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">    mAddTaskView.setPresenter(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="todo-mvp-contentproviders"><a href="#todo-mvp-contentproviders" class="headerlink" title="todo-mvp-contentproviders"></a>todo-mvp-contentproviders</h2><p>这个例子是基于todo-mvp-loaders的, 用content provider来获取repository中的数据.<br><img src="/images/mvp-contentproviders.png" alt="mvp-contentproviders"><br>使用<a href="https://developer.android.com/guide/topics/providers/content-providers.html" target="_blank" rel="external">Content Provider</a>的优势是:</p>
<ul>
<li>管理了结构化数据的访问;</li>
<li>Content Provider是跨进程访问数据的标准接口.</li>
</ul>
<h3 id="Diff-with-todo-mvp-loaders"><a href="#Diff-with-todo-mvp-loaders" class="headerlink" title="Diff with todo-mvp-loaders"></a>Diff with todo-mvp-loaders</h3><p>注意这个例子是唯一一个不基于最基本的todo-mvp, 而是基于todo-mvp-loaders. (但是我觉得也可以认为是直接从todo-mvp转化的.)<br>看diff: <code>git difftool -d todo-mvp-loaders</code>.</p>
<p>去掉了<code>TaskLoader</code>和<code>TasksLoader</code>. (回归到了基本的todo-mvp).</p>
<p><code>TasksRepository</code>中的方法不是同步方法, 而是异步加callback的形式. (回归到了基本的todo-mvp). </p>
<p><code>TasksLocalDataSource</code>中的读方法都变成了空实现, 因为Presenter现在可以自动收到数据更新.</p>
<p>新增<code>LoaderProvider</code>用来创建Cursor Loaders, 有两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回特定fiter下或全部的数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> Loader&lt;Cursor&gt; <span class="title">createFilteredTasksLoader</span><span class="params">(TaskFilter taskFilter)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 返回特定id的数据</span></div><div class="line"><span class="keyword">public</span> Loader&lt;Cursor&gt; <span class="title">createTaskLoader</span><span class="params">(String taskId)</span></div></pre></td></tr></table></figure></p>
<p>其中第一个方法的参数<code>TaskFilter</code>, 用来指定过滤的selection条件, 也是新增类.</p>
<p><code>LoaderManager</code>和<code>LoaderProvider</code>都是由构造传入Presenter, 在回调<code>onTaskLoaded()</code>和<code>onTasksLoaded()</code>中init loader. </p>
<p>在<code>TasksPresenter</code>中还做了判断, 是init loader还是restart loader:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span> </span>&#123;</div><div class="line">    <span class="comment">// we don't care about the result since the CursorLoader will load the data for us</span></div><div class="line">    <span class="keyword">if</span> (mLoaderManager.getLoader(TASKS_LOADER) == <span class="keyword">null</span>) &#123;</div><div class="line">        mLoaderManager.initLoader(TASKS_LOADER, mCurrentFiltering.getFilterExtras(), <span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mLoaderManager.restartLoader(TASKS_LOADER, mCurrentFiltering.getFilterExtras(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">其中initLoader()和restartLoader()时传入的第二个参数是一个bundle, 用来指明过滤类型, 即是带selection条件的数据库查询.</div><div class="line"></div><div class="line">同样是在onLoadFinshed()的时候做View处理, 以`TaskDetailPresenter`为例:</div><div class="line">```java</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFinished</span><span class="params">(Loader&lt;Cursor&gt; loader, Cursor data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (data.moveToLast()) &#123;</div><div class="line">            onDataLoaded(data);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            onDataEmpty();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onDataNotAvailable();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数据类Task中新增了静态方法从Cursor转为Task, 这个方法在Presenter的<code>onLoadFinished()</code>和测试中都用到了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task <span class="title">from</span><span class="params">(Cursor cursor)</span> </span>&#123;</div><div class="line">    String entryId = cursor.getString(cursor.getColumnIndexOrThrow(</div><div class="line">            TasksPersistenceContract.TaskEntry.COLUMN_NAME_ENTRY_ID));</div><div class="line">    String title = cursor.getString(cursor.getColumnIndexOrThrow(</div><div class="line">            TasksPersistenceContract.TaskEntry.COLUMN_NAME_TITLE));</div><div class="line">    String description = cursor.getString(cursor.getColumnIndexOrThrow(</div><div class="line">            TasksPersistenceContract.TaskEntry.COLUMN_NAME_DESCRIPTION));</div><div class="line">    <span class="keyword">boolean</span> completed = cursor.getInt(cursor.getColumnIndexOrThrow(</div><div class="line">            TasksPersistenceContract.TaskEntry.COLUMN_NAME_COMPLETED)) == <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Task(title, description, entryId, completed);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外一些细节:<br>数据库中的内存cache被删了.<br>Adapter改为继承于<code>CursorAdapter</code>.</p>
<h3 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h3><p>新增了<code>MockCursorProvider</code>类, 用于在单元测试中提供数据.<br>其内部类<code>TaskMockCursor</code> mock了Cursor数据.<br>Presenter的测试中仍然mock了所有构造传入的参数, 然后准备了mock数据, 测试的逻辑主要还是拿到数据后的view操作, 比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadAllTasksFromRepositoryAndLoadIntoView</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// When the loader finishes with tasks and filter is set to all</span></div><div class="line">    when(mBundle.getSerializable(TaskFilter.KEY_TASK_FILTER)).thenReturn(TasksFilterType.ALL_TASKS);</div><div class="line">    TaskFilter taskFilter = <span class="keyword">new</span> TaskFilter(mBundle);</div><div class="line"></div><div class="line">    mTasksPresenter.setFiltering(taskFilter);</div><div class="line"></div><div class="line">    mTasksPresenter.onLoadFinished(mock(Loader.class), mAllTasksCursor);</div><div class="line"></div><div class="line">    <span class="comment">// Then progress indicator is hidden and all tasks are shown in UI</span></div><div class="line">    verify(mTasksView).setLoadingIndicator(<span class="keyword">false</span>);</div><div class="line">    verify(mTasksView).showTasks(mShowTasksArgumentCaptor.capture());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="todo-mvp-rxjava"><a href="#todo-mvp-rxjava" class="headerlink" title="todo-mvp-rxjava"></a>todo-mvp-rxjava</h2><p>关于这个例子, 之前看过作者的文章: <a href="https://upday.github.io/blog/model-view-presenter/" target="_blank" rel="external">Android Architecture Patterns Part 2:<br>Model-View-Presenter</a>,<br>这个文章上过Android Weekly Issue #226.</p>
<p>这个例子也是基于todo-mvp, 使用RxJava处理了presenter和数据层之间的通信.</p>
<h3 id="MVP基本接口改变"><a href="#MVP基本接口改变" class="headerlink" title="MVP基本接口改变"></a>MVP基本接口改变</h3><p>BasePresenter接口改为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>View在<code>onResume()</code>的时候调用Presenter的<code>subscribe()</code>; 在onPause()的时候调用presenter的<code>unsubscribe()</code>.</p>
<p>如果View接口的实现不是Fragment或Activity, 而是Android的自定义View, 那么在Android View的<code>onAttachedToWindow()</code>和<code>onDetachedFromWindow()</code>方法里分别调用这两个方法.</p>
<p>Presenter中保存了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> CompositeSubscription mSubscriptions;</div></pre></td></tr></table></figure></p>
<p>在<code>subscribe()</code>的时候, <code>mSubscriptions.add(subscription);</code>;<br>在<code>unsubscribe()</code>的时候, <code>mSubscriptions.clear();</code> .</p>
<h3 id="Diff-with-todo-mvp-4"><a href="#Diff-with-todo-mvp-4" class="headerlink" title="Diff with todo-mvp"></a>Diff with todo-mvp</h3><p>数据层暴露了RxJava的<code>Observable</code>流作为获取数据的方式, <code>TasksDataSource</code>接口中的方法变成了这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable&lt;List&lt;Task&gt;&gt; getTasks();</div><div class="line"></div><div class="line"><span class="function">Observable&lt;Task&gt; <span class="title">getTask</span><span class="params">(@NonNull String taskId)</span></span>;</div></pre></td></tr></table></figure></p>
<p>callback接口被删了, 因为不需要了.</p>
<p><code>TasksLocalDataSource</code>中的实现用了<a href="https://github.com/square/sqlbrite" target="_blank" rel="external">SqlBrite</a>, 从数据库中查询出来的结果很容易地变成了流:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Observable&lt;List&lt;Task&gt;&gt; getTasks() &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> mDatabaseHelper.createQuery(TaskEntry.TABLE_NAME, sql)</div><div class="line">            .mapToList(mTaskMapperFunction);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>TasksRepository</code>中整合了local和remote的data, 最后把<code>Observable</code>返回给消费者(Presenters和Unit Tests). 这里用了<code>.concat()</code>和<code>.first()</code>操作符.</p>
<p>Presenter订阅TasksRepository的Observable, 然后决定View的操作, 而且Presenter也负责线程的调度.<br>简单的比如<code>AddEditTaskPresenter</code>中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mTaskId == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"populateTask() was called but task is new."</span>);</div><div class="line">    &#125;</div><div class="line">    Subscription subscription = mTasksRepository</div><div class="line">            .getTask(mTaskId)</div><div class="line">            .subscribeOn(mSchedulerProvider.computation())</div><div class="line">            .observeOn(mSchedulerProvider.ui())</div><div class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;Task&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</div><div class="line">                        mAddTaskView.showEmptyTaskError();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Task task)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</div><div class="line">                        mAddTaskView.setTitle(task.getTitle());</div><div class="line">                        mAddTaskView.setDescription(task.getDescription());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">    mSubscriptions.add(subscription);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>StatisticsPresenter</code>负责统计数据的显示, <code>TasksPresenter</code>负责过滤显示所有数据, 里面的RxJava操作符运用比较多, 可以看到链式操作的特点.</p>
<p>关于线程调度, 定义了<code>BaseSchedulerProvider</code>接口, 通过构造函数传给Presenter, 然后实现用<code>SchedulerProvider</code>, 测试用<code>ImmediateSchedulerProvider</code>. 这样方便测试.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Content Provider </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> Data Binding </tag>
            
            <tag> MVVM </tag>
            
            <tag> Dagger </tag>
            
            <tag> MVC </tag>
            
            <tag> Clean Architecture </tag>
            
            <tag> Loader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 227]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/10/21/android-weekly-notes-issue-227/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-227"><a href="#Android-Weekly-Issue-227" class="headerlink" title="Android Weekly Issue #227"></a>Android Weekly Issue #227</h1><p>October 16th, 2016<br><a href="http://androidweekly.net/issues/issue-227" target="_blank" rel="external">Android Weekly Issue #227</a>.</p>
<p>本期内容包括: Google的Mobile Vision API 人脸检测; Firebase的Remote Config; 与HashMap有关的优化; 提高RecyclerView帧率的优化; 使用AutoValue生成model代码; 开源库中抽象类和接口的使用讨论; Bottom Sheet的使用; Android Studio中的版本控制系统; ConstraintLayout的使用; 应用换Bottom Navigation; Nougat的Messaging Style Notification; 自定义字体; Reductor的使用等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Face-Detection-Concepts-Overview"><a href="#Face-Detection-Concepts-Overview" class="headerlink" title="Face Detection Concepts Overview"></a><a href="https://developers.google.com/vision/face-detection-concepts" target="_blank" rel="external">Face Detection Concepts Overview</a></h2><p>这篇文章来自Mobile Vision, 讲人脸检测及相关概念.<br>API使用<a href="https://developers.google.com/vision/android/detect-faces-tutorial" target="_blank" rel="external">Tutorial</a>.<br><a href="https://github.com/googlesamples/android-vision" target="_blank" rel="external">Sample</a>.</p>
<h2 id="Exploring-Firebase-on-Android-amp-iOS-Remote-Config"><a href="#Exploring-Firebase-on-Android-amp-iOS-Remote-Config" class="headerlink" title="Exploring Firebase on Android &amp; iOS: Remote Config"></a><a href="https://medium.com/@hitherejoe/exploring-firebase-on-android-ios-remote-config-3e1407b088f6#.ozr0s8s5q" target="_blank" rel="external">Exploring Firebase on Android &amp; iOS: Remote Config</a></h2><p>Remote config是Firebase提供的一个feature, 让我们可以定义参数, 在firebase的console管理, 从而在server端控制应用的UI或者行为, 并且可以选择生效的用户范围.</p>
<p>之前还有这个文章是关于<a href="https://medium.com/exploring-android/exploring-firebase-on-android-ios-analytics-8484b61a21ba#.lu7cv7ejz" target="_blank" rel="external">Firebase Analytics</a>的.</p>
<p>本篇文章介绍了Firebase的Remote Config可以干什么, 以及怎么做, 解说很详细.</p>
<p><strong>参数</strong><br>我们用Remote Config定义的键值对叫参数(parameters).  它提供了这个参数相关的what信息(key, the identifier), 和how信息(value, the configuration).</p>
<p><strong>条件</strong><br>条件值(conditional value)也是一个键值对, 其中condition指定了需要满足的条件, value指定了满足条件时需要返回的值.</p>
<p><strong>优先级</strong><br>如果单个条件被满足, 那么返回对应的值; 如果多个条件都被满足, 那么返回主导条件(list上方的条件)对应的值; 如果没有条件满足, 则返回默认值; 如果没有定义默认值, 则什么也不返回.</p>
<p>文中还详细介绍了Android和iOS端的实现, 以及console的配置.</p>
<h2 id="Android-App-Optimization-Using-ArrayMap-and-SparseArray"><a href="#Android-App-Optimization-Using-ArrayMap-and-SparseArray" class="headerlink" title="Android App Optimization Using ArrayMap and SparseArray"></a><a href="https://medium.com/@amitshekhar/android-app-optimization-using-arraymap-and-sparsearray-f2b4e2e3dc47#.29qai8u8j" target="_blank" rel="external">Android App Optimization Using ArrayMap and SparseArray</a></h2><p>当我们需要存储键值对的时候, 我们总是首先想到用<code>HashMap</code>, 然而IDE(Android Studio)有时候会警告提醒你, 应该用<code>ArrayMap</code>或<code>SparseArray</code>.</p>
<h3 id="HashMap-vs-ArrayMap"><a href="#HashMap-vs-ArrayMap" class="headerlink" title="HashMap vs ArrayMap"></a>HashMap vs ArrayMap</h3><p><code>ArrayMap</code>比传统的<code>HashMap</code>更节省内存, 因为它把自己的映射放在数组结构中: 一个整型数组放每一个item的hash code, 一个Object数组放key/value对. 这样避免了为每一个entry创建额外的对象, 而且数组增长也好控制.</p>
<p>注意<code>ArrayMap</code>并不是为很大的数据集设计的, 并且它会比<code>HashMap</code>慢一些, 以为查找需要二分查找, 增删需要在数组中操作.</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>是一个<code>HashMap.Entry</code>的数组, 其组成是key, value, HashCode, 还有一个指针.</p>
<p>当进行插入时: 首先计算出key的HashCode, 然后用这个hashCode找到对应的bucket, 如果已经存了元素, 则把旧元素的指针指向新元素, 即把bucket变为一个<code>LinkedList</code>.</p>
<p>当进行查询时: 复杂度为O(1), 但是这样是牺牲了更多的空间复杂度得到的.</p>
<p>HashMap的缺点:</p>
<ul>
<li>因为key和value都不能是原生类型, 所以插入时可能会有自动装箱, 导致创建额外的对象.</li>
<li><code>HashMap.Entry</code>本身就是一层额外的对象.</li>
<li>每次HashMap的收缩或者扩张, Buckets都要重新排列, 随着对象变多, 这个操作变得越发昂贵.</li>
</ul>
<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p><code>ArrayMap</code>使用两个数组:<br><code>int[] mHashes</code>用来存哈希值; <code>Object[] mArray</code>来存对象.</p>
<p>当插入键值对时: Key/Value被自动装箱, Key被插入到<code>mArray[]</code>数组的下一个位置, Value也被插入到<code>mArray[]</code>, 在Key的下一个位置.<br>计算出的哈希值被放在<code>mHashes[]</code>的下一个位置.</p>
<p>当查询一个Key时: 首先计算出Key的哈希值, 在<code>mHashes</code>中二分查找这个hashCode(时间复杂度(logN)), 当得到hash的index之后, 我们就知道<code>mArray</code>中<code>2*index</code>和<code>2*index+1</code>的位置对应的是查找的key和value.</p>
<p>虽然时间复杂度提升了, 但是这样却更省空间.</p>
<h3 id="推荐的数据结构"><a href="#推荐的数据结构" class="headerlink" title="推荐的数据结构:"></a>推荐的数据结构:</h3><ul>
<li><code>ArrayMap&lt;K,V&gt;</code> in place of <code>HashMap&lt;K,V&gt;</code></li>
<li><code>ArraySet&lt;K,V&gt;</code> in place of <code>HashSet&lt;K,V&gt;</code></li>
<li><code>SparseArray&lt;V&gt;</code> in place of <code>HashMap&lt;Integer,V&gt;</code></li>
<li><code>SparseBooleanArray</code> in place of <code>HashMap&lt;Integer,Boolean&gt;</code></li>
<li><code>SparseIntArray</code> in place of <code>HashMap&lt;Integer,Integer&gt;</code></li>
<li><code>SparseLongArray</code> in place of <code>HashMap&lt;Integer,Long&gt;</code></li>
<li><code>LongSparseArray&lt;V&gt;</code> in place of <code>HashMap&lt;Long,V&gt;</code></li>
</ul>
<h2 id="RecyclerView-How-we-achieved-60-FPS-in-Workable’s-Android-App"><a href="#RecyclerView-How-we-achieved-60-FPS-in-Workable’s-Android-App" class="headerlink" title="RecyclerView: How we achieved 60 FPS in Workable’s Android App"></a><a href="https://medium.com/@p.tournaris/recyclerview-how-we-achieved-60-fps-tips-in-workables-android-app-recyclerviews-c646c796473c#.h4gimmdkp" target="_blank" rel="external">RecyclerView: How we achieved 60 FPS in Workable’s Android App</a></h2><p>我们经常会用RecyclerView来显示一个list的数据.<br>作者他们做的是一个招聘应用: Workable, 其中会用list来显示candidates.<br>他们还使用了DataBinding.<br>本文是作者他们关于RecyclerView的帧率所做的一些优化.</p>
<p>首先他们使用了Android Studio的Allocation Tracking, 然后上下滚动, 从报告发现, 他们布局中使用的<code>TableLayout</code>花费了很多资源, 于是后来他们改为<code>LinearLayout</code>加权重的方式来解决, 摆脱了耗费资源的<code>TableLayout</code>.</p>
<p>另一个引起很多资源分配的问题是, 对于需要大写的文字, xml中的:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">          <span class="attr">...</span></div><div class="line">  <span class="attr">android:textAllCaps</span>=<span class="string">"true"</span></div><div class="line">          <span class="attr">...</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p><code>TextView</code>的代码中会为此生成一个对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (allCaps) &#123;</div><div class="line">    setTransformationMethod(<span class="keyword">new</span> AllCapsTransformationMethod(getContext()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个在静态的布局中可能没有问题, 但是在一个滚动的list中可能会有些影响.</p>
<p>改进方法是改为用java String的<code>.toUpperCase()</code>.</p>
<p>然后他们使用了RecyclerView的<code>.onViewRecycled()</code>方法. 这个方法让我们知道了RecyclerView中的一行何时被回收, 这样我们就可以释放一些不需要的资源.<br>他们使用了DataBinding, 所以这是一个合适的时机来删除ViewModel中的<code>OnPropertyChangedCallbacks</code>, 然后清理ViewModel自身, 我们还可以清理之前用Glide load到ImageView中的图片.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewRecycled</span><span class="params">(Candidates holder)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(holder != <span class="keyword">null</span>) &#123;</div><div class="line">        holder.binding.getCandidateVM().removePropertyChangedCallback();</div><div class="line">        holder.binding.setCandidateVM(<span class="keyword">null</span>);</div><div class="line">        holder.binding.setHighlightTerm(<span class="keyword">null</span>);</div><div class="line">        holder.binding.setShowJobTitle(<span class="keyword">false</span>);</div><div class="line">        holder.binding.setShowStage(<span class="keyword">false</span>);</div><div class="line">        holder.binding.executePendingBindings();</div><div class="line">        Glide.clear(holder.binding.candidateBrowserAvatar);</div><div class="line">        holder.binding.candidateBrowserAvatar.setImageDrawable(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onViewRecycled(holder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作者他们的应用还有一些cache设置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">binding.fragmentCandidateBrowseList.setItemViewCacheSize(<span class="number">30</span>);</div><div class="line">binding.fragmentCandidateBrowseList.setDrawingCacheEnabled(<span class="keyword">true</span>);</div><div class="line">binding.fragmentCandidateBrowseList.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);</div></pre></td></tr></table></figure></p>
<p>之后作者测量了他们的FPS, 显示是60 FPS, 并且发现去掉这些cache设置仍然是60.</p>
<p>测量帧率FPS的工具: <a href="https://github.com/friendlyrobotnyc/TinyDancer" target="_blank" rel="external">TinyDancer</a>.</p>
<h2 id="No-more-value-classes-boilerplate-—-The-power-of-AutoValue"><a href="#No-more-value-classes-boilerplate-—-The-power-of-AutoValue" class="headerlink" title="No more value classes boilerplate — The power of AutoValue"></a><a href="https://medium.com/rocknnull/no-more-value-classes-boilerplate-the-power-of-autovalue-bbaf36cf8bbe#.r72rsbe34" target="_blank" rel="external">No more value classes boilerplate — The power of AutoValue</a></h2><p>在Java/Android编程中经常需要写model对象来存放一些数据, 使用Google的库<a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="external">AutoValue</a>可以帮你自动生成这些类, 你需要做的就是定义你的字段, 然后给类加上注解.</p>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>在project的<code>build.gradle</code>中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    [...]</div><div class="line">    dependencies &#123;</div><div class="line">        [...]</div><div class="line">        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在app的<code>build.gradle</code>中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.neenbedankt.android-apt&apos; // At the beginning</div><div class="line">[...]</div><div class="line">dependencies &#123;</div><div class="line">    [...]</div><div class="line">    provided &quot;com.google.auto.value:auto-value:1.2&quot;</div><div class="line">    apt &quot;com.google.auto.value:auto-value:1.2&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>比如要创建Film类, 你可以写一个这样的抽象类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoValue</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Film</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> Film <span class="title">create</span><span class="params">(String name, <span class="keyword">int</span> year)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_Film(name, year);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每一个字段都对应一个抽象方法.<br>build一下, <code>AutoValue_Film</code>类就会自动生成, 加上静态工厂方法(上面的<code>create()</code>方法) 然后就可以使用工厂方法来得到model:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Film matrix = Film.create(<span class="string">"The Matrix"</span>, <span class="number">1999</span>);</div></pre></td></tr></table></figure></p>
<p>点进自动生成的类<code>AutoValue_Film</code>里可以看到, 连<code>hashCode()</code>和<code>equals()</code>方法都生成了.</p>
<h3 id="用builder模式"><a href="#用builder模式" class="headerlink" title="用builder模式"></a>用builder模式</h3><p>上面的例子随着字段的增多, <code>create()</code>方法的参数会变得很多, 用起来不方便, 那么此时就需要用Builder模式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoValue</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Film</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_Film.Builder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@AutoValue</span>.Builder</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setName</span><span class="params">(String value)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">abstract</span> Builder <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">abstract</span> Film <span class="title">build</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就可以很方便地加参数了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Film matrix = Film.builder()</div><div class="line">  .setName(<span class="string">"The Matrix"</span>)</div><div class="line">  .setYear(<span class="number">1999</span>)</div><div class="line">  .setCategory(Category.FANTASY)</div><div class="line">  .setRating(<span class="number">8.7f</span>)</div><div class="line">  .setDuration(<span class="number">136</span>)</div><div class="line">  .setReleaseDate(releasedDate)</div><div class="line">  .setDirectors(directorsList)</div><div class="line">  .setCast(castList)</div><div class="line">  .build();</div></pre></td></tr></table></figure></p>
<h3 id="AutoValue扩展-Parcelable"><a href="#AutoValue扩展-Parcelable" class="headerlink" title="AutoValue扩展 Parcelable"></a>AutoValue扩展 Parcelable</h3><p>有时候你需要在Activity之间传数据, 需要你的model是<code>Parcelable</code>的, 此时你就可以用这个<a href="https://github.com/rharter/auto-value-parcel" target="_blank" rel="external">auto-value-parcel</a>, 在代码里也只需要实现这个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoValue</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Film</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">   [...]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有很多的扩展库: <a href="http://search.maven.org/#search%7Cga%7C1%7Cauto-value" target="_blank" rel="external">extensions for AutoValue</a>, 比如AutoValue-Gson, AutoValue-Cursor, AutoValue-With, AutoValue-Redacted等.</p>
<h2 id="Consider-abstract-class-instead-of-interface"><a href="#Consider-abstract-class-instead-of-interface" class="headerlink" title="Consider abstract class instead of interface"></a><a href="http://hannesdorfmann.com/android/library-abstract-class" target="_blank" rel="external">Consider abstract class instead of interface</a></h2><p>这篇文章的作者说, 在library开发中, 应该考虑用抽象类而不是接口. 他的库是<a href="https://github.com/sockeqwe/AdapterDelegates" target="_blank" rel="external">AdapterDelegates</a>.</p>
<p>作者先介绍了通用的概念比较:</p>
<ul>
<li>class vs. interface<br>接口更解耦, 更灵活, 只是定义了一个协议, 不限制实现.</li>
<li>interface vs. abstract class<br>抽象类会有继承的问题, 基类和子类会共享一些实现, 所以子类的编写者最好能清楚基类的实现, 这样才不会在写子类实现抽象方法的时候打破了基类作者的意图. 另外就是基类作者仍然可能会更新基类, 所以得时刻检查子类是否还是符合基类的设计意图.</li>
</ul>
<p>但是为什么作者还是要把自己库中的接口改为抽象类呢? 这是因为作者的库依赖于Android的库, Android的库中相关代码改了, 作者就得改自己的public接口, 加一个方法, 导致所有新版的使用者也都必须实现这个方法.</p>
<p>还有一个情况就是比如一个开发者使用了2.1版本, 但是他项目里依赖的另一个第三方库使用了2.0版本. 编译不会出错, 最终的apk中打包的是2.1版本. 然后在这个第三方库的组件里调用2.1才有的新方法时就会抛出错误.</p>
<p>为了解决这个问题, Jake Wharton建议在库的主要更新(major update)中更改发布的package name和group id: <a href="http://jakewharton.com/java-interoperability-policy-for-major-version-updates/" target="_blank" rel="external">http://jakewharton.com/java-interoperability-policy-for-major-version-updates/</a></p>
<p>作者觉得那每次Android RecyclerView的Adapter更新都会导致自己的库major update, 所以他决定把自己的<code>AdapterDelegate</code>接口改为抽象类. 这样他就可以对新增的方法提供默认空实现.</p>
<p>这样定义的抽象类只有抽象方法和一些空实现的方法, 并没有状态和行为的共享可能会传播给子类, 其实和接口是一样的.</p>
<h2 id="Android-BottomSheetDialog"><a href="#Android-BottomSheetDialog" class="headerlink" title="Android BottomSheetDialog"></a><a href="https://medium.com/@anitas3791/android-bottomsheetdialog-3871a6e9d538#.462vjndmp" target="_blank" rel="external">Android BottomSheetDialog</a></h2><p>实现bottom sheet的时候, 有三种选择: container view + <code>BottomSheetBehavior</code>,  <code>BottomSheetDialogFragment</code>, <code>BottomSheetDialog</code>. 前两种的例子比较多, 作者要介绍的是第三种.</p>
<p>如何选择取决你的用途, container view + <code>BottomSheetBehavior</code> 适用于<a href="https://material.google.com/components/bottom-sheets.html#bottom-sheets-persistent-bottom-sheets" target="_blank" rel="external">persistent bottom sheet</a>, 而<code>BottomSheetDialogFragment</code>和<code>BottomSheetDialog</code>适用于<a href="https://material.google.com/components/bottom-sheets.html#bottom-sheets-modal-bottom-sheets" target="_blank" rel="external">Modal bottom sheets</a>.</p>
<p>之后作者提供了实现代码, 附有theme定制和状态callback的设置.</p>
<h2 id="The-VCS-client-of-Android-Studio"><a href="#The-VCS-client-of-Android-Studio" class="headerlink" title="The VCS client of Android Studio"></a><a href="http://saulmm.github.io/vcs-android-studio" target="_blank" rel="external">The VCS client of Android Studio</a></h2><p>这篇文章介绍Android Studio的版本控制系统.</p>
<p>在Android Studio 2.2开始, 加入了一个<code>Create command line launcher</code>, 这样你就可以在命令行或者第三方的版本控制客户端使用Android Studio的diff/merge tool了.<br>作者使用的客户端是<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>.</p>
<p>用<code>cmd + shift + A</code>可以用来find action, 然后就可以找到<code>Compare with branch</code>:  可以比较当前文件和某个分支上的文件的diff;<br>另外还可以<code>Compare with...</code>, 来比较和之前某一个特定提交的diff;  以及<code>Compare with Clipboard</code>来和剪贴板做比较.</p>
<p>还有一些其他有用的快捷键, 请看原文吧.</p>
<h2 id="Constraint-Layout-Icon-Label-Text"><a href="#Constraint-Layout-Icon-Label-Text" class="headerlink" title="Constraint Layout: Icon Label Text"></a><a href="http://blog.sqisland.com/2016/10/constraint-layout-icon-label-text.html" target="_blank" rel="external">Constraint Layout: Icon Label Text</a></h2><p>作者想做这样一个UI, 左边是一个icon, 右边是两行字, icon的top和bottom分别和第一行字的top和bottom对齐.<br><img src="/images/icon-label-text.jpg" alt="ConstraintLayout: Icon Label Text"><br>怎么做呢? 她想到了用<a href="https://developer.android.com/training/constraint-layout/index.html" target="_blank" rel="external">ConstraintLayout</a>.<br>代码在这里: <a href="https://github.com/chiuki/iconlabeltext" target="_blank" rel="external">iconlabeltext</a></p>
<h2 id="Bye-Bye-Burger"><a href="#Bye-Bye-Burger" class="headerlink" title="Bye, Bye Burger"></a><a href="https://medium.com/startup-grind/bye-bye-burger-5bd963806015#.emir2u5kv" target="_blank" rel="external">Bye, Bye Burger</a></h2><p>作者他们的应用从burger menu改为bottom navigation, 此篇为心得分享和他们改版时设计中的一些细节讨论.</p>
<p>其中状态保存是一个最主要的技术问题.</p>
<p>改版之后, 作者他们的应用数据表明有以下几个好处:</p>
<ul>
<li>用户参与度提升了;</li>
<li>在底部导航有入口的功能使用率提高了;</li>
<li>并没有用户反馈说新的导航不好.</li>
</ul>
<h2 id="Nougat-–-Messaging-Style-Notifications"><a href="#Nougat-–-Messaging-Style-Notifications" class="headerlink" title="Nougat – Messaging Style Notifications"></a><a href="https://blog.stylingandroid.com/nougat-messaging-style-notifications/" target="_blank" rel="external">Nougat – Messaging Style Notifications</a></h2><p>Messaging Style Notifications是为信息应用特殊设计的, 提供了一个像对话一样的view.</p>
<p>Messaging-style notifications和Bundled notifications的主要区别是, Bundled notifications中我们持续创建新的notification, 然后它们被grouped together. 但是用Messaging-style notifications的时候, 我们只有一个notification, 然后我们把所有的信息添加进去.</p>
<p>作者展示了实现代码和效果, 注意这个Messaging style并不是后项兼容的, 只在Nougat及以后的版本才支持.</p>
<h2 id="Bottom-sheet-everything"><a href="#Bottom-sheet-everything" class="headerlink" title="Bottom sheet everything"></a><a href="http://www.hidroh.com/2016/06/17/bottom-sheet-everything/" target="_blank" rel="external">Bottom sheet everything</a></h2><p>作者介绍了他的应用中对于Bottom sheet的使用.</p>
<p><strong>Deep linking with bottom sheet Activity</strong><br>作者用它处理Deep linking, 这样用户就不用每次都全屏打开, 只先提供一个peek, 如果真的感兴趣再打开.</p>
<p>实现是用一个透明的Activity, 还有状态栏处理的细节.</p>
<p><strong>Bottom sheet settings menu</strong><br>关于Settings, 为了节省用户的trip, 作者它们的应用用了options menu的弹出菜单. 后来他们改用bottom sheet来实现, 并且结合了<code>PreferenceFragmentCompat</code>, 省去了一些SharedPreferences的读写操作.</p>
<p><strong>Supporting tablet users</strong><br>bottom sheet在平板上使用, 尤其是横屏的时候, 看起来不太好.<br>所以作者定制了Bottom sheet的宽度, 在平板上时是一个指定宽度, 在手机上维持原状.</p>
<h2 id="Machine-Learning-for-with-the-Mobile-Vision-API—-Part-1"><a href="#Machine-Learning-for-with-the-Mobile-Vision-API—-Part-1" class="headerlink" title="Machine Learning for with the Mobile Vision API— Part 1"></a><a href="https://hackernoon.com/machine-learning-for-android-developers-with-the-mobile-vision-api-part-1-face-detection-e7e24a3e472f?gi=e6e15107d4d6#.8kmih1fyd" target="_blank" rel="external">Machine Learning for with the Mobile Vision API— Part 1</a></h2><p>基于Google的Mobile Vision APIs现在Android开发者可以在应用里用上机器学习了.  现在这个Mobile Vision API包括三种类型Face Detection API, Barcode Detection API和Text API.</p>
<p>本文主要讲人脸检测部分, 后面会讲二维码检测和文字的API.</p>
<p>作者的demo展示了如何从一个静态照片中检测出人脸区域, 并且标记出landmark(眼睛, 鼻子, 嘴巴等), 之后可以根据这些特征位置加上一些覆盖标记.</p>
<p><a href="https://github.com/moyheen/face-detector" target="_blank" rel="external">sample code</a>.</p>
<h2 id="Custom-fonts-formatting-the-simple-way"><a href="#Custom-fonts-formatting-the-simple-way" class="headerlink" title="Custom fonts formatting, the simple way"></a><a href="https://medium.com/@andrei.rosca/custom-fonts-formatting-the-simple-way-c1a0e4f6687f#.kjv5uaaix" target="_blank" rel="external">Custom fonts formatting, the simple way</a></h2><p>在Android中自定义字体的一个库: <a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="external">Calligraphy</a>.</p>
<p>如果你的输入是html文字, 你想自动处理里面的tag(比如<b>), 用另一种字体, 怎么处理呢, 作者给出了代码.<br><img src="/images/custom-fonts-in-one-textview.png" alt="custom font in one textview"></b></p>
<p>完整的例子代码见: <a href="https://github.com/andrei-egeniq/android-tibits/tree/master/StyleSpan" target="_blank" rel="external">sample code</a>.</p>
<h2 id="Reductor-Redux-for-Android-Part-1-Introduction"><a href="#Reductor-Redux-for-Android-Part-1-Introduction" class="headerlink" title="Reductor - Redux for Android. Part 1: Introduction"></a><a href="https://yarikx.github.io/Reductor-introduction/" target="_blank" rel="external">Reductor - Redux for Android. Part 1: Introduction</a></h2><p>之前这个<a href="https://yarikx.github.io/Reductor-prologue/" target="_blank" rel="external">文章</a>介绍过Reductor, 在Android Weekly之前也出现过, 我的笔记: <a href="http://mengdd.github.io/Android/Android-Weekly/2016/10/02/android-weekly-notes-issue-224/#Reductor-Redux-for-Android">Android Weekly Notes Issue 224</a>.</p>
<p><a href="https://github.com/Yarikx/reductor" target="_blank" rel="external">Reductor</a>是一个状态管理的库, 用Java重新实现了JavaScript的库Redux.<br>它的中心思想:<br><img src="/images/redux-idea.png" alt="redux idea"></p>
<p>之前的一篇文章做了一个TODO app, 然后作者发现这种mutable的数据会导致失控的数据改变, 然后可能会出现无法预测的行为. 做了一些改动之后, 我们发现可以通过只保存一个immutable的对象和mutable的reference来避免这个问题.</p>
<p>这篇文章用Reductor来重新实现应用, 文中详细说明了代码实现.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ImageTransition"><a href="#ImageTransition" class="headerlink" title="ImageTransition"></a><a href="https://github.com/vikramkakkar/ImageTransition" target="_blank" rel="external">ImageTransition</a></h2><p>一个很小的库, Activity直接的shared element transition动画, 把一个圆形的ImageView变换到下一个Activity的方形ImageView.</p>
<h2 id="Design-Patterns-In-Kotlin"><a href="#Design-Patterns-In-Kotlin" class="headerlink" title="Design-Patterns-In-Kotlin"></a><a href="https://github.com/dbacinski/Design-Patterns-In-Kotlin/" target="_blank" rel="external">Design-Patterns-In-Kotlin</a></h2><p>用Kotlin实现的设计模式.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Bottom Navigation </tag>
            
            <tag> Bottom Sheet </tag>
            
            <tag> Firebase </tag>
            
            <tag> AutoValue </tag>
            
            <tag> Mobile Vision </tag>
            
            <tag> Face Detection </tag>
            
            <tag> Optimization </tag>
            
            <tag> HashMap </tag>
            
            <tag> ArrayMap </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> FPS </tag>
            
            <tag> Abstract class </tag>
            
            <tag> Interface </tag>
            
            <tag> Android Studio </tag>
            
            <tag> ConstraintLayout </tag>
            
            <tag> Nougat </tag>
            
            <tag> Notification </tag>
            
            <tag> font </tag>
            
            <tag> Reductor </tag>
            
            <tag> Redux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 226]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/10/12/android-weekly-notes-issue-226/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-226"><a href="#Android-Weekly-Issue-226" class="headerlink" title="Android Weekly Issue #226"></a>Android Weekly Issue #226</h1><p>October 9th, 2016<br><a href="http://androidweekly.net/issues/issue-226" target="_blank" rel="external">Android Weekly Issue #226</a></p>
<p>本期内容包括: 用Firebase做A/B Test; 用RxJava做动画; MVP; proguardFiles; RxJava和Android Data Binding的结合; Mockito的更新; Gradle configurations等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="用Firebase做A-B-Test-A-B-Test-your-App-using-Firebase-Remote-Config"><a href="#用Firebase做A-B-Test-A-B-Test-your-App-using-Firebase-Remote-Config" class="headerlink" title="用Firebase做A/B Test A/B Test your App using Firebase Remote Config"></a>用Firebase做A/B Test <a href="https://riggaroo.co.za/ab-test-app-firebase-remote-config/" target="_blank" rel="external">A/B Test your App using Firebase Remote Config</a></h2><p>作者讲了如何用Firebase的Remote Config做A/B Test.</p>
<h2 id="用RxJava做动画-Android-animations-powered-by-RxJava"><a href="#用RxJava做动画-Android-animations-powered-by-RxJava" class="headerlink" title="用RxJava做动画 Android animations powered by RxJava"></a>用RxJava做动画 <a href="https://pspdfkit.com/blog/2016/android-animations-powered-by-rx-java/" target="_blank" rel="external">Android animations powered by RxJava</a></h2><p><strong>动画基础</strong></p>
<p>用<br><a href="https://developer.android.com/reference/android/view/ViewPropertyAnimator.html" target="_blank" rel="external">ViewPropertyAnimator</a> 操作View的属性动画很容易也很方便.</p>
<p>本文讲的内容主要用<a href="https://developer.android.com/reference/android/support/v4/view/ViewPropertyAnimatorCompat.html" target="_blank" rel="external">ViewPropertyAnimatorCompat</a>, 它是通过这个方法获得的: <a href="https://developer.android.com/reference/android/support/v4/view/ViewCompat.html#animate(android.view.View" target="_blank" rel="external">ViewCompat.animate(targetView)</a>).</p>
<p>它是这样用的:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ViewCompat.animate(someButton)</div><div class="line">    .scaleX(<span class="number">0</span>f)                         <span class="comment">// Scale to 0 horizontally</span></div><div class="line">    .scaleY(<span class="number">0</span>f)                         <span class="comment">// Scale to 0 vertically</span></div><div class="line">    .setDuration(<span class="number">300</span>)                   <span class="comment">// Duration of the animation in milliseconds.</span></div><div class="line">    .withEndAction &#123; removeView(view) &#125; <span class="comment">// Called when the animation ends successfully.</span></div></pre></td></tr></table></figure></p>
<p><a href="http://reactivex.io/RxJava/javadoc/rx/Completable.html" target="_blank" rel="external">Completable</a> 是RxJava1.1.1加入的.</p>
<p>作者通过RxJava来做他们的动画效果.<br>这在链式连接多个动画和其他操作的时候很有用.</p>
<h2 id="Android-Architecture-Patterns-Part-2-MVP"><a href="#Android-Architecture-Patterns-Part-2-MVP" class="headerlink" title="Android Architecture Patterns Part 2: MVP"></a><a href="https://upday.github.io/blog/model-view-presenter/" target="_blank" rel="external">Android Architecture Patterns Part 2: MVP</a></h2><p>关于Android程序的架构, google提供了<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Android Architecture Blueprints</a>, 其中作者他们合作于<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-rxjava/" target="_blank" rel="external">MVP &amp; RxJava</a>的sample.</p>
<p><strong>MVP(Model-View-Presenter)模式</strong>:</p>
<ul>
<li>Model: 数据层. 负责与网络层和数据库层的逻辑交互.</li>
<li>View: UI层. 显示数据, 并向Presenter报告用户行为.</li>
<li>Presenter: 从Model拿数据, 应用到UI层, 管理UI的状态, 决定要显示什么以及响应用户的行为.</li>
</ul>
<p>V和P联系紧密, 所以它们通常会持有对方的引用. 为了给P做单元测试, V是一个抽象的接口. P和对应的V的关系定义在一个<code>Contract</code>接口里, 这样可以让代码可读性更好, 更容易发现二者的联系.</p>
<p><strong>MVP模式 &amp; RxJava在Android Architecture Blueprints里的应用</strong></p>
<p>Google blueprint的Sample是一个<a href="https://github.com/googlesamples/android-architecture/wiki/To-do-app-specification" target="_blank" rel="external">To Do应用</a>. 它让用户可以创建, 阅读, 更新和删除to do task, 也可以过滤显示. RxJava主要是用来进行一些非主线程的异步操作.</p>
<p>然后作者详细说明了代码实现.</p>
<p><strong>Model</strong>中用RxJava在本地和网络取数据.<br>(他们的单元测试里是下划线和驼峰结合的方法命名方式.)</p>
<p><strong>View</strong>有一个base接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>View在<code>onResume()</code>的时候调用Presenter的<code>subscribe()</code>, <code>onPause()</code>的时候调用Presenter的<code>unsubscribe()</code>. 如果View接口的实现不是Fragment或Activity, 而是Android的自定义View, 那么在<code>onAttachedToWindow()</code>和<code>onDetachedFromWindow()</code>方法里分别调用这两个方法.</p>
<p>View的测试是用Espresso写的.</p>
<p><strong>Presenter</strong>也有一个base接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>View和Model都通过构造函数传入Presenter, 在Presenter构造里还要调用View的<code>setPresetner()</code>方法.</p>
<p>每一个Presenter还要暴露一些其他的方法, 对应View中用户的行为.</p>
<p><strong>MVP模式的缺点</strong>:<br>MVP模式很好地分离了概念, 当然这是好的. 但是当开发很小的app或者只是做一个原型时, 确实感觉过度设计了. 为了减少所用的接口, 有一些开发者省去了<code>Contract</code>接口类, 也删掉了Presenter的接口.</p>
<p>当把UI的逻辑移到Presenter中时, 它就变成了一个全能的类, 代码很长. 为了解决这个问题, 可以进一步拆分代码, 并且记得创建单一职能, 并且可以被单元测试的类.</p>
<p><strong>结论</strong>:<br><a href="https://upday.github.io/blog/model-view-controller/" target="_blank" rel="external">Model-View-Controller MVC模式</a> 有两个主要的缺点: 首先, View持有Controller和Model的引用; 第二, 它没有把对UI逻辑的操作限制在单一的类里, 这个职能被Controller和View或者Model共享.</p>
<p>MVP模式解决了这两个问题: 砍断了View和Model之间的联系, 用Presenter来管理所有和View显示相关的逻辑(handles everything related to the presentation of the View), 并且这个类是很容易被单元测试的.</p>
<h2 id="proguardFiles-A-Cautionary-Tale"><a href="#proguardFiles-A-Cautionary-Tale" class="headerlink" title="proguardFiles: A Cautionary Tale"></a><a href="https://stkent.github.io/2016/10/07/proguardfiles-a-cautionary-tale.html" target="_blank" rel="external">proguardFiles: A Cautionary Tale</a></h2><p>作者有三个buildTypes: debug, beta, release.</p>
<p>其中beta用了initWith(buildTypes.debug).<br>他想给不同的type加上不同的proguard files. 让debug不混淆(<code>-dontobfuscate</code>), beta和release混淆.<br>结果却发现beta没有混淆.</p>
<p>查看代码发现<code>proguardFiles</code>其实是将proguard files叠加.<br>作者找到的解决方式是用<code>setProguardFiles()</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">  debug &#123;</div><div class="line">    // ...</div><div class="line">    proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;, &apos;proguard-debug.pro&apos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  beta &#123;</div><div class="line">    initWith(buildTypes.debug)</div><div class="line">    // ...</div><div class="line">    // New!</div><div class="line">    setProguardFiles([getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;])</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  release &#123;</div><div class="line">    // ...</div><div class="line">    proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>评论区有人指出还可以这样:<br>在<code>defaultConfig</code>中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div></pre></td></tr></table></figure></p>
<p>然后在<code>debug</code>中: 加<code>proguardFile &#39;proguard-debug.pro</code>, 这样更简洁一些.</p>
<p>相关文档: <a href="https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html" target="_blank" rel="external">BuildType</a>.</p>
<h2 id="RxJava-meets-Android-Data-Binding"><a href="#RxJava-meets-Android-Data-Binding" class="headerlink" title="RxJava meets Android Data Binding"></a><a href="https://medium.com/tangoagency/rxjava-meets-android-data-binding-4ca5e1144107#.p13x1zwkc" target="_blank" rel="external">RxJava meets Android Data Binding</a></h2><p>作者使用例子介绍了如何将RxJava和Android的Data Binding结合起来使用.</p>
<h2 id="Mocking-Kotlin-with-Mockito"><a href="#Mocking-Kotlin-with-Mockito" class="headerlink" title="Mocking Kotlin with Mockito"></a><a href="http://hadihariri.com/2016/10/04/Mocking-Kotlin-With-Mockito/" target="_blank" rel="external">Mocking Kotlin with Mockito</a></h2><p>因为Kotlin默认类和方法都是final的, 如果你想要继承, 必须显式声明<code>open</code>.</p>
<p>当你想要在测试中Mock一些行为时, Mockito可能会报错, 因为它无法mock一个final的class/method.</p>
<p>于是你可能要修改源代码, 加<code>open</code>或者是接口, 仅仅是为了测试.</p>
<p>Mockito 2解决了这个问题: <a href="https://github.com/mockito/mockito/wiki/What&#39;s-new-in-Mockito-2" target="_blank" rel="external">What’s new in Mockito 2</a>.</p>
<p>你只需要在<code>resources/mockito-extensions</code>目录下创建一个文件: <code>org.mockito.plugins.MockMaker</code>.<br>里面只包含一行内容:<br><code>mock-maker-inline</code>.</p>
<h2 id="Droidcon-NYC-2016-Victor-Nascimento"><a href="#Droidcon-NYC-2016-Victor-Nascimento" class="headerlink" title="Droidcon NYC 2016 - Victor Nascimento"></a><a href="https://medium.com/@victor.nascimento/droidcon-ny-2016-e037cb81559#.4ncx0xcgg" target="_blank" rel="external">Droidcon NYC 2016 - Victor Nascimento</a></h2><h2 id="Droidcon-NYC-2016-Florina-Muntenescu"><a href="#Droidcon-NYC-2016-Florina-Muntenescu" class="headerlink" title="Droidcon NYC 2016 - Florina Muntenescu"></a><a href="https://upday.github.io/blog/droidcon_nyc/" target="_blank" rel="external">Droidcon NYC 2016 - Florina Muntenescu</a></h2><p>这两篇是关于Droidcon NYC 2016的感想.</p>
<h2 id="Android-Gradle-configurations"><a href="#Android-Gradle-configurations" class="headerlink" title="Android Gradle configurations"></a><a href="http://www.thedroidsonroids.com/blog/android/android-gradle-configurations/" target="_blank" rel="external">Android Gradle configurations</a></h2><p>Gradle中的configuration是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">	annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</div><div class="line">	compile &apos;com.jakewharton:butterknife:8.4.0&apos;</div><div class="line">	compile project(&apos;:api&apos;)</div><div class="line">	debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.4&apos;</div><div class="line">	releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.4&apos;</div><div class="line">	androidTestCompile &apos;com.android.support.test:runner:0.5&apos;</div><div class="line">	testCompile &apos;org.robolectric:robolectric:3.1.2&apos;</div><div class="line">	testAnnotationProcessor &apos;org.robolectric:robolectric-processor:3.1.2&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>模式是<code>configuationName dependencyNotation</code>.</p>
<p>Configuration names由两部分组成:</p>
<ul>
<li>可选的前缀, 指定build variant, product flavor或者build type.</li>
<li>必需的后缀, 指定scope.</li>
</ul>
<p>比如在<code>debugCompile</code>中, debug就是一个build type.</p>
<p><code>compile</code>没有前缀, 就表示它应用到所有的build类型里.</p>
<p>每一个正常的configuration都有一个相应的unit test版, 比如<code>testCompile</code>, <code>testDebugCompile</code>.</p>
<p>对于功能测试来说是<code>androidTest</code>, 只有这一种.</p>
<p><strong>Scope</strong></p>
<p>Scope是和configuration应用的阶段有关:</p>
<ul>
<li>annotationProcessor/kapt: 注解处理;</li>
<li>provided/compileOnly: 编译期;</li>
<li>compile: 编译 + 执行;</li>
<li>apk: 执行期.</li>
</ul>
<p><strong>继承</strong><br>Configuration可以继承, 意味着子类包含父类所有包含的项目.<br>比如<code>testCompile</code>就继承了<code>compile</code>.<br>但是注意继承必须显式声明, 并不是由名字看出来的, 比如<code>testAnnotationProcessor</code>没有继承<code>annotationProcessor</code>.</p>
<p>利用继承可以定义单元测试和公共测试的基类, 这样它们的共享依赖就可以只声明一次.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">configurations &#123;</div><div class="line"> [androidTestCompile, testCompile].each &#123; it.extendsFrom commonTestCompile &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="android-data-binding-rxjava"><a href="#android-data-binding-rxjava" class="headerlink" title="android-data-binding-rxjava"></a><a href="https://github.com/TangoAgency/android-data-binding-rxjava" target="_blank" rel="external">android-data-binding-rxjava</a></h2><p>例子代码, 展示如何结合RxJava和Android data binding.</p>
<h2 id="AnimatorDurationTile"><a href="#AnimatorDurationTile" class="headerlink" title="AnimatorDurationTile"></a><a href="https://github.com/nickbutcher/AnimatorDurationTile" target="_blank" rel="external">AnimatorDurationTile</a></h2><p>一个Quick Settings tile, 用于控制动画的duration scale.</p>
<h2 id="DateTimeSeer"><a href="#DateTimeSeer" class="headerlink" title="DateTimeSeer"></a><a href="https://github.com/p-v/DateTimeSeer/" target="_blank" rel="external">DateTimeSeer</a></h2><p>一个关于日期和时间的自动提示输入框.</p>
<h2 id="A-list-of-all-Android-permissions"><a href="#A-list-of-all-Android-permissions" class="headerlink" title="A list of all Android permissions"></a><a href="https://gist.github.com/Arinerron/1bcaadc7b1cbeae77de0263f4e15156f" target="_blank" rel="external">A list of all Android permissions</a></h2><p>一个Android所有权限的列表.</p>
<h1 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h1><h2 id="What’s-new-in-Mockito-2"><a href="#What’s-new-in-Mockito-2" class="headerlink" title="What’s new in Mockito 2"></a><a href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2" target="_blank" rel="external">What’s new in Mockito 2</a></h2><p>Mockito 2发布了, 有什么新东西呢?</p>
<h2 id="Kotlin-1-0-5-EAP"><a href="#Kotlin-1-0-5-EAP" class="headerlink" title="Kotlin 1.0.5 EAP"></a><a href="https://discuss.kotlinlang.org/t/kotlin-1-0-5-eap/2023" target="_blank" rel="external">Kotlin 1.0.5 EAP</a></h2><p>Kotlin 1.0.5 EAP (Early Access Program).</p>
<h2 id="What’s-next-for-android-apt"><a href="#What’s-next-for-android-apt" class="headerlink" title="What’s next for android-apt?"></a><a href="http://www.littlerobots.nl/blog/Whats-next-for-android-apt/" target="_blank" rel="external">What’s next for android-apt?</a></h2><p>android-apt将不会再开发了, 因为它的功能已经被包含进了Android Gradle plugin.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Firebase </tag>
            
            <tag> Gradle </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> Animation </tag>
            
            <tag> Proguard </tag>
            
            <tag> Data Binding </tag>
            
            <tag> Mockito </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 225]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/10/09/android-weekly-notes-issue-225/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-225"><a href="#Android-Weekly-Issue-225" class="headerlink" title="Android Weekly Issue #225"></a>Android Weekly Issue #225</h1><p>October 2nd, 2016<br><a href="http://androidweekly.net/issues/issue-225" target="_blank" rel="external">Android Weekly Issue #225</a></p>
<p>本期内容包括: Android 7.0的Quick Settings; Firebase; 兼容旧版本的shared element transition; Wear; ORM: 用ActiveAndroid做数据库存储; 崩溃报告工具对比; Google Cast API介绍; Google的播放器库ExoPlayer 2.x发布; 项目的包结构整理; Task API的使用等等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Android-7-0的快速设置-Quick-Settings-Tiles"><a href="#Android-7-0的快速设置-Quick-Settings-Tiles" class="headerlink" title="Android 7.0的快速设置 Quick Settings Tiles"></a>Android 7.0的快速设置 <a href="https://medium.com/google-developers/quick-settings-tiles-e3c22daf93a8#.4q0cxslwd" target="_blank" rel="external">Quick Settings Tiles</a></h2><p>从Android 7.0 (API 24)开始, 任何app都可以创建一个quick settings tile, 快速访问关键功能.<br>它除了是一个展示最新信息的UI, 点击一个片还可以trigger后台任务, 打开dialog或activity.</p>
<p>一个好的quick settings tile:<br>决定是否要建立这样一个tile时, 主要考虑紧急性和频繁性两个方面.</p>
<p>每一个tile和一个<a href="https://developer.android.com/reference/android/service/quicksettings/TileService.html" target="_blank" rel="external">TileService</a>关联. 和其他service一样, 它需要在manifest中注册, 它的label和icon就是显示在quick settings上的文字和图片.</p>
<p><strong>TileService的生命周期</strong>:<br>TileService是一个<a href="https://developer.android.com/guide/components/bound-services.html" target="_blank" rel="external">bound service</a>, 它的生命周期主要由系统控制. 主要有三个阶段: being added, listening, being removed.</p>
<ul>
<li><code>onTileAdded()</code>: 当用户添加这个tile到quick settings.</li>
<li><code>onStartListening()</code>: tile变为可见.</li>
<li><code>onStopListening()</code>: tile变为不可见.</li>
<li><code>onTileRemoved()</code>: 用户移除这个tile.</li>
</ul>
<p>以上这是默认模式, 如果你准确地知道何时更新, 你可以使用<a href="https://developer.android.com/reference/android/service/quicksettings/TileService.html#META_DATA_ACTIVE_TILE" target="_blank" rel="external">active mode</a>.<br>此时更新的回调<code>onStartListening()</code>是通过静态方法主动触发的.</p>
<p><strong>更新UI</strong>:<br>UI是<a href="https://developer.android.com/reference/android/service/quicksettings/Tile.html" target="_blank" rel="external">Tile</a>, 主要包含icon, label, description和state. 最后必须调用<code>updateTile()</code>方法.</p>
<p><strong>处理点击</strong>:<br>在<code>onClick()</code>回调触发的时候, 我们可以启动一些后台工作, 或者<code>showDialog()</code>, 或者<code>startActivityAndCollapse()</code>.</p>
<p>对于锁屏的机器有一些限制, 不能打开dialog, 并且activity需要有一个特定的flag, 有一个<code>unlockAndRun()</code>方法可以让用户先解锁后做一些工作.</p>
<p>长按tile默认会打开app的app info屏, 当然这个行为也可以override. 只要给你想打开的activity加上<code>ACTION_QS_TILE_PREFERENCES</code>.</p>
<h2 id="Android开发最佳实践-Android-Development-Best-Practices"><a href="#Android开发最佳实践-Android-Development-Best-Practices" class="headerlink" title="Android开发最佳实践 Android Development Best Practices"></a>Android开发最佳实践 <a href="https://medium.freecodecamp.com/android-development-best-practices-83c94b027fd3" target="_blank" rel="external">Android Development Best Practices</a></h2><p>关于性能:<br><a href="https://developer.android.com/training/best-performance.html" target="_blank" rel="external">Best Practices for Performance</a>;<br><a href="https://github.com/amitshekhariitbhu/awesome-android-complete-reference#performance-and-optimization" target="_blank" rel="external">Performance and Optimization</a></p>
<p>关于架构:<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a></p>
<p>写单元测试和UI测试.</p>
<p>使用Proguard, Stetho.<br>复用布局, 使用<merge>标签.<br><a href="https://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">reusing-layouts</a>.</merge></p>
<p>把launcher icons放在mipmap文件夹下.</p>
<p>多用shape和selector而不是图片.</p>
<p>避免深层次的布局.</p>
<p>向Intent或Bundler传数据时, 使用<code>Parcelable</code>而不是<code>Serializable</code>. 因为后者使用反射而比较慢.</p>
<p>不要在UI线程进行文件操作.</p>
<p>明白Bitmaps. 因为它们占用很多memory. <a href="https://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">Displaying Bitmaps</a></p>
<p>使用style来避免重复的属性设置.</p>
<p>需要时使用Fragment.</p>
<p>明白Activity的生命周期.</p>
<p>使用得到公认的libraries而不是自己的实现.</p>
<p>在各种机器上测试.</p>
<h2 id="Recap-Of-Google-Launchpad-Build-Lagos-All-About-Firebase"><a href="#Recap-Of-Google-Launchpad-Build-Lagos-All-About-Firebase" class="headerlink" title="Recap Of Google Launchpad Build Lagos : All About Firebase"></a><a href="http://chikemgbemena.com/2016/09/27/recap-lagos-launchpad-developers-conference-all-about-firebase/" target="_blank" rel="external">Recap Of Google Launchpad Build Lagos : All About Firebase</a></h2><p>作者参加了一个叫Google Launchpad Build的会议, 这篇文章是总结, 全部是关于Firebase的.</p>
<h2 id="Android-Shared-Element-Transitions-for-all"><a href="#Android-Shared-Element-Transitions-for-all" class="headerlink" title="Android Shared-Element Transitions for all"></a><a href="https://medium.com/@aitorvs/android-shared-element-transitions-for-all-b90e9361507d#.rlu4u7kmy" target="_blank" rel="external">Android Shared-Element Transitions for all</a></h2><p>在Lollipop+的设备上, shared element的transition动画很好实现, 但是在旧的版本上该怎么办呢? 作者展示了他的方法:</p>
<ul>
<li>Activity A捕捉origin view的初始值, 通过Intent把它们传给Activity B;</li>
<li>Activity B完全透明地启动;</li>
<li>Activity B读取bundle中的值, 准备场景;</li>
<li>Acitivty B运行shared element动画.</li>
</ul>
<p>几个实现细节:</p>
<p>需要知道View在B中的位置, 时机是layout之后, 但是draw之前, 即<code>onPreDraw()</code>.<br>返回时只需要把这个动画反向播放即可.</p>
<h2 id="Writing-Better-Adapters"><a href="#Writing-Better-Adapters" class="headerlink" title="Writing Better Adapters"></a><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.c5av797rd" target="_blank" rel="external">Writing Better Adapters</a></h2><p>(这个上一期刚讲过, 不知道为什么重复了. )</p>
<p>就是关于RecyclerView的Adapter, 作者认为多种View类型时, Adapter中太多的instance of和强制类型转换不是一种好做法, 于是提出了他的做法. </p>
<h2 id="Android-Wear-Accessing-the-Data-Layer-API"><a href="#Android-Wear-Accessing-the-Data-Layer-API" class="headerlink" title="Android Wear: Accessing the Data Layer API"></a><a href="https://medium.com/@manuelvicnt/android-wear-accessing-the-data-layer-api-d64fd55982e3" target="_blank" rel="external">Android Wear: Accessing the Data Layer API</a></h2><p>Data Layer API是Google Play services的一部分, 用于不同设备(手机和手表)间的数据交换.</p>
<p>作者先提供了代码, 发送和存储数据, 监听数据变化.</p>
<p>问题是, 如果Wear第二次向mobile请求数据, mobile发送了和上一次一样的数据, Wear并不会进入<code>onDataChanged()</code>, 因为数据并没有变化.</p>
<p>所以作者想知道如何从Data Layer API来获取数据, 并展示了他的方法在不同情形下的应用.</p>
<h2 id="Espresso-Tests-For-TextSwitcher"><a href="#Espresso-Tests-For-TextSwitcher" class="headerlink" title="Espresso Tests For TextSwitcher"></a><a href="http://www.ottodroid.net/?p=493" target="_blank" rel="external">Espresso Tests For TextSwitcher</a></h2><p>作者想给TextSwitcher写Espresso测试.</p>
<p>从Android Studio 2.2开始, 你可以录制你的操作, IDE将会自动为你生成Espresso测试代码. 但是作者录了一个有关TextSwitcher的测试之后, 跑失败了.</p>
<p>这是因为<code>TextSwitcher</code>继承了<code>ViewSwitcher</code>, 其实现其实是把两个TextView加到了布局里.<br>所以Espresso抛出了<code>AmbiguousViewMatcherException</code>.</p>
<p>所以作者根据可见性区分了它俩, 修复了测试.<br>还可以根据child view的index来区分.</p>
<h2 id="Animating-Android-Activities-and-Views-with-Slide-Animations"><a href="#Animating-Android-Activities-and-Views-with-Slide-Animations" class="headerlink" title="Animating Android Activities and Views with Slide Animations"></a><a href="https://kylewbanks.com/blog/left-and-right-slide-animations-on-android-activity-or-view" target="_blank" rel="external">Animating Android Activities and Views with Slide Animations</a></h2><p>作者展示了如何给Activity和View加上左右滑动的动画.</p>
<h2 id="Guide-to-ORM-using-ActiveAndroid-Part-1"><a href="#Guide-to-ORM-using-ActiveAndroid-Part-1" class="headerlink" title="Guide to ORM using ActiveAndroid: Part 1"></a><a href="http://www.rscottcarson.com/2016/09/22/the-ultimate-guide-to-orm-in-android-using-activeandroid-part-1/" target="_blank" rel="external">Guide to ORM using ActiveAndroid: Part 1</a></h2><p>这是一个系列教程, 相关的代码在: <a href="https://github.com/rscottcarson/ActiveAndroid-Tutorial" target="_blank" rel="external">ActiveAndroid-Tutorial</a></p>
<p>什么是ORM(Object-Relational Mapping)呢?<br>a technique to convert between incompatible type-systems in an object-oriented programming language.<br>在面向对象的语言中, 转换不兼容的类型的技术.</p>
<p><a href="http://www.activeandroid.com/" target="_blank" rel="external">ActiveAndroid</a>是一个ORM(object relational mapper), 让你不用写SQL语句, 就可以读写数据库.</p>
<p>其他类似的工具还有<a href="https://realm.io/docs/java/latest/" target="_blank" rel="external">Realm</a>和<a href="http://ormlite.com/" target="_blank" rel="external">OrmLite</a>.</p>
<h2 id="A-Comparison-of-Android-Crash-Reporting-Tools"><a href="#A-Comparison-of-Android-Crash-Reporting-Tools" class="headerlink" title="A Comparison of Android Crash Reporting Tools"></a><a href="https://www.captechconsulting.com/blogs/a-comparison-of-android-crash-reporting-tools" target="_blank" rel="external">A Comparison of Android Crash Reporting Tools</a></h2><p>作者对比了几种崩溃报告工具, 并介绍了如何使用.<br>包括: Firebase, <a href="https://fabric.io/kits/android/crashlytics/" target="_blank" rel="external">Crashlytics</a>, <a href="https://www.apteligent.com/" target="_blank" rel="external">Apteligent</a>, <a href="https://bugsnag.com/" target="_blank" rel="external">Bugsnag</a>.</p>
<h2 id="Google-Play-Services-Google-Cast-v3-and-Media"><a href="#Google-Play-Services-Google-Cast-v3-and-Media" class="headerlink" title="Google Play Services: Google Cast v3 and Media"></a><a href="https://code.tutsplus.com/tutorials/google-play-services-google-cast-v3-and-media--cms-26893" target="_blank" rel="external">Google Play Services: Google Cast v3 and Media</a></h2><p>Google Cast是一个让用户把网上的内容发送到设备上的技术. 通常用来和TV交换内容.</p>
<p>作者详细地介绍了如何使用Google Cast SDK来创建应用.</p>
<p>注: 要建造客户端程序, 首先需要注册: <a href="https://cast.google.com/publish/" target="_blank" rel="external">https://cast.google.com/publish/</a>.<br>这是收费的.</p>
<h2 id="ExoPlayer-2-x-It’s-here-plus-FAQs"><a href="#ExoPlayer-2-x-It’s-here-plus-FAQs" class="headerlink" title="ExoPlayer 2.x - It’s here (plus FAQs)!"></a><a href="https://medium.com/google-exoplayer/exoplayer-2-x-its-here-plus-faqs-cce34b0d4c7b#.h6m9czs7y" target="_blank" rel="external">ExoPlayer 2.x - It’s here (plus FAQs)!</a></h2><p>Google的库<a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">google/ExoPlayer</a>升级到v2.x了.<br>(它是一个Media Player, YouTube用的就是它.)<br>这次是个重大更新, 添加了很多新功能, 推荐大家以后用新版.</p>
<h2 id="How-We-Rethought-our-Complete-Package-Structure-for-Buffer-on-Android"><a href="#How-We-Rethought-our-Complete-Package-Structure-for-Buffer-on-Android" class="headerlink" title="How We Rethought our Complete Package Structure for Buffer on Android"></a><a href="https://overflow.buffer.com/2016/09/26/android-rethinking-package-structure/" target="_blank" rel="external">How We Rethought our Complete Package Structure for Buffer on Android</a></h2><p>作者他们重新整理了项目的包结构, 总结了整个过程还有从中学到的东东.</p>
<p>作者他们之前的包结构是按类型的, 有activities, fragments, adapters等包. 因为类名以类型终结, 所以索性就按整个分组.</p>
<p>当app变得越来越大, 这种组织方式发现就不太好, 感觉很难找东西, 并且感觉没什么结构.</p>
<p>经过改变之后, 作者他们采用了一种更加整洁并且易于导航的结构.</p>
<p>新结构中, 当添加一个新的feature, 就保持在同一个目录中, 这样就不用来回切换目录.</p>
<p>作者他们的新结构有四个总目录: </p>
<ul>
<li>data</li>
<li>ui</li>
<li>injection</li>
<li>util</li>
</ul>
<p><strong>data</strong>中包含网络请求及相关的models, preferences, database, data models, 还有其他和数据直接关联的东西.</p>
<p>其中和不同API关联的models又分别组织在子目录下.</p>
<p><strong>ui</strong>目录中包含所有和UI相关的组件, 在这个包中按照功能又拆分了子目录. 其中有base包, 用来盛放Fragment, Activity和MVP的基类, 接口等; 还有common包, 用来盛放公共控件.</p>
<p><strong>injection</strong>中包含所有依赖注入的类, 分component, module和scope的子目录.</p>
<p><strong>util</strong>中含有Helper和Utility类.</p>
<h2 id="Become-a-Firebase-Taskmaster-Part-3"><a href="#Become-a-Firebase-Taskmaster-Part-3" class="headerlink" title="Become a Firebase Taskmaster! (Part 3)"></a><a href="https://firebase.googleblog.com/2016/09/become-a-firebase-taskmaster-part-3_29.html" target="_blank" rel="external">Become a Firebase Taskmaster! (Part 3)</a></h2><p>这是系列文章的第三篇, 这个系列是关于Play services的<a href="https://developers.google.com/android/guides/tasks" target="_blank" rel="external">Task API</a>. </p>
<p>如果项目里已经依赖了Firebase, 变自动包含了Task API, 如果不想用Firebase, 可以单独添加依赖:<br><code>compile &#39;com.google.android.gms:play-services-tasks:9.6.1&#39;</code></p>
<p>创建新的Task可以用下面这两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Task&lt;TResult&gt; <span class="title">call</span><span class="params">(Callable&lt;TResult&gt; callable)</span></span></div><div class="line">Task&lt;TResult&gt; <span class="title">call</span><span class="params">(Executor executor, Callable&lt;TResult&gt; callable)</span></div></pre></td></tr></table></figure></p>
<p>第一个<code>call()</code>方法在主线程执行任务, 第二个<code>call()</code>方法可以把工作提交给一个<code>Executor</code>.</p>
<p><a href="https://developer.android.com/reference/java/util/concurrent/Callable.html" target="_blank" rel="external">Callable</a>有点类似于Runnable:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarlyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Call me maybe"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参数制定了方法的返回值的类型, 进而也是创建出Task的类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Task&lt;String&gt; task = Tasks.call(<span class="keyword">new</span> CarlyCallable());</div></pre></td></tr></table></figure>
<p>想要链式执行, 进行后续操作, 可以用<a href="https://developers.google.com/android/reference/com/google/android/gms/tasks/Continuation" target="_blank" rel="external">Continuation</a>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateWays</span> <span class="keyword">implements</span> <span class="title">Continuation</span>&lt;<span class="title">String</span>, <span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">then</span><span class="params">(Task&lt;String&gt; task)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> Arrays.asList(task.getResult().split(<span class="string">" +"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它继承接口时指定了输入和输出的类型, 它的输入来自于Task的输出.</p>
<p>可以多写几个Continuation类然后连起来:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Task&lt;String&gt; playlist = Tasks.call(<span class="keyword">new</span> CarlyCallable())</div><div class="line">        .continueWith(<span class="keyword">new</span> SeparateWays())</div><div class="line">        .continueWith(<span class="keyword">new</span> AllShookUp())</div><div class="line">        .continueWith(<span class="keyword">new</span> ComeTogether());</div><div class="line">playlist.addOnSuccessListener(<span class="keyword">new</span> OnSuccessListener&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="comment">// The final String with all the words randomized is here</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="LIBRIARIES-amp-CODE"><a href="#LIBRIARIES-amp-CODE" class="headerlink" title="LIBRIARIES &amp; CODE"></a>LIBRIARIES &amp; CODE</h1><h2 id="groupie"><a href="#groupie" class="headerlink" title="groupie"></a><a href="https://github.com/Genius/groupie" target="_blank" rel="external">groupie</a></h2><p>显示和管理复杂的RecyclerView布局, 把你的items按照逻辑分组管理.</p>
<h2 id="android-junit5"><a href="#android-junit5" class="headerlink" title="android-junit5"></a><a href="https://github.com/aurae/android-junit5" target="_blank" rel="external">android-junit5</a></h2><p>Gradle插件, 用JUnit5做Android的单元测试.</p>
<h2 id="epoxy"><a href="#epoxy" class="headerlink" title="epoxy"></a><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">epoxy</a></h2><p>用来构建复杂的RecyclerView屏.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> Wear </tag>
            
            <tag> Firebase </tag>
            
            <tag> Android 7.0 </tag>
            
            <tag> Quick Settings </tag>
            
            <tag> Shared-Element Transtion </tag>
            
            <tag> Animation </tag>
            
            <tag> ORM </tag>
            
            <tag> ActiveAndroid </tag>
            
            <tag> Crash Reporting </tag>
            
            <tag> Google Cast </tag>
            
            <tag> ExoPlayer </tag>
            
            <tag> Packages </tag>
            
            <tag> Task </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 224]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/10/02/android-weekly-notes-issue-224/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-224"><a href="#Android-Weekly-Issue-224" class="headerlink" title="Android Weekly Issue #224"></a>Android Weekly Issue #224</h1><p>September 25th, 2016<br><a href="http://androidweekly.net/issues/issue-224" target="_blank" rel="external">Android Weekly Issue #224</a></p>
<p>本期内容包括: Google Play的pre-launch报告; Wear的Complications API; Android Handler解析; RxAndroid; 测量性能的库: Pury; 方法数限制; APK内容分析; Redux for Android; 一种view造成的泄露; 注解处理; 更好的Adapter; Intro屏等等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Apk的pre-launch报告-Awesome-pre-launch-reports-for-Alpha-Beta-APK’s"><a href="#Apk的pre-launch报告-Awesome-pre-launch-reports-for-Alpha-Beta-APK’s" class="headerlink" title="Apk的pre-launch报告 Awesome pre-launch reports for Alpha/Beta APK’s"></a>Apk的pre-launch报告 <a href="https://medium.com/@AruLNadhaN/awesome-pre-launch-reports-for-alpha-beta-apks-9960ac5c403c#.5qhy3bbqc" target="_blank" rel="external">Awesome pre-launch reports for Alpha/Beta APK’s</a></h2><p>Google Play team在I/O 2016的时候宣布了很多新features, 其中有一个pre-launch report.</p>
<p>这个report是干什么的呢, 它会报告在一些设备上测试你的应用的时候发现的issues.</p>
<p>要生成这种报告, 你应该在Developer console上enable它. 然后<a href="https://support.google.com/googleplay/android-developer/answer/3131213" target="_blank" rel="external">上传alpha/beta apk</a>. 上传到beta channel之后, 5-10分钟就会生成报告.</p>
<p>报告主要包括三个部分:</p>
<ul>
<li>Crashes</li>
<li>Screenshots</li>
<li>Security</li>
</ul>
<p>官方文档: <a href="https://support.google.com/googleplay/android-developer/answer/7002270#sources" target="_blank" rel="external">pre-launch</a></p>
<h2 id="Wear-Complications-API"><a href="#Wear-Complications-API" class="headerlink" title="Wear Complications API"></a><a href="https://medium.com/@danybony_/wear-complications-api-16ab65290aa1#.w6lt2q3rx" target="_blank" rel="external">Wear Complications API</a></h2><p>在钟表的定义里, complications是指表上除了小时和分钟指示之外其他的东西.</p>
<p>在Android Wear里面我们已经有一些complications的例子, 比如向用户显示计步器, 天气预报, 下一个会议时间等等.</p>
<p>但是之前有一个很大的限制就是每一个小应用都必须实现自己的逻辑来取数据, 比如有两个应用都取了今天的天气预报信息, 将会有两套机制取同样的数据, 这明显是一种浪费.</p>
<p>Android Wear 2.0推出了Complications API解决了这个问题.</p>
<p>通信主要是<strong>Data providers</strong>和<strong>Watch faces</strong>之间的, 前者包含取数据的逻辑, 后者负责显示.</p>
<p>Complications API定义了一些Complications Types, 见<a href="https://developer.android.com/wear/preview/features/complications.html#using_complication_types" target="_blank" rel="external">官方文档</a>.</p>
<p>作者在他朋友的开源应用里用了新的API: <a href="https://github.com/alexstyl/Memento-Namedays" target="_blank" rel="external">Memento-Namedays</a>, 这个应用是生日或者日期提醒类的.</p>
<p>首先, 作者用<a href="https://developer.android.com/training/wearables/data-layer/index.html" target="_blank" rel="external">Wearable Data Layer API</a>同步了手机和手表的数据. 然后在Wear module里继承<code>ComplicationProviderService</code>创建了complication data provider, 这里就提供了<code>onComplicationActivated</code>, <code>onComplicationDeactivated</code>, <code>onComplicationUpdate</code>等回调. </p>
<p>用户也可以点击Complications, 可以用<code>setTapAction()</code>指定点击后要启动的Activity.</p>
<p>可以指定<code>ComplicationProviderService</code>的更新频率, 是在manifest里用这个key:<br><code>android.support.wearable.complications.UPDATE_PERIOD_SECONDS</code>.</p>
<p>更新得太频繁会比较费电.<br>需要注意的是这并不是一个常量, 因为系统也会根据手机的状况进行一些调节, 不必要的时候就不需要频繁更新.</p>
<p>本文作者采用的方式是用<code>ProviderUpdateRequester</code>. 在manifest里面设置0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ComponentName providerComponentName = <span class="keyword">new</span> ComponentName(</div><div class="line">    context, </div><div class="line">    MyComplicationProviderService.class</div><div class="line">);</div><div class="line">ProviderUpdateRequester providerUpdateRequester = <span class="keyword">new</span></div><div class="line">    ProviderUpdateRequester(context, providerComponentName);</div><div class="line">providerUpdateRequester.requestUpdateAll();</div></pre></td></tr></table></figure>
<p>最后, 这里是官网文档:<br><a href="https://developer.android.com/wear/preview/features/complications.html" target="_blank" rel="external">Complications</a>.</p>
<p>这里是作者PR: <a href="https://github.com/alexstyl/Memento-Namedays/pull/40" target="_blank" rel="external">PR</a></p>
<h2 id="Android-Handler-Internals"><a href="#Android-Handler-Internals" class="headerlink" title="Android Handler Internals"></a><a href="https://medium.com/@jagsaund/android-handler-internals-b5d49eba6977#.xuogmm2c0" target="_blank" rel="external">Android Handler Internals</a></h2><p>首先, 作者举了一个简单的例子, 用两种方法, 用Handler来实现下载图片并显示到ImageView上的过程.</p>
<p>主要是因为网络请求需要在非UI线程, 而View操作需要在UI线程. Handler就用来在这两种线程之间切换调度.</p>
<p><strong>Handler的组成</strong></p>
<ul>
<li>Handler</li>
<li>Message</li>
<li>Message Queue</li>
<li>Looper</li>
</ul>
<p><strong>Handler</strong></p>
<p><a href="https://developer.android.com/reference/android/os/Handler.html" target="_blank" rel="external">Handler</a>是线程间消息传递的直接接口, 生产者和消费者线程都是通过调用下面的操作和Handler交互:</p>
<ul>
<li>creating, inserting, removing Messages from Message Queue.</li>
<li>processing Messages on the consumer thread.</li>
</ul>
<p>每一个Handler都是和一个Looper和一个Message Queue关联的. 有两种方法来创建一个Handler:</p>
<ul>
<li>用默认构造器, 将会使用当前线程的Looper.</li>
<li>显式地指明要用的Looper.</li>
</ul>
<p>Handler不能没有Looper, 如果构造时没有指明Looper, 当前线程也没有Looper, 那么将会抛出异常.</p>
<p>因为Handler需要Looper中的消息队列.</p>
<p>一个线程上的多个Handler共享同一个消息队列, 因为它们共享同一个Looper.</p>
<p><strong>Message</strong></p>
<p><a href="https://developer.android.com/reference/android/os/Message.html" target="_blank" rel="external">Message</a>是一个包含任意数据的容器, 它包含的数据信息是callback, data bundle和obj/arg1/arg2, 还有三个附加数据what, time和target.</p>
<p>可以调用Handler的<code>obtainMessage()</code>方法来创建Message, 这样message是从message pool中取出的, target会自动设置成Handler自己. 所以直接可以在后面调用<code>sendToTarget()</code>方法.</p>
<p>Message pool是一个最大尺寸为50的LinkedList. 当消息被处理完之后, 会放回pool, 并且重置所有字段.</p>
<p>当我们使用Handler来<code>post(Runnable)</code>的时候, 实际上是隐式地创建一个Message, 它的callback存这个Runnable.</p>
<p><strong>Message Queue</strong></p>
<p><a href="https://developer.android.com/reference/android/os/MessageQueue.html" target="_blank" rel="external">Message Queue</a> 是一个无边界的LinkedList, 元素是Message对象. 它按照时间顺序来插入Message, 所以timestamp最小的最先分发. </p>
<p>MessageQueue中有一个<code>dispatch barrier</code>表示当前时间, 当message的timestamp小于当前时间时, 被分发和处理.</p>
<p>Handler提供了一些方法在发message的时候设置不同的时间戳:</p>
<p><code>sendMessageDelayed()</code>: 当前时间 + delay时间.</p>
<p><code>sendMessageAtFrontOfQueue()</code>: 把时间戳设为0, 不建议使用.</p>
<p><code>sendMessageAtTime()</code>.</p>
<p>Handler经常需要和UI交互, 可能会引用Activity, 所以也经常会引起内存泄漏.<br>作者举了两个例子, 略.</p>
<p>需要注意:<br>非静态内部类会持有外部类实例引用.<br>Message会持有Handler引用, 主线程的Looper和MessageQueue在程序运行期间是一直存在的.</p>
<p>建议的是, 内部类用static修饰, 另用WeakReference.</p>
<p><strong>Debug Tips</strong><br>显示Looper中dispatched的Messages:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Looper looper = getMainLooper();</div><div class="line">looper.setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"Looper"</span>));</div></pre></td></tr></table></figure></p>
<p>显示MessageQueue中和handler相关的pending messages:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">handler.dump(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"Handler"</span>), <span class="string">""</span>);</div></pre></td></tr></table></figure></p>
<p><strong>Looper</strong></p>
<p><a href="https://developer.android.com/reference/android/os/Looper.html" target="_blank" rel="external">Looper</a> 从消息队列中读取消息, 然后分发给target handler. 每当一个Message穿过了<code>dispatch barrier</code>, 它就可以在下一个消息循环中被Looper读.</p>
<p>一个线程只能关联一个Looper. 因为Looper类中有一个静态的ThreadLocal对象保证了只有一个Looper和线程关联, 企图再加一个就会抛出异常.</p>
<p>调用<code>Looper.quit()</code>会立即终止Looper, 丢弃所有消息.<br>而<code>Looper.quitSafely()</code>会将已经通过<code>dispatch barrier</code>的消息处理了, 只丢弃pending的消息.</p>
<p>Looper是在Thread的<code>run()</code>方法里setup的, <code>Looper.prepare()</code>会检查是否之前存在一个<code>Looper</code>和这个线程关联, 如果有则抛异常, 没有则建立一个新的<code>Looper</code>对象, 创建一个新的MessageQueue. 见<a href="https://github.com/android/platform_frameworks_base/blob/e71ecb2c4df15f727f51a0e1b65459f071853e35/core/java/android/os/Looper.java#L83" target="_blank" rel="external">代码</a>.</p>
<p>现在<code>Handler</code>可以接收或者发送消息到<code>MessageQueue</code>了. 执行<code>Looper.loop()</code>方法将会开始从队列读出消息. 每一个loop迭代都会取出下一个消息.</p>
<h2 id="Crunching-RxAndroid-Part-10-细细咀嚼RxAndroid"><a href="#Crunching-RxAndroid-Part-10-细细咀嚼RxAndroid" class="headerlink" title="Crunching RxAndroid - Part 10  细细咀嚼RxAndroid"></a><a href="https://medium.com/crunching-rxandroid/crunching-rxandroid-part-10-cc0c33108ee2#.ri2xoc35c" target="_blank" rel="external">Crunching RxAndroid - Part 10 </a> 细细咀嚼RxAndroid</h2><p>作者这个是个系列文章, 本文是part 10.</p>
<p>Android的listener很多, 我们可以通过RxJava把listener都变成发射信息的源, 然后我们subscribe.</p>
<p>本文举例讲了<code>Observable.fromCallable()</code>和<code>Observable.fromAsync()</code>方法的用法.</p>
<h2 id="Pury-a-new-way-to-profile-your-Android-application"><a href="#Pury-a-new-way-to-profile-your-Android-application" class="headerlink" title="Pury a new way to profile your Android application"></a><a href="https://medium.com/@nikita.kozlov/pury-new-way-to-profile-your-android-application-7e248b5f615e#.a7a9lsexj" target="_blank" rel="external">Pury a new way to profile your Android application</a></h2><p>在做任何优化之前我们都应该先定位问题. 首先是收集性能数据, 如果收集到的信息超过了可以接受的阈值, 我们再进一步深究, 找到引起问题的方法或者API.</p>
<p>幸运的是, 有一些工具可以帮我们profiling:</p>
<ul>
<li><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">Hugo</a> 用<code>@DebugLog</code>注解来标记方法, 然后参数, 返回值, 执行时间都会log出来.</li>
<li>Android Studio toolset. 比如System Trace, 非常准确, 提供了很多信息, 但是需要你花时间来收集和分析数据.</li>
<li>后台解决方案, 比如<a href="https://jmeter.apache.org/" target="_blank" rel="external">JMeter</a>, 它们提供了很多功能, 需要花时间来学习如何使用, 第二就是高并发profile也不是常见的需求.</li>
</ul>
<p><strong>Missing tool</strong></p>
<p>关于我们关心的应用的速度问题, 大多数可以分为两种:</p>
<ul>
<li>特定方法和API的执行时间, 这个可以被Hugo cover.</li>
<li>两个事件之间的时间, 这可能是独立的两段代码, 但是在逻辑上关联. Android Studio toolset可以cover这种, 但是你需要花很多时间来做profile.</li>
</ul>
<p>作者意识到下面的需求没有被满足:</p>
<ul>
<li>开始和结束profiling应该是被两个独立的事件触发的, 这样才可以满足我们灵活性的需求.</li>
<li>如果我们想监控performance, 仅仅开始和结束事件是不够的. 有时候我们需要知道这之间发生了什么, 这些阶段信息应该被放在一个报告里, 让我们更容易明白和分享数据.</li>
<li>有时候我们需要做重复操作, 比如loading RecyclerView的下一页, 那么一个回合的操作显然是不够的, 我们需要进行多次操作, 然后显示统计数据, 比如平均值, 最小最大值.</li>
</ul>
<p>基于上面的需求, 作者创建了Pury.</p>
<p><strong>Introduction to Pury</strong></p>
<p>Pury是一个profiling的库, 用于测量多个独立事件之间的时间.<br>事件可以通过注解或者方法调用来触发, 一个scenario的所有事件被放在同一个报告里.</p>
<p>然后作者举了两个例子, 一个用来测量启动时间, 另一个用来测量loading pages.</p>
<p><strong>Inner structure and limitations</strong></p>
<p>性能测量是<code>Profilers</code>做的, 每一个<code>Profiler</code>包含一个list, 里面是<code>Runs</code>. 多个<code>Profilers</code>可以并行运行, 但是每个<code>Profiler</code>中只有一个<code>Run</code>是active的. </p>
<p><strong>Profiling with Pury</strong></p>
<p>Pury可以测量多个独立事件之间的时间, 事件可以用注解或者方法调用触发.<br>基本的注解有: <code>@StartProfiling</code>, <code>@StopProfiling</code>, <code>@MethodProfiling</code></p>
<p>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pury.startProfiling();</div><div class="line"></div><div class="line">Pury.stopProfiling();</div></pre></td></tr></table></figure></p>
<p>最后作者介绍了一些使用细节.<br>项目地址: <a href="https://github.com/NikitaKozlov/Pury" target="_blank" rel="external">Pury</a></p>
<h2 id="处理方法数限制问题-Dealing-With-the-65K-Methods-limit-on-Android"><a href="#处理方法数限制问题-Dealing-With-the-65K-Methods-limit-on-Android" class="headerlink" title="处理方法数限制问题 Dealing With the 65K Methods limit on Android"></a>处理方法数限制问题 <a href="http://bytes.schibsted.com/dealing-65k-methods-limit-android/" target="_blank" rel="external">Dealing With the 65K Methods limit on Android</a></h2><p>作为Android开发, 你可能会看到过这种信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Too many field references: 88974; max is 65536.</div><div class="line">You may try using –multi-dex option.</div></pre></td></tr></table></figure></p>
<p>首先, 为什么会存在65k的方法数限制呢?</p>
<p>Android应用是放在APK文件里的, 这里面包含了可执行的二进制码文件(DEX - Dalvik Executable), 里面包含了让app工作的代码.</p>
<p>DEX规范限制了单个的DEX文件中的方法总数最大为65535, 包括了Android framework方法, library方法, 还有你自己代码中的方法. 如果超过了这个限制你将不得不配置你的app来生成多个DEX文件(multidex configuration). </p>
<p>但是开启了multidex配置之后有一些随机性的兼容问题, 所以我们在决定开启multidex之前, 首先采取的第一步是减少方法数来避免这个问题.</p>
<p>在我们开始改动之前, 先提出了这些问题:</p>
<ul>
<li>我们有多少方法?</li>
<li>这些方法都是从哪里来?</li>
<li>主要的方法来源是谁?</li>
<li>我们真的需要所有这些方法吗?</li>
</ul>
<p>在搜寻这些问题的答案的过程中, 我们发现了一些有用的工具和tips:</p>
<p><a href="http://www.methodscount.com/" target="_blank" rel="external">MethodsCount.com</a> 将会告诉你一个库有多少方法, 还提供了每个方法的依赖.</p>
<p><a href="https://github.com/JakeWharton/dex-method-list" target="_blank" rel="external">JakeWharton/dex-method-list utility</a> 可以显示.apk, .aar, .dex, .jar或.class文件中的所有方法引用. 这可以用来发现一个库中到底有多少方法是被你的app使用了.</p>
<p><a href="https://github.com/mihaip/dex-method-counts" target="_blank" rel="external">mihaip/dex-method-counts</a> 这个工具可以按包来输出方法, 计算出一个DEX文件中的方法数然后按包来分组输出. 这有利于我们明白哪些库是方法数的主要来源.</p>
<p><a href="https://gradle.org/" target="_blank" rel="external">Gradle build system</a> 提供了关于项目结构很有价值的信息. 一个有用的task是<code>dependencies</code>, 让你看到库的依赖树, 这样你就可以看到重复的依赖, 进而删除它们来减少方法数.</p>
<p><a href="http://classyshark.com/" target="_blank" rel="external">Classyshark</a> 是一个Android可执行文件的浏览器. 用这个工具你可以打开Android的可执行文件(.jar, .class, .apk, .dex, .so, .aar, 和Android XML)来分析它的内容.</p>
<p><a href="http://inloop.github.io/apk-method-count/" target="_blank" rel="external">apk-method-count</a> 这是一个工具, 用来快速地查apk中的方法数, 拖拽apk之后就会得到结果.</p>
<h2 id="What’s-in-the-APK-APK中有什么"><a href="#What’s-in-the-APK-APK中有什么" class="headerlink" title="What’s in the APK APK中有什么"></a><a href="http://crushingcode.co/whats-in-the-apk/" target="_blank" rel="external">What’s in the APK</a> APK中有什么</h2><p>APK: Android application package 是Android系统的一种文件格式, 实际上是一种压缩文件, 如果把.apk重命名为.zip, 就可以取出其内容.</p>
<p>但是此时我们直接在文本编辑器打开AndroidManifest.xml的时候看到的全是机器码.</p>
<p>当然是有工具来帮我们分析这些东西的, 这个工具从一开始就有, 那就是aapt, 它是Android Build Tool的一部分.</p>
<p><strong>aapt - Android Asset Packaging Tool</strong> 这个工具可以用来查看和增删apk中的文件, 打包资源, 研究PNG文件等等.</p>
<p>它的位置在: <code>&lt;path_to_android_sdk&gt;/build-tools/&lt;build_tool_version_such_as_24.0.2&gt;/aapt</code>.</p>
<p>aapt能做的事情, 从man可以看出:</p>
<ul>
<li>aapt list - Listing contents of a ZIP, JAR or APK file.</li>
<li>aapt dump - Dumping specific information from an APK file.</li>
<li>aapt package - Packaging Android resources.</li>
<li>aapt remove - Removing files from a ZIP, JAR or APK file.</li>
<li>aapt add - Adding files to a ZIP, JAR or APK file.</li>
<li>aapt crunch - Crunching PNG files.</li>
</ul>
<p>用这个工具来分析我们的apk:</p>
<p>输出基本信息:<br><code>aapt dump badging app-debug.apk</code></p>
<p>输出声明的权限:<br><code>aapt dump permissions app-debug.apk</code></p>
<p>输出配置:<br><code>aapt dump configurations app-debug.apk</code></p>
<p>还有其他这些:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Print the resource table from the APK.</div><div class="line">aapt dump resources app-debug.apk</div><div class="line"></div><div class="line"># Print the compiled xmls in the given assets.</div><div class="line">aapt dump xmltree app-debug.apk</div><div class="line"></div><div class="line"># Print the strings of the given compiled xml assets.</div><div class="line">aapt dump xmlstrings app-debug.apk</div><div class="line"></div><div class="line"># List contents of Zip-compatible archive.</div><div class="line">aapt list -v -a  app-debug.apk</div></pre></td></tr></table></figure></p>
<h2 id="Reductor-Redux-for-Android"><a href="#Reductor-Redux-for-Android" class="headerlink" title="Reductor - Redux for Android"></a><a href="https://yarikx.github.io/Reductor-prologue/" target="_blank" rel="external">Reductor - Redux for Android</a></h2><p>Redux是一个当前JavaScript中很火的构架模式. Reductor把它的概念借鉴到了Java和Android中.</p>
<p>关于状态管理到底有什么好方法呢, 作者想到了前端开发中的SPA(Single-page application), 和Android应用很像, 有没有什么可借鉴的呢? 答案是有.</p>
<p><a href="http://redux.js.org/" target="_blank" rel="external">Redux</a> 是一个JavaScript应用的可预测的状态容器, 可以用下面三个基本原则来描述:</p>
<ul>
<li>单一的真相来源</li>
<li>状态只读</li>
<li>变化是纯函数造成的</li>
</ul>
<p>Redux的灵感来源有<a href="http://facebook.github.io/flux/" target="_blank" rel="external">Flux</a>和<a href="https://github.com/evancz/elm-architecture-tutorial/" target="_blank" rel="external">Elm Architecture</a>.<br>强烈建议阅读一下它的<a href="http://redux.js.org/docs/introduction/Motivation.html" target="_blank" rel="external">文档</a>.</p>
<p><a href="https://github.com/Yarikx/reductor" target="_blank" rel="external">Reductor</a>是作者用Java又实现了一次Redux.</p>
<p>作者用了一个Todo app的例子来说明如何使用, 以及它的好处.</p>
<p>作者先写了一个naive的实现, 然后不断地举出它的缺点, 然后改进它.</p>
<p>其中作者用到了<a href="https://github.com/hrldcpr/pcollections" target="_blank" rel="external">pcollection</a>来实现persistent/immutable的集合.</p>
<p>最后还把代码改为对测试友好的.</p>
<h2 id="Android-leak-pattern-subscriptions-in-views"><a href="#Android-leak-pattern-subscriptions-in-views" class="headerlink" title="Android leak pattern: subscriptions in views"></a><a href="https://medium.com/@pyricau/android-leak-pattern-subscriptions-in-views-18f0860aa74c?swoff=true" target="_blank" rel="external">Android leak pattern: subscriptions in views</a></h2><p>开始作者举了一个例子, 一个自定义View, subscribe了Authenticator单例的username变化事件, 从而更新UI.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Authenticator authenticator;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HeaderView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> TextView usernameView = (TextView) findViewById(R.id.username);</div><div class="line">    authenticator.username().subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String username)</span> </span>&#123;</div><div class="line">        usernameView.setText(username);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是代码存在一个主要的问题: 我们从来没有unsubscribe. 这样匿名内部类对象就持有外部类对象, 整个view hierarchy就泄露了, 不能被GC.</p>
<p>为了解决这个问题, 在View的<code>onDetachedFromWindow()</code>回调里调用<code>unsubscribe()</code>.</p>
<p>作者以为这样解决了问题, 但是并没有, 还是检测出了泄露, 并且作者发现View的<code>onAttachedToWindow()</code>和<code>onDetachedFromWindow()</code>都没有被调用.</p>
<p>作者研究了<code>onAttachedToWindow()</code>的调用时机:</p>
<ul>
<li>When a view is added to a parent view with a window, onAttachedToWindow() is called immediately, from addView().</li>
<li>When a view is added to a parent view with no window, onAttachedToWindow() will be called when that parent is attached to a window.</li>
</ul>
<p>而作者的布局是在Activity的<code>onCreate()</code>里面<code>setContentView()</code>设置的.<br>这时候每一个View都收到了<code>View.onFinishInflate()</code>回调, 却没有调<code>View.onAttachedToWindow()</code>.</p>
<p><code>View.onAttachedToWindow()</code> is called on the first view traversal, sometime after <code>Activity.onStart()</code>.</p>
<p><code>onStart()</code>方法是不是每次都会调用呢? 不是的, 如果我们在<code>onCreate()</code>里面调用了<code>finish()</code>, <code>onDestroy()</code>会立即执行, 而不经过其中的其他生命周期回调.</p>
<p>明白了这个原理之后, 作者的改进是把订阅放在了<code>View.onAttachedToWindow()</code>里, 这样就不会泄露了. 对称总是好的.</p>
<h2 id="Annotation-Processing-in-Android-Studio-注解和其处理器"><a href="#Annotation-Processing-in-Android-Studio-注解和其处理器" class="headerlink" title="Annotation Processing in Android Studio 注解和其处理器"></a><a href="https://medium.com/@aitorvs/annotation-processing-in-android-studio-7042ccb83024#.khjikdf51" target="_blank" rel="external">Annotation Processing in Android Studio</a> 注解和其处理器</h2><p>作者用例子说明了如何自定义注解和其处理器, 让被标记的类自动成为Parcelable的.<br>看了这个有助于理解各种依赖和了解相关的目录结构.</p>
<p>建议使用: <a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="external">android-apt</a>.</p>
<p><a href="https://developer.android.com/reference/android/os/Parcelable.html" target="_blank" rel="external">Parcelable</a>.<br>相关库代码: <a href="https://github.com/aitorvs/auto-parcel" target="_blank" rel="external">aitorvs/auto-parcel</a>.</p>
<h2 id="Writing-Better-Adapters-写出更好的Adapter"><a href="#Writing-Better-Adapters-写出更好的Adapter" class="headerlink" title="Writing Better Adapters 写出更好的Adapter"></a><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.ngas0y7j1" target="_blank" rel="external">Writing Better Adapters</a> 写出更好的Adapter</h2><p>在Android应用中, 经常需要展示List, 那就需要一个Adapter来持有数据.</p>
<p>RecyclerView的基本操作是: 创建一个view, 然后这个ViewHolder显示view数据; 把这个ViewHolder和adapter持有的数据绑定, 通常是一个model classes的list.</p>
<p>当数据类型只有一种时, 实现很简单, 不容易出错. 但是当要显示的数据有很多种时, 就变得复杂起来.</p>
<p>首先你需要覆写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">override fun getItemViewType(position: Int) : Int</div></pre></td></tr></table></figure></p>
<p>默认是返回0, 实现以后把不同的type转换为不同的整型值.</p>
<p>然后你需要覆写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder</div></pre></td></tr></table></figure></p>
<p>为每一种type创建一个ViewHolder.</p>
<p>第三步是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int): Any</div></pre></td></tr></table></figure></p>
<p>这里没有type参数.</p>
<p><strong>The Uglyness</strong><br>好像看起来没有什么问题?<br>让我们重新看<code>getItemViewType()</code>这个方法. 系统需要给每一个position都对应一个type, 所以你可能会写出这样的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (things.get(position) is Duck) &#123;</div><div class="line">    <span class="keyword">return</span> TYPE_DUCK</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (things.get(position) is Mouse) &#123;</div><div class="line">    <span class="keyword">return</span> TYPE_MOUSE</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这很丑不是吗?</p>
<p>如果你的ViewHolder没有一个共同的基类, 在binding的时候也是这么丑:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123;</div><div class="line">    val thing = things.get(position)</div><div class="line">    if (thing is Animal) &#123;</div><div class="line">        (holder as AnimalViewHolder).bind(thing as Animal)</div><div class="line">    &#125; else if (thing is Car) &#123;</div><div class="line">        (holder as CarViewHolder).bind(thing as Car)</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很多的instance-of和强制类型转换, 它们都是code smells. 违反了很多软件设计的原则, 并且当我们想要新添一种类型时, 需要改动很多方法. 我们的目标是添加新类型的时候不用更改Adapter之前的代码.<br>开闭原则: Open for Extension, Closed for Modification.</p>
<p><strong>Let’s Fix It</strong><br>用一个map来查询? 不好.<br>把type放在model里? 不好.</p>
<p>解决问题的一种办法是: 加入ViewModel, 作为中间层.</p>
<p>但是如果你不想创建很多的ViewModel类, 还有其他的办法: <a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external">Visitor模式</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface Visitable &#123;</div><div class="line">    fun type(typeFactory: TypeFactory) : Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Animal : Visitable</div><div class="line">interface Car : Visitable</div><div class="line"></div><div class="line">class Mouse: Animal &#123;</div><div class="line">    override fun type(typeFactory: TypeFactory) </div><div class="line">        = typeFactory.type(this)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工厂:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface TypeFactory &#123;</div><div class="line">    fun type(duck: Duck): Int</div><div class="line">    fun type(mouse: Mouse): Int</div><div class="line">    fun type(dog: Dog): Int</div><div class="line">    fun type(car: Car): Int</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回对应的id:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class TypeFactoryForList : TypeFactory &#123;</div><div class="line">    override fun type(duck: Duck) = R.layout.duck</div><div class="line">    override fun type(mouse: Mouse) = R.layout.mouse</div><div class="line">    override fun type(dog: Dog) = R.layout.dog</div><div class="line">    override fun type(car: Car) = R.layout.car</div></pre></td></tr></table></figure></p>
<h2 id="Material-Intro-Screen-for-Android-Apps"><a href="#Material-Intro-Screen-for-Android-Apps" class="headerlink" title="Material Intro Screen for Android Apps"></a><a href="https://medium.com/tangoagency/material-intro-screen-for-android-apps-c4317fbac923?source=latest" target="_blank" rel="external">Material Intro Screen for Android Apps</a></h2><p>现在有两个主流的libraries为Android 应用提供了好看的intro screens, 但是感觉并不是很好用, 所以作者他们发布了一个新的欢迎界面的库<a href="https://github.com/TangoAgency/material-intro-screen/" target="_blank" rel="external">TangoAgency/material-intro-screen
</a>, 好用易扩展.</p>
<h2 id="Testing-Legacy-Code-Hidden-Dependencies"><a href="#Testing-Legacy-Code-Hidden-Dependencies" class="headerlink" title="Testing Legacy Code: Hidden Dependencies"></a><a href="https://medium.com/@corneliu/testing-legacy-code-hidden-dependencies-9b8cd617953f" target="_blank" rel="external">Testing Legacy Code: Hidden Dependencies</a></h2><p>本文讨论<a href="https://en.wikipedia.org/wiki/God_object" target="_blank" rel="external">God Object</a>, <a href="https://sourcemaking.com/antipatterns/the-blob" target="_blank" rel="external">Blob</a>, 这种很大的类和方法, 做了很多事情. 如果你想要重构, 先加点测试, 也发现很难, 因为它的依赖太多了, 做了太多事情.</p>
<p>首先, 实例化:<br>加set方法, 让数据库依赖抽离出来, 这样测试的时候可以传一个Fake的进去.</p>
<p>第二, 更多依赖:<br>把UserManger和网络请求等依赖也抽为成员变量, 加上set方法或者构造参数, 这样在测试的时候易于把mock的东西传进去.</p>
<p>第三, 清理: 要牢记<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">单一职能原则</a>, 进行职能拆分.</p>
<p>最后, 现实: 清理是一个持续化的过程, 得一步一步来, 有时候小步的改动会帮助你发现另外需要改动的地方. </p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="EncryptedPreferences"><a href="#EncryptedPreferences" class="headerlink" title="EncryptedPreferences"></a><a href="https://github.com/PDDStudio/EncryptedPreferences" target="_blank" rel="external">EncryptedPreferences</a></h2><p>AES-256加密的SharedPreferences.</p>
<h2 id="Pury"><a href="#Pury" class="headerlink" title="Pury"></a><a href="https://github.com/NikitaKozlov/Pury" target="_blank" rel="external">Pury</a></h2><p>报告多个不同事件之间的时间, 可用于性能测量.</p>
<h2 id="Floating-Navigation-View"><a href="#Floating-Navigation-View" class="headerlink" title="Floating-Navigation-View"></a><a href="https://github.com/andremion/Floating-Navigation-View" target="_blank" rel="external">Floating-Navigation-View</a></h2><p>Floating Action Button, 展开后是一个NavigationView.</p>
<h2 id="Material-Intro-Screen"><a href="#Material-Intro-Screen" class="headerlink" title="Material Intro Screen"></a><a href="https://github.com/TangoAgency/material-intro-screen" target="_blank" rel="external">Material Intro Screen</a></h2><p>易用易扩展的欢迎界面.</p>
<h1 id="SPECIALS"><a href="#SPECIALS" class="headerlink" title="SPECIALS"></a>SPECIALS</h1><h2 id="Huge-list-of-useful-resources-for-Android-development"><a href="#Huge-list-of-useful-resources-for-Android-development" class="headerlink" title="Huge list of useful resources for Android development"></a><a href="http://www.anysoftwaretools.com/best-android-development-resources/" target="_blank" rel="external">Huge list of useful resources for Android development</a></h2><p>资源分享, 包括博客论坛Video社区等等.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Wear </tag>
            
            <tag> Annotation </tag>
            
            <tag> Reductor </tag>
            
            <tag> Redux </tag>
            
            <tag> Memory Leak </tag>
            
            <tag> pre-launch </tag>
            
            <tag> Handler </tag>
            
            <tag> RxAndroid </tag>
            
            <tag> Profile </tag>
            
            <tag> Methods Count </tag>
            
            <tag> APK </tag>
            
            <tag> Adapter </tag>
            
            <tag> Intro Screen </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 223]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/09/22/android-weekly-notes-issue-223/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-223"><a href="#Android-Weekly-Issue-223" class="headerlink" title="Android Weekly Issue #223"></a>Android Weekly Issue #223</h1><p>September 18th, 2016<br><a href="http://androidweekly.net/issues/issue-223" target="_blank" rel="external">Android Weekly Issue #223</a></p>
<p>本期内容包括:<br>Offline时间戳处理;  Accessibility的安全问题可能并不是个问题; 如何在单元测试和UI测试之间共享代码; Android中的指纹认证; 编译时间Kotlin vs Java; MVP结合RxJava, 让View来处理生命周期; RxJava2预览; 内存泄露处理; Gradle相关等等.</p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Offline-First-Introducing-TrueTime-for-Android"><a href="#Offline-First-Introducing-TrueTime-for-Android" class="headerlink" title="Offline First: Introducing TrueTime for Android"></a><a href="https://tech.instacart.com/truetime/" target="_blank" rel="external">Offline First: Introducing TrueTime for Android</a></h2><p>TrueTime是一个NTP library for <a href="https://github.com/instacart/truetime.swift" target="_blank" rel="external">Swift</a> and <a href="https://github.com/instacart/truetime-android" target="_blank" rel="external">Android</a>.</p>
<p>其中NTP是Network Time Protocol.</p>
<p>作者他们有一个购物app, 但是时断时续的网络降低了用户体验, 所以他们进行了离线迁移, 准备出一系列文章分享相关的想法和在此过程中学到的东西.</p>
<p>本文是第一篇, 关于时间.</p>
<p>由于在设置里可以设置设备的日期和时间, 所以设备的时间并不一定是真实的时间, 我们在程序里<code>new Date()</code>得到的其实是设备时间.</p>
<p>关于真实时间的计算, 他们开源了TrueTime库, Android和iOS都能用.</p>
<p>TrueTime如何计算真实时间的呢? 它其实是向NTP的server发了请求, 然后计算出的.</p>
<p>文中和库都说明了用法.</p>
<h2 id="Android-Security-and-Accessibility"><a href="#Android-Security-and-Accessibility" class="headerlink" title="Android Security and Accessibility"></a><a href="https://medium.com/@ataulm/a-few-weeks-ago-android-weekly-promoted-a-post-highlighting-a-security-issue-with-the-android-5eae7ff6b8aa#.p25cbw2wl" target="_blank" rel="external">Android Security and Accessibility</a></h2><p>之前有一个<a href="https://android.jlelse.eu/android-accessibility-75fdc5810025#.94tpbl6z2" target="_blank" rel="external">文章</a>说Accessiblity存在安全隐患, 这个服务可能可以访问到一些隐私信息, 比如密码.</p>
<p>但是这篇文章的作者觉得前一篇文章作者的解决方案不是很好.</p>
<p>因为当用户开启Accessibility权限的时候, Android就已经给出了警告, 说明敏感信息可能会被观察到. 第三方的keyboard也可以访问这些信息, Android也是在开启的时候给出了警告.</p>
<p>另外对于前一篇文章作者提出的解决方案: <code>View.IMPORTANT_FOR_ACCESSIBILITY_NO</code><br>这样真正有视觉障碍的那部分用户也无法看到密码, 可能就无法登陆了.</p>
<p>所以本文作者建议的解决方案是, 可以弹一个对话框来提醒用户, 如果用户允许了, 再继续输入.</p>
<h2 id="Sharing-code-between-UI-amp-unit-tests"><a href="#Sharing-code-between-UI-amp-unit-tests" class="headerlink" title="Sharing code between UI &amp; unit tests"></a><a href="http://trickyandroid.com/android-test-tricks-sharing-code-between-unit-ui-tests/" target="_blank" rel="external">Sharing code between UI &amp; unit tests</a></h2><p>Android的测试分两种:</p>
<p>一种是Unit tests. 单元测试, 在JVM上跑.</p>
<p>另一种是UI测试, 需要Android设备.</p>
<p>在Android Studio中对应<code>test</code>和<code>androidTest</code>文件夹.</p>
<p>这两个测试文件夹之间是不共享代码的, 即一个文件夹里不能访问另一个里面的代码.</p>
<p>但是如果我们想要共用一些代码, 是有办法解决的.</p>
<p>首先在app/src下新建一个文件夹, 比如叫<code>testShared</code>. 里面添加要共享的代码.</p>
<p>然后在<code>app/build.gradle</code>里面添加这个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">android.sourceSets &#123;  </div><div class="line">    test &#123;</div><div class="line">        java.srcDirs += &quot;$projectDir/src/testShared&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    androidTest &#123;</div><div class="line">        java.srcDirs += &quot;$projectDir/src/testShared&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就可以在UI测试和单元测试中共享同一份代码了.</p>
<h2 id="Synchronously-Animating-Colors-on-Android"><a href="#Synchronously-Animating-Colors-on-Android" class="headerlink" title="Synchronously Animating Colors on Android"></a><a href="https://kylewbanks.com/blog/animating-toolbar-tablayout-floatingactionbutton-and-statusbar-background-color-on-android" target="_blank" rel="external">Synchronously Animating Colors on Android</a></h2><p>作者想做的一个效果是, 在切换tab的时候, 把<code>Toolbar</code>, <code>TabLayout</code>, <code>FloatingActionButton</code>还有<code>StatusBar</code>的颜色都动画地改变到另一个颜色.</p>
<p>实现很简单, 首先用当前颜色和目标颜色建立一个<code>ValueAnimator</code>, 然后<code>addUpdateListener()</code>在更新的过程中把值set给相应的控件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">colorAnimation.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animator)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> color = (<span class="keyword">int</span>) animator.getAnimatedValue();</div><div class="line"></div><div class="line">        toolbar.setBackgroundColor(color);</div><div class="line">        tabLayout.setBackgroundColor(color);</div><div class="line">        floatingActionButton.setBackgroundTintList(ColorStateList.valueOf(color));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">            getWindow().setStatusBarColor(color);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line">colorAnimation.start();</div></pre></td></tr></table></figure></p>
<p>其中FloatingActionButton要用<code>setBackgroundTintList()</code>.</p>
<p>StatusBar在21及以上才支持<code>getWindow().setStatusBarColor(color);</code></p>
<h2 id="Android-Fingerprint-Authentication"><a href="#Android-Fingerprint-Authentication" class="headerlink" title="Android Fingerprint Authentication"></a><a href="https://medium.com/@aitorvs/android-fingerprint-authentication-44c047179d9a#.3og72boir" target="_blank" rel="external">Android Fingerprint Authentication</a></h2><p>其实用户都不喜欢验证, 因为用户都比较懒, 不喜欢一次又一次地输入密码或者手势pattern, 但是不锁屏又不安全.</p>
<p>指纹验证<a href="https://developer.android.com/about/versions/marshmallow/android-6.0.html#fingerprint-authentication" target="_blank" rel="external">Fingerprint Authentication</a>是Android M (Android 6.0, API 23)引入的. 它就是为了解决这个问题, 提升用户体验. 这种non-disturbing和easy的方式, 让我们不用在安全和用户体验之间做出妥协.</p>
<p>如果你的应用需要做一些关键操作, 比如支付, 你需要用户在操作前授权, 那么指纹验证会很有帮助.</p>
<p>然后作者介绍了实现的细节.</p>
<p>最后作者附上了自己的相关库: <a href="https://github.com/aitorvs/fingerlock" target="_blank" rel="external">fingerlock</a>.</p>
<h2 id="Kotlin-vs-Java-Compilation-Speed"><a href="#Kotlin-vs-Java-Compilation-Speed" class="headerlink" title="Kotlin vs Java: Compilation Speed"></a><a href="https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d#.nep65secf" target="_blank" rel="external">Kotlin vs Java: Compilation Speed</a></h2><p>这是作者关于Kotlin的第三篇文章, 作者在这篇文章里测试了Kotlin和Java的编译时间.</p>
<p><strong>Clean build with No Gradle daemon</strong><br>Java编译比Kotlin快17%.</p>
<p><strong>Clean build + Gradle daemon</strong><br><code>org.gradle.daemon=true</code></p>
<p>Java编译比Kotlin快13%.</p>
<p><strong>Incremental builds</strong><br><code>kotlin.incremental=true</code></p>
<p>在clean build的时候, Java可能快10-15%, 但是在增量build + gradle daemon时, kotlin和Java一样快, 甚至可能比Java更快一些.</p>
<h2 id="Let-the-view-handle-the-lifecycle-in-MVP-by-using-RxJava"><a href="#Let-the-view-handle-the-lifecycle-in-MVP-by-using-RxJava" class="headerlink" title="Let the view handle the lifecycle in MVP by using RxJava"></a><a href="https://medium.com/@ferhatparmak/let-the-view-handle-the-lifecycle-in-mvp-by-using-rxjava-694d67923871#.vt21pzfr0" target="_blank" rel="external">Let the view handle the lifecycle in MVP by using RxJava</a></h2><p>问题:<br>作者举了一个例子, 在Fragment作为View的MVP中, 如果P从service取一些数据, 然后调用View的显示方法, 则还需要知道<code>onViewCreated()</code>是不是已经调用过了.</p>
<p>解决方案:</p>
<p>首先创建一个Lifecycle的BehaviorSubject, 在<code>onViewCreated()</code>的时候调用<code>onNext(null)</code>.</p>
<p>把View的方法改成返回一个Observable, presenter的方法调用View的方法时实际上是subscribe了一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsFragment</span> <span class="keyword">implements</span> <span class="title">ProductsView</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> ProductsPresenter presenter;</div><div class="line">  <span class="comment">//Lifecycle subject. It is BehaviourSubject because it can be subscribed after onViewCreated call.</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BehaviorSubject&lt;Void&gt; onViewCreatedSubject = BehaviorSubject.create();</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Observable&lt;Void&gt; <span class="title">showProducts</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> onViewCreatedSubject. <span class="comment">// Wait for onViewCreated</span></div><div class="line">        doOnNext(<span class="keyword">new</span> Action1&lt;Object&gt;() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="comment">//Updates recyclerview adapter items</span></div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</div><div class="line">    onViewCreatedSubject.onNext(<span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Presenter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsFragmentPresenter</span> <span class="keyword">implements</span> <span class="title">ProductsPresenter</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> ProductsView view;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProducts</span><span class="params">()</span></span>&#123;</div><div class="line">    productsService.getProducts()</div><div class="line">      .flatMap(<span class="keyword">new</span> Func1&lt;Object, Observable&lt;Void&gt;&gt;() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Observable&lt;Void&gt; <span class="title">call</span><span class="params">(List&lt;Product&gt; productList)</span> </span>&#123;</div><div class="line">            <span class="comment">//Return the view's observable to show products. </span></div><div class="line">            <span class="comment">//No need to check if the view is created!</span></div><div class="line">            <span class="keyword">return</span> view.showProducts(productList); </div><div class="line">          &#125;</div><div class="line">        &#125;) </div><div class="line">      .subscribe();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这并不是一个完整的例子, 完整的例子还需要考虑<code>onDestroyView()</code>还有注销等情况的处理.</p>
<h2 id="Nougat-GCM-Network-Manager"><a href="#Nougat-GCM-Network-Manager" class="headerlink" title="Nougat - GCM Network Manager"></a><a href="https://blog.stylingandroid.com/nougat-gcm-network-manager/" target="_blank" rel="external">Nougat - GCM Network Manager</a></h2><p>作者搞了一个message app来研究Android 7的新特性.</p>
<p>他用到了<a href="http://ryanharter.com/blog/2016/03/22/autovalue/" target="_blank" rel="external">AutoValue</a>.</p>
<p>关于Android 7的另一篇文章: <a href="https://commonsware.com/blog/2016/03/09/random-musings-n-developer-preview.html" target="_blank" rel="external">Random Musings on the N Developer Preview</a></p>
<p>他们的应用首先需要周期性地生产一些消息, 关于生产消息的实现, 作者没有用<code>AlarmManager</code>, 也没有用<code>JobScheduler</code>(因为只支持API 21及以上), 而是选用了<code>GCMNetworkManager</code>.</p>
<p>具体实现见原文, 有详细说明.<br>另: <a href="https://github.com/StylingAndroid/Nougat/tree/GCMNetworkManager" target="_blank" rel="external">代码</a></p>
<p>这只是系列文章的第一篇, 后续应该会写更多.</p>
<h2 id="TransactionTooLargeException-crashes-on-Nougat"><a href="#TransactionTooLargeException-crashes-on-Nougat" class="headerlink" title="TransactionTooLargeException crashes on Nougat"></a><a href="http://blog.sqisland.com/2016/09/transactiontoolargeexception-crashes-nougat.html" target="_blank" rel="external">TransactionTooLargeException crashes on Nougat</a></h2><p>作者自己的应用在Activity转换的时候遇到了一个crash: <code>java.lang.RuntimeException: android.os.TransactionTooLargeException: data parcel size 700848 bytes.</code></p>
<p>之前应用里有相关的Warning log, 但是<br>Android 7 Nougat (API 24)把它作为异常抛出来了.</p>
<p>产生这个问题的原因是在<code>onSaveInstanceState()</code>里面存了太多数据. 作者做了一个测试, 想看看这个限制大概是多少, 大概是500K左右. </p>
<p>所以这里是不应该用来存储太多数据的, 应该只存状态.</p>
<p>底下回复说每个进程都有1M的buffer来接收transactions, 但是是在没有任何其他IPC的情况下. 所以建议存储的状态数据少于100K或者50K, 当然越少越好.</p>
<h2 id="Building-a-blazing-fast-ETC2-compressor"><a href="#Building-a-blazing-fast-ETC2-compressor" class="headerlink" title="Building a blazing fast ETC2 compressor"></a><a href="https://medium.com/@duhroach/building-a-blazing-fast-etc2-compressor-307f3e9aad99#.ixumn3e2v" target="_blank" rel="external">Building a blazing fast ETC2 compressor</a></h2><p>作者是Google的, 以前做游戏的, 所以致力于Performances, GPU, 数据压缩等内容.</p>
<p>作者关注VR, 但是VR中要提升体验, 必定会增加图像的大小和质量.</p>
<p><a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression" target="_blank" rel="external">ETC textures</a> 是OpenGLES 3.0的一种标准格式.</p>
<p>编码一个高质量的ETC2 texture会花费很多时间.<br>以在游戏界最流行的压缩工具<a href="http://malideveloper.arm.com/resources/tools/" target="_blank" rel="external">Mali GPU Texture Compression tool</a>为例, 作者做了实验, 证明确实要花费很多时间(平均10分钟)来encode一个图.</p>
<p>所以作者他们开发了一个新的库: <a href="https://github.com/google/etc2comp" target="_blank" rel="external">etc2comp</a>, 一个很快的texture encoder.</p>
<p>然后和之前的工具做了比较, 平均时间提高到了10秒.</p>
<p>后来他说的技术细节我就看不懂了. 文后还有其他图像格式(JPG, PNG, WebP)相关的文章链接.</p>
<h2 id="Low-Coupling-With-Rx-and-Dagger2-in-Android"><a href="#Low-Coupling-With-Rx-and-Dagger2-in-Android" class="headerlink" title="Low Coupling With Rx and Dagger2 in Android"></a><a href="http://www.ottodroid.net/?p=479" target="_blank" rel="external">Low Coupling With Rx and Dagger2 in Android</a></h2><p>作者举例展示Android程序的解耦.</p>
<p>首先, 他展示一个高度耦合的Android程序, 然后加入Rx, 最后加入Dagger2, 从而一步一步地解耦这个项目.</p>
<p>项目的内容是发现Network中的Services. 这里有官方的Training: <a href="https://developer.android.com/training/connect-devices-wirelessly/nsd.html" target="_blank" rel="external">Network Service Discovery</a>.</p>
<h2 id="RxJava2-An-Early-Preview"><a href="#RxJava2-An-Early-Preview" class="headerlink" title="RxJava2: An Early Preview"></a><a href="https://medium.com/@theMikhail/rxjava2-an-early-preview-5b05de46b07#.ftflhi48n" target="_blank" rel="external">RxJava2: An Early Preview</a></h2><p>最近RxJava2有了第一个Release Candidate. 所以作者在这里先预览一下有哪些有趣的更新和新加的功能:</p>
<p><strong>New Dependency</strong>:<br>添加了依赖: <a href="http://www.reactive-streams.org/" target="_blank" rel="external">ReactiveStreams</a>.</p>
<p><strong>Imports</strong>:<br>RxJava2放在了一个不同的package下:</p>
<p>RxJava:</p>
<p><code>compile ‘io.reactivex:rxjava:1.0.y-SNAPSHOT’</code></p>
<p>RxJava2:</p>
<p><code>compile ‘io.reactivex.rxjava2:rxjava:x.y.z’</code></p>
<p>这意味着, 你可以同时用两个版本的库. 如果你要完全迁移的话, 你需要把所有的import都改到新包.</p>
<p><strong>Null Emissions No Longer Permitted</strong>:<br>不允许再发送null值了, 会直接抛出空指针异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="keyword">null</span>); <span class="comment">//don’t do this</span></div><div class="line">subject.onNext(<span class="keyword">null</span>); <span class="comment">//don’t do this either</span></div></pre></td></tr></table></figure>
<p><strong>Under(Back)Pressure</strong>:</p>
<p><code>Backpressure</code>是当<code>Observable</code>发射值的速度比<code>Observer</code>能处理的速度快时发生的.</p>
<p>RxJava2引入了一个新的Observable类<code>Flowable</code>, with backpressure support.</p>
<p><strong>Single Old and New</strong>:<br>订阅一个Single现在可以用这个:<br><code>SingleObserver&lt;T&gt;</code>.</p>
<p><strong>Hit Me Maybe One More Type</strong>:<br>一个新的类型叫<code>Maybe</code>, 它是<code>Single</code>和<code>Completable</code>的混合体. 用来发射0或1个值.</p>
<p><strong>New BackPressured Subject: Processor</strong>:<br>引入了一个新类型, <code>Processor</code>, 它是一个有backpressure support的<code>Subject</code>.</p>
<p><strong>New Names for Function and Action</strong>:</p>
<ul>
<li><code>Func1</code> -&gt; <code>Function</code></li>
<li><code>Func2</code> -&gt; <code>BiFunction</code></li>
<li><code>FuncN</code> -&gt; <code>Function&lt;Object[], R&gt;</code></li>
<li><code>Func1&lt;T, Boolean&gt;</code> -&gt; <code>Predicate&lt;T&gt;</code></li>
<li><code>Action0</code> -&gt; <code>Consumer</code></li>
<li><code>Action1</code> -&gt; <code>BiConsumer</code></li>
<li><code>ActionN</code> -&gt; <code>Consumer&lt;Object[]&gt;</code></li>
</ul>
<p><strong>Subscriber is Now Disposable</strong>:</p>
<p>因为和Reactive-Streams的命名冲突, 所以<code>Subscriber</code>改名为<code>Disposable</code>. 它有一个<code>.dispose()</code>方法, 类似于<code>Subscription</code>的<code>.unsubscribe()</code>方法.</p>
<p><code>onCompleted()</code>也将变为<code>onComplete()</code>.</p>
<p><strong>Composite Subscriptions Changes</strong>:</p>
<p><code>CompositeSubscription</code> + <code>subscribe()</code>-&gt; <code>CompositeDisposable</code> + <code>subscribeWith()</code></p>
<p><strong>Blocking Calls</strong>:<br>RxJava2加了一些新的操作符来变异步为同步.<br><code>.toBlocking.first()</code> -&gt; <code>.blockingFirst()</code></p>
<p><strong>Better Hooks for Plugins</strong>:<br>plugin系统被重写了. 现在你可以覆写内置schedulers返回的值了. 这样你就可以在做单元测试的时候覆写<code>Schedulers.io()</code>来返回同步的值, 甚至debug Schedulers.</p>
<p><strong>Summary</strong></p>
<p>目标Release日期: October 29.</p>
<p>Retrofit已经支持RxJava2了:<br><a href="https://github.com/JakeWharton/retrofit2-rxjava2-adapter" target="_blank" rel="external">retrofit-rxjava2-adapter</a></p>
<p>这里还有一个Library用来把RxJava1转换到RxJava2: <a href="https://github.com/akarnokd/RxJava2Interop" target="_blank" rel="external">RxJava2Interop</a></p>
<p>Sources:<br><a href="http://reactivex.io/RxJava/2.x/javadoc/" target="_blank" rel="external">RxJava 2.x javadoc</a>,<br><a href="https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0" target="_blank" rel="external">Github Wiki: What’s different in 2.0</a>,<br><a href="http://stackoverflow.com/questions/38423079/differences-between-rxjava1-and-rxjava2" target="_blank" rel="external">Stackoverflow</a></p>
<h2 id="Eight-Ways-Your-Android-App-Can-STOP-Leaking-Memory"><a href="#Eight-Ways-Your-Android-App-Can-STOP-Leaking-Memory" class="headerlink" title="Eight Ways Your Android App Can STOP Leaking Memory"></a><a href="http://blog.nimbledroid.com/2016/09/06/stop-memory-leaks.html" target="_blank" rel="external">Eight Ways Your Android App Can STOP Leaking Memory</a></h2><p>之前作者有个文章叫<a href="http://blog.nimbledroid.com/2016/05/23/memory-leaks.html" target="_blank" rel="external">Eight Ways Your Android App Can Leak Memory</a>, 讲的是Android应用中8种内存泄露的原因, 主要是泄露了Activity.</p>
<p>这篇文章主要讲解决方法:</p>
<h3 id="Static-Activities"><a href="#Static-Activities" class="headerlink" title="Static Activities"></a>Static Activities</h3><p>错误原因: 把Activity存在一个静态引用里, Activity生命周期结束后仍然持有.</p>
<p>解决方法:<br>使用<a href="https://developer.android.com/reference/java/lang/ref/WeakReference.html" target="_blank" rel="external">WeakReference</a>.</p>
<h3 id="Static-Views"><a href="#Static-Views" class="headerlink" title="Static Views"></a>Static Views</h3><p>错误原因: 静态引用了View, 因为attached View引用了Activity, 所以等于间接引用了Activity.</p>
<p>解决方法:</p>
<ol>
<li>使用WeakReference;</li>
<li>在onDestroy()里面把引用置为null.</li>
</ol>
<h3 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h3><p>内部类分两种, 静态内部类和非静态内部类: <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="external">Nested Class</a></p>
<p>错误原因: 在Activity里有一个内部类(非静态), 创建内部类的对象, 然后静态引用之. 因为内部类持有外部类的应用, 所以会造成内存泄露.</p>
<p>解决方法:<br>尽量不要存static引用.</p>
<h3 id="匿名内部类-AsyncTask-Handler-Thread-TimerTask"><a href="#匿名内部类-AsyncTask-Handler-Thread-TimerTask" class="headerlink" title="匿名内部类 AsyncTask, Handler, Thread, TimerTask"></a>匿名内部类 AsyncTask, Handler, Thread, TimerTask</h3><p>错误原因:</p>
<p>如果你不在超出生命周期的地方引用它, 匿名内部类的对象是无害的.</p>
<p>但是上面的这些内部类对象全都是用来产生一些线程的, 这些线程是app全局的, 而且会引用创建它们的对象.</p>
<p>解决方法: </p>
<ol>
<li>把上面的这些类改成静态内部类, 静态的内部类对象不会引用外部类的对象.</li>
<li>如果你坚持使用匿名内部类, 可以在Activity的onDestroy()里面终止线程.</li>
</ol>
<h3 id="Sensor-Manager"><a href="#Sensor-Manager" class="headerlink" title="Sensor Manager"></a>Sensor Manager</h3><p>错误原因:</p>
<p>把Activity作为listener注册给了系统服务, 但是在Activity生命周期结束之前没有注销listener.</p>
<p>解决方法: 在生命周期结束前注销listener.</p>
<h2 id="Auto-rename-Android-versionName-in-Gradle"><a href="#Auto-rename-Android-versionName-in-Gradle" class="headerlink" title="Auto rename Android versionName in Gradle"></a><a href="https://medium.com/@jagonzalez.develop/auto-rename-android-versionname-by-creating-custom-gradle-plugin-2922bbaaaed6#.cds2wvd05" target="_blank" rel="external">Auto rename Android versionName in Gradle</a></h2><p>在应用release的时候, 版本号是确定的, 这没问题. 在应用开发的时候, 如果每一个apk也有一个特定的版本号, 将会非常有帮助.</p>
<p><strong>自定义Gradle Plugin</strong>:<br><code>com.android.application</code>就是一个gradle plugin.</p>
<p>有三种方式可以创建gradle plugin: <a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:packaging_a_plugin" target="_blank" rel="external">doc</a>.</p>
<p>本文作者选择了<code>buildSrc</code>的方式, 因为这很容易, 而且可以被加到repo里, 但是这样将依附于你的project, 不能复用.</p>
<p>具体代码见原文.</p>
<p>这么做了之后, 每一次build的apk都自带了分支信息, Jira卡号, 或者任何你想带的信息.</p>
<h2 id="Is-your-custom-view-interactive-aware"><a href="#Is-your-custom-view-interactive-aware" class="headerlink" title="Is your custom view interactive aware?"></a><a href="https://renaudcerrato.github.io/2016/09/15/is-your-custom-view-interactive-aware/" target="_blank" rel="external">Is your custom view interactive aware?</a></h2><p>什么是<strong>Interactive View</strong>?<br>当View是可见的, 即可以和用户交互, 即为interactive.</p>
<p>当你的自定义View做一些很重的工作, 比如循环的动画或者loading, 或者依赖于传感器, 当这种View变为不可见时,你需要做一些工作来节约电量.</p>
<p>作者写了一个辅助类: <a href="https://gist.github.com/renaudcerrato/746e039700ac5eeaaea40808666e239f" target="_blank" rel="external">InteractiveViewHelper</a> 来做这个.</p>
<p>具体利用了View的这几个回调:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> View::onVisibilityChanged(View, <span class="keyword">int</span>)</div><div class="line"><span class="keyword">void</span> View::onWindowVisibilityChanged()</div><div class="line"><span class="keyword">void</span> View::onAttachedToWindow()</div><div class="line"><span class="keyword">void</span> View::onDetachedFromWindow()</div></pre></td></tr></table></figure></p>
<p>还有两个ACTION:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent.ACTION_SCREEN_ON</div><div class="line">Intent.ACTION_SCREEN_OFF</div></pre></td></tr></table></figure></p>
<h2 id="Beta-Testing-Your-Android-App-With-Build-Variants"><a href="#Beta-Testing-Your-Android-App-With-Build-Variants" class="headerlink" title="Beta Testing Your Android App With Build Variants"></a><a href="http://chikemgbemena.com/2016/09/16/beta-testing-your-app-with-build-variants/" target="_blank" rel="external">Beta Testing Your Android App With Build Variants</a></h2><p>讲了如何用Build Variants, 添加不同的Flavors.</p>
<h2 id="Make-your-build-gradle-great-again"><a href="#Make-your-build-gradle-great-again" class="headerlink" title="Make your build.gradle great again"></a><a href="https://medium.com/@sergii/make-your-build-gradle-great-again-c84cc172a654#.y66yudcxc" target="_blank" rel="external">Make your build.gradle great again</a></h2><h3 id="1-把你的build-gradle分成小份-更加模块化-用apply应用"><a href="#1-把你的build-gradle分成小份-更加模块化-用apply应用" class="headerlink" title="1. 把你的build.gradle分成小份, 更加模块化, 用apply应用."></a>1. 把你的build.gradle分成小份, 更加模块化, 用<code>apply</code>应用.</h3><h3 id="2-在build-file里指明application-id"><a href="#2-在build-file里指明application-id" class="headerlink" title="2. 在build file里指明application id."></a>2. 在build file里指明application id.</h3><p>applicationId是apk最终会用的包名.<br>packageName是用来找代码中的R, 和activity/service组件的相对路径.<br>如果不在build文件里指明applicationId可能会有一些问题.</p>
<h3 id="3-给debug版使用一个不同的applicationId"><a href="#3-给debug版使用一个不同的applicationId" class="headerlink" title="3. 给debug版使用一个不同的applicationId."></a>3. 给debug版使用一个不同的applicationId.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;    </div><div class="line">    debug &#123;</div><div class="line">        applicationIdSuffix &quot;.debug&quot;</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处是同一个机器上可以同时安装debug和release版.</p>
<h3 id="4-统计build时间"><a href="#4-统计build时间" class="headerlink" title="4. 统计build时间."></a>4. 统计build时间.</h3><p>用–profile命令. 或<a href="https://scans.gradle.com/get-started?type=project" target="_blank" rel="external">Build Scans</a></p>
<p>还可以用<a href="https://github.com/passy/build-time-tracker-plugin" target="_blank" rel="external">build-time-tracker-plugin</a></p>
<h3 id="5-配置release"><a href="#5-配置release" class="headerlink" title="5. 配置release."></a>5. 配置release.</h3><p>Proguard在Java层面工作, 对于资源是不管的, 只把R中的id删了.<br>如果想进一步处理不用的资源, 需要加:<br><code>shrinkResources true</code>.</p>
<p>更深一步的居然还可以拆分apk: <a href="https://developer.android.com/studio/build/configure-apk-splits.html" target="_blank" rel="external">config-apk-splits</a></p>
<h3 id="6-发现一些有用的tasks-或者自己开发-Reddit-page"><a href="#6-发现一些有用的tasks-或者自己开发-Reddit-page" class="headerlink" title="6. 发现一些有用的tasks, 或者自己开发. Reddit page."></a>6. 发现一些有用的tasks, 或者自己开发. <a href="https://www.reddit.com/r/androiddev/comments/3ig3gm/show_us_your_gradle_tasks" target="_blank" rel="external">Reddit page</a>.</h3><h3 id="7-把依赖的版本号抽出来"><a href="#7-把依赖的版本号抽出来" class="headerlink" title="7. 把依赖的版本号抽出来."></a>7. 把依赖的版本号抽出来.</h3><h3 id="8-使用jcenter-响应更快"><a href="#8-使用jcenter-响应更快" class="headerlink" title="8. 使用jcenter, 响应更快."></a>8. 使用jcenter, 响应更快.</h3><h3 id="9-在开发时把最小sdk设为21或以上-会build得更快"><a href="#9-在开发时把最小sdk设为21或以上-会build得更快" class="headerlink" title="9. 在开发时把最小sdk设为21或以上, 会build得更快."></a>9. 在开发时把最小sdk设为21或以上, 会build得更快.</h3><h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="Android-Amazing-Open-Source-Apps"><a href="#Android-Amazing-Open-Source-Apps" class="headerlink" title="Android Amazing Open Source Apps"></a><a href="https://medium.com/@amitshekhar/android-amazing-open-source-apps-e44f520593cc" target="_blank" rel="external">Android Amazing Open Source Apps</a></h2><p>这篇文章列举了一些好的开源app.<br>包括<a href="https://github.com/google/iosched" target="_blank" rel="external">google/iosched</a>, <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>, <a href="https://github.com/DrKLO/Telegram" target="_blank" rel="external">Telegram</a>, <a href="https://github.com/nickbutcher/plaid" target="_blank" rel="external">Plaid</a>, <a href="https://github.com/wireapp/wire-android" target="_blank" rel="external">wire-android</a>, <a href="https://github.com/ribot/ribot-app-android" target="_blank" rel="external">ribot/ribot-app-android</a>, <a href="https://github.com/pockethub/PocketHub" target="_blank" rel="external">PocketHub</a>.</p>
<h2 id="DoorSignView"><a href="#DoorSignView" class="headerlink" title="DoorSignView"></a><a href="https://github.com/renaudcerrato/DoorSignView" target="_blank" rel="external">DoorSignView</a></h2><p>一个自定义View, 显示门牌. AnimatedDoorSignView可以根据传感器进行动画.</p>
<h2 id="Java-Error-Handler"><a href="#Java-Error-Handler" class="headerlink" title="Java Error Handler"></a><a href="https://github.com/Workable/java-error-handler/" target="_blank" rel="external">Java Error Handler</a></h2><p>一个统一的错误处理器. 为每一种错误建立全局默认的处理方式.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Gradle </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> Accessibility </tag>
            
            <tag> Nougat </tag>
            
            <tag> Test </tag>
            
            <tag> Fingerprint </tag>
            
            <tag> RxJava2 </tag>
            
            <tag> GCM </tag>
            
            <tag> Memory Leak </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 222]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/09/15/android-weekly-notes-issue-222/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-222"><a href="#Android-Weekly-Issue-222" class="headerlink" title="Android Weekly Issue #222"></a>Android Weekly Issue #222</h1><p>September 11th, 2016<br><a href="http://androidweekly.net/issues/issue-222" target="_blank" rel="external">Android Weekly Issue #222</a></p>
<a id="more"></a>
<h1 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h1><h2 id="Forcing-bytes-download-in-Okio"><a href="#Forcing-bytes-download-in-Okio" class="headerlink" title="Forcing bytes download in Okio"></a><a href="http://jakewharton.com/forcing-bytes-downward-in-okio/" target="_blank" rel="external">Forcing bytes download in Okio</a></h2><p>这是Jake Wharton的文章, 关于Okio的<code>BufferedSink</code>.</p>
<p><a href="https://github.com/square/okio" target="_blank" rel="external">okio</a> 是一个java io库, 包装了一套API用来读写和处理数据. 文档见: <a href="http://square.github.io/okio/1.x/okio/" target="_blank" rel="external">okio doc</a>.</p>
<p>很多库都是在其之上写的, 比如okhttp, Retrofit, Moshi. 这里有个视频: <a href="http://jakewharton.com/a-few-ok-libraries/" target="_blank" rel="external">A Few OK libraries</a></p>
<p>有三个方法可以强制把bytes放入底层的<code>Sink</code>.</p>
<h3 id="flush-emit-and-emitCompleteSegments"><a href="#flush-emit-and-emitCompleteSegments" class="headerlink" title="flush(), emit() and emitCompleteSegments()"></a>flush(), emit() and emitCompleteSegments()</h3><p><code>flush()</code></p>
<p>调用这个方法会使得所有缓存的字节移动到Sink, 然后Sink立即flush自己. 所以调用<code>flush()</code>方法返回后, 你可以保证所有的字节都到了目的地Sink.</p>
<p>当用多级buffer时, <code>flush()</code>会清除所有level的buffer. Okio中多级buffer的花销很小, 一个flush会让每一级把自己的segments移到下一级.</p>
<p>java io中的多级buffer每一级都自己管理自己的字节, 所以flush操作会让每一级都拷贝数据到下一级.</p>
<p>流类型的<code>close()</code>和<code>flush()</code>的行为类似, 在关闭流之前把所有的字节都写了.</p>
<p><code>emit()</code></p>
<p>发射字节的行为和flush类似, 但是不是递归的. 调用<code>emit()</code>会使得所有缓存的字节移动到Sink, 但是与<code>flush()</code>不同, 此时Sink并不会做其他的操作.</p>
<p><code>emitCompleteSegments()</code></p>
<p>调用这个<code>emitCompleteSegments()</code>方法仅仅移动那些完整<code>segment</code>的字节移动到Sink.</p>
<p><code>segment</code>是okio的一个概念.</p>
<p>原文中有动图图解, 看起来更清楚一些.</p>
<h3 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases"></a>Use cases</h3><p>Writing messages to a WebSocket -&gt; <code>flush()</code></p>
<p>Encoding a video to a file -&gt; <code>emitCompleteSegments()</code> + <code>emit()</code>/<code>flush()</code> at the end</p>
<p>Serializing an object to JSON -&gt; <code>emit()</code></p>
<h2 id="Using-Android-Studio’s-Performance-Monitors"><a href="#Using-Android-Studio’s-Performance-Monitors" class="headerlink" title="Using Android Studio’s Performance Monitors"></a><a href="https://medium.com/@andreworobator/debugging-without-a-stacktrace-using-android-studios-performance-monitors-a0d601afd814#.wnqu72q21" target="_blank" rel="external">Using Android Studio’s Performance Monitors</a></h2><p>作者他的音乐应用遇到了不响应的问题, 然后他打开Android Studio的performance monitor看到了是内存问题, 然后他track了一下出问题的时候的memory allocation, 最后发现是有一张要下载的图太大了.</p>
<h2 id="The-hidden-cost-of-code-coverage"><a href="#The-hidden-cost-of-code-coverage" class="headerlink" title="The hidden cost of code coverage"></a><a href="http://jeroenmols.com/blog/2016/09/01/coveragecost/" target="_blank" rel="external">The hidden cost of code coverage</a></h2><p>测试覆盖率是一个很好的方法来激励你和你的团队多写一些测试, 但是你知道吗, 打开测试覆盖率的检测会让你的build变慢.</p>
<p>要测量build时间:</p>
<p><code>./gradlew clean assembleDebug --profile</code></p>
<p>然后作者发现其中<code>:app:transformClassesWithJacocoForDailyDebug</code>占用的时间达到了build时间的14%.</p>
<p>就是因为这句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">    debug &#123;</div><div class="line">        ...</div><div class="line">        testCoverageEnabled true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解决办法</strong><br>只在需要测试覆盖率的时候用它, 所以加一个变量:<br><code>/gradlew -Pcoverage clean connectedDebugAndroidTest</code></p>
<p>gradle里这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">    debug &#123;</div><div class="line">        ...</div><div class="line">        testCoverageEnabled (project.hasProperty(&apos;coverage&apos;) ? true : false)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当你不加这个flag的时候就不会检查测试覆盖率.</p>
<h2 id="Android-Development-Useful-Tools"><a href="#Android-Development-Useful-Tools" class="headerlink" title="Android Development Useful Tools"></a><a href="https://medium.freecodecamp.com/android-development-useful-tools-fd73283e82e3#.ru47kg8kt" target="_blank" rel="external">Android Development Useful Tools</a></h2><p><a href="http://www.methodscount.com/" target="_blank" rel="external">methodscount</a> 可以统计library的方法数, 因为Android有64k的方法数限制.</p>
<p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho</a><br>可以看网络请求, 数据库, shared preferences等.</p>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a> 检测内存泄露的库.</p>
<p><a href="http://inloop.github.io/apk-method-count/" target="_blank" rel="external">apk-method-count</a> 这个网站可以检测apk中的方法数, 根据包分别显示.</p>
<p><a href="http://romannurik.github.io/AndroidAssetStudio/" target="_blank" rel="external">Android Asset Studio</a><br>生成图片, 9-patch等的一系列工具.</p>
<p><a href="https://buckbuild.com/" target="_blank" rel="external">Buck</a> Facebook开发的一套build系统.</p>
<p><a href="http://gradleplease.appspot.com/" target="_blank" rel="external">Gradle, please</a> 输入你要的库, 然后就可以找到对应的dependencies里应该写的 compile xxx.</p>
<p><a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">Proguard</a>或<a href="https://www.guardsquare.com/dexguard" target="_blank" rel="external">DexGuard</a></p>
<p><a href="https://www.genymotion.com/" target="_blank" rel="external">Genymotion</a></p>
<p><a href="https://materialdesignicons.com/" target="_blank" rel="external">Material Design Icons</a></p>
<h2 id="Introduction-to-Automated-Android-Testing-Part-6"><a href="#Introduction-to-Automated-Android-Testing-Part-6" class="headerlink" title="Introduction to Automated Android Testing - Part 6"></a><a href="https://riggaroo.co.za/introduction-automated-android-testing-part-6/" target="_blank" rel="external">Introduction to Automated Android Testing - Part 6</a></h2><p>系列文章的最后一篇, 作者讲用Espresso写UI测试.</p>
<p>如果数据是动态的, 那么要测试View包含指定的信息是很难的. 数据有可能变化, 但是我们的测试不能因此而失败. 所以为了测试可靠和可重复, 我们不应该调用production的API.</p>
<p>所以第一步是mock API, 有几种方法:</p>
<ul>
<li><ol>
<li>用<a href="http://wiremock.org/" target="_blank" rel="external">WireMock</a> (需要server).</li>
</ol>
</li>
<li><ol>
<li>用OkHttp的<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">MockWebServer</a>, 在你的设备上跑一个webserver.</li>
</ol>
</li>
<li><ol>
<li>创建一个Retrofit REST接口, 返回一些dummy对象.</li>
</ol>
</li>
</ul>
<p>Mock数据的时候利用了Gradle的flavor, 可以创建一个mockDebug flavor, 然后在src目录下建一个mock目录, 放一些mock的代码进去, 然后再建一个prod目录, 把真实的实现移动到那里去.</p>
<h3 id="Espresso基础"><a href="#Espresso基础" class="headerlink" title="Espresso基础"></a>Espresso基础</h3><p>用<a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="external">Espresso</a>写测试, 基本格式是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">onView(withId(R.id.menu_search))      <span class="comment">// withId(R.id.menu_search) is a ViewMatcher</span></div><div class="line">  .perform(click())               <span class="comment">// click() is a ViewAction</span></div><div class="line">  .check(matches(isDisplayed())); <span class="comment">// matches(isDisplayed()) is a ViewAssertion</span></div></pre></td></tr></table></figure></p>
<p><code>ViewMatchers</code> 是用来定位View的 有withId, withText, withTag等.</p>
<p><code>ViewActions</code> 是用来跟View交互的, 比如点击, 输入等.</p>
<p><code>ViewAssertations</code> 是用来做出断言的.</p>
<p>这里有个cheat-sheet可以查: <a href="https://google.github.io/android-testing-support-library/downloads/espresso-cheat-sheet-2.1.0.pdf" target="_blank" rel="external">android-expresso-testing.pdf</a></p>
<h3 id="Writing-Espresso-UI-Tests"><a href="#Writing-Espresso-UI-Tests" class="headerlink" title="Writing Espresso UI Tests"></a>Writing Espresso UI Tests</h3><p>这部分具体讲了作者例子的UI测试写法, 见原文.<br>最后作者还看了一下测试覆盖率.</p>
<h2 id="What-2-years-of-Android-Development-Have-Taught-Me"><a href="#What-2-years-of-Android-Development-Have-Taught-Me" class="headerlink" title="What 2 years of Android Development Have Taught Me"></a><a href="https://blog.aritraroy.in/what-my-2-years-of-android-development-have-taught-me-the-hard-way-52b495ba5c51#.ur0ez1ouq" target="_blank" rel="external">What 2 years of Android Development Have Taught Me</a></h2><p>作者讲了他两年来的心路历程, 以及他总结的一些To do和Not to do.</p>
<ol>
<li><p>不要重复造轮子.<br>可以用<a href="https://android-arsenal.com/" target="_blank" rel="external">android-arsenal</a>来查库.</p>
</li>
<li><p>明智地选择库.<br>选择库的时候看看星多不多, 作者有没有什么其他流行的库. 再看看issues, 有时间的话可以看代码.<br><a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="external">Dryrun</a>可以用来跑sample.</p>
</li>
<li><p>坐下来看代码. 我们应该花费多数的时间阅读别人的代码, 而不是写自己的代码.<br>你能写出来的代码是你已经知道的东西的一个反映, 要不断成长和提高自己, 只能不断阅读和学习别人的代码.<br>这里有<a href="https://snowdream.github.io/awesome-android/" target="_blank" rel="external">Library列表</a>和<a href="https://github.com/pcqpcq/open-source-android-apps" target="_blank" rel="external">app列表</a>.</p>
</li>
<li><p>保持一个好的代码风格. 这里有一些参考: <a href="https://source.android.com/source/code-style.html" target="_blank" rel="external">code-style</a>, <a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="external">android-guidelines</a>.</p>
</li>
<li><p>用Proguard, 这样release版本不但缩小了代码也做了混淆. 这里还有一个<a href="https://www.guardsquare.com/dexguard" target="_blank" rel="external">DexGuard</a>.</p>
</li>
<li><p>使用一个合理的架构. 可以用MVP来解耦, 这里有个demo: <a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">Android-CleanArchitecture</a>, 这里是它相关的Guide文章: <a href="https://medium.com/@dmilicic/a-detailed-guide-on-developing-android-apps-using-the-clean-architecture-pattern-d38d71e94029#.j970cogwt" target="_blank" rel="external">Guide on Clean Architecture</a>.<br>更多资源:<br><a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">androidmvp</a>,<br><a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>,<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a>.</p>
</li>
<li><p>对于独立工作的开发, 还需要注意一些UI/UX相关的原则. 可以上<a href="https://dribbble.com/" target="_blank" rel="external">Dribble</a>和<a href="https://material.uplabs.com/" target="_blank" rel="external">MaterialUp</a>多看看.</p>
</li>
<li><p>分析是你的好朋友. 分析包括了crash报告和app使用记录, 可以用<a href="https://firebase.google.com/" target="_blank" rel="external">Firebase</a>.</p>
</li>
<li><p>做一个市场忍者. 对于独立开发者来说, 需要marketing. 这是一个市场分析工具: <a href="https://sensortower.com/#" target="_blank" rel="external">sensor tower</a>.</p>
</li>
<li><p>优化你的App. 推荐检查内存泄露的工具: <a href="https://github.com/square/leakcanary" target="_blank" rel="external">leakcanary</a>.</p>
</li>
<li><p>优化gradle的build时间. 这里有两个Guides: <a href="https://medium.com/@cesarmcferreira/speeding-up-gradle-builds-619c442113cb#.6ezl2rgec" target="_blank" rel="external">speeding up gradle build</a>, <a href="http://zeroturnaround.com/rebellabs/making-gradle-builds-faster/" target="_blank" rel="external">making gradle builds faster</a></p>
</li>
<li><p>多做测试. 发布前花时间测试, 不要急.</p>
</li>
<li><p>兼顾多种机型, 包括屏幕尺寸, API level, 不同厂商的OS等.</p>
</li>
<li><p>用Git. 这是一个<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">Git branch model</a>. 如果你不能负担github上的private repo, 你可以试试<a href="https://bitbucket.org/" target="_blank" rel="external">BitBucket</a></p>
</li>
<li><p>让黑客觉得难处理. Android很容易被攻击, app可以被轻易地反编译和分析. 你需要知道如何处理你的API keys, 如果你需要处理用户的敏感信息, 你应该知道如何加密. 秘钥也要妥善存储. 任何存储在数据库中的敏感信息也都要加密. 相关的资料可以看<a href="https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app" target="_blank" rel="external">Adding Tampering Detection to Your app</a>和<a href="https://rammic.github.io/2015/07/28/hiding-secrets-in-android-apps/" target="_blank" rel="external">Hiding Secrets in Android Apps</a>.</p>
</li>
<li><p>在低级设备上开发. 低级的设备容易暴露问题.</p>
</li>
<li><p>学习设计模式. 这里有一个repo讲了所有的Java中的设计模式: <a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">java-design-patterns</a>. 另外还推荐书籍: GoF的设计模式, Martin Fowler的重构, Joshua Bloch的Effective Java.</p>
</li>
<li><p>贡献自己的力量. StackOverflow, Github, blog posts…</p>
</li>
</ol>
<h2 id="Android-Support-Annotations"><a href="#Android-Support-Annotations" class="headerlink" title="Android Support Annotations"></a><a href="http://mayojava.github.io/android/android-support-annotations/" target="_blank" rel="external">Android Support Annotations</a></h2><p>使用Annotation library:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:support-annotations:&lt;latest-library-version&gt;&apos;</div></pre></td></tr></table></figure>
<p>如果你已经用了<code>appcompat library</code>, 你就已经可以用annotations了, 因为appcompat自己就用了它.</p>
<p>annotations按照用法和功能来分组:</p>
<ul>
<li>Nullness Annotations</li>
<li>Resource Annotations</li>
<li>Thread Annotations</li>
<li>Value Constraints Annotations</li>
<li>Others : Permissions Annotations, CheckResults Annotations and CallSuper Annotations.</li>
</ul>
<h3 id="Nullness-Annotations"><a href="#Nullness-Annotations" class="headerlink" title="Nullness Annotations"></a>Nullness Annotations</h3><p><code>@Nullalbe</code>和<code>@NonNull</code>用来检查变量, 参数和方法返回值为null与否.</p>
<p><code>@NonNull</code>表示变量, 参数或返回值不能为null, 如果为null了编译器会给出警告.</p>
<p><code>@Nullalbe</code>表示可能为null, 用这个注解的时候表示代码中应该加上null check.</p>
<h3 id="Resource-Annotations"><a href="#Resource-Annotations" class="headerlink" title="Resource Annotations"></a>Resource Annotations</h3><p>因为资源号都是int值, 所以如果你把一个drawable的int传给一个期待string resource的代码, 编译器是会接受的.<br>资源注解就是用来做这种情况的类型检查的.</p>
<p>比如用<code>@StringRes</code>来标记参数, 如果你传入一个drawable的id, IDE就会把它标记出来.</p>
<p>每一个Android的资源类型都有一个对应的资源注解, 比如类型是<code>Foo</code>, 那么对应的资源类型注解就是<code>FooRes</code>.</p>
<p>有一个特殊的<code>@AnyRes</code>, 用来表示任意的资源类型.</p>
<h3 id="Thread-Annotations"><a href="#Thread-Annotations" class="headerlink" title="Thread Annotations"></a>Thread Annotations</h3><p>这种注解用来检查方法是不是在特定的线程调用的. 有:</p>
<ul>
<li><code>@UiThread</code></li>
<li><code>@MainThread</code></li>
<li><code>@WorkerThread</code></li>
<li><code>@BinderThread</code></li>
</ul>
<p><code>@UiThread</code>和<code>@MainThread</code>是可互换的.</p>
<p>如果一个类中的所有方法都是从同样的线程调用搞得, 那么可以直接把类给标记了.</p>
<h3 id="Value-Constraints-Annotations"><a href="#Value-Constraints-Annotations" class="headerlink" title="Value Constraints Annotations"></a>Value Constraints Annotations</h3><p><code>@IntRange</code>, <code>@FloatRange</code>和<code>@Size</code>注解是用来验证参数的值的. 比如<code>@IntRange</code>就验证参数是在一个给定的int范围之内.<br>比如下面的方法确保传入的参数是0到255:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@IntRange(from=<span class="number">0</span>, to=<span class="number">255</span>)</span> <span class="keyword">int</span> alpha) </span>&#123;</div><div class="line">    <span class="comment">//set alpha</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相应的<code>@FloatRange</code>检查参数是在一个指定范围内的浮点数.</p>
<p><code>@Size</code>注解是用来检查集合的大小, 还有字符串的长度. 比如<code>@Size(min=1)</code>用来检查集合不为空, <code>@Size(2)</code>检查集合有两个元素.</p>
<h3 id="CheckResult-Annotations"><a href="#CheckResult-Annotations" class="headerlink" title="CheckResult Annotations"></a>CheckResult Annotations</h3><p>这个注解是用来检查一个方法的返回值确实被使用了.<br>一个比较好的例子是<code>String.trim</code>方法, 当这个方法被<code>@CheckResult</code>标注, 如果它的返回值没有被使用, IDE就会报错.</p>
<p>另外一些比较值得看的注解有<code>@CallSuper</code>, <code>@Keep</code>和<code>@RequiresPermission</code>.<br>可以直接查看support annotations的<a href="https://developer.android.com/reference/android/support/annotation/package-summary.html" target="_blank" rel="external">reference</a>.</p>
<p>其他参考资料:</p>
<p><a href="https://developer.android.com/studio/write/annotations.html#adding-nullness" target="_blank" rel="external">Improve code Inspection with Annotations</a></p>
<p><a href="http://tools.android.com/tech-docs/support-annotations" target="_blank" rel="external">Support Annotation documentation</a></p>
<p><a href="http://michaelevans.org/blog/2015/07/14/improving-your-code-with-android-support-annotations/" target="_blank" rel="external">Improving your code with android support annotations</a></p>
<h2 id="ActivityTestRule-Espresso’s-Test-“Lifecycle”"><a href="#ActivityTestRule-Espresso’s-Test-“Lifecycle”" class="headerlink" title="ActivityTestRule: Espresso’s Test “Lifecycle”"></a><a href="https://jabknowsnothing.wordpress.com/2015/11/05/activitytestrule-espressos-test-lifecycle/" target="_blank" rel="external">ActivityTestRule: Espresso’s Test “Lifecycle”</a></h2><p>作者这篇文章的目的是讲讲用Espresso的<code>ActivityTestRule</code>写的测试中的操作顺序, 讨论像<code>beforeActivityLaunched()</code>, <code>afterActivityLaunched()</code>, 和 <code>afterActivityFinished()</code>这些方法相对于测试和Activity的生命周期都是什么时候被调用的. </p>
<p>首先作者介绍了Espresso 2.0及之前的旧的<code>ActivityInstrumentationTestCase2</code>.</p>
<h3 id="ActivityTestRule的”生命周期”"><a href="#ActivityTestRule的”生命周期”" class="headerlink" title="ActivityTestRule的”生命周期”."></a><code>ActivityTestRule</code>的”生命周期”.</h3><p>新的写法是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</div><div class="line"><span class="keyword">public</span> MyNewTest &#123;</div><div class="line">  <span class="meta">@Rule</span></div><div class="line">  <span class="keyword">public</span> MyCustomRule&lt;MyActivity&gt; testRule = <span class="keyword">new</span> MyCustomRule&lt;&gt;(MyActivity.class);</div><div class="line">  </div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStuff</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Wow where's all the boilerplate code?</span></div><div class="line">    </div><div class="line">    <span class="comment">// Verify Oscar Grouch is no longer grouchy.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而其中的MyCustomRule:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomRule</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">MyActivity</span>&gt; <span class="keyword">extends</span> <span class="title">ActivityTestRule</span>&lt;<span class="title">A</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyCustomRule</span><span class="params">(Class&lt;A&gt; activityClass)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(activityClass);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeActivityLaunched</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.beforeActivityLaunched();</div><div class="line">    <span class="comment">// Maybe prepare some mock service calls</span></div><div class="line">    <span class="comment">// Maybe override some depency injection modules with mocks</span></div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> Intent <span class="title">getActivityIntent</span><span class="params">()</span> </span>&#123;</div><div class="line">    Intent customIntent = <span class="keyword">new</span> Intent();</div><div class="line">    <span class="comment">// add some custom extras and stuff</span></div><div class="line">    <span class="keyword">return</span> customIntent;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterActivityLaunched</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.afterActivityLaunched();</div><div class="line">   <span class="comment">// maybe you want to do something here </span></div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterActivityFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.afterActivityFinshed();</div><div class="line">    <span class="comment">// Clean up mocks</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ActivityTestRule-launchActivity-false"><a href="#ActivityTestRule-launchActivity-false" class="headerlink" title="ActivityTestRule: launchActivity=false;"></a><code>ActivityTestRule</code>: launchActivity=false;</h3><p><code>ActivityTestRule</code>的第三个参数允许开发者明确指定对每一个test case启动一个Activity.</p>
<p><code>public ActivityTestRule(Class activityClass, boolean initialTouchMode, boolean launchActivity)</code>.</p>
<p>把第三个参数设置为false, 就可以写出这样的测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleIntentsTest</span> </span>&#123;</div><div class="line">  <span class="meta">@Rule</span></div><div class="line">  <span class="keyword">public</span> ActivityTestRule&lt;MyActivity&gt; testRule = <span class="keyword">new</span> ActivityTestRule&lt;&gt;(MyActivity.class,</div><div class="line">          <span class="keyword">false</span>,    <span class="comment">// initialTouchMode</span></div><div class="line">          <span class="keyword">false</span>);  <span class="comment">// launchActivity. False to set intent per test);</span></div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOscarGrouchy</span><span class="params">()</span> </span>&#123;</div><div class="line">    Intent grouchyIntent = <span class="keyword">new</span> Intent();</div><div class="line">    <span class="comment">// intent stuff</span></div><div class="line">    grouchyIntent.putExtra(<span class="string">"EXTRA_IS_GROUCHY"</span>, <span class="keyword">true</span>);</div><div class="line">    testRule.launchActivity(grouchyIntent);</div><div class="line">    <span class="comment">// verify Oscar is grouchy</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOscarNotGrouchy</span><span class="params">()</span> </span>&#123;</div><div class="line">    Intent happyIntent = <span class="keyword">new</span> Intent();</div><div class="line">    <span class="comment">// intent stuff</span></div><div class="line">    happyIntent.putExtra(<span class="string">"EXTRA_IS_GROUCHY"</span>, <span class="keyword">false</span>);</div><div class="line">    testRule.launchActivity(happyIntent);</div><div class="line">    <span class="comment">// verify Oscar is not grouchy</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个lauchActivity的值默认是为true. 设置为false之后我们在每一个test case里面自己启动activity. 对生命周期产生的影响作者也做了图对比分析, 见原文.</p>
<p>作者最后还讲了几个点, 关于测试迁移, 以及Activity的生命周期方法中启动Intent相关的需要注意的地方.</p>
<h2 id="People-and-resources-to-learn-Android-programming-from"><a href="#People-and-resources-to-learn-Android-programming-from" class="headerlink" title="People and resources to learn Android programming from"></a><a href="https://m.signalvnoise.com/my-favorite-people-and-resources-to-learn-android-programming-from-293f249e2b4e#.6j6qqirem" target="_blank" rel="external">People and resources to learn Android programming from</a></h2><p>作者分享了关于Android编程学习中他积累的人和资源.</p>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><p><a href="https://twitter.com/chiuki" target="_blank" rel="external">Chiu-Ki Chan</a></p>
<p><a href="https://twitter.com/donnfelker" target="_blank" rel="external">Donn Felker</a>, 他的博客: <a href="http://www.donnfelker.com/" target="_blank" rel="external">blog</a>. 他和<a href="https://twitter.com/kaushikgopal" target="_blank" rel="external">Kaushik Gopal</a>一起弄了<a href="http://fragmentedpodcast.com/" target="_blank" rel="external">Fragmented Podcast</a>. 这里还有一个视频教程的网站: <a href="https://caster.io/" target="_blank" rel="external">Caster.io</a>.</p>
<p><a href="https://twitter.com/JakeWharton" target="_blank" rel="external">Jake Wharton</a>, 这个大家都知道啦, 这是他的博客: <a href="http://jakewharton.com/" target="_blank" rel="external">blog</a>.</p>
<p><a href="https://twitter.com/kristinmars" target="_blank" rel="external">Kristin V Marsicano</a>, 这里有一个她的关于Activity生命周期的演讲<a href="https://realm.io/news/activities-in-the-wild-exploring-the-activity-lifecycle-android/" target="_blank" rel="external">Activities in the Wild</a>, 可能有一些你没有想过的东西.</p>
<p><a href="https://twitter.com/rharter" target="_blank" rel="external">Ryan Harter</a></p>
<p><a href="https://twitter.com/ThePracticalDev" target="_blank" rel="external">The Practical Dev</a></p>
<p>最后这有一个列表: <a href="https://twitter.com/dankim/lists/androids" target="_blank" rel="external">Tweet Android List</a></p>
<h3 id="Podcasts"><a href="#Podcasts" class="headerlink" title="Podcasts"></a>Podcasts</h3><p><a href="http://fragmentedpodcast.com/" target="_blank" rel="external">Fragmented</a> 两个独立开发者办的.</p>
<p><a href="http://androidbackstage.blogspot.hk/" target="_blank" rel="external">Android Developers Backstage</a> 写Android的那些人办的.</p>
<p><a href="https://www.relay.fm/material" target="_blank" rel="external">Material</a> 这不是一个技术广播, 讲一些Google新闻.</p>
<h3 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h3><p><a href="https://caster.io/" target="_blank" rel="external">Caster.io</a></p>
<p><a href="https://realm.io/news/" target="_blank" rel="external">Realm.io</a></p>
<p><a href="https://www.youtube.com/channel/UCMEmNnHT69aZuaOrE-dF6ug" target="_blank" rel="external">Android Dialogs (YouTube)</a></p>
<h3 id="Newsletters"><a href="#Newsletters" class="headerlink" title="Newsletters"></a>Newsletters</h3><p><a href="http://androidweekly.net/" target="_blank" rel="external">Android Weekly</a></p>
<p><a href="http://us12.campaign-archive2.com/home/?u=f39692e245b94f7fb693b6d82&amp;id=93b2272cb6" target="_blank" rel="external">Kotline Weekly</a></p>
<h3 id="General-Reading"><a href="#General-Reading" class="headerlink" title="General Reading"></a>General Reading</h3><p>Medium: 标签<a href="https://medium.com/tag/androiddev" target="_blank" rel="external">androiddev</a>和<a href="https://medium.com/tag/android-app-development" target="_blank" rel="external">android-app-development</a></p>
<h3 id="Conferences"><a href="#Conferences" class="headerlink" title="Conferences"></a>Conferences</h3><p><a href="https://events.google.com/io2016/" target="_blank" rel="external">GoogleIO</a></p>
<p><a href="https://360andev.com/" target="_blank" rel="external">360|AnDev</a></p>
<p><a href="http://droidcon.nyc/" target="_blank" rel="external">Droid Con NYC</a></p>
<h2 id="ThirtyInch-a-new-MVP-library-for-Android"><a href="#ThirtyInch-a-new-MVP-library-for-Android" class="headerlink" title="ThirtyInch - a new MVP library for Android"></a><a href="https://medium.com/@passsy/thirtyinch-a-new-mvp-library-for-android-bd1a27262fd6#.dvjdbuvfx" target="_blank" rel="external">ThirtyInch - a new MVP library for Android</a></h2><p>近年来MVP已经变成了Android社区中很流行的一种设计模式, MVC和MVVM也有人用. 这些模式的共同点就是把业务逻辑从Activity中抽取来.</p>
<p>这样做的好处首先是我们可以尽量把需要测试的逻辑用JVM上的单元测试测, 而不是用模拟器上的androidTests.<br>当然有些需要UI测试的地方仍然会用Espresso.</p>
<p>作者介绍了他们的MVP库: <a href="https://github.com/grandcentrix/ThirtyInch/" target="_blank" rel="external">ThirtyInch</a>.</p>
<p>这个库开始的时候<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">mosby</a>还没有release, 建议读一下mosby作者关于MVP的文章: <a href="http://hannesdorfmann.com/android/mosby" target="_blank" rel="external">mosby</a>, 其中关于passive View的概念也在ThirtyInch中用到.</p>
<h3 id="ThirtyInch"><a href="#ThirtyInch" class="headerlink" title="ThirtyInch:"></a>ThirtyInch:</h3><p><a href="https://github.com/grandcentrix/ThirtyInch/" target="_blank" rel="external">ThirtyInch</a>.</p>
<p>有<code>TiPresenter</code>, <code>TiView</code>.<br><code>TiView</code>是一个接口, 可以被attach和detach.</p>
<p><code>TiPresenter</code>有四个生命周期事件:</p>
<ul>
<li><code>onCreate()</code>: 初始化的时候调用一次, 此时view还没有attach.</li>
<li><code>onWakeUp()</code>: view attach了, 并且对用户变为可见.</li>
<li><code>onSleep()</code>: 在这个调用之后, view将被detach, 并且变为对用户不可见.</li>
<li><code>onDestroy()</code>: 在Activity/Fragment完全销毁的时候调用一次.</li>
</ul>
<p><code>onWakeUp()</code>和<code>onSleep()</code>对应了<code>onStart()</code>和<code>onStop()</code>, onResume/onPause没有对应的回调支持, 因为这些生命周期回调应该在View层处理, 见: <a href="http://hannesdorfmann.com/android/presenters-dont-need-lifecycle" target="_blank" rel="external">Presenters dont need lifecycle</a></p>
<h3 id="ThirtyInch有什么不同"><a href="#ThirtyInch有什么不同" class="headerlink" title="ThirtyInch有什么不同"></a>ThirtyInch有什么不同</h3><ul>
<li>可配置. 可以传<code>TiConfiguration</code>对象给TiPresenter, 去掉一些features.</li>
<li>所有Presenter的生命周期都按照正确的顺序调用, <code>onCreate()</code>和<code>onDestroy()</code>只调用一次.</li>
<li>不依赖RxJava. 它有一个独立的Rx module.</li>
<li>View接口的方法注解. 比如<code>@CallOnMainThread</code>和<code>@DistinctUntilChanged</code>.</li>
<li>Public API. 一些基层API可以被所有人利用起来.</li>
<li>不用继承<code>TiActivity</code>. 你可以利用<a href="https://github.com/passsy/CompositeAndroid" target="_blank" rel="external">CompositeAndrodi</a>, 把plugin module作为你的依赖, 然后把<code>TiActivityPlugin</code>加到你的Activity.</li>
</ul>
<p>之后作者举了一个Hello World的例子, 附图讲解很好, 见原文.</p>
<h3 id="不是严格的MVP-MVVM也可以"><a href="#不是严格的MVP-MVVM也可以" class="headerlink" title="不是严格的MVP, MVVM也可以"></a>不是严格的MVP, MVVM也可以</h3><p>作者又列出了一个ViewModel的图.<br>ViewModel存储了当前UI的状态数据.<br>当ViewModel中的数据变化时立即应用到View, 这里<code>@DistinctUtilChanged</code>的使用避免了数据不变时候的重复操作.</p>
<h3 id="测试-Keep-Android-At-Arm’s-Length"><a href="#测试-Keep-Android-At-Arm’s-Length" class="headerlink" title="测试, Keep Android At Arm’s Length"></a>测试, Keep Android At Arm’s Length</h3><p>MVP的初衷之一是为了方便写测试, 因为Android SDK中的一些方法和类不好mock, 所以Presenter中应该是没有Android相关的东西的, 比如Context和Fragment等, Presenter只知道View接口和其中的方法, 是纯java的.</p>
<p>这就是”Keep Android At Arm’s Length.”的意思, 不要把Android和逻辑代码绑在一起, 库的名字ThirtyInch也是来自于这个原则, 因为三十寸是人类手臂, 肩膀到手指的平均长度.</p>
<h3 id="How-does-the-Presenter-survive-the-configuration-change"><a href="#How-does-the-Presenter-survive-the-configuration-change" class="headerlink" title="How does the Presenter survive the configuration change?"></a>How does the Presenter survive the configuration change?</h3><p>Activity在屏幕方向旋转时会被重建. 此时没有被序列化保存的信息就会丢失, 网络请求要么被取消, 要么被忽略, 重新请求.</p>
<p>序列化数据会费时, 而且在这种情况下, 序列话的数据几秒之后就要被反序列化.</p>
<p>Android Framework提供了两个方法来避免这种不必要的序列化:</p>
<ul>
<li>Fragment的<code>setRetainInstance(true)</code>, 之前的那个Fragment实例会被保存.</li>
<li>使用<code>Activity#onRetainNonConfigurationInstance()</code>和<code>Activity#getLastNonConfigurationInstance()</code>来存储和恢复对象. 这也是Android保存上面retained Fragments的方法. 这个方法最近被废弃了.</li>
</ul>
<p>在Java中还有一个比较简单粗暴的方法是保存一个应用级别的单例.</p>
<p>ThirtyInch使用了上述的三种方法来确保TiPresenter在configuration变化的时候不死. 单例的解决方法尽在一些边缘情况必须.</p>
<p>当使用<code>TiPresenter</code>的时候不需要再实现<code>onSaveInstanceState(Bundle)</code>方法了, 因为数据都存在Presenter中.</p>
<h2 id="Firebase-Analytics-VS-Google-Analytics"><a href="#Firebase-Analytics-VS-Google-Analytics" class="headerlink" title="Firebase Analytics VS Google Analytics"></a><a href="https://medium.com/google-developer-experts/firebase-analytics-vs-google-analytics-b2010f34d2bb#.cjqb9n505" target="_blank" rel="external">Firebase Analytics VS Google Analytics</a></h2><p>作者之前对比过 <a href="https://medium.com/google-developer-experts/firebase-crash-reporting-vs-crashlytics-a6c287c4b792#.m4ubzrcds" target="_blank" rel="external">Firebase Crash Reporting和Crashlytics</a>.</p>
<p>在这篇文章里, 作者对比Firebase和Google的分析工具, 下面简称FA和GA.</p>
<p>首先GA是2005年就推出了, 那时候根本没有Android和iOS, 所以GA最开始是网站用的, FA是今年推出的, 从一开始目标就是移动应用.</p>
<p>然后作者总结了FA的优势和当前存在的几个不足.</p>
<p>最后的结论就是:<br>如果你只有app, 用FA; 如果你只有网站, 用GA; 如果你两个都有, 则两个都用.</p>
<h2 id="VectorDrawable-Fill-Windings"><a href="#VectorDrawable-Fill-Windings" class="headerlink" title="VectorDrawable Fill Windings"></a><a href="https://blog.stylingandroid.com/vectordrawable-fill-windings/" target="_blank" rel="external">VectorDrawable Fill Windings</a></h2><p>作者有一个Sketch做的资源, 是一个空洞图, 结果放在程序里看的时候中间的洞没有了, 变成实心的了.</p>
<p>作者分析并详细解释了出现这种问题的原因, 并提供了两种解决方案.</p>
<h1 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h1><h2 id="Basic-Patterns-for-Mobile-Navigation"><a href="#Basic-Patterns-for-Mobile-Navigation" class="headerlink" title="Basic Patterns for Mobile Navigation"></a><a href="https://uxplanet.org/basic-patterns-for-mobile-navigation-d12a87686efe#.1jleu0y6v" target="_blank" rel="external">Basic Patterns for Mobile Navigation</a></h2><p>这篇文章作者分析了三种导航模式: hamburger menu, tab bar和gesture-base navigation.</p>
<h3 id="Hamburger-Menu"><a href="#Hamburger-Menu" class="headerlink" title="Hamburger Menu"></a>Hamburger Menu</h3><p>Pros: 导航选项多, 设计干净, 给主要内容留出了更多空间.</p>
<p>Cons: 不易被发现.<br>在iOS实现时, 和iOS的基本导航元素冲突.<br>hamburger的icon并没有给出上下文.<br>需要点两下才到目标页面.</p>
<p>Tips: 给选项排列优先级. 如果你的高优先级选项不多, 可以考虑用tabs或者tab bar. 重审你的信息结构, 有没有必要划分成多个简单的app.</p>
<h3 id="Tab-Bar"><a href="#Tab-Bar" class="headerlink" title="Tab Bar"></a>Tab Bar</h3><p>Pros: Tab bar可以反映出当前在哪. 它们是永久存在的, 用户可以单击访问.</p>
<p>Cons: 有限的选项数. iOS和Android可能会有不同的设计规范.</p>
<p>Tips: 让点击区域足够大. icon要经过可用性测试. icon和label一起用.</p>
<h3 id="Gesture-Based-Navigation"><a href="#Gesture-Based-Navigation" class="headerlink" title="Gesture-Based Navigation"></a>Gesture-Based Navigation</h3><p>Pros: 移除了UI杂项, 节约了屏幕空间. 自然的人机交互接口.</p>
<p>Cons: 导航不可见. 增加了用户教育成本.</p>
<p>Tips: 确保不要必须教给用户一种全新的交互方式, 设计相似的体验. 使用过程动画的形式教用户如何使用. </p>
<h2 id="Design-Reviews-Going-beyond-the-surface"><a href="#Design-Reviews-Going-beyond-the-surface" class="headerlink" title="Design Reviews: Going beyond the surface"></a><a href="https://design.google.com/articles/going-beyond-the-surface/" target="_blank" rel="external">Design Reviews: Going beyond the surface</a></h2><p>关于设计的review.</p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="green-coffee"><a href="#green-coffee" class="headerlink" title="green-coffee"></a><a href="https://github.com/mauriciotogneri/green-coffee" target="_blank" rel="external">green-coffee</a></h2><p>一个Android库, 让你可以在instrumentation测试中跑Cucumber.</p>
<h2 id="ThirtyInch-1"><a href="#ThirtyInch-1" class="headerlink" title="ThirtyInch"></a><a href="https://github.com/grandcentrix/ThirtyInch/" target="_blank" rel="external">ThirtyInch</a></h2><p>一个Android MVP库.</p>
<h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="Exynap"><a href="#Exynap" class="headerlink" title="Exynap"></a><a href="http://exynap.com/" target="_blank" rel="external">Exynap</a></h2><p>一个Android Studio插件, 可以生成实现代码.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Espresso </tag>
            
            <tag> MVP </tag>
            
            <tag> Resources </tag>
            
            <tag> Okio </tag>
            
            <tag> Tools </tag>
            
            <tag> Support Annotations </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 221]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/09/09/android-weekly-notes-issue-221/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-221"><a href="#Android-Weekly-Issue-221" class="headerlink" title="Android Weekly Issue #221"></a>Android Weekly Issue #221</h1><p>September 4th, 2016<br><a href="http://androidweekly.net/issues/issue-221" target="_blank" rel="external">Android Weekly Issue #221</a></p>
<a id="more"></a>
<h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Android-ImageView-ScaleType-A-Visual-Guide"><a href="#Android-ImageView-ScaleType-A-Visual-Guide" class="headerlink" title="Android ImageView ScaleType: A Visual Guide"></a><a href="https://robots.thoughtbot.com/android-imageview-scaletype-a-visual-guide" target="_blank" rel="external">Android ImageView ScaleType: A Visual Guide</a></h2><p>回想一下, 你是不是总是记不住ImageView的不同ScaleType的区别, 每次都要各种尝试来找到自己适合的.<br>这篇文章的作者也有这样的烦恼, 于是他把各种ScaleType都截了图:<br><img src="/images/ImageView-ScaleTypes.png" alt="ImageView-ScaleTypes"></p>
<p>如果用了CENTER_INSIDE, FIT_CENTER, FIT_START,或者FIT_END, 而实际View的大小比图像的大, 可以使用<code>android:adjustViewBounds</code>属性为true, 就会调整View的大小.</p>
<p>官方文档: <a href="https://developer.android.com/reference/android/widget/ImageView.ScaleType.html" target="_blank" rel="external">ImageView.ScaleType</a></p>
<h2 id="5-steps-to-creating-frustration-free-Android-test-devices"><a href="#5-steps-to-creating-frustration-free-Android-test-devices" class="headerlink" title="5 steps to creating frustration-free Android test devices"></a><a href="https://m.signalvnoise.com/5-steps-to-creating-frustration-free-android-test-devices-9bb2750edd19#.56mnep7p1" target="_blank" rel="external">5 steps to creating frustration-free Android test devices</a></h2><p>作者讲了如何统一管理测试机.</p>
<h3 id="1-根据你要支持的API-level来安装系统"><a href="#1-根据你要支持的API-level来安装系统" class="headerlink" title="1.根据你要支持的API level来安装系统."></a>1.根据你要支持的API level来安装系统.</h3><p>理想情况下你应该每一个API都有一个对应的机器, 更进一步可以统计一下你的用户用什么的最多来进行调整. </p>
<p>作者列举了他当前的五个机器, 一般来讲, 你至少需要高中低API版本的, 也需要Samsung的机器来测试一些可能会被定制的地方, (当然作者是在国外了, 国内估计需要测试的定制机型就更多了), 另外还需要一个大屏幕的, 来查看UI的适配情况.</p>
<p>幸运的是除了品牌定制机, 其他都可以用模拟器来补救, 在此推荐一下genymotion, 传说中最快的模拟器.</p>
<h3 id="2-安装并配置测试所需的应用"><a href="#2-安装并配置测试所需的应用" class="headerlink" title="2. 安装并配置测试所需的应用"></a>2. 安装并配置测试所需的应用</h3><p>为了测试你的app, 你可能需要一系列的工具app, 所以第二步你需要安装它们, 登录及设置等等.<br>原作者常用的工具app有:</p>
<ul>
<li>1Password: 管理密码.</li>
<li>AZ Screen Recorder: 截屏, 制作gif.</li>
<li>Chrome Beta: 因为原作者做WebView相关的工作, 所以需要看这个.</li>
<li>Dropbox: 自动上传截图, 从电脑可以方便拿, 也可以用来做一些文件相关的测试.</li>
<li>Flesky / Swiftkey / Google Keyboard: 也是作者应用相关, 需要测试各种键盘.</li>
<li>Keep: 很好用的笔记应用, 可以存一些小notes, url等, 跨设备同步.</li>
<li>Solid Explorer: 文件管理器, 可以在系统中方便地移动文件.</li>
</ul>
<h3 id="3-在各处都登录"><a href="#3-在各处都登录" class="headerlink" title="3. 在各处都登录"></a>3. 在各处都登录</h3><p>需要登录的账号都登录.</p>
<h3 id="4-为了统一体验装个Nova-Launcher"><a href="#4-为了统一体验装个Nova-Launcher" class="headerlink" title="4. 为了统一体验装个Nova Launcher"></a>4. 为了统一体验装个Nova Launcher</h3><p>为了让每个机器都看起来一样, 原作者装了个launcher应用: <a href="https://play.google.com/store/apps/details?id=com.teslacoilsw.launcher" target="_blank" rel="external">Nova Launcher</a>.</p>
<p>确实, 因为每个机器的launcher和组织方式不一样, 所以有时候换个机器就会很难找到你想要的东西.</p>
<p>用了这个Nova Launcher之后, 你可以设置好你的home, dock, drawer, 然后多个机器分享设置, 这样当你拿起另一个机器的时候, 所有的应用都在同样的位置.</p>
<h3 id="5-设置每个机器的系统设置"><a href="#5-设置每个机器的系统设置" class="headerlink" title="5. 设置每个机器的系统设置"></a>5. 设置每个机器的系统设置</h3><p>最后一件事就是一些系统上的设置, 包括:</p>
<ul>
<li>所有地点的Wi-Fi;</li>
<li>DND/total silence: 关声音;</li>
<li>Developer options和USB debugging开关打开;</li>
<li>当插线时仍然保持屏幕唤醒;</li>
<li>亮度设置.</li>
</ul>
<p>最后作者建议开发者平时生活中可以多玩玩各种Android应用.</p>
<h2 id="Security-issues-with-Android-Accessibility"><a href="#Security-issues-with-Android-Accessibility" class="headerlink" title="Security issues with Android Accessibility"></a><a href="https://medium.com/@vedprakashrout/android-accessibility-75fdc5810025#.f10tnu6oj" target="_blank" rel="external">Security issues with Android Accessibility</a></h2><p>看这篇文章之前, 让我们了解一下Accessibility是什么, 搜了一下Android相关文档:</p>
<ul>
<li><a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="external">Guides of Accessibility</a></li>
<li><a href="https://developer.android.com/training/accessibility/index.html" target="_blank" rel="external">Training for Implementing Accessibility</a></li>
<li><a href="https://developer.android.com/design/patterns/accessibility.html" target="_blank" rel="external">Design Guidelines for Accessibility</a></li>
<li><a href="https://material.google.com/usability/accessibility.html#" target="_blank" rel="external">Material Design Accessibility</a></li>
</ul>
<p>Accessibility是为了扩展访问和利用应用的形式, 基本出发点是为了辅助老年人或者是有障碍的人, 增加一些听觉或触觉反馈, 也可以用来辅助一些特殊场合下的用户, 比如正在开车或照顾孩子, 或者处于非常嘈杂的环境下的情形.</p>
<p>可以结合Google的<a href="https://play.google.com/store/apps/details?id=com.google.android.marvin.talkback" target="_blank" rel="external">TalkBack</a>, 也可以自己开发相关的服务.</p>
<p>好了, 话题收敛回来, 看看作者说的安全问题指的是什么.</p>
<p>作者一开篇以一个印度很流行的应用Voodoo为例指出, 把屏幕上的文字读出来这个功能是有安全漏洞的.</p>
<p>首先Voodoo向用户请求accessibility的权限, 这个权限使得应用可以从屏幕上读取文字, 但是用户会认为所有的敏感字段应该不在这个范围之内, 这就是开发者需要认真对待的了.</p>
<p>最近有一个新的登录设计, 已经被应用开来, 就是用户可以选择显示或者隐藏密码字段.</p>
<p>当我们把输入框的input type设置为密码, 那么它是不会被读取到的, 但是有一些应用为了支持显示密码的功能, 可能会把input type设置为其他类型, 这样就会导致密码暴露, 有accessibility权限的恶意应用就会借此盗用用户的敏感信息.</p>
<p>这样当然是不好的啦, 用户开启权限的时候还认为敏感字段总会受到保护呢, 所以我们开发者应该小心地对待用户的敏感信息, 很简单:</p>
<p><code>ViewCompat.setImportantForAccessibility(your_view, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);</code></p>
<p>新的<code>TextInputLayout</code>的API可以实现密码显示的toggle功能, 希望这个问题在TextInputLayout中已经解决了, 但是在用这个View之前, 上面的hotfix也算一种解决办法.</p>
<h2 id="How-to-fix-horizontal-scrolling-in-your-Android-app"><a href="#How-to-fix-horizontal-scrolling-in-your-Android-app" class="headerlink" title="How to fix horizontal scrolling in your Android app"></a><a href="http://nerds.headout.com/fix-horizontal-scrolling-in-your-android-app/" target="_blank" rel="external">How to fix horizontal scrolling in your Android app</a></h2><p>在Android中垂直的滚动很常见, 但是如果在垂直滚动的View里嵌套一个水平滚动的View, 那滑动的体验将会非常不好.</p>
<p><strong>Problem</strong>: 垂直滚动和内嵌的水平滚动打架了, 滚动体验不佳.</p>
<p><strong>What’s happening inside</strong>:</p>
<p>例子里根view是一个<code>RecyclerView</code>加垂直 <code>LinearLayoutManager</code>, 里面的child是一个<code>RecyclerView</code>加水平<code>LinearLayoutManager</code>.</p>
<p>但是当用户做水平滚动的时候, touch事件首先被外面的父View给拦截了.</p>
<p>看<code>RecyclerView</code>的代码可知, 在<code>onInterceptTouchEvent()</code>方法里, 在垂直滚动使能的情况下, 只要垂直移动的距离(dy)大于一定程度(<code>Math.abs(dy) &gt; mTouchSlop</code>), 就会被认为是垂直滚动.</p>
<p>所以作者他们的解决方案是继承了RecyclerView, 覆写了这个方法, 把条件改成:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop &amp;&amp; (canScrollHorizontally || Math.abs(dy) &gt; Math.abs(dx))) &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>这是他们的完整代码: <a href="https://gist.github.com/manidesto/ecccd38787fa8e287a3f18bcd9867189" target="_blank" rel="external">BetterRecyclerView</a></p>
<p><strong>Bonus</strong><br>还有一个跟fling相关的问题: <code>RecyclerView</code>在fling之后需要挺长的一段时间来稳定(settle)下来, 当child还在这个稳定过程中时, 如果用户尝试竖直滚动, touch事件实际上是被child吃掉的.</p>
<p>还是从<code>onInterceptTouchEvent()</code>的代码可以看出:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mScrollState == SCROLL_STATE_SETTLING) &#123;</div><div class="line">    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">    setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当child处于SETTLING状态时, child会要求它的parent不要拦截touch事件.</p>
<p>这在通常情况下是好的.<br>但是在作者的使用场景里, 他们的root中没有其他竖直滚动和拖拽的child, 所以他们又继承了刚才那个BetterRecyclerView, 写了一个<code>requestDisallowInterceptTouchEvent()</code>为空实现的View作为root.</p>
<p>他们的sample demo在这里: <a href="https://github.com/manidesto/scrolling-demo" target="_blank" rel="external">manidesto/scrolling-demo</a>.</p>
<h2 id="Update-Dependencies-Code-Repeat"><a href="#Update-Dependencies-Code-Repeat" class="headerlink" title="Update Dependencies. Code. Repeat."></a><a href="http://crushingcode.co/update-dependencies-code-repeat/" target="_blank" rel="external">Update Dependencies. Code. Repeat.</a></h2><p>每一个Android开发可能都需要对他们的项目进行(更新依赖, 编码, 重复)这样的循环工作, 如果你想要你的所有项目都有同样的版本号, 这样是很浪费时间的.</p>
<p>原文作者就经历了这样的情景, 他想要把他这个目录<a href="https://github.com/nisrulz/android-examples" target="_blank" rel="external">Android-Examples</a>下的所有项目都更新一下. 这个目录里全是那种很小的简单例子, 但都是可独立运行的工程.<br>每当gradle-plugin, support library或者google play services要更新版本号, 保持这些工程全部都updated是一项很难的工作.</p>
<p>所以原作者想要放弃原先逐个更新的土办法, 更有效率地来更新依赖版本号.<br>首先想到的就是在gradle里定义一个变量, 然后双引号加$引用这个变量.<br>为了让所有的module都采用同一变量, 可以在根项目的build.gradle文件里定义变量, 即使用ext块.<br>但是到此, 只能统一管理在同一个project下的各个modules的依赖版本.</p>
<p>如果跨projects呢?<br>首先, 作者在存放这些projects的根目录下建了一个gradle文件, 然后把变量都定义在那里.<br>然后如何应用到各个project呢?于是原作者找啊找, 找到了这块: <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:subproject_configuration" target="_blank" rel="external">gradle Subproject configuration</a><br>他给每个工程的根build文件加了个这个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// This is added to apply the gradle file to each module under the project</div><div class="line">subprojects &#123;</div><div class="line">    apply from: &apos;../../dependencies.gradle&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样以后在每个工程的module里面都可以直接引用变量了.</p>
<p>但是, 这对于android-gradle-plugin的版本是不管用的.</p>
<p>这是因为上面应用的配置只对subproject起作用, 对每一个root project是没有应用到的.<br>所以作者在每一个项目的root build.gradle中, 在buildscript块又加了它的依赖配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    // This is added to apply the gradle file to facilitate providing variable values to root build.gradle of the project</div><div class="line">    apply from: &apos;../dependencies.gradle&apos;</div><div class="line">    ..</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;com.android.tools.build:gradle:$androidPluginVer&quot;</div><div class="line">        ..</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好啦, 至此, 所有的依赖配置问题就解决了, 以后改版本号只需要改一个地方就可以应用到所有项目.</p>
<h2 id="DI-101-Part-2"><a href="#DI-101-Part-2" class="headerlink" title="DI 101 - Part 2"></a><a href="https://medium.com/di-101/di-101-part-2-9f7f4e1dcc81#.bfcmljct9" target="_blank" rel="external">DI 101 - Part 2</a></h2><p>作者上一篇的文章里介绍了Dagger的基本使用.<br>这篇还是教程类文章, 讲:</p>
<p><strong>多个Modules</strong>:</p>
<p>写了一个Retrofit 2的ApiModule, 和一个Realm的DatabaseModule.</p>
<p><strong>多个对象</strong>:</p>
<p>有时候我们需要提供一个类的不同对象, 我们可以用<code>@Named</code>注解, 然后用不同的字符串来区分它们.</p>
<p>文中的例子是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provides</span></div><div class="line"><span class="meta">@Named</span>(IMAGE_URL)</div><div class="line"><span class="function">String <span class="title">provideImageUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> ImageApiService.ENDPOINT;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Provides</span></div><div class="line"><span class="meta">@Named</span>(URL)</div><div class="line"><span class="function">String <span class="title">provideBaseUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> RestApiService.ENDPOINT;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Provides</span> <span class="meta">@Singleton</span> <span class="meta">@Named</span>(REST_API_RETROFIT)</div><div class="line"><span class="function">Retrofit <span class="title">provideRetrofit</span><span class="params">(@Named(URL)</span> String baseUrl, OkHttpClient client) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="meta">@Provides</span> <span class="meta">@Singleton</span> <span class="meta">@Named</span>(IMAGE_API_RETROFIT)</div><div class="line"><span class="function">Retrofit <span class="title">provideImageRetrofit</span><span class="params">(@Named(IMAGE_URL)</span> String baseUrl, OkHttpClient client) </span>&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Inject-interfaces-without-provide-methods-on-Dagger-2"><a href="#Inject-interfaces-without-provide-methods-on-Dagger-2" class="headerlink" title="Inject interfaces without provide methods on Dagger 2"></a><a href="https://android.jlelse.eu/inject-interfaces-without-providing-in-dagger-2-618cce9b1e29?swoff=true#.66p0l6oik" target="_blank" rel="external">Inject interfaces without provide methods on Dagger 2</a></h2><p>用dagger2注入接口, 返回实现类的对象, 比较常规的方法是在Module里面写一个<code>@Provides</code>标注的providesXXX()方法, 返回值类型是接口, 实际返回的是实现类的对象, 比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Provides</span></div><div class="line">  <span class="function"><span class="keyword">public</span> HomePresenter <span class="title">providesHomePresenter</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HomePresenterImp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果我们想给实现类加一个依赖UserService呢?</p>
<p>我们当然可以把UserService作为参数传给这个provide方法, 然后传到实现类的构造函数中, 在里面存一个字段.</p>
<p>又或者, 我们可以使用<code>@Binds</code>注解, 像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Binds</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> HomePresenter <span class="title">bindHomePresenter</span><span class="params">(HomePresenterImp   </span></span></div><div class="line">    homePresenterImp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个抽象类中的抽象方法, 这个方法的签名意思是告诉dagger, 注入<code>HomePresenter</code>接口(返回值)时, 使用<code>HomePresenterImpl</code>(方法参数)实现.</p>
<p>然后, 在<code>HomePresenterImpl</code>类的构造函数上加一个<code>@Inject</code>就可以了.</p>
<p>这样我们就不需要在provide方法上加依赖参数了.</p>
<h2 id="Introducing-ExpandableRecyclerView"><a href="#Introducing-ExpandableRecyclerView" class="headerlink" title="Introducing ExpandableRecyclerView"></a><a href="https://robots.thoughtbot.com/introducing-expandablerecyclerview" target="_blank" rel="external">Introducing ExpandableRecyclerView</a></h2><p>本文介绍<a href="https://github.com/thoughtbot/expandable-recycler-view" target="_blank" rel="external">expandable-recycler-view</a>, 一个开源的库, 可以展开和折叠RecyclerView中的组.</p>
<p><code>RecyclerView</code>作为<code>ListView</code>的升级版, 却也减少了一些功能比如<code>OnItemClickListener</code>, <code>ChoiseModes</code>, 还有扩展版的<code>ExpandableListView</code>.<br>本文作者就介绍这个开源库, <code>ExpandableRecyclerView</code>, 用自定义的<code>RecyclerView.Adapter</code>来实现展开关闭分组的功能.</p>
<p>首先明白一下Adapter的功能, 其实adapter就是一个中间人, 将一些数据按照index翻译给View, 然后显示.</p>
<p>当显示的list是单维度的时候, 这样的翻译很简单, 数据的index就直接对应了屏幕上view的index.</p>
<p>当时当你显示二维数据时, 翻译就变得有点复杂,数据和view的index可能对应, 也可能不对应.<br><code>RecyclerView.Adapter</code>就只能处理一维数据的情况, 这就是为什么要对其进行一些扩展, 才能实现ExpandableRecyclerView.</p>
<p>后来作者简单讲了实现的原理, 用到了<code>ExpandableListPosition</code>, 是Android SDK中就有的类, 只不过有包限制, 所以拷贝到了这个库里.</p>
<p>最后附上repo地址: <a href="https://github.com/thoughtbot/expandable-recycler-view" target="_blank" rel="external">expandable-recycler-view</a></p>
<h2 id="Creating-Custom-Annotations-in-Android"><a href="#Creating-Custom-Annotations-in-Android" class="headerlink" title="Creating Custom Annotations in Android"></a><a href="https://medium.freecodecamp.com/creating-custom-annotations-in-android-a855c5b43ed9#.dq08cdjsm" target="_blank" rel="external">Creating Custom Annotations in Android</a></h2><p><strong>注解是什么</strong></p>
<p><strong>Annotations are Metadata.</strong></p>
<p>注解是元数据, 而元数据是一些关于其他数据的信息.<br>所以说, 注解是关于代码的信息.</p>
<p>比如<code>@Override</code>注解, 即便你不在方法上标注它, 程序依然能够正常工作. 那么它是用来干什么的呢? </p>
<p><code>@Override</code>是用来告诉编译器, 这个方法覆写了一个方法, 如果父类没有这个方法, 则会报一个编译错误.</p>
<p>如果你不加这个注解, 有可能你方法名不小心拼错了却仍然编译通过了.</p>
<p><strong>创建自定义注解</strong>:<br>比如, 创建一个:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Status &#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</div><div class="line">  <span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</div><div class="line">  <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> “Amit”</span>;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">completion</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>@Target</code>指定了这个注解可以放在哪里. 如果你不设置, 这个注解可以放在任何地方.<br>可能的值有:</p>
<ul>
<li><code>ElementType.TYPE</code> (class, interface, enum)</li>
<li><code>ElementType.FIELD</code> (instance variable)</li>
<li><code>ElementType.METHOD</code></li>
<li><code>ElementType.PARAMETER</code></li>
<li><code>ElementType.CONSTRUCTOR</code></li>
<li><code>ElementType.LOCAL_VARIABLE</code></li>
</ul>
<p><code>@Retention</code>定义这个注解可以被保存多久.<br>可能的值有:</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> - 到编译结束, 不会被编进.class, 只会留在源文件中. <code>@Override</code>, <code>@SuppressWarnings</code>都是这种.</li>
<li><code>RetentionPolicy.CLASS</code> - 到类加载丢弃, 注解将存储在.class文件中, 这是默认值.</li>
<li><code>RetentionPolicy.RUNTIME</code> - 不被丢弃. .class文件中有, 并且可由VM读入, 在运行时可以通过反射的方式读取到.</li>
</ul>
<p>上面的注解使用时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in Foo.java</span></div><div class="line"><span class="meta">@Status</span>(priority = STATUS.Priority.MEDIUM, author = “Amit Shekhar”, completion = <span class="number">0</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="comment">//no code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// get the annotation information</span></div><div class="line"> Class foo = Foo.class;</div><div class="line"> <span class="keyword">for</span>(Method method : foo.getMethods()) &#123;</div><div class="line">    Status statusAnnotation = (Status)method.getAnnotation(Status.class);</div><div class="line">    <span class="keyword">if</span>(statusAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">     System.out.println(<span class="string">" Method Name : "</span> + method.getName());</div><div class="line">     System.out.println(<span class="string">" Author : "</span> + statusAnnotation.author());</div><div class="line">     System.out.println(<span class="string">" Priority : "</span> + statusAnnotation.priority());</div><div class="line">     System.out.println(<span class="string">" Completion Status : "</span> + statusAnnotation.completion());</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>如果你的注解中仅有一个属性, 它应该叫value, 并且使用的时候不用指定属性名.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> Status&#123;</div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> <span class="meta">@Status</span>(<span class="number">50</span>)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//few codes</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>最后作者还附上了另一个他的文章, 推荐他的网络请求库: <a href="https://medium.freecodecamp.com/simple-and-fast-android-networking-19ed860d1455#.3hqqpr1ba" target="_blank" rel="external">Fast Android Networking</a></p>
<h2 id="It’s-parfetti-time"><a href="#It’s-parfetti-time" class="headerlink" title="It’s parfetti time!"></a><a href="https://medium.com/@jinatonic/its-parfetti-time-f40634472608#.9vf9fxn99" target="_blank" rel="external">It’s parfetti time!</a></h2><p>作者介绍他的库: <a href="https://github.com/jinatonic/confetti" target="_blank" rel="external">confetti</a>.</p>
<p>这个库实现了一个粒子系统, 来发射出随机的纸屑, 并且可以被定制化, 比如发射源的形状(点或者线), 初始的物理约束(速度, 加速度, 旋转等), 还可以定义消失或者拖拽行为, 感觉效果还挺好的.</p>
<p>关于性能, 纸屑对象是循环利用的, 每一个bitmap也只被分配一次地址, 动画参数也做了一些预计算, 所以作者说不用担心丢帧, 除非你一次性出现的片儿实在是太多了.</p>
<h2 id="Converting-callback-async-calls-to-RxJava"><a href="#Converting-callback-async-calls-to-RxJava" class="headerlink" title="Converting callback async calls to RxJava"></a><a href="https://medium.com/we-are-yammer/converting-callback-async-calls-to-rxjava-ebc68bde5831#.mmtpwqgkh" target="_blank" rel="external">Converting callback async calls to RxJava</a></h2><p>作者他们在自己Android应用里开始使用RxJava以后, 经常会遇到由于API没有follow reactive model, 导致他们必须做一些转换工作, 将它们和其他的RxJava Observable链连接起来.</p>
<p>API对于很重的操作通常提供这两种方式之一</p>
<ul>
<li>1.同步阻塞方法调用, 通常需要后台线程调用.</li>
<li>2.异步非阻塞方法调用, 结合callback, listener, 或者broadcast receiver等.</li>
</ul>
<p><strong>把同步方法变为Observable</strong>:</p>
<p>用这个<a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#fromCallable%28java.util.concurrent.Callable%29" target="_blank" rel="external">Observable.fromCallable()</a></p>
<p>比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// wrapping synchronous operation in an RxJava Observable</span></div><div class="line"><span class="function">Observable&lt;Boolean&gt; <span class="title">wipeContents</span><span class="params">(<span class="keyword">final</span> SharedPreferences sharedPreferences)</span> </span>&#123; </div><div class="line">    <span class="keyword">return</span> Observable.fromCallable(<span class="keyword">new</span> Callable&lt;Boolean&gt;() &#123; </div><div class="line">        <span class="meta">@Override</span> </div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </div><div class="line">            <span class="keyword">return</span> sharedPreferences.edit().clear().commit(); </div><div class="line">        &#125; </div><div class="line">    &#125;); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>把异步方法变为Observable</strong>:</p>
<p>变异步没那么简单了, 之前有一些模式是用工厂方法<code>Observable.create()</code>把它们包起来, 比如<a href="http://ryanharter.com/blog/2015/07/07/wrapping-existing-libraries-with-rxjava/" target="_blank" rel="external">here</a>, <a href="http://andriydruk.com/post/rxdnssd/" target="_blank" rel="external">here</a>, <a href="http://stackoverflow.com/questions/29679801/chaining-rxjava-observables-with-callbacks-listeners/29682801#29682801" target="_blank" rel="external">here</a>, 但是这种方法存在一些缺点.</p>
<p>作者举了一个传感器监听的例子.<br>用create()转换之后, 需要处理一些问题, 比如注销listener, 错误处理, 检查subscriber等, 这几个都可能办到, 但是还有一个backpressure的问题, 不好办.<br>这个backpressure是什么捏: <a href="http://stackoverflow.com/documentation/rx-java/2341/backpressure#t=201609081434407670206" target="_blank" rel="external">backpressure</a><br>当生产者发射值的速率比消费者可以处理的速率快的时候, 有一个内置的buffer size, 当超出的时候就会抛出<code>MissingBackpressureException</code>.</p>
<p>幸运的是, RxJava v1.1.7推出了<code>Observable.fromAsync()</code>, 在v1.2.0改名为<code>Observable.fromEmitter()</code>.<br>这个里面对于backpressure的处理定义了好几种策略, 你只需要选一种模式就行.</p>
<p>然后作者给出了采用这个新方法的例子, 这里不再赘述, 可以看原文.<br>Sample代码在: <a href="https://github.com/murki/AndroidRxFromAsyncSample" target="_blank" rel="external">AndroidRxFromAsyncSample</a></p>
<h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="ItemTouchHelper-Extension"><a href="#ItemTouchHelper-Extension" class="headerlink" title="ItemTouchHelper Extension"></a><a href="https://github.com/loopeer/itemtouchhelper-extension" target="_blank" rel="external">ItemTouchHelper Extension</a></h2><p><code>ItemTouchHelper</code>的扩展, 加滑动settling和恢复. Sample的效果是给单个item加了滑动后出现删除和refresh两个按钮.</p>
<h2 id="Fresco-Image-Viewer"><a href="#Fresco-Image-Viewer" class="headerlink" title="Fresco Image Viewer"></a><a href="https://github.com/stfalcon-studio/FrescoImageViewer" target="_blank" rel="external">Fresco Image Viewer</a></h2><p>为Fresco库加的全屏查看图像的工具, 支持双手指的zoom和滑动关闭手势.</p>
<h2 id="ABTestGen"><a href="#ABTestGen" class="headerlink" title="ABTestGen"></a><a href="https://github.com/imperial-crystalline-recursion/abtestgen" target="_blank" rel="external">ABTestGen</a></h2><p>一个生成简单A/B test的库, 使用注解.</p>
<h2 id="RecyclerViewHelper-v24-2-0"><a href="#RecyclerViewHelper-v24-2-0" class="headerlink" title="RecyclerViewHelper v24.2.0"></a><a href="https://github.com/nisrulz/recyclerviewhelper" target="_blank" rel="external">RecyclerViewHelper v24.2.0</a></h2><p>一个RecyclerView的辅助类, 提供滑动删除, 拖动, divider, 选中和非选中事件等的支持.</p>
<h2 id="Paginize"><a href="#Paginize" class="headerlink" title="Paginize"></a><a href="https://github.com/neevek/Paginize" target="_blank" rel="external">Paginize</a></h2><p>一个轻量级的Android应用framework.</p>
<h1 id="SPECIALS"><a href="#SPECIALS" class="headerlink" title="SPECIALS"></a>SPECIALS</h1><h2 id="Tips-and-tricks-for-Android-Development"><a href="#Tips-and-tricks-for-Android-Development" class="headerlink" title="Tips and tricks for Android Development"></a><a href="https://github.com/nisrulz/android-tips-tricks" target="_blank" rel="external">Tips and tricks for Android Development</a></h2><p>一个很长的README, 包含了各种快捷键, 编码建议, 工具, 插件, 还有有一些推荐的网站等, 其中有mock api和新闻网站及其他有用的工具等.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Security </tag>
            
            <tag> Gradle </tag>
            
            <tag> RxJava </tag>
            
            <tag> ScaleType </tag>
            
            <tag> Devices </tag>
            
            <tag> Accessibility </tag>
            
            <tag> Scrolling </tag>
            
            <tag> ExpandableRecyclerView </tag>
            
            <tag> Annotation </tag>
            
            <tag> ItemTouchHelper </tag>
            
            <tag> Fresco </tag>
            
            <tag> Resources </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[取代SharedPreferences的多进程解决方案]]></title>
      <url>http://mengdd.github.io/Android/2016/09/07/hello-preferences-provider/</url>
      <content type="html"><![CDATA[<p>Android的SharedPreferences用来存储一些键值对, 但是却不支持跨进程使用.<br>跨进程来用的话, 当然是放在数据库更可靠啦, 本文主要是给作者的新库<a href="https://github.com/mengdd/PreferencesProvider" target="_blank" rel="external">PreferencesProvider</a>打个广告.<br>这是一个用ContentProvider实现的, 可以像SharedPreferences一样用于存储键值对, 支持跨进程使用.</p>
<a id="more"></a>
<h2 id="SharedPreferences不支持多进程"><a href="#SharedPreferences不支持多进程" class="headerlink" title="SharedPreferences不支持多进程"></a>SharedPreferences不支持多进程</h2><p>SharedPreferences对多进程的支持不好, 你用什么mode也没用, 所以官方已经废弃了原先的MODE_MULTI_PROCESS, 并且建议跨进程存取值还是用ContentProvider之类的更靠谱一些.<br>说明见:<br><a href="https://developer.android.com/reference/android/content/Context.html#MODE_MULTI_PROCESS" target="_blank" rel="external">Context#MODE_MULTI_PROCESS</a></p>
<h2 id="用ContentProvider来取代SharedPreferences-心路历程"><a href="#用ContentProvider来取代SharedPreferences-心路历程" class="headerlink" title="用ContentProvider来取代SharedPreferences 心路历程"></a>用ContentProvider来取代SharedPreferences 心路历程</h2><p>之前项目中为了解决跨进程存取值的问题, 找了一个解决方案: <a href="https://github.com/grandcentrix/tray" target="_blank" rel="external">grandcentrix/tray</a>, 感觉还挺好用.</p>
<p>我们最后一次用的版本是tray的v0.10.0, 因为项目发布以后后台的崩溃里总是有相关的crash, 也是它的一个issue: <a href="https://github.com/grandcentrix/tray/issues/50" target="_blank" rel="external">https://github.com/grandcentrix/tray/issues/50</a><br>这个crash不是必现的, 概率比较低, 但是还是影响了一部分用户, 当我们解决了项目中的其他更重要的crash之后, 这个crash的排名就越来越靠前了.</p>
<p>后来作者做了一些改动, 说是在v0.11.0这个issue将会被修复, 但是这个版本却迟迟没有发布, 似乎作者做了一些很大的改动.</p>
<p>为了及时补救, 不再让用户体验到这个随机的崩溃, 我们决定放弃等待Tray的下个版本, 自己实现用ContentProvider来存取preferences.</p>
<p>实现过程用了<a href="https://github.com/BoD/android-contentprovider-generator" target="_blank" rel="external">BoD/android-contentprovider-generator</a>来生成ContentProvider相关的代码.<br>我们把存preferences的表放在了自己的数据库里, 然后借鉴了Tray的接口, 封装了读取方法, 使之用起来和SharedPreferences类似.<br>之后我们就用自己写的新代码全面取代了Tray, 当然数据库升级时还需要对原来存在Tray里的重要数据进行迁移.</p>
<p>做完了这些以后, 发现可以做一个像Tray一样的库, 更简单, 造福其他人, 那么何乐而不为呢.</p>
<h2 id="PreferencesProvider优势"><a href="#PreferencesProvider优势" class="headerlink" title="PreferencesProvider优势"></a>PreferencesProvider优势</h2><ul>
<li>基于ContentProvider实现, 支持跨进程使用;</li>
<li>采用模块化的管理方式, 可以将preferences分组管理;</li>
<li>没有Tray在v0.10.0版本的crash, 因为实现比Tray简单, 没有升级等功能.<br>(其实在我们实际项目的使用中, 基本上用不到对存preferences的表进行数据库升级的情况).</li>
<li>使用方式简单, 见项目README说明:<a href="https://github.com/mengdd/PreferencesProvider" target="_blank" rel="external">PreferencesProvider</a>.</li>
</ul>
<h2 id="有用的工具"><a href="#有用的工具" class="headerlink" title="有用的工具"></a>有用的工具</h2><p>生成ContentProvider相关代码:<br><a href="https://github.com/BoD/android-contentprovider-generator" target="_blank" rel="external">BoD/android-contentprovider-generator</a><br>只要定义数据库基本信息, 在json中定义表结构, 就可以生成所有相关代码.</p>
<p>查看数据库:<br><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho</a><br>在Chrome中像调试网页一样看Android应用的资源, 这个真是太好用了.</p>
<p>最后再次附上本文推荐的解决方案库: <a href="https://github.com/mengdd/PreferencesProvider" target="_blank" rel="external">PreferencesProvider</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Content Provider </tag>
            
            <tag> SharedPreferences </tag>
            
            <tag> Mutilprocess </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 220]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/09/01/android-weekly-notes-issue-220/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-220"><a href="#Android-Weekly-Issue-220" class="headerlink" title="Android Weekly Issue #220"></a>Android Weekly Issue #220</h1><p>August 28th, 2016<br><a href="http://androidweekly.net/issues/issue-220" target="_blank" rel="external">Android Weekly Issue #220</a></p>
<a id="more"></a>
<h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h3 id="Manage-dependencies-versions-with-gradle-extra-properties"><a href="#Manage-dependencies-versions-with-gradle-extra-properties" class="headerlink" title="Manage dependencies versions with gradle extra properties"></a><a href="https://segunfamisa.com/posts/android-gradle-extra-properties" target="_blank" rel="external">Manage dependencies versions with gradle extra properties</a></h3><p>依赖管理的小Tip: 把依赖的版本号作为变量管理.<br>改造之后, build.gradle文件变成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div><div class="line"></div><div class="line">ext &#123;</div><div class="line">    supportLibraryVersion = &apos;23.4.0&apos;</div><div class="line">    playServicesVersion = &apos;9.2.1&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    // support libraries</div><div class="line">    compile &quot;com.android.support:appcompat-v7:$supportLibraryVersion&quot;</div><div class="line">    compile &quot;com.android.support:design:$supportLibraryVersion&quot;</div><div class="line">    compile &quot;com.android.support:percent:$supportLibraryVersion&quot;</div><div class="line">    compile &quot;com.android.support:cardview-v7:$supportLibraryVersion&quot;</div><div class="line">    compile &quot;com.android.support:gridlayout-v7:$supportLibraryVersion&quot;</div><div class="line"></div><div class="line">    //play services</div><div class="line">    compile &quot;com.google.android.gms:play-services-location:$playServicesVersion&quot;</div><div class="line">    compile &quot;com.google.android.gms:play-services-gcm:$playServicesVersion&quot;</div><div class="line"></div><div class="line">    // other dependencies</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了版本号变量, 原来hardcode时的单引号变成了双引号, 然后用$符号取变量值.</p>
<p>上面这个是app module里面使用的例子, 如果你的应用有多个module怎么办呢?<br>当然一种办法是每个module里定义一组版本号变量, 更方便的办法是在项目工程总目录的build.gradle文件里定义变量.<br>可以在工程的build文件里写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">    // sdk and tools</div><div class="line">    minSdkVersion = 14</div><div class="line">    targetSdkVersion = 23</div><div class="line">    compileSdkVersion = 23</div><div class="line">    buildToolsVersion = &apos;23.0.2&apos;</div><div class="line"></div><div class="line">    // dependencies versions</div><div class="line">    supportLibraryVersion = &apos;23.4.0&apos;</div><div class="line">    playServicesVersion = &apos;9.2.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以这样定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">project.ext.supportLibVersion = &apos;24.0.0&apos;</div></pre></td></tr></table></figure></p>
<p>使用的时候可以这样取值: <code>$rootProject.supportLibraryVersion</code>.<br>也可以省略前面的rootProject, 直接取<code>$supportLibraryVersion</code></p>
<h3 id="Android-CI-with-Docker"><a href="#Android-CI-with-Docker" class="headerlink" title="Android CI with Docker"></a><a href="https://medium.com/@Malinskiy/android-ci-with-docker-a2f522086640#.ud9unt793" target="_blank" rel="external">Android CI with Docker</a></h3><p>作者讲了他怎么用Docker搭建CI.</p>
<ol>
<li><p>环境:<br>首先, CI需要Android环境(JDK 7&amp;8, Android SDK, Gradle, Release keychain, google-services.json, etc).<br>装了这些环境之后, 需要保证他们在每一个CI实例上都是同步更新的.<br>用了Docker之后, 更新环境的步骤变为:<br>更新你的Dockerfile -&gt; Push到版本管理系统 -&gt; CI会build新的image, 然后push到docker registry.</p>
</li>
<li><p>Build:<br><code>docker run -v ./app:/opt/app docker-ci-android:latest gradle assembleRelease</code></p>
</li>
<li><p>Test:<br>有两种测试, 一种是单元测试, 只需要JVM; 另一种是UI或者功能测试, 需要Android.<br>emulator会有一些问题: <a href="https://developer.android.com/training/articles/smp.html" target="_blank" rel="external">why</a><br>所以你可能想要在更真实的机器上测试: <a href="https://github.com/openstf/stf" target="_blank" rel="external">STF</a>提供了服务, 你只需要用这个<a href="https://github.com/Malinskiy/stf-client" target="_blank" rel="external">stf-client</a>.</p>
</li>
<li><p>Deploy:<br>部署用一些gradle的task就可以完成.<br><a href="https://docs.fabric.io/android/beta/gradle.html#distribution-with-gradle" target="_blank" rel="external">fabric</a><br><a href="https://github.com/Triple-T/gradle-play-publisher" target="_blank" rel="external">gradle-play-publisher</a></p>
</li>
</ol>
<p>后面还提到了一些扩展和问题.</p>
<h3 id="Bottom-Sheets-in-Android"><a href="#Bottom-Sheets-in-Android" class="headerlink" title="Bottom Sheets in Android"></a><a href="http://mayojava.github.io/android/bottom-sheets-android/" target="_blank" rel="external">Bottom Sheets in Android</a></h3><p>BottomSheet是support library 23.2加入的, 是从底部滑上来的一个块块, 用来向用户展现更多内容.<br>Support Library提供了:<br><code>BottomSheetBehavior</code>: 加在<code>CoordinatorLayout</code>的直接child view上, 然后在java代码里get出来, 设置state控制其状态.<br>有HIDE, COLLAPSED和EXPANDED三种状态, 分别对应隐藏, 展开到指定高度(peekHeight)和完全展开.<br><code>BottomSheetDialog</code>:<br><code>BottomSheetDialogFragment</code>.<br>Behaviour是给View加行为, 后面这两种是更加模块化的dialog, 状态控制都一样.</p>
<p>这里推荐一下笔者自己的demo: <a href="https://github.com/mengdd/AndroidDesignWidgetsSample" target="_blank" rel="external">AndroidDesignWidgetsSample</a><br>再推荐一下这篇文章里面的Bottom Sheets部分: <a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout" target="_blank" rel="external">CodePath-Handling-Scrolls-with-CoordinatorLayout</a></p>
<h3 id="Certificate-public-key-pinning-using-Retrofit-2"><a href="#Certificate-public-key-pinning-using-Retrofit-2" class="headerlink" title="Certificate public key pinning using Retrofit 2"></a><a href="https://medium.com/@sreekumar_av/certificate-public-key-pinning-in-android-using-retrofit-2-0-74140800025b#.9ajsf36qp" target="_blank" rel="external">Certificate public key pinning using Retrofit 2</a></h3><p>SSL handshake, 交换了证书(Certificate), 这样客户端就可以通过证书来验证服务器的身份.<br>什么是Certificate public key pinning呢? 也叫作SSL pinning.</p>
<p>把host name和<a href="https://tools.ietf.org/html/rfc7469#section-2.4" target="_blank" rel="external">public key</a>关联起来, 这个public key将用来和证书中的public key比较, 如果匹配了, 就证明你正在和正确的server通信.<br>而直接pinning证书相比pinning public key更容易一些, 但是也有不好的地方, 如果网站(比如Google)经常轮换证书(rotate its certificate), 你的应用就也得经常更新, 而这种情况一般证书里面的public keys是保持不变的.<br>如何在Android中用Retrofit实现pinning呢?<br>首先需要网站的public key的hash, 有很多获取方法, 参见<a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/CertificatePinner.java" target="_blank" rel="external">okhttp3-CertificatePinner</a>.<br>然后构建CertificatePinner类对象, 加到OkHttpClient上.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CertificatePinner certificatePinner = <span class="keyword">new</span> CertificatePinner.Builder()</div><div class="line">                   .add(<span class="string">"api.github.com"</span>, <span class="string">"sha256/6wJsqVDF8K19zxfLxV5DGRneLyzso9adVdUN/exDacw="</span>)</div><div class="line">                   .build();</div><div class="line"><span class="keyword">final</span> OkHttpClient client = httpBuilder.certificatePinner(certificatePinner).build();</div><div class="line"></div><div class="line"> Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                   .baseUrl(END_POINT)</div><div class="line">                   .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                   .client(client)</div><div class="line">                   .build();</div></pre></td></tr></table></figure></p>
<p>TLSv1.2从Android16+开始支持, 但是对于20+的设备默认是disabled的, 为了强制获取支持, 可以继承<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/javax/net/ssl/SSLSocketFactory.java" target="_blank" rel="external">SSLSocketFactory</a>, 强制设置为enabled, 代码见原文吧.<br>Github上有完整的代码<a href="https://github.com/pollux-/PublicKeyPinning" target="_blank" rel="external">PublicKeyPinning</a><br>作者最后还推荐了一个测试的工具<a href="https://mitmproxy.org/" target="_blank" rel="external">mitmproxy</a>.</p>
<h3 id="Isometric-AnimatedVectorDrawable-Part-3"><a href="#Isometric-AnimatedVectorDrawable-Part-3" class="headerlink" title="Isometric AnimatedVectorDrawable - Part 3"></a><a href="https://blog.stylingandroid.com/isometric-animatedvectordrawable-part-3/" target="_blank" rel="external">Isometric AnimatedVectorDrawable - Part 3</a></h3><p>作者继续讲了他如何构建方块地形图的动态效果.<br>一个AnimatedVectorDrawable的xml文件实际上是用来建立一个映射关系, 关联objectAnimators和VectorDrawable上的独立元素. 我们可以建立一个objectAnimator, 操纵我们的一块元素的动画效果.<br>文中实现了让方块地形动起来的动画效果.</p>
<h3 id="The-many-flavors-of-commit"><a href="#The-many-flavors-of-commit" class="headerlink" title="The many flavors of commit()"></a><a href="https://medium.com/@bherbst/the-many-flavors-of-commit-186608a015b1#.uwl2v86cx" target="_blank" rel="external">The many flavors of commit()</a></h3><p><strong>FragmentTransaction的提交方法</strong>:<br>support library的<code>FragmentTransaction</code>现在提供了四种不同的方法来commit一个transaction:<br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commit%28%29" target="_blank" rel="external">commit()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitAllowingStateLoss%28%29" target="_blank" rel="external">commitAllowingStateLoss()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitNow%28%29" target="_blank" rel="external">commitNow()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitNowAllowingStateLoss%28%29" target="_blank" rel="external">commitNowAllowingStateLoss()</a><br>这篇文章分析了这四个方法的不同.</p>
<p><strong>commit() vs commitAllowingStateLoss()</strong>:<br>用<code>commit()</code>提交有时候会遇到<code>IllegalStateException</code>, 说你在<code>onSaveInstanceState()</code>之后提交, 这里有另一个文章很好地分析了这个问题:<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="external">Fragment Transactions &amp; Activity State Loss</a><br><code>commit()</code>和<code>commitAllowingStateLoss()</code>在实现上唯一的不同就是当你调用<code>commit()</code>的时候, FragmentManger会检查是否已经存储了它自己的状态, 如果已经存了, 就抛出<code>IllegalStateException</code>.<br>那么如果你调用的是<code>commitAllowingStateLoss()</code>, 并且是在<code>onSaveInstanceState()</code>之后, 你可能会丢失掉什么状态呢?<br>答案是你<strong>可能</strong>会丢掉FragmentManager的状态, 即save之后任何被添加或被移除的Fragments.<br>举例说明:<br>1.在Activity里显示一个FragmentA;<br>2.然后Activity被后台, <code>onStop()</code>和<code>onSaveInstanceState()</code>被调用;<br>3.在某个事件触发下, 你用FragmentB replace FragmentA , 使用的是 <code>commitAllowingStateLoss()</code>.<br>这时候, 用户再返回应用, 可能会有两种情况发生:<br>1.如果系统杀死了你的activity, 你的activity将会重建, 使用了上述步骤2保存的状态, 所以A会显示, B不会显示;<br>2.如果系统没有杀死你的activity, 它会被提到前台, FragmentB就会显示出来, 到下次Activity stop的时候, 这个包含了B的状态就会被存下来.<br>(上述测试可以利用开发者选项中的”Don’t Keep Activities”选项).<br>那么你要选择哪一种呢? 这就取决于你提交的是什么, 还有你是否能接受丢失.</p>
<p><strong>commit(), commitNow() 和 executePendingTransactions()</strong>:<br>使用<code>commit()</code>的时候, 一旦调用, 这个commit并不是立即执行的, 它会被发送到主线程的任务队列当中去, 当主线程准备好执行它的时候执行.<br><code>popBackStack()</code>的工作也是这样, 发送到主线程任务队列中去. 也即说它们都是异步的.</p>
<p>但是有时候你希望你的操作是立即执行的, 之前的开发者会在<code>commit()</code>调用之后加上 <code>executePendingTransactions()</code>来保证立即执行, 即变异步为同步.<br>support library从v24.0.0开始提供了 <code>commitNow()</code>方法, 之前用<code>executePendingTransactions()</code>会将所有pending在队列中还有你新提交的transactions都执行了, 而<code>commitNow()</code>将只会执行你当前要提交的transaction. 所以<code>commitNow()</code>避免你会不小心执行了那些你可能并不想执行的transactions.</p>
<p>但是你不能对要加在back stack中的transaction使用<code>commitNow()</code>, 即<code>addToBackStack()</code>和<code>commitNow()</code>不能同时使用.<br>为什么呢?<br>想想一下, 如果你有一个提交使用了<code>commit()</code>, 紧接着又有另一个提交使用了<code>commitNow()</code>, 两个都想加入back stack, 那back stack会变成什么样呢? 到底是哪个transaction在上, 哪个在下? 答案将是一种不确定的状态, 因为系统并没有提供任何保证来确保顺序, 所以系统决定干脆不支持这个操作.</p>
<p>前面提过<code>popBackStack()</code>是异步的, 所以它同样也有一个同步的兄弟<code>popBackStackImmediate()</code>.</p>
<p>所以实际应用的时候怎么选择呢?</p>
<ol>
<li>如果你需要同步的操作, 并且你不需要加到back stack里, 使用<code>commitNow()</code>.<br>support library在FragmentPagerAdapter里就使用了commitNow()来保证在更新结束的时候, 正确的页面被加上或移除.</li>
<li>如果你操作很多transactions, 并且不需要同步, 或者你需要把transactions加在back stack里, 那就使用<code>commit()</code>.</li>
<li>如果你希望在某一个指定的点, 确保所有的transactions都被执行, 那么使用<code>executePendingTransactions()</code>.</li>
</ol>
<h3 id="Break-circular-dependency-with-RxJava-用RxJava打破循环依赖"><a href="#Break-circular-dependency-with-RxJava-用RxJava打破循环依赖" class="headerlink" title="Break circular dependency with RxJava 用RxJava打破循环依赖."></a><a href="https://medium.com/@ferhatparmak/break-your-circular-dependency-with-rxjava-8a487345061#.4718laogc" target="_blank" rel="external">Break circular dependency with RxJava</a> 用RxJava打破循环依赖.</h3><p>当你把代码分成各个部分, 比如用MVP, 这些各个部分之间可能会有相互依赖, 比如View需要Presenter, Presenter也需要View.<br>作者也没有说双向关联有什么缺点, 但是他说RxJava可以把这种双向的依赖改成单向的.<br>作者的办法是使用<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a>把button的click事件变成一个Observable, 然后Presenter监听click这个Observable, 后面接一个flatMap, 里面发网络请求, 得到结果之后再调用view的方法.<br>这么一改以后View中就不需要再持有Presenter的引用了.<br>举这个例子, 最后是想说, 如果你想从A中调用B的异步方法, 你不用总是在A中保存一个B的引用, 你可以把A中的事件作为一个Observable. 这样只需要B保存了A的引用就可以了.</p>
<h3 id="Asynchronous-layout-inflation-异步解析layout"><a href="#Asynchronous-layout-inflation-异步解析layout" class="headerlink" title="Asynchronous layout inflation 异步解析layout"></a><a href="https://medium.com/@lupajz/asynchronous-layout-inflation-7cbca2653bf#.lld73d5uq" target="_blank" rel="external">Asynchronous layout inflation</a> 异步解析layout</h3><p>最近的support library revision 24中, Google的开发者在v4包中加入了一个新的辅助类<a href="https://developer.android.com/reference/android/support/v4/view/AsyncLayoutInflater.html" target="_blank" rel="external">AsyncLayoutInflater</a>, 来实现布局的异步解析.</p>
<p>我们现在常用的布局解析inflate方法都是同步的, 那什么时候需要异步地做这件事情呢?<br>比如你想延迟加载布局中的一块, 或者你想把布局解析作为用户某个交互的一个响应. 这样就可以用这个异步布局解析类, 保证了主线程在inflation进行的时候仍然可响应.<br>怎么使用呢?<br>首先, 在主线程创建对象<code>AsyncLayoutInflater(this)</code>,<br>用它inflate布局的时候第三个参数是一个<code>OnInflateFinishedListener</code>回调.<br>以前同步方法的第三个参数是一个boolean, 说布局是否需要attach到parent上, 现在没有这个boolean参数了.<br>当然, 使用异步解析也有缺点:</p>
<ul>
<li>父类方法<code>generateLayoutParams()</code>必须是线程安全的.</li>
<li>被创建的所有View不能创建Handler,或者调用<code>Looper.myLooper()</code>方法.</li>
<li>不支持设置<code>LayoutInflater.Factory</code>和<code>LayoutInflater.Factory2</code></li>
<li>不支持布局里有Fragment.<br>如果我们要异步inflate的布局不能支持异步, inflate的过程将会自动转化为在UI线程的解析.<br>作者文中附有Kotlin的例子.</li>
</ul>
<h3 id="Introduction-to-Automated-Android-Testing-Part-5"><a href="#Introduction-to-Automated-Android-Testing-Part-5" class="headerlink" title="Introduction to Automated Android Testing - Part 5"></a><a href="https://riggaroo.co.za/introduction-automated-android-testing-part-5/" target="_blank" rel="external">Introduction to Automated Android Testing - Part 5</a></h3><p>系列文章的第五篇, 之前第四篇的时候写了Presenter, 定义了V和P的接口, 本篇接着写View接口的实现.</p>
<p>这里Presenter和View关联作者写了两个attachView()和detachView()方法, 前者在Presenter构造之后调用, 后者在Activity的onDestroy()里调用. 这里同时会unregister RxJava的subscriptions, 避免了内存泄露的发生.</p>
<p>作者在布局时用了<code>ConstraintLayout</code>, 关于这个layout的使用她有另一个<a href="https://riggaroo.co.za/constraintlayout-101-new-layout-builder-android-studio/" target="_blank" rel="external">blog</a><br>另外作者还加了Toolbar上的SearchView, 到此, 作者的这个app就基本完成了.<br>作者的代码里还有一个Injection类, 用来提供retrofit的service, 即代码中UserRepo的获取, 在Presenter构造时传入.</p>
<p>作者的代码: <a href="https://github.com/riggaroo/GithubUsersSearchApp/tree/testing-tutorial-part5-complete" target="_blank" rel="external">GithubUsersSearchApp</a><br>预告下一篇将会加入UI测试.</p>
<h3 id="DiffUtil-is-a-must"><a href="#DiffUtil-is-a-must" class="headerlink" title="DiffUtil is a must!"></a><a href="https://medium.com/@nullthemall/diffutil-is-a-must-797502bc1149#.lqfl9xikm" target="_blank" rel="external">DiffUtil is a must!</a></h3><p>support library 24.2.0推出了一个新的辅助类<code>DiffUtil</code>, 它是用来解决什么问题的呢?<br>如果你的RecyclerView.Adapter第一次接收到了新的数据, 这很简单, 只需要将它们显示出来, 但如果已经有了数据, 新的数据又来了, 这时候怎么做才是最好的呢?<br><a href="https://developer.android.com/reference/android/support/v7/util/DiffUtil.html" target="_blank" rel="external">DiffUtil</a>来了, 它就是专门为了解决RecyclerView的Adapter更新而设计的, 他可以计算出前后两个list的不同, 然后返回一组更新操作, 把第一个list变为第二个list.<br><code>DiffUtil</code>需要知道你的两个list的基本信息: 长度, 基本item的比较.<br><code>DiffUtil.Callback</code>是用来向<code>DiffUtil</code>提供这些基本信息的, 它是一个抽象类, 你需要继承它, 然后覆写里面的几个方法. 它的构造传入了两个待比较的list, 覆写的方法主要是get它们的size, 比较它们的内容.<br>Callback里还有一个<code>getChangePayload()</code>方法, 它不是抽象的, 这个方法在<code>areItemsTheSame()</code> 返回<code>true</code>, 但是<code>areContentsTheSame()</code>返回<code>false</code>的时候被调用.<br>这意味着我们的item还是之前的那个item,但是可能里面的字段变化了.<br>这个方法的返回值即为两个对应item的diff, 基本来说, 这个方法返回的是为什么我们认为list变化了.<br>文中的代码例子返回了一个Bundle, 把compare不相等的字段都放进去了, 用的是new item的值.</p>
<p>一旦我们写好了这个Callback类, 剩下的事情就很简单了, 我们只需要在新数据到来的时候计算一下diff, 然后更新.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@ <span class="function">Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewProducts</span><span class="params">(List&lt;Product&gt; newProducts)</span> &#123;</div><div class="line">    DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="keyword">new</span> ProductListDiffCallback(mProducts, newProducts));</div><div class="line">    diffResult.dispatchUpdatesTo(mProductAdapter);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然上面<code>getChangePayload()</code>返回的对象还得我们自己利用起来, 它会被<code>DiffResult</code>分发到Adapter.<br>用的是<code>notifyItemRangeChange(position, count, payload)</code>方法, 传到了Adapter的<code>onBindViewHolder()</code>方法, 我们判断payload不为空时, 从里面拿出diff做更新.</p>
<p>文档里说<code>DiffUtil</code>对很大的数据集可能比较费时, 所以建议把计算放在后台线程.</p>
<p>作者还给出了一个RxJava的例子, 各种flatMap.</p>
<h2 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h2><p><a href="http://facebook.design/handskit" target="_blank" rel="external">Diverse Device Hands</a><br>Facebook的design资源, 很多拿着手机的手的照片.</p>
<h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h3 id="unipiazza-android-twostepslogin"><a href="#unipiazza-android-twostepslogin" class="headerlink" title="unipiazza-android-twostepslogin"></a><a href="https://github.com/unipiazza/unipiazza-android-twostepslogin" target="_blank" rel="external">unipiazza-android-twostepslogin</a></h3><p>一个实现两步登录的库, 比如Google web登录, Material Design.<br>要用它的布局, 然后设置一些属性, 还有UI交互事件的Listener.</p>
<h3 id="Om-Recorder"><a href="#Om-Recorder" class="headerlink" title="Om Recorder"></a><a href="https://kailash09dabhi.github.io/OmRecorder/" target="_blank" rel="external">Om Recorder</a></h3><p>一个简单的Pcm / Wav 录音机, API简单, 可以录制Pcm和Wav音频, 可以配置输出, 有暂停功能.</p>
<h3 id="tiger"><a href="#tiger" class="headerlink" title="tiger"></a><a href="https://github.com/google/tiger" target="_blank" rel="external">tiger</a></h3><p>又一个依赖注入库, 但是README里说这不算一个Google的官方产品, 官方的是<a href="https://github.com/google/dagger" target="_blank" rel="external">Dagger</a>和<a href="https://github.com/google/guice" target="_blank" rel="external">Guice</a>.<br>这个tiger好像自称是目前最快的java依赖注入.</p>
<h2 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h2><p><a href="http://android-developers.blogspot.com.au/2016/08/taking-final-wrapper-off-of-nougat.html" target="_blank" rel="external">Taking the final wrapper off of Android 7.0 Nougat</a><br>Android 7.0已经问世了, 从Nexus开始, 同时API 24的source code已经push到AOSP了.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> AnimatedVectorDrawable </tag>
            
            <tag> Bottom Sheet </tag>
            
            <tag> Gradle </tag>
            
            <tag> Docker </tag>
            
            <tag> Certificate </tag>
            
            <tag> Retrofit </tag>
            
            <tag> RxJava </tag>
            
            <tag> MVP </tag>
            
            <tag> AsyncLayoutInflater </tag>
            
            <tag> DiffUtil </tag>
            
            <tag> Recorder </tag>
            
            <tag> tiger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[commit(), commitNow()和commitAllowingStateLoss()]]></title>
      <url>http://mengdd.github.io/Android/2016/08/31/commit-commitNow-and-commitAllowingStateLoss/</url>
      <content type="html"><![CDATA[<p>关于FragmentTransaction的各种提交方法: <code>commit()</code>,<code>commitAllowingStateLoss()</code>,<code>commitNow()</code>和<code>commitNowAllowingStateLoss()</code>.<br>作者Bryan Herbst发了一个blog <a href="https://medium.com/@bherbst/the-many-flavors-of-commit-186608a015b1#.uwl2v86cx" target="_blank" rel="external">The many flavors of commit()</a>讨论这几个方法的特点和用途.<br>下文是中文摘要.</p>
<a id="more"></a>
<h1 id="FragmentTransaction的提交方法"><a href="#FragmentTransaction的提交方法" class="headerlink" title="FragmentTransaction的提交方法"></a>FragmentTransaction的提交方法</h1><p>support library的<code>FragmentTransaction</code>现在提供了四种不同的方法来commit一个transaction:<br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commit%28%29" target="_blank" rel="external">commit()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitAllowingStateLoss%28%29" target="_blank" rel="external">commitAllowingStateLoss()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitNow%28%29" target="_blank" rel="external">commitNow()</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commitNowAllowingStateLoss%28%29" target="_blank" rel="external">commitNowAllowingStateLoss()</a></p>
<p>这篇文章分析了这四个方法的不同.</p>
<h2 id="commit-vs-commitAllowingStateLoss"><a href="#commit-vs-commitAllowingStateLoss" class="headerlink" title="commit() vs commitAllowingStateLoss()"></a>commit() vs commitAllowingStateLoss()</h2><p>用<code>commit()</code>提交有时候会遇到<code>IllegalStateException</code>, 说你在<code>onSaveInstanceState()</code>之后提交, 这里有另一个文章很好地分析了这个问题:<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="external">Fragment Transactions &amp; Activity State Loss</a><br><code>commit()</code>和<code>commitAllowingStateLoss()</code>在实现上唯一的不同就是当你调用<code>commit()</code>的时候, FragmentManger会检查是否已经存储了它自己的状态, 如果已经存了, 就抛出<code>IllegalStateException</code>.<br>那么如果你调用的是<code>commitAllowingStateLoss()</code>, 并且是在<code>onSaveInstanceState()</code>之后, 你可能会丢失掉什么状态呢?<br>答案是你<strong>可能</strong>会丢掉FragmentManager的状态, 即save之后任何被添加或被移除的Fragments.<br>举例说明:<br>1.在Activity里显示一个FragmentA;<br>2.然后Activity被后台, <code>onStop()</code>和<code>onSaveInstanceState()</code>被调用;<br>3.在某个事件触发下, 你用FragmentB replace FragmentA , 使用的是 <code>commitAllowingStateLoss()</code>.<br>这时候, 用户再返回应用, 可能会有两种情况发生:<br>1.如果系统杀死了你的activity, 你的activity将会重建, 使用了上述步骤2保存的状态, 所以A会显示, B不会显示;<br>2.如果系统没有杀死你的activity, 它会被提到前台, FragmentB就会显示出来, 到下次Activity stop的时候, 这个包含了B的状态就会被存下来.<br>(上述测试可以利用开发者选项中的”Don’t Keep Activities”选项).<br>那么你要选择哪一种呢? 这就取决于你提交的是什么, 还有你是否能接受丢失.</p>
<h2 id="commit-commitNow-和-executePendingTransactions"><a href="#commit-commitNow-和-executePendingTransactions" class="headerlink" title="commit(), commitNow() 和 executePendingTransactions()"></a>commit(), commitNow() 和 executePendingTransactions()</h2><p>使用<code>commit()</code>的时候, 一旦调用, 这个commit并不是立即执行的, 它会被发送到主线程的任务队列当中去, 当主线程准备好执行它的时候执行.<br><code>popBackStack()</code>的工作也是这样, 发送到主线程任务队列中去. 也即说它们都是异步的.</p>
<p>但是有时候你希望你的操作是立即执行的, 之前的开发者会在<code>commit()</code>调用之后加上 <code>executePendingTransactions()</code>来保证立即执行, 即变异步为同步.<br>support library从v24.0.0开始提供了 <code>commitNow()</code>方法, 之前用<code>executePendingTransactions()</code>会将所有pending在队列中还有你新提交的transactions都执行了, 而<code>commitNow()</code>将只会执行你当前要提交的transaction. 所以<code>commitNow()</code>避免你会不小心执行了那些你可能并不想执行的transactions.</p>
<p>但是你不能对要加在back stack中的transaction使用<code>commitNow()</code>, 即<code>addToBackStack()</code>和<code>commitNow()</code>不能同时使用.<br>为什么呢?<br>想想一下, 如果你有一个提交使用了<code>commit()</code>, 紧接着又有另一个提交使用了<code>commitNow()</code>, 两个都想加入back stack, 那back stack会变成什么样呢? 到底是哪个transaction在上, 哪个在下? 答案将是一种不确定的状态, 因为系统并没有提供任何保证来确保顺序, 所以系统决定干脆不支持这个操作.</p>
<p>前面提过<code>popBackStack()</code>是异步的, 所以它同样也有一个同步的兄弟<code>popBackStackImmediate()</code>.</p>
<p>所以实际应用的时候怎么选择呢?</p>
<ol>
<li>如果你需要同步的操作, 并且你不需要加到back stack里, 使用<code>commitNow()</code>.<br>support library在FragmentPagerAdapter里就使用了commitNow()来保证在更新结束的时候, 正确的页面被加上或移除.</li>
<li>如果你操作很多transactions, 并且不需要同步, 或者你需要把transactions加在back stack里, 那就使用<code>commit()</code>.</li>
<li>如果你希望在某一个指定的点, 确保所有的transactions都被执行, 那么使用<code>executePendingTransactions()</code>.</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>这是Android Weekly #220的一篇文章, 我在做这期笔记的时候觉得这个写得很好, 所以决定单独拿出来说一说. 这期整体的笔记稍后推出, 敬请期待哇.<br>原文<a href="https://medium.com/@bherbst/the-many-flavors-of-commit-186608a015b1#.uwl2v86cx" target="_blank" rel="external">The many flavors of commit()</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 7.0 Nougat released]]></title>
      <url>http://mengdd.github.io/Android/Android-News/2016/08/29/android-7-0-Nougat-released/</url>
      <content type="html"><![CDATA[<p>Android 7.0 Nougat 牛轧糖于本月发布了. 从官方blog里可以了解到这个版本的新特性.</p>
<a id="more"></a>
<p>Android 7.0 从2016年8月正式推出, 从Nexus设备开始发行.<br>据说此版本有250个主要的features, 其中值得高亮的几个是:</p>
<h3 id="更加个性化"><a href="#更加个性化" class="headerlink" title="更加个性化"></a>更加个性化</h3><p>扩展了emoji: 现在内置有超过1500个emoji, 其中72是新增的.<br>快速设置控制: 快速设置给予了对一些东西更方便的访问途径, 比如蓝牙, Wi-Fi, 手电筒等. 在Android Nougat中, 你现在可以控制这些按钮的位置, 按自己的需要来移动它们.<br>支持多地点: app可以根据你的地点设置来定制内容, 如果你讲多种语言, 那么可能应用里搜索引擎会用多种语言返回给你结果.</p>
<h3 id="更有效率"><a href="#更有效率" class="headerlink" title="更有效率"></a>更有效率</h3><p>不管你是在回复工作邮件或者跟朋友制定计划, Android Nougat让你的多任务变得更加容易.<br>Multi-window 多窗口: 可以同时显示两个应用窗口, 可拖拽调整窗口大小.<br>Direct Reply 直接回应: 可以直接回应通知, 不必打开app.<br>Quick Switch 快速转换: 双击overview button, 可以在你最近使用的两个app间切换.</p>
<h3 id="更加省电"><a href="#更加省电" class="headerlink" title="更加省电"></a>更加省电</h3><p>从Android Marshmallow开始, 加了Doze模式, 让电池更加智能地工作. 在Android Nougat中, doze模式又做了一些改进, 在你走路的时候, 把手机装在兜里, 也会进入省电模式.</p>
<h3 id="更沉浸的体验"><a href="#更沉浸的体验" class="headerlink" title="更沉浸的体验"></a>更沉浸的体验</h3><p>Android Nougat设计的时候也考虑了一些沉浸体验相关的东东, 支持VulkanTM(一个高级的3D渲染API)和Daydream(Google的mobile VR平台).</p>
<h3 id="更安全"><a href="#更安全" class="headerlink" title="更安全"></a>更安全</h3><p>Seamless Updates 无缝更新: 现在Nougat可以后台安装应用了.<br>File-based encryption 文件加密: 设备上各个用户的文件得到了分离和保护.<br>Direct Boot 直接启动: 手机启动更快了, 当你重启设备时, 应用即便是在你没有解锁时也跑得更安全了.</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>更多信息请查看:<br><a href="https://developer.android.com/about/versions/nougat/index.html" target="_blank" rel="external">Android 7.0 Nougat</a><br><a href="https://android.googleblog.com/2016/08/android-70-nougat-more-powerful-os-made.html" target="_blank" rel="external">Android 7.0 Nougat: a more powerful OS, made for you</a><br><a href="http://android-developers.blogspot.com.au/2016/08/taking-final-wrapper-off-of-nougat.html" target="_blank" rel="external">Taking the final wrapper off of Android 7.0 Nougat</a> 揭开Android 7.0 (牛轧糖) 的最后一层面纱.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android News </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android News </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 219]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/08/24/android-weekly-notes-issue-219/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-219"><a href="#Android-Weekly-Issue-219" class="headerlink" title="Android Weekly Issue #219"></a>Android Weekly Issue #219</h1><p>August 21st, 2016<br><a href="http://androidweekly.net/issues/issue-219" target="_blank" rel="external">Android Weekly Issue #219</a></p>
<a id="more"></a>
<h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h3 id="Android-Bottom-Sheet"><a href="#Android-Bottom-Sheet" class="headerlink" title="Android: Bottom Sheet"></a><a href="https://medium.com/@emrullahluleci/android-bottom-sheet-30284293f066#.i3i4ggv13" target="_blank" rel="external">Android: Bottom Sheet</a></h3><p>Bottom Sheet是一个从底部滑上来的组件, 关于这个<a href="https://material.google.com/components/bottom-sheets.html" target="_blank" rel="external">Google Material Design</a>有相关的guidelines.<br>这篇文章主要讲了基本使用, 比较简单.</p>
<p>这里私心推荐一下我自己的repo和另一个我觉得很好的教程:<br><a href="https://github.com/mengdd/AndroidDesignWidgetsSample" target="_blank" rel="external">AndroidDesignWidgetsSample</a><br><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout#bottom-sheets" target="_blank" rel="external">CodePath-handling-scrolls-with-CoordinatorLayout</a></p>
<h3 id="DI-101-Part-1"><a href="#DI-101-Part-1" class="headerlink" title="DI 101 - Part 1"></a><a href="https://medium.com/di-101/di-101-part-1-81896c2858a0#.sdgvcu8v3" target="_blank" rel="external">DI 101 - Part 1</a></h3><p>Android平台的依赖注入.<br>文章开始讲了下依赖注入的概念, 当前在Android上的依赖注入最著名的是<a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger2</a>.<br>然后文章讲了如何set up dagger 2, 举了个例子, 写Module, Component, 然后使用.</p>
<p>这里再私心推荐一下我自己的一篇教程:<br><a href="http://www.cnblogs.com/mengdd/p/5613889.html" target="_blank" rel="external">Using Dagger2 in Android</a></p>
<h3 id="Android-Security-Welcome-to-Shell-Permissions"><a href="#Android-Security-Welcome-to-Shell-Permissions" class="headerlink" title="Android Security: Welcome to Shell (Permissions)"></a><a href="http://doridori.github.io/Android-Security-welcome-to-shell/#sthash.2BSXwRAF.dpbs" target="_blank" rel="external">Android Security: Welcome to Shell (Permissions)</a></h3><p>作者在Reddit上看到了这么一句话:<br><code>ADB is a shell that you get on a PC with the same permissions as if you were to run a shell/terminal app on the phone itself.</code><br>于是就写了这篇文章来讨论一下shell命令的权限问题, 关于系统底层的权限如何工作.<br>作者在里面提到了这本书<a href="https://www.amazon.co.uk/Android-Security-Internals-Depth-Architecture/dp/1593275811" target="_blank" rel="external">Android Security Internals: An In-Depth Guide to Android’s Security Architecture</a>.<br>关于Android安全方面的研究, 作者还建了一个repo: <a href="https://github.com/doridori/Android-Security-Reference" target="_blank" rel="external">Android-Security-Reference</a>, 里面是关于安全问题的各种notes, still WIP.</p>
<h3 id="Lessons-from-converting-an-app-to-100-Kotlin"><a href="#Lessons-from-converting-an-app-to-100-Kotlin" class="headerlink" title="Lessons from converting an app to 100% Kotlin"></a><a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6#.mrqsqq9ap" target="_blank" rel="external">Lessons from converting an app to 100% Kotlin</a></h3><p>这是关于Kotlin的系列文章之part 1, part 2的文章在这里<a href="https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.eyvm3gp5t" target="_blank" rel="external">Kotlin: The Good, The Bad, and The Ugly</a>, 讨论Kotlin的语言设计.<br>本篇文章讲什么呢?<br>作者是一个应用的leader engineer, 学习了几天Kotlin之后, 觉得可以解决Java存在的一些痛点, 于是把应用改为用Kotlin了, 这篇文章是在此过程中的一些想法.</p>
<p><strong>方法数问题</strong>: 因为dex对方法数有要求, 不能超过64k, 见这里:<a href="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="external">multidex</a>, 作者用了这个工具来统计方法数<a href="https://github.com/KeepSafe/dexcount-gradle-plugin" target="_blank" rel="external">dexcount-gradle-plugin</a>. 最后证明迁移到Kotlin之后, 代码行数减少了30%, 方法数减少了10%.</p>
<p><strong>Retrolambda</strong>: 本来Retrolamda会生成匿名类, 并加上一些方法. Kotlin有内置的方法(apply), lamda可以直接传入, 不用生成匿名类, 不用添加额外的方法.</p>
<p><strong>Guava</strong>: Guava的功能已经被Kotlin的标准库覆盖, 作者举例了Guava中的<code>ComparisonChains</code>, <code>Optional</code>, lazy fields和<code>Preconditions</code>等, 均有对应的Kotlin方法.</p>
<p><strong>ButterKnife</strong>: ButterKnife仍然可以使用, 但是<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="external">Kotlin Android Extensions</a>提供了更加自然的方式来访问绑定的views. 还有其他的方案比如<a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="external">Kotterknife</a>和<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a>, 但是这俩都各自有些缺点, 不如Kotlin Android Extensions好用.</p>
<p><strong>RxJava</strong>: RxJava仍然是很好的, 但是由于对集合并没有函数式的方法, 所以有时候会用Kotlin替代一下.</p>
<p>Kotlin的一个优势就是它和Java可以互相调用, 所以可以逐步改动.<br>Intellij有自动把Java转化为Kotlin的功能, 但是有时候会有错.</p>
<p>作者推荐了学习Kotlin的资源:<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="external">Reference</a>.<br>最后鼓励大家使用Kotlin, 因为它现在已经足够成熟了.</p>
<h3 id="Rewriting-Android-Priority-JobQueue-Lessons-Learned"><a href="#Rewriting-Android-Priority-JobQueue-Lessons-Learned" class="headerlink" title="Rewriting Android Priority JobQueue - Lessons Learned"></a><a href="http://www.birbit.com/rewriting-android-priority-jobqueue-lessons-learned/" target="_blank" rel="external">Rewriting Android Priority JobQueue - Lessons Learned</a></h3><p>作者有一个repo: <a href="https://github.com/yigit/android-priority-jobqueue" target="_blank" rel="external">android-priority-jobqueue</a>, 是为Android写的任务队列管理framework, 用于调度管理后台任务.<br>后来Android自己也加了这个类<a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">JobScheduler</a>.<br>最近作者重写了这个库, 改善了稳定性并加了new features, 发了V2版, 然后写个文章分享一下心得:</p>
<ul>
<li>不要通过share memory来通信, 应该通过通信来share memory.<br>以前是多个线程访问加锁的共享资源, 线程里的一些字段标记为volatile. 新版JobManager改为单线程, 只有它可以访问共享资源, 其他线程都和JobManager通信. 这里有个文章在说这种方法<a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="external">Share Memory By Communicating</a></li>
<li>如果你的代码需要做时钟相关的事情, 抽象出来.<br>这主要是为测试和CI考虑.</li>
<li>加新API之前多想想.</li>
</ul>
<h3 id="Trello-Android-Schema-Upgrades"><a href="#Trello-Android-Schema-Upgrades" class="headerlink" title="Trello Android Schema Upgrades"></a><a href="https://tech.trello.com/android-schemas/" target="_blank" rel="external">Trello Android Schema Upgrades</a></h3><p>Trello Android之前的数据库升级方式相当简单粗暴, 他们drop整个数据库, 重新创建, 然后用server上的数据填进来.<br>这样在以前是没有问题的, 因为Trello的每一个操作都会立即发送给server, 不支持离线操作, 所以server上的数据永远是最新的.<br>但是最近他们想支持离线工作了, 这就说明不能简单地删数据库了, 因为其中可能含有没有发给服务器的离线数据.<br>他们要升级数据库, 这篇文章讲了他们的升级策略和他们为数据库升级而写的测试.</p>
<h3 id="Animating-the-text-lt-gt-dots-translation-on-password-field"><a href="#Animating-the-text-lt-gt-dots-translation-on-password-field" class="headerlink" title="Animating the text &lt;-&gt; dots translation on password field"></a><a href="https://twitter.com/crafty/status/766967057921417216?s=03" target="_blank" rel="external">Animating the text &lt;-&gt; dots translation on password field</a></h3><p>这个链接点进去是Twitter.<br>在新的support库升级(August 2016, v24.2.0)<a href="https://developer.android.com/topic/libraries/support-library/revisions.html" target="_blank" rel="external">Support Library Revision History</a>中, TextInputLayout增加了密码可见的toggle. Nick Butcher决定给按钮和文字的改变都加上动画.<br>这是他的repo: <a href="https://github.com/nickbutcher/plaid" target="_blank" rel="external">plaid</a>.</p>
<h3 id="Introducing-Android-code-style-guidelines-at-Buffer"><a href="#Introducing-Android-code-style-guidelines-at-Buffer" class="headerlink" title="Introducing Android code style guidelines at Buffer"></a><a href="https://overflow.buffer.com/2016/08/18/introducing-android-code-style-guidelines-buffer/" target="_blank" rel="external">Introducing Android code style guidelines at Buffer</a></h3><p>团队工作中, 有统一的代码风格很重要, 代码风格主要是代码的可读性和一致性相关问题.<br>作者他们为自己的Android App归档了新的code style: <a href="https://github.com/bufferapp/android-guidelines/blob/master/project_style_guidelines.md" target="_blank" rel="external">project style guidelines</a>, 当然啦, 文档是在使用中不断成长的.<br>做这种事主要目标是以下几个点: 一致性, 可读性, 可维护性, 易于浏览查询, 有意义.<br>文档写得很详细, 涉及到各个方面, 值得一看.</p>
<h3 id="Building-UserScope-with-Dagger-2"><a href="#Building-UserScope-with-Dagger-2" class="headerlink" title="Building UserScope with Dagger 2"></a><a href="http://frogermcs.github.io/building-userscope-with-dagger2/" target="_blank" rel="external">Building UserScope with Dagger 2</a></h3><p>关于Dagger 2里面自定义scope, 作者之前有一篇文章<a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/" target="_blank" rel="external">Dependency injection with Dagger 2 - Custom scopes</a>, 本篇文章继续了这个话题.<br>所谓scope呢, 就是限制了单例的生存周期, 有些单例可能在整个应用生命周期都存在, 另一些单例可能只需要存在一定的时间. Dagger 2默认只提供了一个scope @Singleton, 所以我们要根据需要自定义自己的scope.<br>作者的例子中定义了@UserScope, 以实例说明了他的实现, 还讨论了UserScope的状态恢复问题.<br>例子代码: <a href="https://github.com/frogermcs/Dagger2Recipes-UserScope" target="_blank" rel="external">Dagger2Recipes-UserScope</a></p>
<h3 id="Using-Java-8-Lambda-expressions-in-Android"><a href="#Using-Java-8-Lambda-expressions-in-Android" class="headerlink" title="Using Java 8 Lambda expressions in Android"></a><a href="http://mayojava.github.io/android/java/using-java8-lambda-expressions-in-android/" target="_blank" rel="external">Using Java 8 Lambda expressions in Android</a></h3><p>Java 8的一个重要特性是加入了Lambda表达式.</p>
<p><strong>Lambda表达式的语法</strong>:</p>
<ul>
<li><p>括号里是用逗号分隔的参数列表, 类型可以省略, 如果只有一个参数, 连括号也可以省略.<br>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView textView = (TextView) findViewById(R.id.text_view);</div><div class="line">textView.setOnLongClickListener(v -&gt; System.out.println(<span class="string">"Long Click"</span>));</div></pre></td></tr></table></figure>
</li>
<li><p>箭头符号 <code>-&gt;</code></p>
</li>
<li>箭头后面的body是单个表达式或者一个语句块.<br>如果是单个表达式, java runtime会返回它的值;<br>如果是语句块, 用大括号<code>{}</code>包起来.</li>
</ul>
<p><strong>在Android中使用Lambda表达式</strong>:<br>需要改build.gradle:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">  ...</div><div class="line">  defaultConfig &#123;</div><div class="line">    ...</div><div class="line">    jackOptions &#123;</div><div class="line">      enabled true</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有另一种方式是使用RetroLambda plugin: <a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">gradle-retrolambda</a></p>
<h3 id="Developing-for-Android-Wear-A-Noob’s-perspective"><a href="#Developing-for-Android-Wear-A-Noob’s-perspective" class="headerlink" title="Developing for Android Wear - A Noob’s perspective"></a><a href="https://medium.com/@moyinoluwa/developing-for-android-wear-a-noob-s-perspective-de47c4686ffb#.xjawtq69e" target="_blank" rel="external">Developing for Android Wear - A Noob’s perspective</a></h3><p>这篇文章讲了作者作为一个新手, 第一次开发Wear应用的时候遇到的种种问题.<br>比如, 手表和手机是需要配对的, 在手机上安装Google的这个<a href="https://play.google.com/store/apps/details?id=com.google.android.wearable.app" target="_blank" rel="external">软件</a>, 才能和手表配对, 配对了之后, 给手机安装release版apk的时候就会自动给手表安装应用.<br>也可以在Android Studio中选择wear来单跑Wear应用安装到手表, 但是只有配对了才能和手机有通信.<br>使用Wear的模拟器, 还需要运行这个命令adb -d forward tcp:5601 tcp:5601来和连接到电脑的手机连接.<br>还有在传输Assets时, 作者按照官方文档的例子, 却遇到了一些方法不能在UI线程调用的问题, 后来也解决了.</p>
<h3 id="Remote-config-with-Firebase"><a href="#Remote-config-with-Firebase" class="headerlink" title="Remote config with Firebase"></a><a href="http://segunfamisa.com/posts/firebase-remote-config" target="_blank" rel="external">Remote config with Firebase</a></h3><p>作者讲了如何实现Firebase的Remote config.<br>Remote config可以使我们控制应用的更新, 而不用重新发布一个版本.<br>为什么要使用远程配置呢? 主要的原因是测试新的功能, 然后可以根据用户的反馈快速地做出响应, 把更好的行为呈现给用户. 简单来说就是做A/B Test.<br>Firebase的remote config很强大, 指定参数后可以指定应用条件, 包括国家, 系统, 应用版本, 随机等等.</p>
<h2 id="DESIGN"><a href="#DESIGN" class="headerlink" title="DESIGN"></a>DESIGN</h2><h3 id="Updates-in-Material-design-guidelines"><a href="#Updates-in-Material-design-guidelines" class="headerlink" title="Updates in Material design guidelines"></a><a href="https://material.google.com/material-design/whats-new.html" target="_blank" rel="external">Updates in Material design guidelines</a></h3><p>2016年8月新发布的Material design包括了以下更新:<br>Notifications, Widgets, 确认操作和操作后的提示.<br>比较重要的更新是:<br>Navigation现在包括了如何使用Up和Back button.<br>还有使用全屏模式的三种模式:Lean back, Immersive, Lights Out以及它们相应的交互行为.</p>
<h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h3 id="Auto-value-firebase"><a href="#Auto-value-firebase" class="headerlink" title="Auto-value-firebase"></a><a href="https://github.com/mattlogan/auto-value-firebase" target="_blank" rel="external">Auto-value-firebase</a></h3><p>AutoValue的扩展, 用来创建Firebase的数据库对象.<br><a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="external">AutoValue</a>是google的一个库. 用来创建interchangeable的对象, 即如果两个对象的所有fields是相等的, 我们认为这两个对象相等.</p>
<h3 id="Icicle"><a href="#Icicle" class="headerlink" title="Icicle"></a><a href="https://github.com/segunfamisa/Icicle" target="_blank" rel="external">Icicle</a></h3><p>基于注解的一个工具, 用来保存和恢复实例的状态.<br>感觉跟<a href="https://github.com/frankiesardo/icepick" target="_blank" rel="external">Icepick</a>一样.</p>
<h3 id="ReadMoreTextView"><a href="#ReadMoreTextView" class="headerlink" title="ReadMoreTextView"></a><a href="https://github.com/borjabravo10/ReadMoreTextView" target="_blank" rel="external">ReadMoreTextView</a></h3><p>一个自定义的TextView, 可以指定按照文字长度或者行数截取显示, 带展开和关闭按钮操作.</p>
<h3 id="Android-priority-jobqueue"><a href="#Android-priority-jobqueue" class="headerlink" title="Android-priority-jobqueue"></a><a href="https://github.com/yigit/android-priority-jobqueue" target="_blank" rel="external">Android-priority-jobqueue</a></h3><p>一个为Android写的后台任务队列管理程序.</p>
<h2 id="NEWS"><a href="#NEWS" class="headerlink" title="NEWS"></a>NEWS</h2><h3 id="Support-Library-Revision-History"><a href="#Support-Library-Revision-History" class="headerlink" title="Support Library Revision History"></a><a href="https://developer.android.com/topic/libraries/support-library/revisions.html" target="_blank" rel="external">Support Library Revision History</a></h3><p>Android Support Library 24.2.0发布啦(August 2016).</p>
<p>v4被分成了很多小模块.</p>
<p><strong>API更新</strong>:<br>Custom Tabs可以控制instant app是否打开.<br>TextInputLayout加了密码可见的toggle.<br>Transition兼容到API 14及其以上.<br>Custom Tabs support library支持给secondary toolbar用RemoteViews.<br>AppCompatResources加了可以通过getDrawable()方法, 以resource id加载<vector>和<animated-vector>的功能.<br>CoordinatorLayout现在支持定义inset views, 然后指定其他Views给其让路. 就是当Snackbar出现的时候, FloatingActionButton躲开的那种行为, 只不过现在给任意的child view都可以设置了.<br>DiffUtil类可以计算出两个集合的不同, 然后得出一个更新操作的list, 可以交给RecyclerView.Adapter.<br>新增了RecyclerView.OnFlingListener. 有SnapHelper和LinearSnapHelper可供选择使用.</animated-vector></vector></p>
<p><strong>行为改变</strong>:<br>day/night模式改变的时候, activity将会自动重启.<br>如果status bar是透明的, Snacker现在会在navigation bar后面绘制.</p>
<p>其他还有一些deprecations和bug fixes.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> Wear </tag>
            
            <tag> Bottom Sheet </tag>
            
            <tag> Security </tag>
            
            <tag> Kotlin </tag>
            
            <tag> JobScheduler </tag>
            
            <tag> Trello </tag>
            
            <tag> TextInputLayout </tag>
            
            <tag> Code Style </tag>
            
            <tag> Java 8 </tag>
            
            <tag> Lambda </tag>
            
            <tag> Firebase </tag>
            
            <tag> AutoValue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Weekly Notes Issue 218]]></title>
      <url>http://mengdd.github.io/Android/Android-Weekly/2016/08/18/android-weekly-notes-issue-218/</url>
      <content type="html"><![CDATA[<h1 id="Android-Weekly-Issue-218"><a href="#Android-Weekly-Issue-218" class="headerlink" title="Android Weekly Issue #218"></a>Android Weekly Issue #218</h1><p>August 14th, 2016<br><a href="http://androidweekly.net/issues/issue-218" target="_blank" rel="external">http://androidweekly.net/issues/issue-218</a></p>
<a id="more"></a>
<h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h3 id="PathMorphing-with-AnimatedVectorDrawables"><a href="#PathMorphing-with-AnimatedVectorDrawables" class="headerlink" title="PathMorphing with AnimatedVectorDrawables"></a><a href="https://lewismcgeary.github.io/posts/animated-vector-drawable-pathMorphing/" target="_blank" rel="external">PathMorphing with AnimatedVectorDrawables</a></h3><p>Android 5.0 推出了<a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a>, 矢量图为处理多种屏幕尺寸的带来了很多好处. 这篇文章先介绍了VectorDrawable的使用, 然后主要讲如何实时操纵图像的改变, 用<a href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" target="_blank" rel="external">AnimatedVectorDrawable</a>实现一个图像变形的效果.<br>文中的例子是Android和Apple的log在互相变化.<br><a href="https://github.com/lewismcgeary/AndroidtoAppleVectorLogo" target="_blank" rel="external">source code available</a></p>
<h3 id="Android-UI-Instrumentation-test-with-Espresso"><a href="#Android-UI-Instrumentation-test-with-Espresso" class="headerlink" title="Android UI Instrumentation test with Espresso"></a><a href="http://mayojava.github.io/android/android-ui-instrumentation-test-with-espresso/" target="_blank" rel="external">Android UI Instrumentation test with Espresso</a></h3><p>用Espresso写UI功能测试, 通常是: 定位UI元素, 然后与其交互, 检查UI元素的状态.<br>三种主要的组件是: ViewMatchers, ViewActions 和ViewAssertions.<br>一个简短的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">onView(withId(R.id.my_view))            <span class="comment">// withId(R.id.my_view) - ViewMatcher</span></div><div class="line">    .perform(click())                  <span class="comment">// click() - ViewAction</span></div><div class="line">    .check(matches(isDisplayed()));   <span class="comment">//matches(isDisplayed()) - ViewAssertion</span></div></pre></td></tr></table></figure></p>
<p>为了测试不受animation的影响, 有时候可能需要把设备上的Developer Options里的下面几个animation全关掉:<br>Window animation scale<br>Transition animation scale<br>Animator duration scale<br>然后这个文章里有具体的例子介绍如何写并且运行测试, 还附有相关源码.</p>
<h3 id="How-to-Build-an-Android-App-for-Fire-TV-Part-1"><a href="#How-to-Build-an-Android-App-for-Fire-TV-Part-1" class="headerlink" title="How to Build an Android App for Fire TV - Part 1"></a><a href="https://medium.com/amazon-appstore/developing-for-the-living-room-how-to-build-an-android-app-for-fire-tv-part-1-6ae108106fd2#.n39tl15pa" target="_blank" rel="external">How to Build an Android App for Fire TV - Part 1</a></h3><p>创建在亚马逊的Fire TV上跑的Android应用.<br>文后可以点进part 2.</p>
<h3 id="Android-Wear-Development-for-beginners"><a href="#Android-Wear-Development-for-beginners" class="headerlink" title="Android Wear Development for beginners"></a><a href="https://medium.com/android-news/android-wear-development-for-beginners-82c2b06ff13a#.15v0ar2g3" target="_blank" rel="external">Android Wear Development for beginners</a></h3><p>Complication是指手表上显示的除了小时和分钟之外的东西, 比如, 一个电池指示标志.<br>使用了Complication API之后, 用户就可以自己选一个地方, 然后从应用的列表中选一个东东来显示.<br>Wear应用是嵌入到一个主应用里面的, 当google play上主应用的apk被安装到手机上的时候, Wearable应用会自动安装在配对的设备上.<br>这篇文章详细介绍了如何创建一个Wear应用, 代码在<a href="https://github.com/moyheen/radar-watch-face" target="_blank" rel="external">github</a></p>
<p>官方文档: <a href="https://developer.android.com/wear/preview/features/complications.html" target="_blank" rel="external">Watch Face Complications</a><br>官方sample: <a href="https://github.com/googlesamples/android-WatchFace" target="_blank" rel="external">android-WatchFace</a></p>
<h3 id="Router-—-Everything-in-its-Right-Place"><a href="#Router-—-Everything-in-its-Right-Place" class="headerlink" title="Router — Everything in its Right Place"></a><a href="https://medium.com/stories-from-eyeem/router-everything-in-its-right-place-4ca437871052#.cvou4493z" target="_blank" rel="external">Router — Everything in its Right Place</a></h3><p>之前有一篇文章介绍了用装饰者模式来构建高度模块化的Android应用: <a href="https://medium.com/stories-from-eyeem/creating-highly-modular-android-apps-933271fbdb7d#.4gtrccg9n" target="_blank" rel="external">Creating Highly Modular Android Apps</a><br>那篇文章里也有一个例子<a href="https://github.com/eyeem/decorator" target="_blank" rel="external">Decorator</a>.<br>这篇文章讲同样采用装饰者思想的一个库: <a href="https://github.com/eyeem/router" target="_blank" rel="external">Router</a>.</p>
<p>Router首先基于一个将URL映射到程序界面的库: <a href="https://github.com/clayallsopp/routable-android" target="_blank" rel="external">routable-android</a><br>Router在此基础上做出了一些扩展和改进, 可以用一个map文件(YAML/JSON/XML)来定义基本的构架.<br>输入是URL(可以带参数), 根据map进行解析, 然后传到plugins, 然后每个plugin创造一部分的输出, 当左右plugins的工作结束后, 输出就可用了(输出是由多个plugins组装而成的).<br>文末附有<a href="https://github.com/eyeem/router/tree/master/app" target="_blank" rel="external">sample</a>.</p>
<h3 id="Boosting-app-performance-with-reflectionless-de-serialization"><a href="#Boosting-app-performance-with-reflectionless-de-serialization" class="headerlink" title="Boosting app performance with reflectionless (de)serialization"></a><a href="http://makingvimeo.com/post/148808044404/boosting-app-performance-with-reflectionless" target="_blank" rel="external">Boosting app performance with reflectionless (de)serialization</a></h3><p>这篇文章研究了在解析JSON响应的时候如何提高效率.<br>作者他们的应用Vimeo Android用了Retrofit来做网络请求, 用Gson来反序列化, 不好的一点就是有点慢, 因为Gson用反射来解析JSON. 为了改进,他们想要去除反射.<br>他们创建了自己的Gson TypeAdapters, 并且利用程序中各个不同大小的model来测量对比了了反序列化的时间.<br>他们的实验测试了不同的机器对于不同大小model的处理, 在多数情况下, 不用反射会提高性能, 但是也有例外, 在解析很大的model时, 在高性能的机器上, 反而是使用反射的情况比较快.<br>他们的库: <a href="https://github.com/vimeo/stag-java" target="_blank" rel="external">stag-java</a><br>STAG: Speedy Type Adapter Generation.</p>
<h3 id="Introduction-to-Automated-Android-Testing-Part-4"><a href="#Introduction-to-Automated-Android-Testing-Part-4" class="headerlink" title="Introduction to Automated Android Testing - Part 4"></a><a href="https://riggaroo.co.za/introduction-android-testing-part-4/" target="_blank" rel="external">Introduction to Automated Android Testing - Part 4</a></h3><p>讲如何写测试的系列文章, 有一个案例sample: <a href="https://github.com/riggaroo/GithubUsersSearchApp" target="_blank" rel="external">GithubUsersSearchApp</a>.<br>举例了一个MVP的真实例子, 然后给P写单元测试.<br>Presenter里有一个CompositeSubscription, 用来管理RxJava的subscriptions, detach的时候会注销所有的订阅, 防止了内存泄露和可能存在危险的view操作.<br>还创建了一个Contract接口, 把View和Presenter的接口定义写在里面.<br>这里面还有很机智的一点是把RxJava要用到的Scheduler也从presenter的构造函数传入, 这样在测试的时候就可以使用<code>Schedulers.immediate()</code>, 而在View里面我们就按实际情况使用其他.</p>
<h3 id="Introduction-to-Android-Testing-Part-3"><a href="#Introduction-to-Android-Testing-Part-3" class="headerlink" title="Introduction to Android Testing - Part 3"></a><a href="https://riggaroo.co.za/introduction-android-testing-part3/" target="_blank" rel="external">Introduction to Android Testing - Part 3</a></h3><p>这应该是跟上面那条一个系列文章的第三篇.<br>介绍了如何用Retrofit和RxJava请求Github API然后解析到models.<br>后面是写单元测试, 步骤很清楚, given, when, then.<br>可以从中学习一下怎么给这种Retrofit + RxJava的程序写单元测试.</p>
<h3 id="Git-as-a-secure-private-Maven-repository"><a href="#Git-as-a-secure-private-Maven-repository" class="headerlink" title="Git as a secure private Maven repository"></a><a href="http://jeroenmols.com/blog/2016/02/05/wagongit/" target="_blank" rel="external">Git as a secure private Maven repository</a></h3><p><a href="https://bitbucket.org/" target="_blank" rel="external">Bitbucket</a> is a web-based hosting service for projects using Git.<br>讲了如何使用BitBucket或者Github作为一个private的Maven repository.<br>例子: <a href="https://github.com/JeroenMols/WagonGitExample" target="_blank" rel="external">WagonGitExample</a><br>Gradle 脚本: <a href="https://github.com/JeroenMols/GitAsMaven" target="_blank" rel="external">GitAsMaven</a></p>
<h3 id="Crash-reporting-in-Firebase"><a href="#Crash-reporting-in-Firebase" class="headerlink" title="Crash reporting in Firebase"></a><a href="http://segunfamisa.com/posts/firebase-crash-reporting" target="_blank" rel="external">Crash reporting in Firebase</a></h3><p>比较简单的一个文章, 如何set up Firebase的crash reporting.<br>其实Firebase Crash Reporting一旦构建好之后, 不需要加java代码, 所有uncaught的异常都是自动报告的.<br><a href="https://firebase.google.com/docs/crash/android" target="_blank" rel="external">Firebase Report Crashes</a>.</p>
<h3 id="Isometric-AnimatedVectorDrawable-–-Part-1"><a href="#Isometric-AnimatedVectorDrawable-–-Part-1" class="headerlink" title="Isometric AnimatedVectorDrawable – Part 1"></a><a href="https://blog.stylingandroid.com/isometric-animatedvectordrawable-part-1/" target="_blank" rel="external">Isometric AnimatedVectorDrawable – Part 1</a></h3><p>神奇的<a href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" target="_blank" rel="external">AnimatedVectorDrawable</a>, 这篇文章讲了用它来实现栅格地形图, 游戏里可以升降的草地的类似的东东. (看文章里的图吧, 我也形容不好.)<br>遗憾的是pathData animation当前在VectorDrawableCompat library暂不支持, 所以文中所讲的技术只能在api 21及其之上使用.<br>文中的例子有9个方块, 4个三角形, 把SVG作为矢量图VectorDrawable导入Android Studio, 然后给每一个path起名字.<br>本文只是part 1, 预告了下一篇文章将讲如何动画.<br>Source code available here: <a href="https://github.com/StylingAndroid/IsometricAnimatedVector/tree/Part1" target="_blank" rel="external">IsometricAnimatedVector</a></p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Don’t-just-port-an-iOS-navigation-model-to-Android"><a href="#Don’t-just-port-an-iOS-navigation-model-to-Android" class="headerlink" title="Don’t just port an iOS navigation model to Android"></a><a href="http://www.androidpolice.com/2016/08/13/opinion-bottom-navigation-material-guidelines-platform-awareness/" target="_blank" rel="external">Don’t just port an iOS navigation model to Android</a></h3><p>关于bottom nav bars的讨论.<br>Hamburger menu有时候感觉不是很理想, 是因为抽屉里的items总是隐藏状态, 用户不易发现和使用.<br>Bottom bar则把每一个item都时刻展现给用户, 在iOS上使用得很成功.<br>Google在2016年3月提供了Guides: <a href="https://material.google.com/components/bottom-navigation.html" target="_blank" rel="external">Bottom navigation</a>.</p>
<ul>
<li>什么时候该用bottom navigation呢?<br>应用有3到5个top级别的目的地, 且它们需要直接被访问, 从各个目的地之间转换, 并且它们应该是具有同等重要性的.</li>
<li>什么时候bottom navigation不适用呢?<br>不能因为怕用户看不见一个东东, 就把它放在bottom nav bar, 作为推广手段.<br>bottom nav bar也不是用来放menu的, 比如放不下了加个more tab, 展开以后是更多的二级页面入口; 也不要用来放一些弹出窗口, 它们同样也不是top level的目的地.<br>bottom nav bar不能放低级别的目的地.<br>最后文章强调了每个平台应该遵从自己的特性, 对Android来说, 如果完全拷贝iOS的设计可能不是一个好主意.</li>
</ul>
<h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h3 id="stag-java"><a href="#stag-java" class="headerlink" title="stag-java"></a><a href="https://github.com/vimeo/stag-java" target="_blank" rel="external">stag-java</a></h3><p>Stag通过减少反射改善了Gson的性能, 为你的model对象自动生成TypeAdapters.</p>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a><a href="https://github.com/eyeem/router" target="_blank" rel="external">Router</a></h3><p>一个基于routable-android的新的Android URL router, 摒弃了Activity/Intent依赖, 并加入了新的特性.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Android Weekly </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Weekly </tag>
            
            <tag> AnimatedVectorDrawable </tag>
            
            <tag> Espresso </tag>
            
            <tag> TV </tag>
            
            <tag> Wear </tag>
            
            <tag> Router </tag>
            
            <tag> Performance </tag>
            
            <tag> Maven </tag>
            
            <tag> Bottom Navigation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CoordinatorLayout, AppBarLayout, CollapsingToolbarLayout使用]]></title>
      <url>http://mengdd.github.io/Android/Design-Support-Library/2016/07/04/design-support-library-AppBarLayout/</url>
      <content type="html"><![CDATA[<p>本文介绍Design Support Library中CoordinatorLayout, AppBarLayout, CollapsingToolbarLayout的使用.<br>先列出了Design Support Library中的Features, 然后如何set up, 最后附有Demo程序, 介绍CoordinatorLayout, AppBarLayout, CollapsingToolbarLayout的使用.</p>
<a id="more"></a>
<h2 id="Design-Support-Library-Features"><a href="#Design-Support-Library-Features" class="headerlink" title="Design Support Library Features"></a>Design Support Library Features</h2><p>Design Support Library中有</p>
<ul>
<li><a href="https://guides.codepath.com/android/Floating-Action-Buttons" target="_blank" rel="external">FloatingActionButton</a></li>
<li><a href="https://guides.codepath.com/android/Google-Play-Style-Tabs-using-TabLayout" target="_blank" rel="external">TabLayout</a></li>
<li><a href="https://guides.codepath.com/android/Fragment-Navigation-Drawer" target="_blank" rel="external">NavigationView</a></li>
<li><a href="https://guides.codepath.com/android/Displaying-the-Snackbar" target="_blank" rel="external">SnackBar</a></li>
<li><a href="https://guides.codepath.com/android/Working-with-the-EditText#displaying-floating-label-feedback" target="_blank" rel="external">TextInputLayout</a></li>
<li><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout" target="_blank" rel="external">CoordinatorLayout</a></li>
<li><a href="https://developer.android.com/reference/android/support/design/widget/AppBarLayout.html" target="_blank" rel="external">AppBarLayout</a></li>
<li><a href="https://developer.android.com/reference/android/support/design/widget/CollapsingToolbarLayout.html" target="_blank" rel="external">CollapsingToolbarLayout</a></li>
<li><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout#bottom-sheets" target="_blank" rel="external">Bottom Sheets</a></li>
<li><a href="https://guides.codepath.com/android/Constructing-View-Layouts#percentrelativelayout" target="_blank" rel="external">PercentRelativeLayout</a> and <a href="https://developer.android.com/reference/android/support/percent/PercentFrameLayout.html" target="_blank" rel="external">PercentFrameLayout</a></li>
<li><a href="https://guides.codepath.com/android/Drawables#vector-drawables" target="_blank" rel="external">Vector Drawables</a></li>
</ul>
<h2 id="Design-Support-Library-Setup"><a href="#Design-Support-Library-Setup" class="headerlink" title="Design Support Library Setup"></a>Design Support Library Setup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">   compileSdkVersion 23  // needs to be consistent with major support libs used</div><div class="line">&#125;</div><div class="line"></div><div class="line">ext &#123;</div><div class="line">  supportLibVersion = &apos;23.4.0&apos;  // variable that can be referenced to keep support libs consistent</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &quot;com.android.support:appcompat-v7:$&#123;supportLibVersion&#125;&quot;</div><div class="line">    compile &quot;com.android.support:design:$&#123;supportLibVersion&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CoordinatorLayout-AppBarLayout使用"><a href="#CoordinatorLayout-AppBarLayout使用" class="headerlink" title="CoordinatorLayout, AppBarLayout使用"></a>CoordinatorLayout, AppBarLayout使用</h2><p><a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html" target="_blank" rel="external">CoordinatorLayout</a><br>实际上是一个更强大的FrameLayout, 可以通过<a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" target="_blank" rel="external">Behavior</a> 来控制其中各个child view的交互行为. 也可以指定anchor来指定floating view相对于其他某个View的位置. 比如Floating Action Button在显示Snackbar的时候自动向上移动.</p>
<p>为了使Toolbar响应滚动事件, 我们需要给它外边包一个<a href="https://developer.android.com/reference/android/support/design/widget/AppBarLayout.html" target="_blank" rel="external">AppBarLayout</a>.<br>它是一个纵向的LinearLayout, 必须要作为CoordinateLayout的直接child使用.<br>然后, 我们需要定义AppBarLayout和我们scroll的内容View的关系.<br>这里可以是一个RecyclerView, 或者其他支持嵌套scrolling的view, 比如<a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView.html" target="_blank" rel="external">NestedScrollView</a></p>
<p>(实际上View类就有方法setNestedScrollingEnabled(), 但是还是需要View自己实现nested scrolling的功能, 否则这个开关也没有效果.)</p>
<p>support library提供了<code>@string/appbar_scrolling_view_behavior</code>, 它映射到<code>AppBarLayout.ScrollingViewBehavior</code>.<br>它是用来告诉AppBarLayout下面那个scroll view上的scroll事件什么时候发生.<br>所以这个属性必须在触发事件的view上指定, 比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/rvToDoList"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</div></pre></td></tr></table></figure>
<p>当CoordinatorLayout看到自己的child(比如RecyclerView)声明了这个属性, 就会在自己的其他child中寻找相关的view(AppBarLayout).<br>这样, 当RecyclerView发生scroll事件的时候, AppBarLayout和其中的views都会被通知到.</p>
<p>滚动事件怎么通知到AppBarLayout的呢? 还需要一个属性: <code>app:layout_scrollFlags</code>.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>app:layout_scrollFlags</code>属性中:</p>
<ul>
<li><code>scroll</code>必须有, 这样scroll的任何效果才能生效.</li>
<li><code>enterAlways</code>: 表示只要列表上方内容滚动出现, View就应该出现. 适用的情形: 当把列表滚到底部时, Toolbar被隐藏了, 一旦回滚一点儿, Toolbar就应该立即出现. 如果不设置这个flag, 默认的行为是一直要把列表滚到顶部, Toolbar才会出现.</li>
<li><code>enterAlwaysCollapsed</code>: 正常情况下, 如果只有<code>enterAlways</code>被指定, 在列表向下滚动的过程中Toolbar将会一直展开.<br>如果同时指定了<code>enterAlwaysCollapsed</code>和<code>minHeight</code>, 那么开始滚动以后, 只滚动到minHeight为止, 直到滚动到达列表顶部的时候, view才会展开到全部高度.</li>
<li><code>exitUntilCollapsed</code>: 正常只指定scroll的情况下, scrolling down(即显示列表底部)将会使得整个Toolbar移动到不见.<br>如果同时指定了<code>exitUntilCollapsed</code>和<code>minHeight</code>, 那么将会收缩到minHeight为止, Toolbar不会一直滚动和退出屏幕.</li>
<li><code>snap</code>: 使用了这个属性, 等scroll事件结束的时候, View可见的尺寸小于它的50%, 则它会直接消失, 如果大于50%, 则它会完整地出现.</li>
</ul>
<p>还可以用<code>app:layout_scrollInterpolator</code>属性指定滚动动画效果的插值器.</p>
<h3 id="折叠效果"><a href="#折叠效果" class="headerlink" title="折叠效果"></a>折叠效果</h3><p>如果想要折叠Toolbar的效果, 可以在Toolbar外面包一层<a href="https://developer.android.com/reference/android/support/design/widget/CollapsingToolbarLayout.html" target="_blank" rel="external">CollapsingToolbarLayout</a><br>这个类必须作为AppBarLayout的直接child使用.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">            <span class="attr">app:contentScrim</span>=<span class="string">"?attr/colorPrimary"</span></div><div class="line">            <span class="attr">app:expandedTitleMarginEnd</span>=<span class="string">"64dp"</span></div><div class="line">            <span class="attr">app:expandedTitleMarginStart</span>=<span class="string">"48dp"</span></div><div class="line">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</div><div class="line"></div><div class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">                <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">                <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">                <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span>&gt;<span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>包了这个类之后, setTitle要调用这个类的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar);</div><div class="line">collapsingToolbar.setTitle(<span class="string">"Title"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="背景图平行淡出"><a href="#背景图平行淡出" class="headerlink" title="背景图平行淡出"></a>背景图平行淡出</h3><p>这个类使得我们可以做更高级的动画效果, 比如放一个ImageView, 它在折叠的时候淡出.<br>这时候需要把ImageView的<code>app:layout_collapseMode</code>属性置为<code>parallax</code>.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/appbar"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></div><div class="line">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">app:contentScrim</span>=<span class="string">"?attr/colorPrimary"</span></div><div class="line">        <span class="attr">app:expandedTitleMarginEnd</span>=<span class="string">"64dp"</span></div><div class="line">        <span class="attr">app:expandedTitleMarginStart</span>=<span class="string">"48dp"</span></div><div class="line">        <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span></div><div class="line">        <span class="attr">app:layout_scrollInterpolator</span>=<span class="string">"@anim/hero_image_interpolator"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/logo"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:contentDescription</span>=<span class="string">"@null"</span></div><div class="line">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></div><div class="line">            <span class="attr">android:scaleType</span>=<span class="string">"fitCenter"</span></div><div class="line">            <span class="attr">android:src</span>=<span class="string">"@drawable/android_logo"</span></div><div class="line">            <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span></div><div class="line">            <span class="attr">app:layout_collapseParallaxMultiplier</span>=<span class="string">"0.1"</span> /&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">            <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span></div><div class="line">            <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>这里推荐Demo: <a href="https://github.com/mengdd/AndroidDesignWidgetsSample" target="_blank" rel="external">AndroidDesignWidgetsSample</a><br><img src="/images/AndroidDesignWidgetsSample-screen-video.gif" alt="Android Design Widgets Sample screen video"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout" target="_blank" rel="external">Handling Scrolls with CoordinatorLayout</a><br><a href="https://material.google.com/patterns/scrolling-techniques.html#scrolling-techniques-behavior" target="_blank" rel="external">Material Design: scrolling techniques</a><br><a href="https://guides.codepath.com/android/Design-Support-Library#official-source-code" target="_blank" rel="external">Design Support Library</a><br><a href="http://saulmm.github.io/mastering-coordinator" target="_blank" rel="external">Mastering the Coordinator Layout</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Design Support Library </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Toolbar </tag>
            
            <tag> Design Support Library </tag>
            
            <tag> AppBarLayout </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Using Dagger2 in Android]]></title>
      <url>http://mengdd.github.io/Android/2016/06/24/using-dagger2-in-android/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/google/dagger" target="_blank" rel="external">Dagger2</a>是一个Java和Android的依赖注入框架.<br>本文介绍Android中dagger2的基本使用.<br>其中包括<code>@Inject</code>, <code>@Component</code>, <code>@Module</code>和<code>@Provides</code>注解的使用.</p>
<a id="more"></a>
<h1 id="使用依赖注入的好处"><a href="#使用依赖注入的好处" class="headerlink" title="使用依赖注入的好处"></a>使用依赖注入的好处</h1><p>1.使用类和被依赖的对象构造分开,这样如果我们需要改变被依赖类的构造方法,不必改动每一个使用类.<br>2.对各种被依赖类的实例,可以只构造一次.<br>3.当我们需要更换一种实现时,只需要保证接口一致.<br>4.利于单元测试,我们可以方便地mock依赖类的对象.</p>
<p>优点总结: 创建对象和使用对象分离, 模块化增强.</p>
<h1 id="Dagger2的使用"><a href="#Dagger2的使用" class="headerlink" title="Dagger2的使用"></a>Dagger2的使用</h1><h2 id="Set-Up"><a href="#Set-Up" class="headerlink" title="Set Up"></a>Set Up</h2><p>在项目的<strong>build.gradle</strong>里加这个:<br>classpath ‘com.neenbedankt.gradle.plugins:android-apt:1.8’</p>
<p>然后<strong>app的build.gradle</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line">apply plugin: &apos;com.neenbedankt.android-apt&apos;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 24</div><div class="line">    buildToolsVersion &quot;24.0.0&quot;</div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.ddmeng.dagger2sample&quot;</div><div class="line">        minSdkVersion 16</div><div class="line">        targetSdkVersion 24</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    testCompile &apos;junit:junit:4.12&apos;</div><div class="line">    compile &apos;com.android.support:appcompat-v7:24.0.0&apos;</div><div class="line">    compile &apos;javax.annotation:jsr250-api:1.0&apos;</div><div class="line">    compile &apos;com.google.dagger:dagger:2.2&apos;</div><div class="line">    apt &apos;com.google.dagger:dagger-compiler:2.2&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>最常使用的主要是以下这几个注解:</p>
<p><a href="http://google.github.io/dagger/api/latest/dagger/Component.html" target="_blank" rel="external">@Component</a><br>Annotates an interface or abstract class for which a fully-formed, dependency-injected implementation is to be generated from a set of modules(). The generated class will have the name of the type annotated with @Component prepended with Dagger. For example, @Component interface MyComponent {…} will produce an implementation named DaggerMyComponent.</p>
<p><a href="http://google.github.io/dagger/api/latest/dagger/Module.html" target="_blank" rel="external">@Module</a><br>Annotates a class that contributes to the object graph.</p>
<p><a href="http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html" target="_blank" rel="external">@Inject</a><br>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the javax.inject.Inject annotation to identify which constructors and fields it is interested in.</p>
<p>Use @Inject to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
<p><a href="http://google.github.io/dagger/api/latest/dagger/Provides.html" target="_blank" rel="external">@Provides</a><br>Annotates methods of a module to create a provider method binding. The method’s return type is bound to its returned value. The component implementation will pass dependencies to the method as parameters.</p>
<h2 id="Dagger2基本使用"><a href="#Dagger2基本使用" class="headerlink" title="Dagger2基本使用"></a>Dagger2基本使用</h2><h3 id="最简单的一个实例"><a href="#最简单的一个实例" class="headerlink" title="最简单的一个实例"></a>最简单的一个实例</h3><p>首先写一个Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = MyApplicationModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyApplicationComponent</span> </span>&#123;</div><div class="line">    <span class="comment">// this should be an interface or abstract class</span></div><div class="line"></div><div class="line">    <span class="comment">// write like this, and Make Project, then a DaggerMyApplicationComponent class will be generated</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时里面的Module内容可以暂时为空:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationModule</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写好后make一下,就生成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.ddmeng.dagger2sample.component;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.ddmeng.dagger2sample.<span class="keyword">module</span>.MyApplicationModule;</div><div class="line"><span class="keyword">import</span> dagger.internal.Preconditions;</div><div class="line"><span class="keyword">import</span> javax.annotation.Generated;</div><div class="line"></div><div class="line"><span class="meta">@Generated</span>(</div><div class="line">  value = <span class="string">"dagger.internal.codegen.ComponentProcessor"</span>,</div><div class="line">  comments = <span class="string">"https://google.github.io/dagger"</span></div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerMyApplicationComponent</span> <span class="keyword">implements</span> <span class="title">MyApplicationComponent</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerMyApplicationComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyApplicationComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MyApplicationComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerMyApplicationComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@deprecated</span> This module is declared, but an instance is not used in the component. This method is a no-op. For more, see https://google.github.io/dagger/unused-modules.</div><div class="line">     */</div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">myApplicationModule</span><span class="params">(MyApplicationModule myApplicationModule)</span> </span>&#123;</div><div class="line">      Preconditions.checkNotNull(myApplicationModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要切换到project视图下才能看见.<br>生成的这个实现,名字是在我们自己的Component名前面加了Dagger.<br>如果我们的类名不是顶级的,即还有外部类,则会以下划线分隔连接.</p>
<p>现在我们的生成的myApplicationModule()方法被标记为<code>@Deprecated</code>,这是因为我的module里面什么都还没有呢,所以被认为是没有必要的.</p>
<p>现在我们添加一个要用的LogUtils类. 想要在MainActivity里面用.<br>写好LogUtils类,在构造函数上标记<code>@Inject</code>. 这时候就将LogUtils加入了dependency graph中, 相当于作为预备队员.</p>
<p>想要在MainActivity作为一个字段用,<br>在Component里面写一句:<br><code>void inject(MainActivity activity);</code></p>
<p>因为此时还是没有用到Module,所以在application里面可以直接build,保存component:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MyApplicationComponent component;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        component = DaggerMyApplicationComponent.builder().build();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> MyApplicationComponent <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> component;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在MainActivity使用的时候, 先get到Component, 然后调用inject()方法, 字段就被注入了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    LogUtils logUtils;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ((SampleApplication) getApplication()).getComponent().inject(<span class="keyword">this</span>);</div><div class="line">        logUtils.i(<span class="string">"tag"</span>, <span class="string">"hi, I'm an instance of LogUtils"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序后可以看到打出log,证明注入成功.</p>
<p>此时我们看到生成的代码有三个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerMyApplicationComponent</span> <span class="keyword">implements</span> <span class="title">MyApplicationComponent</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LogUtils_Factory implements Factory&lt;LogUtils&gt; &#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</div></pre></td></tr></table></figure>
<p>可以通过查看调用栈来看调用关系.</p>
<h3 id="单例-Singleton"><a href="#单例-Singleton" class="headerlink" title="单例@Singleton"></a>单例<code>@Singleton</code></h3><p>如果我们想让工具类是单例,只需要在上面的基础上,在类名前加上<code>@Singleton</code>.</p>
<p>此时对应的Component也需要加上<code>@Singleton</code>.否则编译会不通过.<br>加好之后,可以打印hashCode()看出, 标记了<code>@Singleton</code>的这个对象,不论被注入几次,都是同一个对象.</p>
<p>在我们的例子中, 可以让FileUtils作为一个单例被注入:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileUtils</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(LogUtils.TAG, <span class="string">"new FileUtils: "</span> + hashCode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(LogUtils.TAG, <span class="string">"do sth with FileUtils "</span> + hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看生成的代码,可以看见<code>DaggerMyApplicationComponent</code>为单例的类多保存了一个字段:<br><code>private Provider&lt;FileUtils&gt; fileUtilsProvider;</code></p>
<p>它在init的时候被初始化为:<br><code>this.fileUtilsProvider = ScopedProvider.create(FileUtils_Factory.create());</code></p>
<p>包了一层之后,在ScopeProvider里实现了单例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// double-check idiom from EJ2: Item 71</span></div><div class="line">  Object result = instance;</div><div class="line">  <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      result = instance;</div><div class="line">      <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</div><div class="line">        instance = result = factory.get();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Module-和-Provides的使用"><a href="#Module-和-Provides的使用" class="headerlink" title="@Module 和 @Provides的使用"></a><code>@Module</code> 和 <code>@Provides</code>的使用</h3><p>上面的注入都是用<code>@Inject</code>, 在构造函数和要使用的字段上标记.<br>有些情况下<code>@Inject</code>是不能满足需求的.</p>
<p><strong>But @Inject doesn’t work everywhere</strong>.</p>
<ol>
<li>Interfaces can’t be constructed. 接口类型不能直接被构造.</li>
<li>Third-party classes can’t be annotated. 第三方的类不能改动它的代码.</li>
<li>Configurable objects must be configured! 需要配置的对象需要被配置.</li>
</ol>
<p>这些情况下, <code>@Inject</code>不够用啦, 这时候就要用<code>@Provides</code>标记的方法.<br>方法的返回值返回了它满足的依赖, 它实际返回的对象可以是返回值接口的实现,或者是返回值类型的子类.<br><code>@Provides</code>方法也可以有依赖, 即它的参数.<br>Dagger会注入它的参数值, 如果它的参数值不能被注入, 则编译会失败.<br>注意这个寻找参数注入的过程是在<code>@Component</code>级别的, 只要这个Component里面有这个参数类型的注入, 即便可能是在另一个Module, 就会自动采用.</p>
<p>所有的<code>@Provides</code>方法都需要放在<code>@Module</code>里面.<br>按照命名习惯(By convention), 一般<code>@Provides</code>标记的方法都有一个provide前缀, 而module类都有一个Module后缀.<br>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationModule</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">providesContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Inject interface, return implementation class instance</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HttpUtil <span class="title">provideHttpUtil</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(LogUtils.TAG, <span class="string">"provideHttpUtil"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHttpUtil();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Inject class from third-party, or Android framework service</span></div><div class="line">    <span class="comment">// This provide method need a parameter, Dagger will obtain the parameter value (injected it)</span></div><div class="line">    <span class="comment">// If the parameter is not injectable, then compilation failed</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@Singleton</span></div><div class="line">    <span class="function">ConnectivityManager <span class="title">provideConnectivityManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Dagger2中几种常用注解总结"><a href="#Dagger2中几种常用注解总结" class="headerlink" title="Dagger2中几种常用注解总结"></a>Dagger2中几种常用注解总结</h1><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a><code>@Inject</code></h3><p><code>@Inject</code>的用法分为三种</p>
<ul>
<li>构造函数上的<code>@Inject</code>:</li>
</ul>
<p>如果构造函数是有参数的, 则它的所有参数都会自动从dependency graph中找到并注入.<br>同时构造的这个类也被作为dependency graph的一部分.<br>但是我们在一个类中最多只能用@Inject标记一个构造方法.</p>
<ul>
<li>字段上的<code>@Inject</code>: 从dependency graph中找到并注入字段.</li>
</ul>
<p>这里需要手动调用<br><code>(SampleApplication) getApplication()).getComponent().inject(this);</code><br>类似的方法, 在这个方法被调用之前, 字段都是null.<br>注意这里的字段不能是private的.</p>
<ul>
<li>public方法上的<code>@Inject</code>:</li>
</ul>
<p>所有方法的参数都会由dependency graph提供.<br>方法注入在构造函数<em>之后</em>立即调用, 意味着我们可以用一个构建好的this对象.</p>
<h3 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a><code>@Module</code> 和 <code>@Provides</code></h3><p><code>@Module</code>标记了提供依赖的类, 其中包含了一些<code>@Provides</code>标注的方法, 返回值即依赖.</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><code>@Component</code></h3><p>用<code>@Component</code>标记的接口负责将所有的事情联系起来, 可以看做是<code>@Module</code>和<code>@Inject</code>之间的桥梁.<br>我们可以定义我们用的依赖来自哪些Module或者Component.</p>
<p>在Component里可以定义哪些依赖是公有的 (提供返回值为某种依赖的无参数方法) , 也可以定义我们的component可以去哪里inject对象 (void inject()方法, 参数是去注入的地方) .</p>
<p><code>@Component</code>可以有自己的子Component, 也可以有lifecycle.</p>
<p>先就这么多吧, 更多更高级的使用可以期待下文, 也可以参见后面的参考资料.</p>
<p>本文地址: <a href="http://www.cnblogs.com/mengdd/p/5613889.html" target="_blank" rel="external">Using Dagger2 in Android</a><br>本文Demo: <a href="https://github.com/mengdd/dagger2-sample" target="_blank" rel="external">dagger2-sample</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><p><a href="https://github.com/google/dagger" target="_blank" rel="external">dagger2 repo</a><br><a href="http://google.github.io/dagger/" target="_blank" rel="external">dagger2 website</a><br><a href="http://google.github.io/dagger/users-guide.html" target="_blank" rel="external">User Guide</a></p>
<p><a href="https://docs.google.com/document/d/1fwg-NsMKYtYxeEWe82rISIHjNrtdqonfiHgp8-PQ7m8/edit" target="_blank" rel="external">Dagger 2.0文档</a><br><a href="https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee" target="_blank" rel="external">dagger 2的sample</a></p>
<p>这里有些guides:<br><a href="https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2" target="_blank" rel="external">Code Path Guides: DI with dagger2</a><br><a href="https://blog.gouline.net/dagger-2-even-sharper-less-square-b52101863542#.me0ieiaph" target="_blank" rel="external">Dagger2</a></p>
<p>这里有一系列关于Dagger2的文章还挺好的:<br><a href="http://frogermcs.github.io/" target="_blank" rel="external">Froger_mcs dev blog</a><br><a href="http://frogermcs.github.io/dagger-1-to-2-migration/" target="_blank" rel="external">dagger 1 to dagger 2 migration</a><br><a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-introdution-to-di/" target="_blank" rel="external">Introduction to DI</a><br><a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/" target="_blank" rel="external">Dagger2 API</a><br><a href="https://medium.com/@froger_mcs/inject-everything-viewholder-and-dagger-2-e1551a76a908#.e3zxrynq4" target="_blank" rel="external">Inject everything - ViewHolder and Dagger2 (with Multibinding and AutoFactory example)</a><br><a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/" target="_blank" rel="external">Custom Scope</a></p>
<p>作者的例子:<br><a href="https://github.com/frogermcs/GithubClient" target="_blank" rel="external">Github Client</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Fragment使用(四) Toolbar使用及Fragment中的Toolbar处理]]></title>
      <url>http://mengdd.github.io/Android/2016/06/16/android-fragment-usage-4-toolbar/</url>
      <content type="html"><![CDATA[<h1 id="Toolbar作为ActionBar使用介绍"><a href="#Toolbar作为ActionBar使用介绍" class="headerlink" title="Toolbar作为ActionBar使用介绍"></a>Toolbar作为ActionBar使用介绍</h1><p>本文介绍了在Android中将Toolbar作为ActionBar使用的方法.<br>并且介绍了在Fragment和嵌套Fragment中使用Toolbar作为ActionBar使用时需要注意的事项.<br><a id="more"></a></p>
<h2 id="使用support-library的Toolbar"><a href="#使用support-library的Toolbar" class="headerlink" title="使用support library的Toolbar"></a>使用support library的Toolbar</h2><p>Android的ActionBar每个版本都会做一些改变, 所以原生的ActionBar在不同的系统上看起来可能会不一样.<br>使用support library版本的<a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html" target="_blank" rel="external">Toolbar</a>可以让你的应用在多种设备类型上保持一致. support library中总是包含了最新的features.<br>Android从5.0 (API Level 21)开始提供<a href="https://developer.android.com/design/material/index.html" target="_blank" rel="external">Material Design</a>, 使用v7版本的Toolbar后, 在任何Android 2.1(API Level 7)以上的机器上都可以看到Material Design风格的Toolbar.</p>
<h2 id="在Activity中使用Toolbar"><a href="#在Activity中使用Toolbar" class="headerlink" title="在Activity中使用Toolbar"></a>在Activity中使用Toolbar</h2><p>1.首先项目gradle中添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:appcompat-v7:23.4.0&apos;</div></pre></td></tr></table></figure></p>
<p>2.确保Activity继承<code>AppCompatActivity</code><br>3.在application设置中使用NoActionBar的主题:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Light.NoActionBar"</span></div><div class="line">    /&gt;</div></pre></td></tr></table></figure>
<p>4.把Toolbar写在布局中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></div><div class="line">   <span class="attr">android:id</span>=<span class="string">"@+id/my_toolbar"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></div><div class="line">   <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></div><div class="line">   <span class="attr">android:elevation</span>=<span class="string">"4dp"</span></div><div class="line">   <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.ActionBar"</span></div><div class="line">   <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span>/&gt;</div></pre></td></tr></table></figure>
<p>5.在Activity里面把Toolbar设置成为ActionBar<br>首先把Toolbar find出来, 然后调用<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#setSupportActionBar(android.support.v7.widget.Toolbar" target="_blank" rel="external">setSupportActionBar方法</a>)<br>把Toolbar设置为自己的ActionBar即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolbarDemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.toolbar)</div><div class="line">    Toolbar toolbar;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_toolbar_demo);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        setSupportActionBar(toolbar);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就可以随意使用啦, 用<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#getSupportActionBar(" target="_blank" rel="external">getSupportActionBar</a>)可以获取ActionBar类型的对象, 从而使用<a href="https://developer.android.com/reference/android/support/v7/app/ActionBar.html" target="_blank" rel="external">ActionBar</a>的方法.</p>
<h3 id="添加Action-Buttons"><a href="#添加Action-Buttons" class="headerlink" title="添加Action Buttons"></a>添加Action Buttons</h3><p>定义menu:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/action_android"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_android_black_24dp"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"@string/action_android"</span></div><div class="line">        <span class="attr">app:showAsAction</span>=<span class="string">"always"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/action_favourite"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_favorite_black_24dp"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"@string/action_favourite"</span></div><div class="line">        <span class="attr">app:showAsAction</span>=<span class="string">"ifRoom"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/action_settings"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"@string/action_settings"</span></div><div class="line">        <span class="attr">app:showAsAction</span>=<span class="string">"never"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在代码中inflate和处理它的点击事件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</div><div class="line">    Log.i(TAG, <span class="string">"onCreateOptionsMenu()"</span>);</div><div class="line">    getMenuInflater().inflate(R.menu.menu_activity_main, menu);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">        <span class="keyword">case</span> R.id.action_android:</div><div class="line">            Log.i(TAG, <span class="string">"action android selected"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">case</span> R.id.action_favourite:</div><div class="line">            Log.i(TAG, <span class="string">"action favourite selected"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">case</span> R.id.action_settings:</div><div class="line">            Log.i(TAG, <span class="string">"action settings selected"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加向上返回的action"><a href="#添加向上返回的action" class="headerlink" title="添加向上返回的action"></a>添加向上返回的action</h3><p>添加向上返回parent的action:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_toolbar_demo);</div><div class="line">    ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">    setSupportActionBar(toolbar);</div><div class="line"></div><div class="line">    <span class="comment">// add a left arrow to back to parent activity,</span></div><div class="line">    <span class="comment">// no need to handle action selected event, this is handled by super</span></div><div class="line">    getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后只需要在manifest中指定parent:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".toolbar.ToolbarDemoActivity"</span></div><div class="line">    <span class="attr">android:parentActivityName</span>=<span class="string">".MainActivity"</span>&gt;<span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="在Fragment中使用Toolbar"><a href="#在Fragment中使用Toolbar" class="headerlink" title="在Fragment中使用Toolbar"></a>在Fragment中使用Toolbar</h2><p>在Fragment中使用Toolbar的步骤和Activity差不多.<br>在Fragment布局中添加一个Toolbar, 然后find它, 然后调用Activity的方法来把它设置成ActionBar:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((AppCompatActivity) getActivity()).setSupportActionBar(toolbar);</div></pre></td></tr></table></figure></p>
<p>注意此处有一个强转, 必须是AppCompatActivity才有这个方法.<br>但是此时运行到Fragment之后, 发现Toolbar上的文字和按钮全是Activity传过来的, 这是因为只有Activity的<code>onCreateOptionsMenu()</code>被调用了, 但是Fragment的并没有被调用.<br>在Fragment中加上这句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setHasOptionsMenu(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>此时Fragment的<code>onCreateOptionsMenu()</code>回调会被调到了, 但是inflate出的按钮和Activity中的actions加在一起显示出来了.<br>因为Activity的<code>onCreateOptionsMenu()</code>会在之前调用到.<br>于是Fragment中的写成这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu, MenuInflater inflater)</span> </span>&#123;</div><div class="line">    Log.e(TAG, <span class="string">"onCreateOptionsMenu()"</span>);</div><div class="line">    menu.clear();</div><div class="line">    inflater.inflate(R.menu.menu_parent_fragment, menu);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即先clear()一下, 这样按钮就只有Fragment中设置的自己的了, 不会有Activity中的按钮.</p>
<h2 id="在嵌套的子Fragment中使用Toolbar"><a href="#在嵌套的子Fragment中使用Toolbar" class="headerlink" title="在嵌套的子Fragment中使用Toolbar"></a>在嵌套的子Fragment中使用Toolbar</h2><p>前面已经介绍过, Fragment可以嵌套使用: <a href="http://www.cnblogs.com/mengdd/p/5552721.html" target="_blank" rel="external">Android Fragment使用(二) 嵌套Fragments (Nested Fragments) 的使用及常见错误</a>.<br>那么在前面的Fragment中再显示一个子Fragment, 并且又带有一个不一样的Toolbar, 还需要哪些处理呢?<br>首先, java代码中还是需要有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setHasOptionsMenu(<span class="keyword">true</span>)</div><div class="line">((AppCompatActivity) getActivity()).setSupportActionBar(toolbar);</div></pre></td></tr></table></figure></p>
<p>然后根据是否需要菜单按钮, 覆写onCreateOptionsMenu()方法来inflate自己的menu文件即可.<br>感觉和在普通的Fragment中使用Toolbar作为ActionBar并没有什么区别.<br>但是如果你的多个Fragment有不同的Toolbar菜单选项, 如果你没有懂得其中的原理, 可能就会出现一些混乱.<br>下面来解说一下相关的方法.</p>
<h3 id="onCreateOptionsMenu-方法的调用"><a href="#onCreateOptionsMenu-方法的调用" class="headerlink" title="onCreateOptionsMenu()方法的调用"></a>onCreateOptionsMenu()方法的调用</h3><p>一旦调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((AppCompatActivity) getActivity()).setSupportActionBar(toolbar);</div></pre></td></tr></table></figure></p>
<p>就会导致Activity<code>onCreateOptionsMenu()</code>方法的调用, 而Activity会根据其中Fragment是否设置了setHasOptionsMenu(true)来调用Fragment的<br><code>onCreateOptionsMenu()</code>方法, 调用顺序是树形的, 按层级调用, 中间如果有false则跳过.</p>
<p>假设当前Activity, Parent Fragment和Child Fragment中都设置了自己的Toolbar为ActionBar.<br>在打开Child fragment的时候, <code>onCreateOptionsMenu()</code>的调用顺序是.<br><code>Activity -&gt; Parent -&gt; Child.</code> 此时parent和child fragment都设置了setHasOptionsMenu(true).</p>
<p>关于这个, 还有以下几种情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 如果Parent的`setHasOptionsMenu(false)`, Child为true, 则Parent的`onCreateOptionsMenu()`不会调用, 打开Child的时候Activity -&gt; Child.</div><div class="line">- 如果Child的`setHasOptionsMenu(false)`, Parent为true, 则打开Child的时候仍然会调用Activity和Parent的onCreateOptionsMenu()方法.</div><div class="line">- 如果Parent和Child都置为false, 打开Parent和Child Fragment的时候都会调用Activity的onCreateOptionsMenu()方法.</div></pre></td></tr></table></figure></p>
<p><strong>仅仅是child Fragment的show() hide()的切换, activity和parent Fragment的onCreateOptionsMenu()也会重新进入.</strong><br>这一点我还没有想明白, 是项目中遇到的, 初步推测可能是menu的显隐变化invalidate了menu, 改天有空再试试.</p>
<p>上面的机制常常是导致Toolbar上面的按钮混淆错乱的原因.<br>举个例子:<br>如果我们现在Activity和Parent Fragment有不同的Toolbar按钮, 但是Child只有文字, 没有按钮.<br>很显然我们不需要给child写menu文件, 也不需要覆写child里的<code>onCreateOptionsMenu()</code>方法.<br>但是此时不管怎样, parent的<code>onCreateOptionsMenu()</code>方法都会被调用, 这样我们打开child的时候, toolbar上就神奇地出现了parent里的按钮.<br>这种情况如何解决呢?<br>可以在parent中加一个条件, 当没有child fragment的时候才做inflate的工作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu, MenuInflater inflater)</span> </span>&#123;</div><div class="line">    Log.e(TAG, <span class="string">"onCreateOptionsMenu()"</span>);</div><div class="line">    menu.clear();</div><div class="line">    <span class="keyword">if</span> (getChildFragmentManager().getBackStackEntryCount() == <span class="number">0</span>) &#123;</div><div class="line">        inflater.inflate(R.menu.menu_parent_fragment, menu);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外, 除了<code>setSupportActionBar()</code>之外, 如果我们想<strong>主动触发</strong> <code>onCreateOptionsMenu()</code>方法的调用, 可以用<br><code>invalidateOptionsMenu()</code>方法.</p>
<h3 id="onOptionsItemSelected-方法的调用"><a href="#onOptionsItemSelected-方法的调用" class="headerlink" title="onOptionsItemSelected()方法的调用"></a>onOptionsItemSelected()方法的调用</h3><p>在Activity和其中的Fragment都有options menu的时候, 需要注意menu item的id不要重复.<br>以为点击事件的分发也是从Activity开始分发下去的, 如果child fragment中有个选项的id和Activity中一个选项的id重复了, 则在Activity中就会将其处理, 不会继续分发.</p>
<h3 id="有嵌套Fragment时-Back键处理"><a href="#有嵌套Fragment时-Back键处理" class="headerlink" title="有嵌套Fragment时 Back键处理"></a>有嵌套Fragment时 Back键处理</h3><p>之前没有嵌套Fragment的情况下, 只要将Fragment加入到Back Stack中, 那么按下Back键的时候pop动作是系统自动做好的.<br>虽然在添加child fragment的时候将其加入到back stack中, 但是按back键的时候仍然是将parent fragment弹出, 只剩下Activity.<br>这是因为back键只检查第一层Fragment的back stack, 对于child fragment, 需要在其parent中自己处理.<br>比如这样处理:</p>
<p>在Activity中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</div><div class="line">    Fragment fragment = getSupportFragmentManager().findFragmentById(android.R.id.content);</div><div class="line">    <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ToolbarFragment) &#123;</div><div class="line">        <span class="keyword">if</span> (((ToolbarFragment) fragment).onBackPressed()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.onBackPressed();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中ToolbarFragment是直接加在Activity中作为parent fragment的.<br>在parent fragment中(即ToolbarFragment中):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getChildFragmentManager().popBackStackImmediate();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本文Demo地址: <a href="https://github.com/mengdd/HelloActivityAndFragment" target="_blank" rel="external">Demo on github</a><br>其中的: ToolbarDemoActivity即为Toolbar Demo.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Developer Android:<br><a href="https://developer.android.com/training/appbar/index.html" target="_blank" rel="external">Training AppBar</a><br><a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html" target="_blank" rel="external">v7.widget.Toolbar Reference</a><br><a href="https://developer.android.com/reference/android/support/v7/app/ActionBar.html" target="_blank" rel="external">v7.app.ActionBar</a></p>
<p><a href="https://guides.codepath.com/android/Creating-and-Using-Fragments#actionbar-menu-items-and-fragments" target="_blank" rel="external">Guides: action bar menu items and fragments</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> Nested Fragments </tag>
            
            <tag> Toolbar </tag>
            
            <tag> ActionBar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Fragment使用(三) Activity, Fragment, WebView的状态保存和恢复]]></title>
      <url>http://mengdd.github.io/Android/2016/06/13/android-fragment-usage-3-state-restore/</url>
      <content type="html"><![CDATA[<h1 id="Android中的状态保存和恢复"><a href="#Android中的状态保存和恢复" class="headerlink" title="Android中的状态保存和恢复"></a>Android中的状态保存和恢复</h1><p>Android中的状态保存和恢复, 包括Activity和Fragment以及其中View的状态处理.<br>Activity的状态除了其中的View和Fragment的状态之外, 还需要用户手动保存一些成员变量.<br>Fragment的状态有它自己的实例状态和其中的View状态, 因为其生命周期的灵活性和实际需要的不同, 情况会多一些.<br>根据源码, 列出了Fragment中实例状态和View状态保存和恢复的几个入口, 便于分析查看.<br>最后专门讲了WebView状态保存和恢复, 问题及处理.<br>还有一个工具类icepick的介绍.</p>
<a id="more"></a>
<h1 id="Activity的状态保存和恢复"><a href="#Activity的状态保存和恢复" class="headerlink" title="Activity的状态保存和恢复"></a>Activity的状态保存和恢复</h1><p>作为热身, 先来讲一下Activity的状态保存和恢复.</p>
<h2 id="什么时候需要恢复Activity"><a href="#什么时候需要恢复Activity" class="headerlink" title="什么时候需要恢复Activity"></a>什么时候需要恢复Activity</h2><p>关于Activity的销毁和重建, 之前有这么一篇博文: <a href="http://www.cnblogs.com/mengdd/archive/2012/12/17/2822291.html" target="_blank" rel="external">Activity的重新创建</a><br>总结来说, 就是Activity的销毁, 分为彻底销毁和留下数据的销毁两种.</p>
<p><strong>彻底销毁</strong>是指用户主动去关闭或退出这个Activity. 此时是不需要状态恢复的, 因为下次回来又是重新创建全新的实例.<br><strong>留下数据的销毁</strong>是指系统销毁了activity, 但是当用户返回来时, 会重新创建它, 让用户觉得它一直都在.</p>
<p>屏幕旋转重建可以归结为第二种情况, 打开Do not keep activities开关, 切换activities也是会出现第二种情况.<br>打开<strong>Do not keep activities</strong>开关就是为了模拟内存不足时的系统行为, 这里有一篇<a href="http://www.cnblogs.com/mengdd/p/4528417.html" target="_blank" rel="external">分析</a></p>
<h2 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h2><p>实际上系统已经帮我们做好了View层面基本的恢复工作, 主要是依靠下面两个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</div><div class="line">    <span class="comment">// 在onStop()之前调用, 文档中说并不保证在onPause()的之前还是之后</span></div><div class="line">    <span class="comment">// 我的试验中一般是在onPause()之后</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</div><div class="line">    <span class="comment">// 在onStart() 之后</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bundle其中包含了activity中的view和fragment的各种信息, 所以调用基类的方法就可以完成基本的view层面的恢复工作.<br><strong>注意这两个方法并不是activity的生命周期回调, 对于activity来说它们不是一定会发生的.</strong><br><strong>另外需要注意的是, View必须要有id才能被恢复.</strong></p>
<p>举一个实例来说明:<br>Activity A start B, 那么A的<code>onSaveInstanceState()</code>会在onStop()之前调用, 以防A被系统销毁.<br>但是在B中按下back键finish()了自己后, B被销毁的过程中, 并没有调用<code>onSaveInstanceState()</code>, 是因为B并没有被压入task的back stack中,<br>也即系统知道B并不需要储存自己的状态.<br>正常情况下, 返回到A, A没有被销毁, 也不会调用<code>onRestoreInstanceState()</code>, 因为所有的状态都还在, 并不需要重建.</p>
<p>如果我们打开了<strong>Do not keep activities</strong>开关, 模拟系统内存不足时的行为, 从A到B, 可以看到当B resume的时候A会一路走到onDestroy(),<br>而关掉B之后, A会从onCreate()开始走, 此时onCreate()的参数bundle就不为空了, onStart()之后会调用<code>onRestoreInstanceState()</code>方法, 其参数bundle中内容类似于如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bundle[&#123;android:viewHierarchyState=Bundle[mParcelledData.dataSize=272]&#125;]</div></pre></td></tr></table></figure>
<p>其中包含了View的状态, 如果有Fragment, 也会包含Fragment的状态, 其实质是保存了FragmentManagerState, 内容类似于如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@bc382e7, 2131492950=CompoundButton.SavedState&#123;4034f96 checked=true&#125;, 2131492951=android.view.AbsSavedState$1@bc382e7&#125;&#125;], android:fragments=android.app.FragmentManagerState@bacc717&#125;]</div></pre></td></tr></table></figure>
<p>对于上面的例子来说, B什么时候会调用<code>onSaveInstanceState()</code>呢?<br>当从A打开B之后, 按下Home键, B就会调用<code>onSaveInstanceState()</code>.<br>因为这时候系统不知道用户什么时候会返回, 有可能会把B也销毁了, 所以保存一下它的状态.<br>如果下次回来它没有被重建, <code>onRestoreInstanceState()</code>就不会被调用, 如果它被重建了, <code>onRestoreInstanceState()</code>才会被调用.</p>
<h3 id="Activity保存方法的调用时机"><a href="#Activity保存方法的调用时机" class="headerlink" title="Activity保存方法的调用时机"></a>Activity保存方法的调用时机</h3><p><strong>activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>方法在如下情形下会调用:</strong></p>
<ol>
<li>屏幕旋转重建: 先save再restore.</li>
<li>启动另一个activity: 当前activity在离开前会save, 返回时如果因为被系统杀死需要重建, 则会从onCreate()重新开始生命周期, 调用onRestoreInstanceState(); 如果没有重建, 则不会调用onCreate(), 也不会调用onRestoreInstanceState(), 生命周期从onRestart()开始, 接着onStart()和onResume().</li>
<li>按Home键的情形和启动另一个activity一样, 当前activity在离开前会save, 用户再次点击应用图标返回时, 如果重建发生, 则会调用onCreate()和onRestoreInstanceState(); 如果activity不需要重建, 只是onRestart(), 则不会调用onRestoreInstanceState().</li>
</ol>
<h3 id="Activity恢复方法的调用时机"><a href="#Activity恢复方法的调用时机" class="headerlink" title="Activity恢复方法的调用时机"></a>Activity恢复方法的调用时机</h3><p><strong>activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>方法在如下情形下不会调用:</strong></p>
<ol>
<li>用户主动finish()掉的activity不会调用onSaveInstanceState(), 包括主动按back退出的情况.</li>
<li>新建的activity, 从onCreate()开始, 不会调用onRestoreInstanceState().</li>
</ol>
<h2 id="Activity中还需要手动恢复什么"><a href="#Activity中还需要手动恢复什么" class="headerlink" title="Activity中还需要手动恢复什么"></a>Activity中还需要手动恢复什么</h2><p>如上, 系统已经为我们恢复了activity中的各种view和fragment, 那么我们自己需要保存和恢复一些什么呢?<br>答案是<strong>成员变量值</strong>.</p>
<p>因为系统并不知道你的各种成员变量有什么用, 哪些值需要保存, 所以需要你自己覆写上面两个方法, 然后把自己需要保存的值加进bundle里面去. 具体例子, 这里<a href="http://www.cnblogs.com/mengdd/archive/2012/12/17/2822291.html" target="_blank" rel="external">Activity的重新创建</a>有, 我就不重复了.<br>重要的是不要忘记调用super的方法, 那里有系统帮我们恢复的工作.</p>
<h1 id="工具类Icepick介绍"><a href="#工具类Icepick介绍" class="headerlink" title="工具类Icepick介绍"></a>工具类Icepick介绍</h1><p>在介绍下面的内容之前, 先介绍一个小工具: <a href="https://github.com/frankiesardo/icepick" target="_blank" rel="external">Icepick</a><br>这个工具的作用是, 在你想保存和重建自己的成员变量数据时, 帮你省去那些put和get方法的调用, 你也不用为每一个字段起一个常量key.<br>你需要做的就是简单地在你想要保存状态的字段上面加上一个<code>@State</code> 注解.<br>然后在保存和恢复的时候分别加上一句话:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">  Icepick.restoreInstanceState(<span class="keyword">this</span>, savedInstanceState);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.onSaveInstanceState(outState);</div><div class="line">  Icepick.saveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后你的成员变量就有了它应该有的值了, DONE!</p>
<h1 id="Fragment的状态保存和恢复"><a href="#Fragment的状态保存和恢复" class="headerlink" title="Fragment的状态保存和恢复"></a>Fragment的状态保存和恢复</h1><p>Fragment的状态比Activity的要复杂一些, 因为它的生命周期状态比较多.</p>
<h2 id="Fragment状态保存和恢复的相关方法"><a href="#Fragment状态保存和恢复的相关方法" class="headerlink" title="Fragment状态保存和恢复的相关方法"></a>Fragment状态保存和恢复的相关方法</h2><p>按照上面的思路, 我先去查找Fragment中保存和恢复的回调方法了.<br>Fragment的状态保存回调是这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="comment">// may be called any time before onDestroy()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法和之前activity的情况大体是类似的, 它不是生命周期的回调, 所以只在有需要的时候会调到.<br>onSaveInstanceState()在activity调用onSaveInstanceState()的时候发生, 用于保存实例状态.(看它的方法名: instance state).<br><code>onSaveInstanceState()</code>方法保存的bundle会返回给几个生命周期回调: <code>onCreate()</code>, <code>onCreateView()</code>, <code>onViewCreated()</code>和<code>onActivityCreated()</code>.</p>
<p>Fragment并没有对应的onRestoreInstanceState()方法.<br>也即没有实例状态的恢复回调.</p>
<p>Fragment只有一个onViewStateRestored()的回调方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewStateRestored</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="comment">// 在onActivityCreated()和onStart()之间调用</span></div><div class="line">    mCalled = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onViewStateRestored()每次新建Fragment都会发生.<br>它并不是实例状态恢复的方法, 只是一个View状态恢复的回调.</p>
<p><strong>这里需要注意, Fragment的状态分两个类型: 实例状态和View状态</strong>.<br>这里有个最佳实践: <a href="https://inthecheesefactory.com/blog/fragment-state-saving-best-practices/en" target="_blank" rel="external">The Real Best Practices to Save/Restore Activity’s and Fragment’s state</a><br><strong>不要把Fragment的实例状态和View状态混在一起处理.</strong></p>
<p>在这里我先上个结论, 把查看源码中Fragment状态保存和恢复的相关方法列出来:</p>
<p>Fragment状态保存入口:<br><img src="/images/fragment-state-save-entries.png" alt="Fragment state saving"></p>
<p>Fragment的状态保存入口有三个:</p>
<ol>
<li>Activity的状态保存, 在Activity的<code>onSaveInstanceState()</code>里, 调用了FragmentManger的<code>saveAllState()</code>方法, 其中会对mActive中各个Fragment的实例状态和View状态分别进行保存.</li>
<li>FragmentManager还提供了public方法: <code>saveFragmentInstanceState()</code>, 可以对单个Fragment进行状态保存, 这是提供给我们用的, 后面会有例子介绍这个. 其中调用的<code>saveFragmentBasicState()</code>方法即为情况一中所用, 图中已画出标记.</li>
<li>FragmentManager的<code>moveToState()</code>方法中, 当状态回退到<code>ACTIVITY_CREATED</code>, 会调用<code>saveFragmentViewState()</code>方法, 保存View的状态.</li>
</ol>
<p><code>moveToState()</code>方法中有很长的switch case, 中间不带break, 基本是根据新状态和当前状态的比较, 分为正向创建和反向销毁两个方向, 一路沿着多个case走下去.</p>
<p>Fragment状态恢复入口:<br><img src="/images/fragment-state-restore-entries.png" alt="Fragment state restoring"></p>
<p>三个恢复的入口和三个保存的入口刚好对应.</p>
<ol>
<li>在Activity重新创建的时候, 恢复所有的Fragment状态.</li>
<li>如果调用了FragmentManager的方法: <code>saveFragmentInstanceState()</code>, 返回值得到的状态可以用Fragment的<code>setInitialSavedState()</code>方法设置给新的Fragment实例, 作为初始状态.</li>
<li>FragmentManager的<code>moveToState()</code>方法中, 当状态正向创建到<code>CREATED</code>时, Fragment自己会恢复View的状态.</li>
</ol>
<p>这三个入口分别对应的情况是:<br>入口1对应系统销毁和重建新实例.<br>入口2对应用户自定义销毁和创建新Fragment实例的状态传递.<br>入口3对应同一Fragment实例自身的View状态重建.</p>
<h2 id="Fragment状态保存恢复和Activity的联系"><a href="#Fragment状态保存恢复和Activity的联系" class="headerlink" title="Fragment状态保存恢复和Activity的联系"></a>Fragment状态保存恢复和Activity的联系</h2><p>这里对应的是入口1的情况.<br>当Activity在做状态保存和恢复的时候, 在它其中的fragment自然也需要做状态保存和恢复.<br>所以Fragment的onSaveInstanceState()在activity调用onSaveInstanceState()的时候一定会发生.<br>同样的, 如果Fragment中有一些成员变量的值在此时需要保存, 也可以用@State标记, 处理方法和上面一样.<br>也即, 在Activity需要保存状态的时候, 其中的Fragments的<strong>实例状态</strong>自动被处理保存.</p>
<h2 id="Fragment同一实例的View状态恢复"><a href="#Fragment同一实例的View状态恢复" class="headerlink" title="Fragment同一实例的View状态恢复"></a>Fragment同一实例的View状态恢复</h2><p>这里对应的是入口3的情况.<br>前面介绍过, activity在保存状态的时候, 会将所有View和Fragment的状态都保存起来等待重建的时候使用.<br>但是如果是单个Activity对应多个Fragments的架构, Activity永远是resume状态, 多个Fragments在切换的过程中, 没有activity的帮助, 如何保存自己的状态?</p>
<p>首先, 取决于你的多个Fragments是如何初始化的.<br>我做了一个实验, 在activity的onCreate()里面初始化两个Fragment:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFragments</span><span class="params">()</span> </span>&#123;</div><div class="line">    tab1Fragment = getFragmentManager().findFragmentByTag(Tab1Fragment.TAG);</div><div class="line">    <span class="keyword">if</span> (tab1Fragment == <span class="keyword">null</span>) &#123;</div><div class="line">        tab1Fragment = <span class="keyword">new</span> Tab1Fragment();</div><div class="line">    &#125;</div><div class="line">    tab2Fragment = getFragmentManager().findFragmentByTag(Tab2Fragment.TAG);</div><div class="line">    <span class="keyword">if</span> (tab2Fragment == <span class="keyword">null</span>) &#123;</div><div class="line">        tab2Fragment = <span class="keyword">new</span> Tab2Fragment();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后点击两个按钮来切换它们, replace(), 并且不加入到back stack中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnClick</span>(R.id.tab1)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTab1Clicked</span><span class="params">()</span> </span>&#123;</div><div class="line">    getFragmentManager().beginTransaction()</div><div class="line">            .replace(R.id.content_container, tab1Fragment, Tab1Fragment.TAG)</div><div class="line">            .commit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@OnClick</span>(R.id.tab2)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTab2Clicked</span><span class="params">()</span> </span>&#123;</div><div class="line">    getFragmentManager().beginTransaction()</div><div class="line">            .replace(R.id.content_container, tab2Fragment, Tab2Fragment.TAG)</div><div class="line">            .commit();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到, 每一次的切换, 都是一个Fragment的完全destroy, detach和另一个fragment的attach, create,<br>但是当我在这两个fragment中各自加上EditText, 发现只要EditText有id, 切换过程中EditText的内容是被保存的.<br>这是谁在什么时候保存并恢复的呢?<br>我在TextChange的回调里打了断点, 发现调用栈如下:<br><img src="/images/fragment-state-debug-onRestore.png" alt="Fragment view state debug"></p>
<p>在<code>FragmentManagerImpl</code>中, <code>moveToState()</code>方法的case Fragment.CREATED中:<br>调用了: <code>f.restoreViewState(f.mSavedFragmentState);</code><br>此时我没有做任何保存状态的处理, 但是断点中可以看出:<br><img src="/images/fragment-states.png" alt="Fragment states"></p>
<p>虽然mSavedFragmentState是null, 但是mSavedViewState却有值.<br>所以这个View状态保存和恢复对应的入口即是上面两个图中的入口三.</p>
<p>这是因为我的两个fragment只new了一次, 然后保存了成员变量, 即便是Fragment重新onCreate(), 但是对应的实例仍然是同一个.<br>这和Activity是不同的, 因为你是无法new一个Activity的.</p>
<p>在上面的例子中, 如果不保存Fragment的引用, 每次都new Fragment, 那么View的状态是不会被保存的, 因为不同实例间的状态传递只有在系统销毁恢复的情况下才会发生(入口一).<br>如果我们需要在不同的实例间传递状态, 就需要用到下面的方法:</p>
<h2 id="不同Fragment实例间的状态保存和恢复"><a href="#不同Fragment实例间的状态保存和恢复" class="headerlink" title="不同Fragment实例间的状态保存和恢复"></a>不同Fragment实例间的状态保存和恢复</h2><p>这里对应的是入口2, 不同于入口1和3, 它们是自动的, 入口2是用户主动保存和恢复的情形.<br>自己主动保存Fragment的状态, 可以调用FragmentManager的这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract Fragment.SavedState saveFragmentInstanceState(Fragment f);</div></pre></td></tr></table></figure>
<p>它的实现是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Fragment.<span class="function">SavedState <span class="title">saveFragmentInstanceState</span><span class="params">(Fragment fragment)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fragment.mIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        throwException(<span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + fragment</div><div class="line">                + <span class="string">" is not currently in the FragmentManager"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fragment.mState &gt; Fragment.INITIALIZING) &#123;</div><div class="line">        Bundle result = saveFragmentBasicState(fragment);</div><div class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> ? <span class="keyword">new</span> Fragment.SavedState(result) : <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回的数据类型是: Fragment.SavedState, 这个state可以通过Fragment的这个方法设置给自己:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitialSavedState</span><span class="params">(SavedState state)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already active"</span>);</div><div class="line">    &#125;</div><div class="line">    mSavedFragmentState = state != <span class="keyword">null</span> &amp;&amp; state.mState != <span class="keyword">null</span></div><div class="line">            ? state.mState : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是注意只能在Fragment被加入之前设置, 这是一个初始状态.<br>利用这两个方法可以更加自由地保存和恢复状态, 而不依赖于Activity.<br>这样处理以后, 不必保存Fragment的引用, 每次切换的时候虽然都new了新的实例, 但是旧的实例的状态可以设置给新实例.</p>
<p>例子代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@State</span></div><div class="line">SparseArray&lt;Fragment.SavedState&gt; savedStateSparseArray = <span class="keyword">new</span> SparseArray&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTab1Clicked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// save current tab</span></div><div class="line">    Fragment tab2Fragment = getSupportFragmentManager().findFragmentByTag(Tab2Fragment.TAG);</div><div class="line">    <span class="keyword">if</span> (tab2Fragment != <span class="keyword">null</span>) &#123;</div><div class="line">        saveFragmentState(<span class="number">1</span>, tab2Fragment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// restore last state</span></div><div class="line">    Tab1Fragment tab1Fragment = <span class="keyword">new</span> Tab1Fragment();</div><div class="line">    restoreFragmentState(<span class="number">0</span>, tab1Fragment);</div><div class="line"></div><div class="line">    <span class="comment">// show new tab</span></div><div class="line">    getSupportFragmentManager().beginTransaction()</div><div class="line">            .replace(R.id.content_container, tab1Fragment, Tab1Fragment.TAG)</div><div class="line">            .commit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveFragmentState</span><span class="params">(<span class="keyword">int</span> index, Fragment fragment)</span> </span>&#123;</div><div class="line">    Fragment.SavedState savedState = getSupportFragmentManager().saveFragmentInstanceState(fragment);</div><div class="line">    savedStateSparseArray.put(index, savedState);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreFragmentState</span><span class="params">(<span class="keyword">int</span> index, Fragment fragment)</span> </span>&#123;</div><div class="line">    Fragment.SavedState savedState = savedStateSparseArray.get(index);</div><div class="line">    fragment.setInitialSavedState(savedState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里用了SparseArray来存储Fragment的状态, 并且加上了<code>@State</code>, 这样在Activity重建的时候其中的内容也能够被恢复.</p>
<h2 id="Back-stack中的fragment"><a href="#Back-stack中的fragment" class="headerlink" title="Back stack中的fragment"></a>Back stack中的fragment</h2><p>有一点很特殊的是, 当Fragment从back stack中返回, 实际上是经历了一次View的销毁和重建, 但是它本身并没有被重建.<br>即View状态需要重建, 实例状态不需要重建.</p>
<p>举个例子说明这种情形: Fragment被另一个Fragment replace(), 并且压入back stack中, 此时它的View是被销毁的, 但是它本身并没有被销毁.<br>也即, 它走到了onDestroyView(), 却没有走<code>onDestroy()</code>和<code>onDetact()</code>.<br>等back回来的时候, 它的view会被重建, 重新从onCreateView()开始走生命周期.<br>在这整个过程中, 该Fragment中的成员变量是保持不变的, 只有View会被重新创建.<br>在这个过程中, instance state的saving并没有发生.</p>
<p><strong>所以, 很多时候Fragment还需要考虑的是在没有Activity帮助的情形下(Activity并没有可能重建的情形), 自身View状态的保存.</strong><br>此时要注意一些不容易发现的错误, 比如List的新实例需要重新setAdapter等.</p>
<h2 id="Fragment-setRetainInstance"><a href="#Fragment-setRetainInstance" class="headerlink" title="Fragment setRetainInstance"></a>Fragment setRetainInstance</h2><p>Fragment有一个相关方法:<br><a href="https://developer.android.com/reference/android/app/Fragment.html#setRetainInstance(boolean" target="_blank" rel="external">setRetainInstance</a>)<br>这个方法设置为true的时候表示, 即便activity重建了, 但是fragment的实例并不被重建.<br>注意此方法只对没有放在back stack中的fragment生效.<br>什么时候要用这个方法呢? 处理configuration change的时候:<br><a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html" target="_blank" rel="external">Handling Configuration Changes with Fragments</a><br>这样, 当屏幕旋转, Activity重建, 但是其中的fragment和fragment正在执行的任务不必重建.<br>更多解释可以参见:<br><a href="http://stackoverflow.com/questions/11182180/understanding-fragments-setretaininstanceboolean" target="_blank" rel="external">http://stackoverflow.com/questions/11182180/understanding-fragments-setretaininstanceboolean</a><br><a href="http://stackoverflow.com/questions/11160412/why-use-fragmentsetretaininstanceboolean" target="_blank" rel="external">http://stackoverflow.com/questions/11160412/why-use-fragmentsetretaininstanceboolean</a></p>
<p>注意这个方法只是针对<strong>configuration change</strong>, 并不影响用户主动关闭和系统销毁的情况:<br>当activity被用户主动finish, 其中的所有fragments仍然会被销毁.<br>当activity不在最顶端, memory不够了, 系统仍然可能会销毁activity和其中的fragments.</p>
<h1 id="View的状态保存和恢复"><a href="#View的状态保存和恢复" class="headerlink" title="View的状态保存和恢复"></a>View的状态保存和恢复</h1><p>View的状态保存和恢复主要是依赖于下面几个方法:<br>保存: <code>saveHierarchyState()</code> -&gt; <code>dispatchSaveInstanceState()</code> -&gt; <code>onSaveInstanceState()</code><br>恢复: <code>restoreHierarchyState()</code> -&gt; <code>dispatchRestoreInstanceState()</code> -&gt; <code>onRestoreInstanceState()</code><br>还有两个重要的前提条件是View要有id, 并且<code>setSavedEnabled()</code>为true.(这个值默认为true).<br>在系统的widget里(比如TextView, EditText, Checkbox等), 这些都是已经被处理好的, 我们只需要给View赋予id, Activity和Fragment重建的时候会自动恢复其中的状态. (这里的Fragment恢复对应入口一和入口三, 入口二属于跨实例新建的情况).</p>
<p>但是如果你要使用第三方的自定义View, 就需要确认一下它们内部是否有状态保存和恢复的代码.<br>如果不行你就需要继承该自定义View, 然后实现这两个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Assumes that SomeSmartButton is a 3rd Party view that</span></div><div class="line"><span class="comment">// View State Saving/Restoring are not implemented internally</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeBetterSmartButton</span> <span class="keyword">extends</span> <span class="title">SomeSmartButton</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">        <span class="comment">// Save current View's state here</span></div><div class="line">        <span class="keyword">return</span> bundle;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Parcelable state)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onRestoreInstanceState(state);</div><div class="line">        <span class="comment">// Restore View's state here</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="WebView的状态保存和恢复"><a href="#WebView的状态保存和恢复" class="headerlink" title="WebView的状态保存和恢复"></a>WebView的状态保存和恢复</h1><p>WebView的状态保存和恢复不像其他原生View一样是自动完成的.<br>WebView不是继承自View的.<br>如果我们把WebView放在布局里, 不加处理, 那么Activity或Fragment重建的过程中, WebView的状态就会丢失, 变成初始状态.</p>
<p>在Fragment的onSaveInstanceState()里面可以加入如下代码来保存WebView的状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line">    webView.saveState(outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在初始化的时候, 增加判断, 不必每次都打开初始链接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (savedInstanceState != null) &#123;</div><div class="line">    webView.restoreState(savedInstanceState);</div><div class="line">&#125; else &#123;</div><div class="line">    webView.loadUrl(TEST_URL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样处理以后, 在重新建立的时候, WebView的状态就能恢复到离开前的页面.<br>不论WebView是放在Activity里还是Fragment里, 这个方法都适用.</p>
<p>但是Fragment还有另一种情况, 即Fragment被压入back stack, 此时它没有被destroy(), 所以没有调用onSavedInstanceState()这个方法.<br>这种情况返回的时候, 会从onCreateView()开始, 并且savedInstanceState为null, 于是其中WebView之前的状态在此时丢失了.<br>解决这种情况可以利用Fragment实例并未销毁的条件, 增加一个成员变量bundle, 保存WebView的状态, 最终解决如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Bundle webViewState;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</div><div class="line">    ButterKnife.bind(<span class="keyword">this</span>, view);</div><div class="line"></div><div class="line">    initWebView();</div><div class="line">    <span class="keyword">if</span> (webViewState != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//Fragment实例并未被销毁, 重新create view</span></div><div class="line">        webView.restoreState(webViewState);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//Fragment实例被销毁重建</span></div><div class="line">        webView.restoreState(savedInstanceState);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//全新Fragment</span></div><div class="line">        webView.loadUrl(TEST_URL);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onPause();</div><div class="line">    webView.onPause();</div><div class="line"></div><div class="line">    <span class="comment">//Fragment不被销毁(Fragment被加入back stack)的情况下, 依靠Fragment中的成员变量保存WebView状态</span></div><div class="line">    webViewState = <span class="keyword">new</span> Bundle();</div><div class="line">    webView.saveState(webViewState);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</div><div class="line">    <span class="comment">//Fragment被销毁的情况, 依靠outState保存WebView状态</span></div><div class="line">    <span class="keyword">if</span> (webView != <span class="keyword">null</span>) &#123;</div><div class="line">        webView.saveState(outState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本文完整例子相关实验代码可见:<br><a href="https://github.com/mengdd/HelloActivityAndFragment" target="_blank" rel="external">HelloActivityAndFragment</a><br>中的State Restore Demo.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Developer Android:<br><a href="https://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Android Fragment Reference</a><br><a href="https://developer.android.com/reference/android/app/FragmentManager.html" target="_blank" rel="external">Android FragmentManager Reference</a></p>
<p>Posts:<br><a href="https://developer.android.com/training/basics/activity-lifecycle/recreating.html" target="_blank" rel="external">Recreating an Activity</a><br><a href="http://www.cnblogs.com/mengdd/archive/2012/12/17/2822291.html" target="_blank" rel="external">Activity的重新创建</a><br><a href="http://www.jianshu.com/p/180d2cc0feb5" target="_blank" rel="external">从源码角度剖析Fragment核心知识点</a><br><a href="http://www.jianshu.com/p/bd4a8be309c8" target="_blank" rel="external">Fragment源码阅读笔记</a><br><a href="https://inthecheesefactory.com/blog/fragment-state-saving-best-practices/en" target="_blank" rel="external">The Real Best Practices to Save/Restore Activity’s and Fragment’s state</a><br><a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2648.html" target="_blank" rel="external">Android中保存和恢复Fragment状态的最好方法</a></p>
<p><a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html" target="_blank" rel="external">Handling Configuration Changes with Fragments</a><br><a href="http://trickyandroid.com/saving-android-view-state-correctly/" target="_blank" rel="external">Saving Android View state correctly</a></p>
<p>Tools:<br><a href="https://github.com/frankiesardo/icepick" target="_blank" rel="external">icepick</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> WebView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Fragment使用(二) 嵌套Fragments (Nested Fragments) 的使用及常见错误]]></title>
      <url>http://mengdd.github.io/Android/2016/06/02/android-fragment-usage-2-nested-fragments/</url>
      <content type="html"><![CDATA[<h1 id="嵌套Fragment的使用及常见错误"><a href="#嵌套Fragment的使用及常见错误" class="headerlink" title="嵌套Fragment的使用及常见错误"></a>嵌套Fragment的使用及常见错误</h1><p>嵌套Fragments (Nested Fragments), 是在Fragment内部又添加Fragment.<br>使用时, 主要要依靠宿主Fragment的 <code>getChildFragmentManager()</code> 来获取FragmentManger.<br>虽然看起来和在activity中添加fragment差不多, 但因为fragment生命周期及管理恢复模式不同, 其中有一些需要特别注意的地方.<br>本文内容还包括了从Fragment迁移到v4.Fragment代码中需要改动的一些地方.</p>
<a id="more"></a>
<h2 id="嵌套Fragments"><a href="#嵌套Fragments" class="headerlink" title="嵌套Fragments"></a>嵌套Fragments</h2><p>嵌套Fragments <a href="https://developer.android.com/about/versions/android-4.2.html#NestedFragments" target="_blank" rel="external">Nested Fragments</a> 是Android 4.2 API 17 引入的.<br>目的: 进一步增强动态复用.<br>如果要在Android 4.2之前使用, 可以用support library v4的版本, 后面会有详细的迁移过程介绍.</p>
<h3 id="嵌套Fragment的动态添加"><a href="#嵌套Fragment的动态添加" class="headerlink" title="嵌套Fragment的动态添加"></a>嵌套Fragment的动态添加</h3><p>在宿主fragment里调用<a href="https://developer.android.com/reference/android/app/Fragment.html#getChildFragmentManager(" target="_blank" rel="external">getChildFragmentManager()</a>)<br>即可用它来向这个fragment内部添加fragments.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fragment videoFragment = <span class="keyword">new</span> VideoPlayerFragment();</div><div class="line">FragmentTransaction transaction = getChildFragmentManager().beginTransaction();</div><div class="line">transaction.add(R.id.video_fragment, videoFragment).commit();</div></pre></td></tr></table></figure>
<p>同样, 对于内部的fragment来说, <a href="https://developer.android.com/reference/android/app/Fragment.html#getParentFragment(" target="_blank" rel="external">getParentFragment()</a>) 方法可以获取到fragment的宿主fragment.</p>
<h3 id="getChildFragmentManager-和-getFragmentManager"><a href="#getChildFragmentManager-和-getFragmentManager" class="headerlink" title="getChildFragmentManager() 和 getFragmentManager()"></a>getChildFragmentManager() 和 getFragmentManager()</h3><p><code>getChildFragmentManager()</code>是fragment中的方法, 返回的是管理当前fragment内部子fragments的manager.<br><code>getFragmentManager()</code>在activity和fragment中都有.<br>在activity中, 如果用的是v4 support库, 方法应该用<code>getSupportFragmentManager()</code>, 返回的是管理activity中fragments的manager.<br>在fragment中, 还叫getFragmentManager(), 返回的是把自己加进来的那个manager.</p>
<p>也即, 如果fragment在activity中, fragment.getFragmentManager()得到的是activity中管理fragments的那个manager.<br>如果fragment是嵌套在另一个fragment中, fragment.getFragmentManager()得到的是它的parent的getChildFragmentManager().</p>
<p>总结就是: <strong><em>getFragmentManager()是本级别管理者, getChildFragmentManager()是下一级别管理者</em></strong>.<br>这实际上是一个树形管理结构.</p>
<h2 id="使用Support-library"><a href="#使用Support-library" class="headerlink" title="使用Support library"></a>使用Support library</h2><h3 id="为什么要使用support-library-有两种原因"><a href="#为什么要使用support-library-有两种原因" class="headerlink" title="为什么要使用support library? 有两种原因:"></a>为什么要使用support library? 有两种原因:</h3><ol>
<li>要在API level11之前使用fragment.</li>
<li>要在API Level 17之前使用<code>getChildFragmentManager()</code>, 即使用嵌套Fragment.</li>
</ol>
<h3 id="迁移到support-library需要改动哪些地方"><a href="#迁移到support-library需要改动哪些地方" class="headerlink" title="迁移到support library需要改动哪些地方?"></a>迁移到support library需要改动哪些地方?</h3><p>把Fragment迁移到v4版本, 需要改动如下地方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import android.app.Fragment; -&gt; import android.support.v4.app.Fragment;</div><div class="line">Activity -&gt; FragmentActivity / AppCompatActivity</div><div class="line">activity.getFragmentManager() -&gt; getSupportFragmentManager()</div><div class="line"></div><div class="line">Loader, LoaderManager, LoaderCursor也需要改成v4包的.</div><div class="line">activity.getLoaderManager() -&gt; getSupportLoaderManager()</div></pre></td></tr></table></figure>
<p>Fragment中onTrimMemory()方法不见了<br>以前是这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onTrimMemory(level);</div><div class="line">    imageLoader.trimMemory(level);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>v4版本需要改成这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">super</span>.onLowMemory();</div><div class="line">     imageLoader.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="嵌套Fragment使用常见错误"><a href="#嵌套Fragment使用常见错误" class="headerlink" title="嵌套Fragment使用常见错误"></a>嵌套Fragment使用常见错误</h2><h3 id="错误情形1-把嵌套Fragment放在布局里"><a href="#错误情形1-把嵌套Fragment放在布局里" class="headerlink" title="错误情形1: 把嵌套Fragment放在布局里"></a>错误情形1: 把嵌套Fragment放在布局里</h3><p>把嵌套Fragment放在布局里 -&gt; <code>InflateException in Binary XML</code></p>
<p>看起来嵌套fragment的使用除了要用<code>getChildFragmentManager()</code>以外, 其他跟之前似乎没什么区别.<br>如果嵌套的fragment不需要太多控制, 固定地占据了一块地方, 你可能想当然地为了省事就把它放进了xml布局文件里, 写个<fragment>标签.<br>运行一下初看起来似乎没什么错, run一下也能显示出来, 但是千万不要这样做, 多玩两下更复杂的你就知道了.</fragment></p>
<p>上面<a href="https://developer.android.com/about/versions/android-4.2.html#NestedFragments" target="_blank" rel="external">官网介绍时</a>就有这么一句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Note: You cannot inflate a layout into a fragment when that layout includes a &lt;fragment&gt;.</div><div class="line">Nested fragments are only supported when added to a fragment dynamically.</div></pre></td></tr></table></figure></p>
<p>人家这么说肯定是有原因的哇, 下面我来告诉你我知道的问题:<br>如果Fragment被嵌套写在了布局里, inflate到这个标签的时候就相当于将它加进了FragmentManager里.<br>如果嵌套的parent fragment因为需要重建View而重新走了<code>onCreateView()</code>方法, 再次inflate, 此时就会抛出异常:  <code>InflateException in Binary XML</code></p>
<p>之前为什么可以呢? 非嵌套的情况, fragment直接加在activity里, 如果需要重新inflate, 必定是在onCreate()里, activity是重新建的, 所以没有问题, 因为不存在fragmentManager中已经持有同一个fragment的问题.</p>
<p>举一个例子:<br>在嵌套的情况下, 如果FragmentE布局里有FragmentA, 这时候我们需要叠加一个FragmentD.<br>用了<code>replace()</code>, 并且<code>addToBackStack()</code>.<br>当D显示的时候, E实际上View是被销毁的, 然后back回来, 重建View, 即FragementE需要重新从onCreateView<br>()开始走生命周期, 走到inflate的时候又看到了fragmentA的标签.<br>但是这时候A实际上还在FragmentManager里面, 所以就会抛出如下的异常:<br><code>android.view.InflateException: Binary XML file line # XX: Binary XML file line #XX: Error inflating class fragment</code><br>崩溃的位置就在parent fragment(FragmentE) inflate的时候.<br>打印具体的异常栈信息可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">at com.example.ddmeng.helloactivityandfragment.fragment.FragmentE.onCreateView(FragmentE.java:35)</div><div class="line">at android.app.Fragment.performCreateView(Fragment.java:2220)</div><div class="line">at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:973)</div><div class="line">at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1148)</div><div class="line">at android.app.FragmentManagerImpl.popBackStackState(FragmentManager.java:1587)</div><div class="line">at android.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:578)</div><div class="line">at android.support.v4.app.BaseFragmentActivityEclair.onBackPressedNotHandled(BaseFragmentActivityEclair.java:27)</div><div class="line">at android.support.v4.app.FragmentActivity.onBackPressed(FragmentActivity.java:189)</div><div class="line"> Caused by: java.lang.IllegalArgumentException: Binary XML file line #16: Duplicate id 0x7f0c0059, tag null, or parent id 0xffffffff with another fragment for com.example.ddmeng.helloactivityandfragment.fragment.FragmentA</div><div class="line">at android.app.FragmentManagerImpl.onCreateView(FragmentManager.java:2205)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/mengdd/HelloActivityAndFragment" target="_blank" rel="external">实验例子代码</a></p>
<h4 id="Solution-1-动态添加child-fragment"><a href="#Solution-1-动态添加child-fragment" class="headerlink" title="Solution 1: 动态添加child fragment"></a>Solution 1: 动态添加child fragment</h4><p>解决上面的问题有各种方法, 最常规的做法是, 使用动态添加:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Fragment fragmentA = getChildFragmentManager().findFragmentByTag(NESTED_FRAGMENT_TAG);</div><div class="line"><span class="keyword">if</span> (fragmentA == <span class="keyword">null</span>) &#123;</div><div class="line">    Log.i(LOG_TAG, <span class="string">"add new FragmentA !!"</span>);</div><div class="line">    fragmentA = <span class="keyword">new</span> FragmentA();</div><div class="line">    FragmentTransaction fragmentTransaction = getChildFragmentManager().beginTransaction();</div><div class="line">    fragmentTransaction.add(R.id.fragment_container, fragmentA, NESTED_FRAGMENT_TAG).commit();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    Log.i(LOG_TAG, <span class="string">"found existing FragmentA, no need to add it again !!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Solution-2-在异常之前remove-child-fragment"><a href="#Solution-2-在异常之前remove-child-fragment" class="headerlink" title="Solution 2: 在异常之前remove child fragment"></a>Solution 2: 在异常之前remove child fragment</h4><p>如果你的子fragment非要加在布局里不可, 而你的程序确实会有重建父fragment view的情形.<br>为了避免上面的异常, 你也可以这样做(tricky and not recommended):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChildFragment</span><span class="params">(Fragment parentFragment)</span> </span>&#123;</div><div class="line">    FragmentManager fragmentManager = parentFragment.getChildFragmentManager();</div><div class="line">    Fragment child = fragmentManager.findFragmentById(R.id.child);</div><div class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">        fragmentManager.beginTransaction()</div><div class="line">        .remove(child)</div><div class="line">        .commitAllowingStateLoss();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在parentFragment的<code>onCreateView()</code>方法中inflate之前和<code>onSaveInstanceState()</code>方法中做save工作之前调用它.<br>这两个地方是发生异常的地方, 只要在其之前remove就好.</p>
<h3 id="错误情形2-把fragment放在一个动态布局里"><a href="#错误情形2-把fragment放在一个动态布局里" class="headerlink" title="错误情形2: 把fragment放在一个动态布局里"></a>错误情形2: 把fragment放在一个动态布局里</h3><p>把fragment放在一个动态布局里 -&gt; <code>java.lang.IllegalArgumentException: No view found for id</code></p>
<p>发现这个错误是因为项目中的一个子Fragment是添加在RecyclerView里面的一块的.<br>RecyclerView要等到Loader的数据取到了之后再populate每一块的布局.<br>还是上面的流程, 启动父fragment, load数据, 添加子fragment, 这都没有问题.<br>但是一旦如果是上面的<code>replace()</code>加<code>addToBackStack()</code> , 并且再次返回, 就会出现异常.</p>
<p>因为当重建View的时候, fragmentManager其中是持有child fragment的, 但是找不到它的container, 于是就会抛出异常.<br>我也同样做了一个小实验, 在我的demo程序里:<br><a href="https://github.com/mengdd/HelloActivityAndFragment" target="_blank" rel="external">HelloActivityAndFragment</a><br>Nested Fragment in Dynamic Container:<br>在Fragment F中, 先添加一个FrameLayout, 再把child fragment A加进去.<br>然后在Activity中, 用D replace F, 按back键返回, 就会有crash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalArgumentException: No view found for id 0x7f0c0062 (com.example.ddmeng.helloactivityandfragment:id/frame_container) for fragment FragmentA&#123;b37763 #0 id=0x7f0c0062 FragmentA&#125;</div><div class="line">    at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:965)</div><div class="line">    at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1148)</div><div class="line">    at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1130)</div><div class="line">    at android.app.FragmentManagerImpl.dispatchActivityCreated(FragmentManager.java:1953)</div><div class="line">    at android.app.Fragment.performActivityCreated(Fragment.java:2234)</div><div class="line">    at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:992)</div><div class="line">    at android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1148)</div><div class="line">    at android.app.BackStackRecord.popFromBackStack(BackStackRecord.java:1670)</div><div class="line">    at android.app.FragmentManagerImpl.popBackStackState(FragmentManager.java:1587)</div><div class="line">    at android.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:578)</div><div class="line">    at android.app.Activity.onBackPressed(Activity.java:2503)</div></pre></td></tr></table></figure>
<p>这是因为返回的时候FragmentManager找不到对应的container了.<br>所以应该避免这种做法, 尽量把fragment加进parent的根布局里, 而不是某个动态添加的布局.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于嵌套fragments的情况, 可能和ViewPager结合使用的情形比较多.<br>这个感觉说来话长了, 以为有很多系统帮忙做的事情, 改天有空再说吧.</p>
<p>这里有个大哥写了个工具类<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation</a>.<br>他也有几篇博文分析遇到的坑和原因(见上面repo的README给出的链接), 里面有一些back stack的问题, 还有动画什么的, 大家有兴趣可以看看.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://guides.codepath.com/android/Creating-and-Using-Fragments#nesting-fragments-within-fragments" target="_blank" rel="external">Guide: Nested Fragments</a></p>
<p><a href="https://github.com/mengdd/HelloActivityAndFragment" target="_blank" rel="external">相关Demo</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
            <tag> Nested Fragments </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Fragment使用(一) 基础篇 温故知新]]></title>
      <url>http://mengdd.github.io/Android/2016/05/31/android-fragment-usage-1-basic-part/</url>
      <content type="html"><![CDATA[<p>Fragment使用的基本知识点总结, 包括Fragment的添加, 参数传递和通信, 生命周期和各种操作.</p>
<a id="more"></a>
<h1 id="Fragment使用基础"><a href="#Fragment使用基础" class="headerlink" title="Fragment使用基础"></a>Fragment使用基础</h1><h2 id="Fragment添加"><a href="#Fragment添加" class="headerlink" title="Fragment添加"></a>Fragment添加</h2><p>方法一: 布局里的标签<fragment><br>标识符: tag, id, 如果都没有, container的id将会被使用.</fragment></p>
<p>方法二: 动态添加<br>动态添加利用了一个transaction:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FragmentManager fragmentManager = getFragmentManager();</div><div class="line">Fragment fragment = fragmentManager.findFragmentByTag(FragmentB.TAG);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == fragment) &#123;</div><div class="line">    FragmentB fragmentB = <span class="keyword">new</span> FragmentB();</div><div class="line">    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div><div class="line">    fragmentTransaction.add(R.id.fragment_container, fragmentB, FragmentB.TAG)</div><div class="line">                       .commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commit()</code>方法并不立即执行transaction中包含的动作,而是把它加入到UI线程队列中.<br>如果想要立即执行,可以在commit之后立即调用FragmentManager的<a href="https://developer.android.com/reference/android/app/FragmentManager.html#executePendingTransactions(" target="_blank" rel="external"><code>executePendingTransactions()</code></a>)方法.</p>
<p><code>commit()</code>方法必须在状态存储之前调用,否则会抛出异常,如果觉得状态丢失没关系,可以调用<code>commitAllowingStateLoss()</code>. 但是除非万不得已, 一般不推荐用这个方法, 会掩盖很多错误.</p>
<h2 id="Back-Stack"><a href="#Back-Stack" class="headerlink" title="Back Stack"></a>Back Stack</h2><p>Activity的back stack: 系统维护, 每个task一个back stack.<br>Fragment的back stack: 宿主activity掌管, 每个activity一个.</p>
<p>通过调用<code>addToBackStack()</code>,commit()的一系列转换作为一个transaction被存储在back stack中,<br>用户按Back键, 从栈中pop出一个transaction, 逆转操作, 可以返回上一个转换前的状态.</p>
<p>一个transaction可以包含多种操作, 并且不局限于对同一个Fragment, 所以每一个transaction实际上可以是一系列对多个fragment的操作的组合.<br>加入到back stack中去的时候, 是把这一系列的组合作为一个原子, 加入到back stack中.</p>
<h2 id="构造和参数传递"><a href="#构造和参数传递" class="headerlink" title="构造和参数传递"></a>构造和参数传递</h2><p>所有的Fragment都必须有一个<code>public的无参构造函数</code>, 因为framework经常会在需要的时候重新创建实例(状态恢复时), 它需要的就是这个构造.<br>如果无参构造没有提供,会有异常.</p>
<p>所以<code>不要给Fragment写有参数的构造函数, 也不要企图搞个什么单例的Fragment</code>. 这些都是反设计的.</p>
<p>参数传递的正确姿势:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FragmentWithParameters <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    FragmentWithParameters fragmentWithParameter = <span class="keyword">new</span> FragmentWithParameters();</div><div class="line">    Bundle args = <span class="keyword">new</span> Bundle();</div><div class="line">    args.putInt(NUM, num);</div><div class="line">    fragmentWithParameter.setArguments(args);</div><div class="line">    <span class="keyword">return</span> fragmentWithParameter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    num = getArguments() != <span class="keyword">null</span> ? getArguments().getInt(NUM) : <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是提供了一个静态方法, 也可以new出对象后自己set Bundle参数.</p>
<h2 id="Fragment的通信"><a href="#Fragment的通信" class="headerlink" title="Fragment的通信"></a>Fragment的通信</h2><p>除了DialogFragment和嵌套Fragment需要与自己的parent fragment通信以外, 一般的fragment是不与其他fragment有任何通信的. 因为要求应尽量独立, 模块化, 可复用.<br>fragment与自己的parent activity (除了嵌套和dialog的情况外, 这个parent通常是activity) 有直接通信, 一般以这三种方式:</p>
<ol>
<li>在构造fragment的时候, 通过Bundle传递参数.</li>
<li>parent可以直接调用fragment的public方法, 这里也可以传递一些参数.</li>
<li>Listener, 也即parent实现的callback接口, fragment可以在自己内部调用, 这里fragment也可以传递参数出去.</li>
</ol>
<p>对于DialogFragment来说, 可以通过一个public的set方法将外面的target设置进去.<br>比如用Fragment的这个方法: <a href="https://developer.android.com/reference/android/app/Fragment.html#setTargetFragment(android.app.Fragment,%20int" target="_blank" rel="external">setTargetFragment()</a>)</p>
<p><a href="https://guides.codepath.com/android/Using-DialogFragment#passing-data-to-parent-fragment" target="_blank" rel="external">例子</a><br>对于嵌套(nested)Fragment, 通信方式与上面普通的fragment类似, 只不过parent此时不是activity而是一个fragment.<br>后面会单独有一个文章说嵌套Fragment的使用, 敬请期待.</p>
<h1 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h1><p>Fragment的生命周期首先和Activity的生命周期密切相关,<br>如果activity stopped,其中所有的fragment都不能start;<br>如果activity destroyed, 其中所有的fragment都会被destroyed.<br>只有activity在resumed状态下,fragment的生命周期可以独立改变,否则它被activity控制.</p>
<p><img src="/images/fragment-lifecycle.png" alt=""><br><img src="/images/fragment-lifecycle-2.png" alt=""><br><img src="/images/activity-fragment-lifecycle.png" alt=""><br><img src="/images/fragment-lifecycle-with-callbacks.png" alt=""></p>
<p>上面这个图来自于: <a href="https://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external">https://corner.squareup.com/2014/10/advocating-against-android-fragments.html</a><br>这里还有一个更吊的图: <a href="https://github.com/xxv/android-lifecycle" target="_blank" rel="external">https://github.com/xxv/android-lifecycle</a></p>
<h1 id="FragmentTransaction基础操作"><a href="#FragmentTransaction基础操作" class="headerlink" title="FragmentTransaction基础操作"></a>FragmentTransaction基础操作</h1><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><p><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html" target="_blank" rel="external">FragmentTransaction</a> 中对Fragment有如下几种操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">attach(), detach()</div><div class="line">add(), remove(),</div><div class="line">show(), hide(),</div><div class="line">replace()</div></pre></td></tr></table></figure>
<p>除了<code>replace()</code>以外其他都是成对的.</p>
<p>其中<code>attach()</code>和<code>detach()</code>不是很常用.<br>调用<code>detach()</code>之后, fragment实际的生命周期会走到onDestroyView(), 但不会走onDestroy()和onDetach(), 也即fragment本身并没有被销毁, 只是view被销毁了. 这和addToBackStack()的情况一样, 尽管调用detach()的时候没有addToBackStack(), 仍然只是走到view被销毁的阶段.</p>
<p><code>add()</code>和<code>remove()</code>是将fragment添加和移除.<br>remove()比detach()要彻底一些, 如果不加入到back stack, remove()的时候, fragment的生命周期会一直走到onDetach().</p>
<p><code>show()</code>和<code>hide()</code>是用来设置fragment的显示和隐藏状态, 这两个方法并不对应fragment的状态变化,只是将view设置为visible和gone,然后调用onHiddenChanged()的回调.</p>
<p>实际上<code>replace() == remove() + add()</code>, 所以它的反操作也是replace(), 只不过把add和remove的东西交换一下.</p>
<p>关于replace()和show(), hide()的选择, 要根据实际使用情形来定.<br><code>replace()</code>的好处是会减少内存占用, 但是返回时需要重新走完初始化的过程.<br><code>show()</code>和<code>hide()</code>只是控制了fragment的显示和隐藏, 不会改变生命周期状态, 也即fragment始终是处于running状态的, 被保持在内存中, 适用于频繁切换的情形.</p>
<h2 id="remove-replace-是否加到back-stack对生命周期的影响"><a href="#remove-replace-是否加到back-stack对生命周期的影响" class="headerlink" title="remove(), replace()是否加到back stack对生命周期的影响"></a>remove(), replace()是否加到back stack对生命周期的影响</h2><p>前面说过, <code>replace() == remove() + add()</code><br>新的fragment将取代在容器布局中的fragment, 如果没有,将直接添加新的fragment.</p>
<p>是否添加到back stack对fragment的生命周期是有影响的.<br><code>remove()</code>或者<code>replace()</code>的时候,如果<code>commit()</code>之前没有调用<code>addToBackStack()</code>,那个旧fragment将会被destroyed和detach; 即完全销毁和移除.</p>
<p>如果调用了<code>addToBackStack()</code>,旧的fragment会处在stopped状态,调用到<code>onDestroyView()</code>, 可以通过返回键来resume.<br>这个时候对于旧的Fragment来说, 成员变量依然在,但是View被销毁了. 所以返回时它的生命周期从<code>onCreateView()</code>开始重建View.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Android Reference Fragment</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html" target="_blank" rel="external">Android Reference FragmentTransaction</a><br><a href="https://guides.codepath.com/android/Creating-and-Using-Fragments" target="_blank" rel="external">CodePath Guides: Creating and Using Fragments</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Test Links]]></title>
      <url>http://mengdd.github.io/uncategorized/2016/05/31/test-links/</url>
      <content type="html"><![CDATA[<p><a href="http://www.realestate.com.au/property-house-nsw-singleton+heights-122331330" target="_blank" rel="external">http://www.realestate.com.au/property-house-nsw-singleton+heights-122331330</a></p>
<p><a href="https://m.realestate.com.au/sold/property-house-act-waramanga-122532898" target="_blank" rel="external">https://m.realestate.com.au/sold/property-house-act-waramanga-122532898</a></p>
<p>realestate.com.au/suggested-properties</p>
<p><a href="http://www.realestate.com.au/suggested-properties" target="_blank" rel="external">http://www.realestate.com.au/suggested-properties</a></p>
<p><a href="http://www.realestate.com.au/blog/expand-your-real-estate-search-with-apps-suggested-properties/" target="_blank" rel="external">http://www.realestate.com.au/blog/expand-your-real-estate-search-with-apps-suggested-properties/</a></p>
<p><a href="http://www.realestate.com.au/buy/property-house-with-1-bedroom-between-600000-750000-in-mentone%2c+vic+3194%3b/list-1?maxBeds=2&amp;includeSurrounding=false" target="_blank" rel="external">http://www.realestate.com.au/buy/property-house-with-1-bedroom-between-600000-750000-in-mentone%2c+vic+3194%3b/list-1?maxBeds=2&amp;includeSurrounding=false</a></p>
<p><a href="http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-400-between-800000-900000-in-mentone%2c+vic+3194/list-1?keywords=pool&amp;numParkingSpaces=3&amp;numBaths=2&amp;maxBeds=2&amp;includeSurrounding=false&amp;persistIncludeSurrounding=true&amp;source=location-search" target="_blank" rel="external">http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-400-between-800000-900000-in-mentone%2c+vic+3194/list-1?keywords=pool&amp;numParkingSpaces=3&amp;numBaths=2&amp;maxBeds=2&amp;includeSurrounding=false&amp;persistIncludeSurrounding=true&amp;source=location-search</a></p>
<p><a href="http://www.realestate.com.au/rent/property-townhouse-villa-acreage-with-2-bedrooms-between-300-450-in-parkdale%2c+vic+3195%3b/list-1?availableBefore=2016-05-16" target="_blank" rel="external">http://www.realestate.com.au/rent/property-townhouse-villa-acreage-with-2-bedrooms-between-300-450-in-parkdale%2c+vic+3195%3b/list-1?availableBefore=2016-05-16</a></p>
<p><a href="http://www.realestate.com.au/sold/property-house-townhouse-with-3-bedrooms-between-0-1000000-in-sandringham%2c+vic+3191/map-1?maxBeds=3&amp;includeSurrounding=false" target="_blank" rel="external">http://www.realestate.com.au/sold/property-house-townhouse-with-3-bedrooms-between-0-1000000-in-sandringham%2c+vic+3191/map-1?maxBeds=3&amp;includeSurrounding=false</a></p>
<p><a href="http://www.realestate.com.au/sold/property-house-with-2-bedrooms-between-50000-950000-in-kew%2c+vic+3101/list-1?maxBeds=3" target="_blank" rel="external">http://www.realestate.com.au/sold/property-house-with-2-bedrooms-between-50000-950000-in-kew%2c+vic+3101/list-1?maxBeds=3</a> </p>
<p><a href="https://m.realestate.com.au/sold/property-townhouse-with-studio-in-weston+creek+district%2c+act/list-1?numParkingSpaces=1&amp;numBaths=1&amp;keywords=car&amp;activeSort=sold-price-desc" target="_blank" rel="external">https://m.realestate.com.au/sold/property-townhouse-with-studio-in-weston+creek+district%2c+act/list-1?numParkingSpaces=1&amp;numBaths=1&amp;keywords=car&amp;activeSort=sold-price-desc</a> </p>
<p><a href="http://www.realestate.com.au/sold/in-scoresby%2c+vic+3179%3b/list-1" target="_blank" rel="external">http://www.realestate.com.au/sold/in-scoresby%2c+vic+3179%3b/list-1</a> </p>
<p>2016-06-15<br><a href="http://www.realestate.com.au/sold/in-bentleigh%2c+vic+3204/list-1" target="_blank" rel="external">http://www.realestate.com.au/sold/in-bentleigh%2c+vic+3204/list-1</a><br><a href="http://www.realestate.com.au/buy/property-house-between-0-2000000-in-melbourne%2c+vic+3000/list-1?numBaths=1&amp;numParkingSpaces=1&amp;activeSort=price-asc" target="_blank" rel="external">http://www.realestate.com.au/buy/property-house-between-0-2000000-in-melbourne%2c+vic+3000/list-1?numBaths=1&amp;numParkingSpaces=1&amp;activeSort=price-asc</a><br><a href="http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-1-between-0-2000000-in-melbourne%2c+vic+3000/list-1?maxBeds=5&amp;numBaths=1&amp;numParkingSpaces=1&amp;activeSort=list-date" target="_blank" rel="external">http://www.realestate.com.au/buy/property-house-with-1-bedroom-size-1-between-0-2000000-in-melbourne%2c+vic+3000/list-1?maxBeds=5&amp;numBaths=1&amp;numParkingSpaces=1&amp;activeSort=list-date</a></p>
<p>2016-08-03<br><a href="https://m.realestate.com.au/saved-properties" target="_blank" rel="external">https://m.realestate.com.au/saved-properties</a></p>
<p>2016-11-7<br>Property detail:<br><a href="http://www.realestate.com.au/property-apartment-vic-melbourne-122718062" target="_blank" rel="external">http://www.realestate.com.au/property-apartment-vic-melbourne-122718062</a><br>Saved Properties -&gt; should open second tab<br><a href="https://m.realestate.com.au/saved-properties" target="_blank" rel="external">https://m.realestate.com.au/saved-properties</a><br>Saved Property Notification: -&gt; should open detail page on second tab<br>rea-app://saved-properties/122718062<br>Agenda deeplink: -&gt; should open inspections on second tab<br>rea-app://saved-properties/inbox-style</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Set up github pages with Hexo]]></title>
      <url>http://mengdd.github.io/uncategorized/2016/05/23/set-up-github-pages-with-hexo/</url>
      <content type="html"><![CDATA[<h1 id="Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll"><a href="#Set-up-Github-Pages-with-Hexo-migrating-from-Jekyll" class="headerlink" title="Set up Github Pages with Hexo, migrating from Jekyll."></a>Set up Github Pages with Hexo, migrating from Jekyll.</h1><p>本文介绍用Hexo建立github pages, 其中包含了从Jekyll迁移过来的过程.<br>Migrate github pages from Jekyll to <a href="https://hexo.io/docs/index.html" target="_blank" rel="external">Hexo</a>.<br>Set up github pages using Hexo.<br>不光是迁移哇, 直接用Hexo setup github pages 看这个也有用哇.</p>
<a id="more"></a>
<p>为什么要把github pages 从Jekyll实现迁移到Hexo?<br>前阵子用Jekyll建了github pages(官方推荐), 但是发现添加代码段比较痛苦, markdown的前后三个点并不能标记一个代码块, 需要在代码块前后加上两句特定的语句.<br>如果一篇文章有很多代码块, 这样一个一个加下来比较费劲, 而且加完了之后代码段的样式也不是很好看.</p>
<p>为此很苦恼的我问了phodal大神, 大神回复: Hexo.</p>
<p>下文记录了我的操作过程.</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>必要条件:<br><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br>可以选个pkg,下载后点击安装, 装完之后告诉你路径.</p>
<p>也可以用nvm装的<br><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a><br>Git<br>这个一般大家都有哒~</p>
<p>上面两个都有之后, 安装Hexo:</p>
<p><code>$ npm install -g hero-cli</code><br>装得也很快.<br>之后试一下hexo命令,如果有命令介绍(而不是command not found)就代表装好了.</p>
<h2 id="设置和迁移"><a href="#设置和迁移" class="headerlink" title="设置和迁移"></a>设置和迁移</h2><p><a href="https://hexo.io/docs/setup.html" target="_blank" rel="external">Setup</a></p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先, 从原先的_posts/目录下将原来的文章都拷贝出来.<br>另外将.git目录也拷贝出来(这是为了保持github上的历史).<br>这些文件另外保存.</p>
<h3 id="建立新的目录"><a href="#建立新的目录" class="headerlink" title="建立新的目录"></a>建立新的目录</h3><p>在准备好的空目录运行命令:<br><code>hexo init .</code><br>就建立好了hexo的目录,相关介绍可以去网站看.<br><code>npm install</code> 下载依赖包.</p>
<p>Hexo会自动忽略下划线开头的目录和文件名,但是_posts目录除外.<br>这时候可以运行<br><code>$ hexo server</code><br>然后访问<a href="http://localhost:4000/预览一下" target="_blank" rel="external">http://localhost:4000/预览一下</a>.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>网站的设置文件是<code>_config.yml</code><br>打开可以配置一些新东东, 比如title url之类的.<br>具体设置参照这个: <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">configuration</a></p>
<h3 id="内容迁移"><a href="#内容迁移" class="headerlink" title="内容迁移"></a>内容迁移</h3><p>这是内容迁移的介绍:<br><a href="https://hexo.io/docs/migration.html" target="_blank" rel="external">migration</a></p>
<p>所以首先在<code>_config.yml</code>文件里把 new_post_name字段改为:<br><code>new_post_name: :year-:month-:day-:title.md</code><br>否则就要修改之前每一个文章的文件名,太麻烦,而且我觉得加个日期也比较好.</p>
<p>然后把原来备份的博客文章移到source/_posts/目录下.</p>
<p>比较bug的是以前jekyll文章里的代码段前后加的那两句还得手动移除.<br>用Hexo后 前后各加三个点即可标记代码段.<br>如果想要代码高亮, 比如是java, 代码段首的三个点后加个java.<br>这里可以查看代码高亮的各种语言: <a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="external">highlightjs</a></p>
<p>完成之后可以运行hexo server 命令在本地看一下样子.</p>
<p>然后把.git目录拷贝回来放在根目录. 可以看到repo地址啊, 历史记录啊还在.<br>最后提交, 本次提交即为迁移提交, push.</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">部署Deployment</a></p>
<p>我本来以为跟Jekyll一样本地运行好了, push上去就生效了, 结果并没有.<br>访问原地址, github pages并不生效,居然还是原来的那个样子.</p>
<p>查了一下是因为deploy没有设置.</p>
<p>打开<code>_config.yml</code>文件,找到deploy字段, 设置一下.<br>我的是这样写的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/mengdd/mengdd.github.io</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>然后执行一下这条命令:<br><code>npm install hexo-deployer-git --save</code><br>这条命令执行后package.json会有一条改动, 新添加了一个插件.<br>把这个提交了.</p>
<p>然后generate和deploy:<br><code>$ hexo generate --deploy</code><br><code>$ hexo deploy --generate</code><br>这两条命令是一样的.<br>运行这条命令的时候可能会要求你输入github的账户名和密码(如果你没有配置SSH key的话).<br>这个需要等待比较长的时间, 实际上最后它是给master分支做了一个<code>git push -f</code><br>所以它实际上是不用你自己push的.</p>
<p>之后就可以访问啦: <a href="http://mengdd.github.io/">http://mengdd.github.io/</a><br>哒哒!</p>
<h2 id="网站代码和静态网页管理"><a href="#网站代码和静态网页管理" class="headerlink" title="网站代码和静态网页管理"></a>网站代码和静态网页管理</h2><p>在知乎上看到这个问题: <a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">使用hexo, 如果换了电脑怎么更新博客?</a><br>乍一看感觉很奇怪, 换一台电脑难道不是clone下来就行了吗? 仔细看了一下恍然大悟.<br>前面提到刚刚的部署命令执行了一次强制push, 可是当我们查看github上的repo(<a href="https://github.com/mengdd/mengdd.github.io" target="_blank" rel="external">https://github.com/mengdd/mengdd.github.io</a>),<br>发现push上去的文件和我们本地的这些完全不同.<br>现在在origin master上的全是一些静态html文件.<br>而我们本地master分支上是一些配置, 还有source文件等.<br>也就是等于我们把母鸡留在了本地电脑, 执行deploy之后只把鸡蛋push到了origin. (我这个形象的比喻).</p>
<p>那么怎么解决呢? 该问题下排名第一的 [CrazyMilk] 大哥已经给出了答案.<br><a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">他的博文</a><br>所以解决办法就是新建一个分支把网站代码(母鸡)放上去咯~哈~</p>
<p>首先在本地, 基于当前本地的master新建一个hexo分支:<br><code>git checkout -b hexo</code><br>然后push到origin上去:<br><code>git push origin hexo</code><br>耗时比较久, 请耐心等待.</p>
<p>最后在github的settings页面把hexo分支设置为default.<br>DONE!</p>
<h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>之后想设置一个好看的主题, 知乎上居然还有这么个问题:<br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">有哪些好看的Hexo主题?</a><br>我打算选这个试试: <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">https://github.com/wuchong/jacman</a><br>在本地hexo分支根目录下运行:<br><code>git clone https://github.com/wuchong/jacman.git themes/jacman</code><br>就会clone到themes目录下面叫jacman的目录下.<br>然后在根目录下的<code>_config.yml</code>中把theme名改为jacman.</p>
<p>然后用命令hexo server就可以在本地查看效果.<br>改主题大概就酱, 两步就可以完成, 可以多试几个选一选.<br>选完了在hexo分支提交保存,然后运行<code>hexo d -g</code>生成部署即可.</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>需要用到的命令: <a href="https://hexo.io/docs/commands.html" target="_blank" rel="external">commands</a> 随时查看哇.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mengdd.github.io/uncategorized/2016/05/20/hello-world-from-hexo/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! </p>
<a id="more"></a>
<p>This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[EventBus源码阅读记录]]></title>
      <url>http://mengdd.github.io/Android/2016/03/10/eventbus-codes-analysis/</url>
      <content type="html"><![CDATA[<h1 id="EventBus源码阅读记录"><a href="#EventBus源码阅读记录" class="headerlink" title="EventBus源码阅读记录"></a>EventBus源码阅读记录</h1><p>EventBus是一个Android上用的消息分发的类库,非常灵活好用,主要的原理是利用了反射注册以及调用.<br>本文是在阅读EventBus的源码过程中所记录的东西, 遇到不懂的去查了,然后留下了链接.<br>有点流水账,讲得也不是很深入,如果有错请帮忙指正.<br>repo地址:<br><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">greenrobot/EventBus</a></p>
<a id="more"></a>
<h2 id="EventBus的构造"><a href="#EventBus的构造" class="headerlink" title="EventBus的构造"></a>EventBus的构造</h2><p>双重加锁的单例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是仍然开放了构造函数,用于构造其他别的对象.</p>
<p><strong>Builder模式</strong>: <code>EventBusBuilder</code>.<br>有一个<code>DEFAULT_BUILDER</code>.</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>注册即添加订阅者,调用<code>register()</code>方法:<br>方法参数最全时共有三个参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</div><div class="line">    <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">        subscribe(subscriber, subscriberMethod, sticky, priority);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>subscriber</code>(订阅者)传入的是一个对象,用到了它的class.<br><code>SubscriberMethodFinder</code>会去找这个类中的方法.<br>被找到的方法最后会被缓存到一个map里,key是<code>class</code>, value是<code>ArrayList&lt;SubscriberMethod&gt;()</code>.</p>
<h3 id="寻找方法"><a href="#寻找方法" class="headerlink" title="寻找方法"></a>寻找方法</h3><p>在一个类(class)中寻找方法的过程, 首先是拿出方法:<br>在循环中skip了一些系统的类, 因为我们不可能在这些类里加入方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">    String name = clazz.getName();</div><div class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"java."</span>) || name.startsWith(<span class="string">"javax."</span>) || name.startsWith(<span class="string">"android."</span>)) &#123;</div><div class="line">        <span class="comment">// Skip system classes, this just degrades performance</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers a fat classes like Activities</span></div><div class="line">        Method[] methods = clazz.getDeclaredMethods();</div><div class="line">        filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">        Method[] methods = subscriberClass.getMethods();</div><div class="line">        subscriberMethods.clear();</div><div class="line">        eventTypesFound.clear();</div><div class="line">        filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    clazz = clazz.getSuperclass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>关于反射的性能讨论, 代码中有说:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This is faster than getMethods, especially when subscribers a fat classes like Activities</span></div><div class="line">Method[] methods = clazz.getDeclaredMethods();</div></pre></td></tr></table></figure>
<p>为什么呢?<br><code>getMethods()</code>返回了所有的public方法,包含从所有基类继承的,也即包含了从Object类中继承的public方法.<br><code>getDeclaredMethods()</code>返回了该类中声明的所有方法,包括各种访问级别的,但是只包含本类中的,不包括基类中的方法.</p>
<p>相关DOC:</p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="external">反射package-summary</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredMethods(" target="_blank" rel="external">getDeclaredMethods()</a>)<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getMethods(" target="_blank" rel="external">getMethods()</a>)</p>
<h4 id="Issue-of-NoClassDefFoundError"><a href="#Issue-of-NoClassDefFoundError" class="headerlink" title="Issue of NoClassDefFoundError"></a>Issue of NoClassDefFoundError</h4><p>这里有一个try catch主要是为了解决这个issue: <a href="https://github.com/greenrobot/EventBus/issues/149" target="_blank" rel="external">https://github.com/greenrobot/EventBus/issues/149</a><br>本来的流程是: </p>
<ol>
<li>从自己的class开始,每次都<code>getDeclaredMethods()</code>, 即提取自己类中的方法,不取基类.</li>
<li>取完之后, <code>getSuperclass()</code>,获取基类的class,重新进入while循环.直到进入java包或者android包才退出.</li>
</ol>
<p>但是<code>getDeclaredMethods()</code>会检查一些参数和返回值, 如果找不到类型则抛出NoClassDefFoundError.<br><code>getMethods()</code>却不检查.</p>
<p>什么样的情况会抛出这个Error呢?</p>
<p>Android代码里可能会有一些方法标明了<code>@TargetApi</code>,表明是更高级的sdk上才会有的.<br>这样在低版本的机器上遇到了这些代码,就无法解析出它们的类了.</p>
<p><strong>只要你的作为subscriber的class里含有这种东西,就会出现问题.</strong></p>
<p>为了解决这个崩溃, 所以代码里catch了一把,然后采用第二种方案<code>getMethods()</code>,一次性get所有基类中的方法,这种效率虽然低,但是不会抛异常.<br>需要把之前的map都清理一把.</p>
<h3 id="筛选方法"><a href="#筛选方法" class="headerlink" title="筛选方法"></a>筛选方法</h3><p>得到了所有的方法之后,开始筛选方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterSubscriberMethods</span><span class="params">(List&lt;SubscriberMethod&gt; subscriberMethods, HashMap&lt;String, Class&gt; eventTypesFound, </span></span></div><div class="line">StringBuilder methodKeyBuilder, Method[] methods)</div></pre></td></tr></table></figure>
<p>这里第一个参数会作为最后的返回值,即我们方法选择的结果.</p>
<p>筛选的过程, 遍历所有找到的方法:</p>
<ol>
<li>看它是以”onEvent”开头,即为我们要找的目标方法.</li>
<li><p>然后<code>getModifiers()</code>看它是一个<strong>public</strong>的方法,并且不是我们要忽略的方法.<br>注意这里用到了位操作<strong>&amp;</strong>来比较. 结果不为零表示满足,为零表示不满足.<br>默认的忽略方法是<strong><em>static, bridge, synthetic</em></strong>方法.<br>后两个词指的其实是同一种东东,但是这是什么东东呢?<br>是编译器生成的方法, 见参考链接:<br><a href="https://javax0.wordpress.com/2014/02/26/syntethic-and-bridge-methods/" target="_blank" rel="external">https://javax0.wordpress.com/2014/02/26/syntethic-and-bridge-methods/</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html</a><br>从上面的例子中可以看出,编译器生成<strong><em>bridge</em></strong>方法主要是为了保证多态的顺利进行.它和基类的签名一样,但是实现去调用了子类的方法.自己偷偷完成了其中的类型转换.</p>
</li>
<li><p>获取参数类型:必须是一个参数.</p>
</li>
<li><p>获取<code>ThreadMode</code>: 即看方法名中onEvent之后还是什么,一共有四种Mode,对应四种方法名:<br><strong><em>onEvent(), onEventMainThread(), onEventBackgroundThread(), onEventAsync()</em></strong><br>如果获取不到<code>ThreadMode</code>,则continue;即这个方法不是我们要找的方法.</p>
</li>
<li><p>用<code>StringBuilder</code>组成一个key: <strong><em>method name&gt;parameterType class name</em></strong>.<br>注意这里StringBuilder的清理方式是<code>setLength(0)</code>.<br>然后放进了一个<code>eventTypesFound</code>的HashMap, String是key, Class是value,这里放的是<code>method.getDeclaringClass()</code>;即方法声明的那个类的类型.</p>
</li>
</ol>
<p>注意这里还利用了<code>put()</code>方法的返回值,如果map里之前有这个key对应的值,那么老的value会作为返回值返回.<br>文档:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html#put(K,%20V" target="_blank" rel="external">HashMap.put()</a>)</p>
<p>这里还用了这个一个方法: <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#isAssignableFrom(java.lang.Class" target="_blank" rel="external">isAssignableFrom</a>)<br>判断是否自己的class是参数的基类或接口.如果传入的参数是当前对象的子类或自身,则返回true.</p>
<p>如果有old class存在,并且old class和新的class不能互相转换, 后者old是new的子类, 那么<code>eventTypesFound</code>这个map里还是保存老的值.</p>
<p>如果存在old class,但是old class是新加class的父类,会把新的class加进<code>eventTypesFound</code>的map,取代前者,即这个map中尽量放继承体系下层中更具体的类.<br>这里虽然父类没有被放进<code>eventTypesFound</code>,但是父类的方法仍然会被加进最后返回的methods的map.</p>
<p>筛选结束后,我们就获取到了所有的目标方法.<br>把它们都存在了一个cache map里面,以免同一个类下次我们又要重新筛选一遍:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; methodCache = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>得到了方法的list(<code>List&lt;SubscriberMethod&gt;</code>)之后,我们要对每一个成员调用<br><code>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority)</code> 方法.</p>
<p>里面有一个新的数据类型<code>CopyOnWriteArrayList</code>:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="external">CopyOnWriteArrayList Java doc</a><br><a href="http://developer.android.com/reference/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="external">CopyOnWriteArrayList android doc</a></p>
<p>类说明: <em>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</em></p>
<p>这个数据类型是一个ArrayList,但是它在每次进行变异操作之前都拷贝一份新的.它底层的数组是<strong><em>volatile</em></strong>的.<br>这种数据类型的写操作代价很高.</p>
<p><code>subscribe()</code>方法中主要是给这两个字段放数据:</p>
<ol>
<li><p><code>private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</code><br>key是eventType的Class, value是Subscription这种数据类型的数组:<br><code>Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);</code></p>
</li>
<li><p><code>private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</code><br>key是subscriber,即订阅者的类的对象,value是eventType的class,即事件类.</p>
</li>
</ol>
<h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p><code>unregister()</code>的时候, 传入subscriber:<br>首先从typesBySubscriber获取到事件的List,然后遍历这个List, 从subscriptionsByEventType中移除该eventType,并且subscriber是当前subscriber的Subscription.<br>遍历完成之后,从typesBySubscriber移除该subscriber.</p>
<h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>好了,注册和反注册到这里就结束了,看起来也就是找到一些方法和类型,放在一些map里面,注销的时候再从map里面拿出来而已.<br>真正做事情的代码呢?</p>
<p>首先看事件的触发: <code>post()</code>方法, 这里传入的参数是事件类对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    eventQueue.add(event);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致地看上去好像就是加入了一个队列,然后发送出去直到队列为空.</p>
<p>对每一个事件来说,是调用了<code>postSingleEvent()</code>这个方法.</p>
<p><code>postSingleEvent()</code>这个方法里<code>eventInheritance</code>为true时(默认行为)会把event的class拿出来,然后取出它的所有基类和接口,和它自己一起放在一个map里.<br>这是可以理解的,因为可能我们本来的需求是监听了一个灾难事件,后来的需求发展,又写了个它的子类事件叫地震.<br>那么当我post地震事件的时候,除了地震事件后来新加的处理,当然也要采取原先灾难事件的相关措施.</p>
<p>取出所有基类和接口的方法:<code>lookupAllEventTypes()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></div><div class="line"><span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (eventTypesCache) &#123;</div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</div><div class="line">        <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</div><div class="line">            eventTypes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">            Class&lt;?&gt; clazz = eventClass;</div><div class="line">            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                eventTypes.add(clazz);</div><div class="line">                addInterfaces(eventTypes, clazz.getInterfaces());</div><div class="line">                clazz = clazz.getSuperclass();</div><div class="line">            &#125;</div><div class="line">            eventTypesCache.put(eventClass, eventTypes);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> eventTypes;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有这些费时的遍历查找操作都是有一个map作为cache的.<br>注意这里添加接口的时候,因为<strong>接口是多继承的</strong>,所以除了去重以外,还需要深入遍历:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Recurses through super interfaces. */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</div><div class="line">        <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</div><div class="line">            eventTypes.add(interfaceClass);</div><div class="line">            addInterfaces(eventTypes, interfaceClass.getInterfaces());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到所有类型之后,进行遍历, 对每一个eventClass进行处理, 真正的对每一个类型post的方法是这个:<br><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</code></p>
<p>这里,从之前那个<code>subscriptionsByEventType</code>里面,根据eventClass把<code>CopyOnWriteArrayList&lt;Subscription&gt;</code>拿出来.<br>这里拿出来的就是一个List,里面是一个一个的<em>onEventXXX</em>方法的个体,<br>对每一个<code>Subscription</code>,执行了:<br><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread)</code></p>
<h3 id="线程模式"><a href="#线程模式" class="headerlink" title="线程模式"></a>线程模式</h3><p>这里根据线程模式不同,有一个switch case.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">        <span class="keyword">case</span> PostThread:</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MainThread:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BackgroundThread:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                backgroundPoster.enqueue(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> Async:</div><div class="line">            asyncPoster.enqueue(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>invokeSubscriber(Subscription subscription, Object event)</code>方法就是直接通过<code>Method</code>, 反射调用, invoke了那个方法.</p>
<pre><code>`case PostThread`: 直接在当前线程调用这个方法.
`case MainThread`: 如果当前线程是主线程,则直接调用,否则加入mainThreadPoster的队列.
`case BackgroundThread`: 如果当前是主线程,加入backgroundPoster队列, 否则直接调用.
`case Async`: 加入asyncPoster队列.
</code></pre><p>加入的三个队列类型如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerPoster mainThreadPoster; </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster;</div></pre></td></tr></table></figure></p>
<p><code>HandlerPoster</code>继承自Handler, 内部有一个<code>PendingPostQueue</code>.<br>这三个poster里面都是这个<code>PendingPostQueue</code>, 数据结构是<code>PendingPost</code></p>
<h4 id="关于Queue的相关知识"><a href="#关于Queue的相关知识" class="headerlink" title="关于Queue的相关知识"></a>关于Queue的相关知识</h4><p>队列Queue: Java中Queue是一个接口, 类文档:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html" target="_blank" rel="external">Queue Java doc</a><br>它是继承自Collection这个接口:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a></p>
<p>Queue这个数据结构可以自己定义顺序, 可以用来做FIFO也可以用来做LIFO.<br>每一种Queue的实现都必须指定要用什么顺序.<br>不管是什么顺序,head上的那个元素都是<code>remove()</code>或<code>poll()</code>即将移除的元素.</p>
<p><code>offer()</code>方法将会试图插入一个元素,如果失败了就会返回false.<br><code>remove()</code>和<code>poll()</code>方法都会删除并返回head元素.<br><code>peek()</code>只查询,不remove.</p>
<h4 id="主线程处理-HandlerPoster"><a href="#主线程处理-HandlerPoster" class="headerlink" title="主线程处理 HandlerPoster"></a>主线程处理 HandlerPoster</h4><p>所以这里看看<code>HandlerPoster</code>是怎么做的:</p>
<ol>
<li>它继承自<code>Handler</code>, 初始化的时候用的是mainLooper,所以确保了消息处理操作都是在主线程:<br><code>mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</code></li>
<li>这个里面写了一个自己的queue: PendingPostQueue里面包含的数据是:<code>PendingPost</code>.<br><code>PendingPost</code>这个类里用了一个pool来实现一个对象池,最大限制是10000.<br>obtain的时候, 如果池子里有对象,则从池子里拿出来一个, 如果池中没有对象,则new一个新的PendingPost; release的时候放回池子去.</li>
</ol>
<p><code>HandlerPoster</code>主要做两件事:</p>
<ol>
<li>enqueue一个PendingPost, sendMessage, </li>
<li>在handleMessage()方法里面处理message.<br>handleMessage()里面是一个while循环,从队列里面拿出PendingPost然后调用EventBus的invokeSubscriber()方法.<br>这里调用方法之前就会release该PendingPost.</li>
</ol>
<h4 id="异步和后台处理-AsyncPoster和BackgroundPoster"><a href="#异步和后台处理-AsyncPoster和BackgroundPoster" class="headerlink" title="异步和后台处理 AsyncPoster和BackgroundPoster"></a>异步和后台处理 AsyncPoster和BackgroundPoster</h4><p><code>AsyncPoster</code>和<code>BackgroundPoster</code>都是一个<code>Runnable</code>.</p>
<p>enqueue的时候把PendingPost加入队列, 然后调用<code>eventBus.getExecutorService().execute(this);</code></p>
<p><code>run()</code>方法里面就是从队列中拿出PendingPost,然后invoke,和上面很像.</p>
<p>默认的对象是:<br><code>private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</code><br>提供了一个线程池,可以异步地执行操作.</p>
<p>那么它们两者有什么不同呢?</p>
<p>AsyncPoster很简单, run里面直接invoke, 没有过多的判断. 即对每一个任务都是直接启动线程执行.<br>BackgroundPoster比较复杂,有一个boolean来判断是否正在run, run()方法里面是一个while true的循环,当queue全部被执行完之后才return.<br>如果队列中有任务正在执行,这时候enqueue()操作会加入元素到队列中,等待执行.<br>即BackgroundPoster只用了一个线程,所有的事件都是按顺序执行的,等到前面的任务执行完了才会进行下一个.</p>
<p>对各个模式的说明可以参见<code>ThreadMode.java</code>类.<br>Async模式下,不管你的post thread是什么,都是会新启线程来执行任务的,所以适用于那些比较耗时的操作.<br>为了避免并发线程过多, EventBus里面使用了一个线程池来复用线程.</p>
<h2 id="事件取消"><a href="#事件取消" class="headerlink" title="事件取消"></a>事件取消</h2><p>有一个public的cancel方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelEventDelivery</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(</div><div class="line">                <span class="string">"This method may only be called from inside event handling methods on the posting thread"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Event may not be null"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (postingState.event != event) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Only the currently handled event may be aborted"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (postingState.subscription.subscriberMethod.threadMode != ThreadMode.PostThread) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">" event handlers may only abort the incoming event"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    postingState.canceled = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的使用可以从测试代码里面看出来:<br>1.首先它只能在handler里面调用, 即第一个异常.这里判断的isPosting这个值在post的时候变为true,处理完就变为false.<br>这里用到的currentPostingState:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ThreadLocal类是什么?<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="external">ThreadLocal类</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</div></pre></td></tr></table></figure>
<p>主要是用来给每一个线程保存一个不同的状态值.<br>这个currentPostingThreadState在第一次被调用<code>get()</code>方法的时候初始化,也即在<code>public void post(Object event)</code> 方法里.<br>然后修改了它的状态, 之后再在同一个线程里,即可访问到它的状态.</p>
<p>这里cancel的测试也写得很有意思,可以看一下.</p>
<h2 id="黏性事件"><a href="#黏性事件" class="headerlink" title="黏性事件"></a>黏性事件</h2><p>什么叫Sticky?<br>字面上看是黏性的.</p>
<p>之前的事件都是非黏性的,即有一个<code>register()</code>和<code>unregister()</code>方法.<br><code>register()</code>了subscriber之后, EventBus会扫描该类中的onEventXXX()方法,建立一些map来记录.<br><code>unregister()</code>即合理地清除了这些数据.</p>
<p>而对于sticky的事件,注册时调用<code>registerSticky()</code>, 并没有相应的注销方法.只有一个单独的<code>removeAllStickyEvents()</code>方法.</p>
<p>sticky的事件注册的时候, <code>subscribe()</code>方法中, 除了重复上面正常的过程之外, 还有一个额外的map:<br><code>private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</code><br>这个数据类型是: <code>stickyEvents = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</code><br>存的是event的Class和event对象.</p>
<p>注册时如果发现这个map中相同的event type要处理,<strong><em>会立即触发</em></strong>, 通知到它的订阅者.</p>
<p>注意这个sticky event存的是最近的一个事件: <strong>most recent event</strong>.</p>
<p>sticky事件触发的时候调用:<br><code>public void postSticky(Object event)</code></p>
<p>sticky的代码里有一个<code>cast()</code>方法:<br>看文档:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html" target="_blank" rel="external">Class</a></p>
<p>这个<code>cast()</code>方法就是用来把对象强转成当前的这个Class类型.</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>EventBus是一个Android上用的消息分发的类库,非常灵活好用,主要的原理是利用了反射注册以及调用. </p>
<p>本文是在阅读EventBus的源码过程中所记录的东西, 遇到不懂的去查了, 然后留下了链接.<br>有点流水账,讲得也不是很深入,如果有错请帮忙指正.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[My First Post]]></title>
      <url>http://mengdd.github.io/others/2016/01/28/my-first-post/</url>
      <content type="html"><![CDATA[<p>Hi, this is the first post.<br>As you know, this is just for testing.</p>
<p>Anyway, if you are here, you must be bored and are trying to find something to do.</p>
<p>My plan is to grow here as my second blog site.<br>The first one is here:</p>
<p><a href="http://www.cnblogs.com/mengdd/" target="_blank" rel="external">圣骑士wind的博客</a></p>
<p><em>Do whatever improves yourself.</em></p>
<p><strong>Life is so beautiful~</strong></p>
<p><strong><em>Haha and Bye</em></strong></p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
